<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"bd78488a2d87b4f8af25a2d9d62a31671672339fb32597bdc56b36a3237c7403c8b892e0e6f4c1c89312f2f3ccbe016b4252d2f85380ccac0edc623049e8ab23d8b91fbe1042d2404c8bf33d05aa6a584242cb3fbc4703d9883ebf5cb2265cb71b2db9e1bd09569f43ed964bc5a3fd36f8311ead09a55303e08283b9a0c15cc104eab6ffa4eac575d832c5cb79331a58757aaacd89c2c8c875154c50840b55c0e5090e740e6394d6e8f8286e88dcf8071d8f62b5f15d17725cfdaa7f6258daee43196e75f7aa46ae5a92f8d44fa7f2bdc0ba8e30b8046e0d6a22d6bbd5dd434d54ceb5c5a4f988d684c07e534cf4d71e616a66f3b0b4531d92379bd37888bedc6145f0284c323892b322fca649e1b2dc31957db9f09bbec268e207af2fd272a1167d3c499bc37ee0a4e209fb379c5a05a1830496993e8dedf467bd6c9b3d5700add4fd94ab263dd1f7d9c0ddd6841c7624842169f6995c134e28ae41f19a67837669d0739760ecde77d5c1f28cad24dfff3b6c1e284a19099a7848dcd1a669b96cd7b723452422035395a4f9795da81b59d3aa03996ca62e8d98a4e17ab7f898d9c12fec5e77950ddcbe00852a0e5d0f836b9b39de10f4be8fbfcf6430eb3207032cde40d13122a8ae95d9737241af36dd350ce589defe3d1f385efb79c996da40215d7c52bd99108848795deaab21b4e64eac109c515912275259c01b03844e045ec795211ae80421daf5f8e13f1b220b06ffd071d591f9c1b2c00d3ddd4ba442a59e3c20658beec315aef2cd17aec8b8511f377aad940e2528d893d207a042513ea110ca79d60c1fe866497e506b2275f4109846fc71f42853423a70bc486272ba505dc35b86095c6b129302cd2082d3296a5060a1bd60e706d618ca2f35b602c3a0a5ca75c1bb53f748f041b09197b0cafe39fe6d8239c9e36dca52798109faa808de2c736a022270367a8fec915a6cecca2721a484bf8c34c76932b87559ee8574eefaf799abd1089c1f6d296816e37138acc256a73eba266008b44a5ce38c5c31e342cbbabe527588895dda21d5b9508984e670660caf22272456776dad818bc7426d8a42f5a4445db27678ded08189aebefdb3b8af95c534fbd252aa44412692abef0e7f4df93a4240e962f631542d21039ab1c988b1b06dbb0e69a7d478683553b18b45a1806bb13e7d24c5069ee967c133fe13a447cca95c9aeb1372d5109467e5f15b291664673b47f5341a6a69ed4f4ce60db889eac6f5c85c80b395ee2bd4f3032fdcde3f4284e6ec3628d8c5300b29279b97411807e558332218c0876f4cbd1aa2036b01454c6b03397eb1fdf68f100357e429f9d64f663c15f529292a4638773813f1012b1d9507ed2d973ee3ef82b218a2c07add348db93c9b44ed272956993c7aa2f11cc2aa7943b8641c1039d0c0874920549829907e89eae46287b3977ef3cf88627fb68f97813228280a147951a98a094fd00c73da47c7ed250451de3623fa62d1e6db5696ec4cf0cef36abe6f07ae592b284b056a9814a4b39fa494c53af545f211e6c28e07c2cfe91f778e2a956874f69df6b66404481b283c2fcf594df0246bed41c6b0d6660d993b35549e9d2aac2882931e31ef42ed0ae4bb0f8556a399f3359f258970e6ab15b7bb85953e2ab395d64e84f1f0c43784c27bfaf3ca96b8422ca2cb0022f5bcfec2eda6ee64339b8b590292bbaedc2ca6558892876949432457aa6ad86909b3e056031809fa7f48eb5192b888a2b979668ab6d1b9de4b53f2480e9623a05ea966b6999e3faf1e232f91c3de0312ec0c6860a41c5b341d86992823b6b90fd2ada78b3ac8e1519a75cd0959512351cdc1e87e1ca8673bbc8652ee3719d5de0108d3e97b17ffcc9d2d5a9511c847f4f6d3ce1e8118c4bda75573972ae222bc576b4a4dd5da9d4c236c85402e7056be72bb9f465fca00fa4ebd2676b9cd77dd9e1de9e629d5956a94b8788545e478216efe7197ef8bdc84502143bbc4badba39dfbfe27c8f91db602d8ad5dca7370adae87175d7bbb8b8cad5accd3a4b44663a3b986e528be163a2ac34c00614639453007609fa619256b9a3eec2dc9cdd1546280aacead11334d985192671d6be3379c638224dd2263bc341dcc4436579dd0206485af9f137cd630a8cbe066e257f474c06c07722601960c39735fcfeabe44c0fde1530ec1cbbd96ebcae61ff362e9088e190ee829ff0be55418dbd72f592406eb95862dfbe3842fc2355e77133f94bc2ca5a50aa436b8b7db7733106fb0093358c56eb343b3b618f93b2a58927662b5ffd606cb6d77edd9ae9fa63b7baac17cafb71ef671d7728b149d2bc60aa412f8b86810535f56270779d649138bc0d22a711de089f4c3e728b7ea69acd762e6c0ec2c17fea546c5ed690e4012b4332d7cce07762930ce03c96489f5568d1784fba82b11bbaf8dde6f6d803a961b3fc51c951f5bfe0ac95af990ff11ed5ea00f9c56500ac34fe83d03501b44976bb7486b93bb43d7f462d6036b793ad084dfb6488e1f20b0c444d6b3314ea05114f5bd05670bb17c236735d07d922fdb25b4dc3fb9e449f0fc3a4af30494e12a6d21ea9e6e1456e46c1c86c3d15346d1e00e238cee84d325b8b359c9ac4030059834257f64371ea0c58518abc0b48c98ab881cb560db03d7271950f444de7553c8431fec0698dfee280ca55c4d5e8b152bc8323a156ae43c2ad4bee6befcc790e3344d9555795f236a2e7b2740b8c61dc09a461de5efb93af1b358cb497c4a27fa1fc4a88774882bea1d2ddaa18813a4136cd3a38ff24a0d6f788345c19e362d8b7b38bfccf71326f15318cdde5395ee3f4ec5d789f0fe0800696aef03f3defaaf8b3107b10b087d870784d24c924408fee118f80e6076a36c5cf84174bb0ed87bdb82f512cd8738a51b2a0cbdbce099aa1e78b02a361968f43130eb500d380054b5fd5bc78a74940f7759f3cbccdb14f81aaf2511131027770bb629170089417ab500ba03b2c06fb6e09d15a6f0bab6b81e6a27c776cfd09da64a8761df7d8209667b3d9c4de03b83d84ddbc5db1b3deecf564ee359c9f90109cd815c18b6bb3a5659fccf586ddb513d738f0a97b605af9a1e4106e3b85e231e22b4921a0f00f7d7268045e6bfbc1a3d61d6b4f0160fcf0aa6975edea50ce24ba8c6fc973209740c05709a2905755f4d8a78e19d060a7c8feceb2496fd06ac6c2bccb6277ffb05093d137792a116cc07dc3b529c5b90e1102ba9be8500798bdd79a7a8b3e6712fc6890312361faaa610ab943a5dda7bfec877e70272119b9274cdf3a3a0135dc8fb1a169e3674b24361470fc6611ade1474d32f9c313e6b6ce17c4c1ff89b205d8e09f3320e8a98e869251bc4f2d6763528c54a87a9c09943e701fb7f64ea5a8aca0c9a5404d1b37b6fa2b3a3255a61fc826a51d4b74848953d7a3b5a4a1a53b5fa67301874b96de864c5b132c725cafb4063f2f1b69026f2973c7a22eb81b6b213607bd2eacfd7df49ec879d09dbc193c7832e30221eed3dbcbd1baaf06610110a130571a2bc9d1390132bb24ff2091d8c2340606bb10807d6d041b147677c6d054fbd7f14c164860bc375d1ee44d8237c7d53d712ab847c0e22e51348c809c72f1e42df5fbcc2eaaf7bfcadf142b41f20cb7348b2ef857e7ea40aa472038e31c396f102e9db503fe94b59a99dfaab21bff8d106ab62b53c596b5b7006394a835a7dbe5c250943f6c1b21538265b879859695e49d02f484a07ffec938089623951491d259fe9259f0c31ce99e76343b1b3efcaa2e0a22007ce8711f2a760755117934b639fbb6c75b492d5a61562c1d5cbfa93b40de25b39daedd635b808cec3dd592e7d2258108e77677aaac8810549539ba918b85b6c4f805f21c6673fabf42da0b1af0fe66e82c6e0109535864c3ff3538c86d61dcd4411d50cf5b5d82f06bb253a2faaa4a520a96c2b0d578a2bd9c61da6167aec67a07d0b865def17ed507508e6a0664a93aa071da359ce9c0ed9503bbd4a8952a31d7bcc7389e564a67d3e3429f1dec33f9abb331861d2e8febf912077f072f9ccf2194e4cc2331dd48ee6bdb81a6ae4260f72ee2de07c986d22c5202987cd21a93477423acfa5b0a0d06956d66d3e1c1f29bf1d97037d4739cf5cd62defc0cea7b9803422e744e6ab94159b7aadd309fa7ccddc581acab91741ae3774b6ce73d08b8af768ede28eb91f312fb091c9fa4468572edffc95ea1cfc61df2b308d249474a10f09bd2790c9bd524f52892ac277af66616e9694bde393393f1ce5df760489088922383cddcdf2f7b5dfdf1338aebe9a2e3dfb9eac482cb44b69f5d8a0a44a64f9642d00e02068f86456b3b1ab68701fab0164ca1eafb827bf00bed559f4a769a4480cf61c51355dbc49697fae42643bf0cf4839d6d147324078bac18f287c05c0c3d23b9518678b5f4620ec2d5065885cf663d80deafae9cf6274d02e064f0d20ecda494cc4d4c824a7d4a024849551c9d2a396cb2d34975690a8de520e943da2153c1ddeb070941fd48345e7914afb81c3499e791aa409a70bed35914d3395e08f81516022050db6581927c7a60461e8d8bdf61a3748521cd0adbd52f436899dc184d5180e8dc7e4a671c0489cd845124c9edcf83d8c91766d2c59db588f011cf00303e20572d1bb7922070e1bce0b59fce17f9b364d921dcd7507a8703e4fdcf2e9d9876ba80b108656bfe892c271002bb077ede19d7ebec8178723c6312eb6f495ac2f2b21445a5466da42ad8f79d1704c41c4e835e2f2a3223e349f15c89ef87eb80cd20f0a0b3f649945ba9ad6f57c7759cdbc36f6324bc09aff2a8c3c9e5c2df5e88c38c5ac109c3ef9e01de8f5b4e685ee08c4b4dbb6a2493599121decc12c82aca47db1dd815f06db80953c88b49b36277b9f76dce9c9a2a54fd2b55a14910cba2404a78e7a9091e85312a2d058183b971c7ac2df1332ce6a1afaad3e25b699862f490e585a1ce43831adc6d6f5fb465d93197f70766051cb5d2dbe93bc3aa0dd8ea3104e20c51cc9adac05bbaec5ecd15cd8896843a0ebd9adc3b95696f6e2d44f4c397a165e994b1d4f1655646b1ecb0d483eef23910cc0c9d07398b52ff71db6249aa169f670b279d094a21e53ad6597fd3818c802b2c9aa528f411ca73f3eef7a349075ab92846634da28d157078585747b175172a48e7f3383bee782024d0a3c4ec5378fb4552b042c2be787a8f6a93a28cf376e26239779dfdf888e4fa9c5e60a24e87a622fd0a8ff74b5bb90af94f434d2bf449ec70ca01bb91a9cfeced2542db5cee4219c236396bec4a9dc61a3e8897280558aad2612b26b8cae5acea440c1bd8e2392c75776638dea8e10a8d938e6e07b145200e321608ee93c5b4057736d5a826437a4c10ec71af6123921137ecd1cd061abc4963c9f4293605e8c81bd946cc03ae66c67055c942e168330ad9b789863a178021d39920a4a22d82d45c088ce412b64d973b113c8a095ab3f607593faa958644970c8408d1c61fb6cabce48eeb879af8d27aade4f0832c94a52821986fcf2504d56c79f06cd0c5fb914b7f21a1cca813a0c131a781cc56dfda4f34cb23d25661f525ff333636fcc25c63110ec02901849942c9a711339f955fa6e32bb3b269cef77f1f1ecdb284019b1f38a16f7d054af31723dec3fcad19eacbf7ffb3820f6978a2f68b4b490b8e29a70f7286d05033de0d09d2cc6c94a3f412a1684eb6587572056f46b581542f4343eed65701a29152bfec4cec79adaf71c94a1eb6975d13cecbdb642fbbdbed786655b2ef4b0d590421bd573a5a21aed3bd58f5de1099da2a7e9b6f3b0638851be932084c532271e426f730df2bb1ee877c973d60db6ce98ee3bb55e7c0dda35dd79fab7e56d9b651bce34b1cb06c0d48e219b9edab648b327bd860e62fac551ed0c1fe78361431b5131259faaf1234b82386b43403d20cbf900a56987eb0731d48334f14bcf164620aca4677a42bef5a7d007353c55f61bcd2985730017159d013351ee5740b4d2a870390f840978023fa6881b1771ef20f77e8439615a3aeb453bd78206a1fe6d85992b43cecfbc292e8c4ba5cadb7ed07418412b085a7f085354d15384f6d0b35cac9e1c10a4229e5bf9731e2bfe5d263db7b11be25397bcd44c14cd0e51b31281b4e7cd2ecd49d6580151f88005ce378590c5c5f71d5ccdf5691789cd28b45132b35bcb7367ea6bc44f7492f51497aa6be378ec787f124dfedeb9db4d5ec53232983305eb69ce0ed1cd902ad49e7492356a1d6af6aa18b7d11e07606fa551a22593564daf87624ad3a6e166b84946c38628e34e9c364fe5d7a08e047f90c715d9058b624c3723dbad7004721acee93d4fa035d642440adc6c29ef59d03640af1ab956dd1a85a3ee41711cc39a5b274ea3b9ded15501d491cb0778d5ad0b78da205c2ec82b9ddd68637da092c972b00b9a5a33c71d7436667f086ee80087eaee4c070fd741399edb5fba69aa31d5fc35acf9c7066cf72e64c33a022fe1509a23f092461be6a45984ef194abd54b6be5dc91ccee9fe24782da198539268f74b984db8074864eba26e168e66464b01f0843eea16bc9492a465cff64e873d74b38d1a7b8d70647c26ea0a81d255cf5125b9e5d375fcb96cfe9bee4c7bcc40fe0246194098923ecc9aafdc12b1a885bac2581e4a4d15e8f9f346458de565e28b8d9eb8c305517504e072d8e075cf496e4f19b36952b237f5424ee757c2c92aa2aaa896c063b29e17763a2916c9c5e5b09f61601e8cacf8db0292d6f1ac66a86c861a0d5bac9fefd67a49a35a4c187d02005e88616180e181a9fffed4df9934e5db2e15b2517a2d2012dfc96304b4de9dc68f8871399765b3197a50e8d68d0214d2d3cb5a2f01a3bcf0b3321cda36a83ed322a7c8be21e6c49c54f8d0daba5658e803b62a153bb76ddff0a8cdcf2cd8f3ecc7262d3742724ab3ee576cbcaddba856395732ffba37207d1c7c1379cda0d0f0c7fe057bad2f95920c467fd1c1f8ed3b046106234ed8393ea7bdf1a4101b12a51a7cbea7d1f1f3399c603cdbdf93462d19e1ba9e00b89a904b0ba53dcca4fa35227a4e86f136bcfbd3f1fee4e909f690b888bb4fa897cf709915c2576340f6e963d874260d926ef881d03c6fd131fd220e1eeea1f31a09ac9cff4d4196303d23ad1a2d2a6cd82a833d144c9e305c69253f3d95f467d45356ff28139915215648c45f781bc951ecee489733b779186216def600cc7b06deb99379a107319c11bdff708d9b78dee4e253cb3634eee6dd7837ba606228cc0f254ab32137d05f002660a19b3110a3df1321b7e71aaa927ea4dee7ae969f19b5806a944298ad80e630c91bbde0b3d4a445bc876ed09ab3dcda2fde7c52cacd1c4f4f8128fb8b5f627ff18601df7e9f9d9ba49029eb12fbd52a7f37c1e3bf5dcfb1405160a460aea5fe7a36d07a41732e053fb7f59ff04de4e8c82fd7967e9131d5db458b4f46f6ffed277fa88c23addc97ba9738cc589381d038af2da3cc3a304079141431c4c8f8db12f4c0f9f3bb1536a02bda417b3a3ede61b0cb2bc8259cf7253e143f39f50c2aa425236e964e70fba13622f136ef93ff389fae16f8e96469f742b98e2f3298a1cfbac4bcd26c86f64f255b0d778b274a7421216061ca40801777cd06e7be323dcbb2e47ba1e2a63e1b31516df23df7e741f4b84d9ab25ba79bd4bfe593d3927064b4bb19265bbec76409664e06652736a2a52c83edc2fa191b88f0b7c0e0e29ebab2757cf71f86aba3b6ead9f26ea24fbf1d71d4e42ee3927dfecf7ce1f4ec46a8dbee07036461f8c6d4b139ffb556dbd22c7e1ff4a67d4f48fdadd385e158b28ca0d83d08a03ee12aed0598591380189d35b37e17d5a031c6b2e5058070c86f794a8cb6c464896af2abdba814b82326da300e5ac129f5ac4932f3f1423646a45bd036908b80b53d0ca0f271ca71b1341f77873480457c9f9886ec69b78285c87080a687a4fcb0ae7b886e28ff017c7caba1d23860be98260dfbad0da1907e2703aae0523966f451ad30ecbc798d54cae050de7eb30a9175ce474c978efc87ba469b52f8a66d0c87b5328971555f5200a3258c68eb8f491e798878a4babffc4618a633a134761ed3ff43941d652b4eb8e599fab29f00eca058d7910ba506119620d7766ca8803671deb4885067038003f86d532d5e84fd68374aa0e21f1756f21ed7becb45444c23ad0d0b3c6c39a03782dea7fb6f4fb6e5bb1ad2cd33daf88b6f49d2cef204240b6cac96c31e0c18b67c6d3f176bd9a4b257cf30e20f8e867ac8ce260b77aa4ab378cc04999af145e3b5dc1315319a9e08d37726d7cb040dbe182bda4baa70077b15847fa6eed3d0657b5b29bfbfe3c3278b439edf9ce0cb80f4df9afaccf104c5df17eee1146d67611a1e8ce099412b3739a8e15e287d9f9e48a755deda27cff43cafd1d9d2df345fc56404a748eb5d059daec74736d12399de895120ee8dd8c24c8570da54196da3191a76d977c1299d5faead638b2c77029628a0d02bf31f117ad0865ed8ab2305d8022fa27cab75091b4cd339f2ca6aa9b7245a728e30535361d6436291d194e965bbabaab5a00ba8921fb84c086a93f9794fa39bf9dba6544a1fdfdd4b96c8b2dae8ebd440d957c7660520bdeb95d3e86be937cbea377f210ac4523c7b84bd47aea7ccd86cb941251f1ee2eb968882d2e02e06c1e88ebf398cf385643a7d7e23649a34604b70e48aaa97596d8909546c99d0a0a269b51e7b07cf3b136ce249162c94f68e0abdf5d4a58c221126706ed70c3ae9e87ac1e2236264fcabc7c9015103ebd473ad503b0d281bfc0cfe545357a0c7393f848b3ef091570b2f1b410f7e917a579a12925d4a9ca6e8cb9399a76d144e88b0f6c46eee6f7e10fd1a5cf006f97be4686987807a221feae03efed9178563a946db590b54f87544801f98c1d527e5e7b9efd4eebb5b2c45e65b55d00366f68fef851ec861bf3dc4924b9c971587ee786daf9e20ad0fb379f08ab841f5e84bc0697fa5a04808dd79d5971ad95422b88e9ebd0e3f912f02a00a56bde1a2b205d33b3b952440382246b7dcf56d830d7d364d1d86357ed7da866ba20cd854ba2ccc9b485902aae65703a4abf085afaca6b94942dbc7d592b9d9475be7a54ec14455bde42fc7e2d607f3750ad4d02bdafb828197dd1d0e0090d31d8c4b1e252fba8e2d402f06d7e6ca07a1885c0729b984bd481709e2db061ee318df33afa320a76bd7646974e99bbd29a4326d81c5a09a72b4544bc931a2936297cd458dd5fa0583307fc0918fefa8daad809931f2be0841b6f00fceaeb1c6e2b27abaebe5759fe1a1e72962a7c75477782de5cb7604037eeaac60944fd47ce88544e7ee59c81448cbd2198bd8f20fb919930565f0e66c871531d146aa03dc238531f8e3563332d0296761e14cf03888c68d3def593ead0dfa561765ae52a7ee267f8a225e82c0aae964028f09677501687a603c64e29244401fba83af494d1a90c3549baae6dddf3da7677d933073434653b586c68c78aa70a4586724b9949db65a6cb63c43b2c7310dc3e4d60a21c9dba0e070927d60a14030043c0e53347809faf1f9ff2cd04dcf2275f4ca1827a0b61ae74a97dd701a11e3701e93fbdf10fae00163d817a3accb767add7df6d568d3a07f9608f7684fba26645c3cb59c0bdbd2cecc65e5eb66992bcfa2d87b93114529a9a5b90f5785d04f9830de1943cfe70e3a6a4caccb465b5b8f2715d803e65c2f7efa3f3d7054d761a8bdac231e199c864bcacf83affdf069a8af6cab8a3ae0108239565f1249af1f0db7bf815b878dd4e69e9b5f83c80dffb7f71e30715c89d600f6fb2a7ac27b0811a744bbf3c16972f7c6f30470925bfea6277062ff17b4193c661cee2d83ea31f7157dc14a6f0903e905d7dfe382632150afbdd3daabf7b991294fa0e722d2002b8c5d7297afbbf60f237a5efa87f789c69755a40f7c84bdbf00d73e9d47e2b70a2f07e688d80fb6a81434f94955dfdb0b44851b8a9bbd16cc7f16959b064fd7a8e9289dda7026d9bc02a181c1f4628397daa2d6083e48592b0525f995599e003de9141c44b2fb4684d2239e61910e48af043c072d5d5713ee0cf8c0945f0a9f009c409ea1180303363028bb2901b49e238170a1cfa829f6c6b3991a569e49b1703f0198cc83f81f732f1c0b10d5a5c0bc9347ff00aade7feed3c121e8e1ca1f51158fb917b8f57f9715e490b8ba2228c43228547f5c7384567daee4d5a4150737fce15c6eafc8ad33b1d9902187112361a37c40d7a917101df8b75f9ac684c653aef9ae9e8dbcaa5c4edc1b045d1fdaca0f256dfb16d16250b16594cd4b0f8f17aa2f8e112d2cdee7a0b0d516b38af7075149eb102edd32154dc211982a071f00da78c0dda05fe0c729bceab5718932e69d007e5a7ee1a6e6f86189435b5db84e558d7eb983de89375b8ca0e79f08cf9c12a1a56c5fc21c2a136341650228c899f42d2b2692fc051a4696b0034a9cc2f87f90a606987d5512b3b029cdcb5e5c4a0128c686fd3f244854aa85aec0233674d86544f6d624452afb413f85a6e3c71ff2f5409792b9fcfea41b9ebcd883cf1291ff08f3b329cdcf3289d9d41fb2d936883e0c01e615613d6abf4e1a973e437fe961b82074b16bf0f9359ab2e93c179d0be2956fb646e045ca58d6cb8d2171dca74abf0b3a515a24e2fecb4663236018b936ec14928a0933c77fc7a75cf172b05edba62887a6f3c275e12af777d5d90d60f11019a048afc1dc5396a001d1757d4bcadbe7d1876465bc7d1fcdc73f55c5b146480a49fb3504a5c3b855c44e2fe898c169168e7aab0426fe8e81a3b62b65ff117ec377c347a3193d9b9433942e4da6066e2dfea340c26641db2d433027ba2cffde534b0b178fa51a4265bd61ced9b56b0b2b36d2c64be3420b0e1757ffe29bf5565416d45a548e7d456592da12582de73ae0254ed97b7b50f77bce2aa36b9bb04e56bec9709b089c8fa2f0fbab6fa38ee594339b56b94b4248d9659877332e7f90aa0e4c27cd205ab9c48f56253feb665849526731b4a9dcca2ec44e74cbea3b1fac659312497724ac4f7712743e828a5119d6c3b552f99d2f72d4ad6b727c07e3f5079374cc8120fbb030fd2ae873aee59748f12a9295de315be32036567fea67351de463d5259eb7f9097cf79d30569aab26c7001326cfbd188e51ba47fb2fb7c06dc4585513f4ff6dbe33a23508c000eb069c680bd5bd2fbe45c9d965428a363f0ace331cbdc4f24ee34b0184f7728d0b165b289e1bc45690500eba79815febb2bed227445b87adadf292f11ded8db55aad102175344346bb5ca13a340dbda1779e63fac61161707f69535d24ffe8e8493816170314c8a4c3c12d07dce0215c99de8c8bf73c7829a2b0674e73a7dd06e9b933461507babb87ef0f79b775c3190b8b341d0ee4e67d4c3c168fdf6d65f92c0d02c3cc313ec34d32a4c794082474a9a83b7dd321d406b85eb0e27cb86dec77cf25e095ef8c649b57e133c71022940428893a5e4bb98be8f29cc96cdfb4389e8cd1e725ac1e79f51e18d72decaa9a24efae300139403c9838d5915be4272ddabe78d303aaac25fb7f461020ad727b0e2634a006dc861666585b8a15d44ea0390ee218806235f83bae2f3c2f3a841133572e2427889e30ce1e3a7de801eb2cbfa2ada4a563ed679d540c1227aa2914dacb3f888b1ceda91d5ecc9378889972298d0ad679e65b083ce15a713346dea603c59a990b03bf2ad9afc2ab0a3a03e4b78f6dab431d8d046c513a263c43176a239db5748798ec060d113d9ad99cbc9cc068defa9d0bc296f47d1a1ee987c472d33c33cfe51e5e93bc4a10c5dde1cd158c4d5166a37ed21d80bc28231b91e58c58070f1ebe7ed4d5fd452f31bd0749a8874149ce5bb2fa872d6e2f7cde1bb2c44a618999e8538added8244c11b93fd8d16b707462515dfab68c0650258cd981b1674e64eac689acafe18d531c2f179fefd4235142a92674cb28cffbc35496913684fd302837defd03c1602379319955b892c331d647be0612c5f6d900980629772452f07b597413b233c2543c5363983b81b0ef124cadfd17f16d51b9ba0ebe77f5ba87c5700779a2edf2a6cc41dfd404dc08562a6a6c6956c81a9c64c24a5442c887b05ffbcd495c359281a2b183986fb46782a857aab5a42ea7fc751a544c27b6a93e835a968375bb9bee6c5c702aa2c80be67b520cb4a4ac910a8aa3838f1e28723b7fa6efabbceec8b07d51739d8798e3e0c8adb7dcee82723c14fefb6648dcd70feeba7812301fcf0e427e75e7d31565a8b430f3eebdc73c8dc44eb76e4a6617b0e1bbc2baff3f6c66a1ea04a07adf5d592f6fb1a61a0e73884dcac47724540549be0fde66b593acaedebca3691589fd5f119a8f3647d81af1c6af4e70f1b6eab3dc18ab48624dcfd5c01b330d1824d65fa40168c226afc735eb689dbfcd67927b2839e58a4ae32700a0b90e60830f5d5062513b436d5a4c26a8cbfd26ad7848497cd7e9a040e0e45548249981667ac017c4d8f005eff8899241aabc503add4da2deeaa0d7f35e640c2b3b8e45007531a15aecd1834d04ba65f20a7dd1eb74e0a3579dad17c0182833470da642642f13938412314c02c0b7f35766c0c14ab48a737844b2ee813873cc5886d1b5a1f3b2847d824049cba9412e7983cd0fb78e9c32d29796b0697b202c67d31b230c773ac2272b1759ac9f748c9a2d435a71c650e923d55dbc3347341731fc5d52e29f44187dd9360fd77624b583b9f549b7119762f82c8a0d81a12119768a06eba2f7285bda5e1753ea9adba1aedd6b112363ca1e2d3e865a62f89746bfe7c8755ee618c5a21956eff6936c0fa86ef6d3a2cfcc6fd7649d0f4602de156e0338155c29349ef1b74feff6d5ebe60fe1852e2d01e301c46533e6e992344a3e4450af85fbd1877c62c39840d5408dd112c229a54b745f182fd2833fe9ee8c5039581d78d1d6b8a45415ee4d45c4d5b9152840865916b3a79e363b780a7157162c7f2cd2a0bb7f204b129c9ffddf62762a2a0e0e72b53c25d082713a120e97d4951078cea72c436639ae0794a9c0765f2846f74ae04c9d6a97b1790e327c29ff361c2d15f84d13cb36d0b0cb788f39d4d01047ddc31360aec0849bb985f2d10c4c392157fdda12b3d1cee4100e8eb95be18767a835067bf4f4081c68020d06caf3978577ad512ddf25e87649946e54542361830d0c21e461814e03d2fcf8cba4ba8deb519bfdc5849c90ecaab616429f312cc9a89624f6c55be865ca8c6672a9529273e230349115f2a3d5a014ef2d3b4be9070700624053e75e59a1597be42ea9ed168f79d50b9ba576bbe124c7c3bab9a6ed3ac36cced76127fda3b3e72d114dad7e70f87e3913005029c4834457ef4d7d452d8025062e8a4a17d19af93f33eef973089941ad4cd07c05d75b1eb3b60d4dd8e284d8ecf3e65e1e0ea21b77e35442ce8aacdbb5feba87e5b2e292b1fd0ac55d5bc5961dffce47af487ca1593bf7c49dcc924ba8f0abc787a429b18a720dc61185d625be89251ca552a7dfd8e2643c7d09b6d2d1882ae0ad1d4db9619a50d83c97fafe681b85889007fa6b503b6c107ff4926504d3d2c4050e66ad154acc922bb7da58d12f7500411e14b9373ad3f689e30d240c2688bf1514605f23e003f4f926e5d716559a8d1cfa21a727026448f55b09a469206d243ff4e1935aeb0331623ae888efb3a43f8aa9f547e01fac943a7556ecd09f273ff7e9b3b6c00556300a553c78cb3d4666dc6d8e25a446f0ed362f784bbca47722f02aeacddbdd6e52da5a087fd92b7e1b2fe87a0e7490df9795c055722b8762aaa2b2661ba773f5de6e30322371b01f15f04906fceb3790f8ffe4b4d0ea539a53ae3434d4d39df90d94ee7dd0b295dc6e19325352a53f8d888e6efe16327f137ab5c0255018cf06b6684dedd0a39c61951177cffb47577edb47ee49041db69c71bb29a65c25c0820504eb66ab182b68fde5cb37ee072a3f6458403d1cde595a24f3dace46c6ca92a8a3bc3436627cd864a48cf40c7d4f0088366f0b22ffb241726ea570e1bfc3580f2978166c886b141e212af455144aac0c69f676727c9998b4171e08bd12f177c9dab83056cbc82d59bd10209abbb379af244a3369b7cc9b4459caa38ac12f1d210223eb719bde70fd6d1fd778bfdf072cf76833e35b727db93bcf43fd9480930ccae44b2c0435088c79a05111f161047a0939b802f40d3e6287739372af0e1b5ba01ccd5f9704ff46d26a2f799b4c9e6d23525c26d679f88c3ffa3e41d1742c908e3b5b4979a3ef95f934af41e91c725ac1e3d9d3379220cb718a680508c988512cfbdfa16373d16df1c15d39656e25a11c86ea0bc37d1b4457f76eda4b80090c4bbcf0bfb402d2e72067f175ba28695e11ff9c06b731281ca6a19233458241c761a8b3efdfc47b2924a0c2a822877ae181f2b279277cdcdb3631851af350b75453f7503ec8389eec46ff30c94409acfeec3792860dab8a181a15d15793797893a3c256009fe4444d2b2933b441159a1738c6acbbabee456069897e442bd516f29656a534bc197031bf363df718612de65a368e0530766d4a3856442574e9fc273d5ef13f80257f67ae8fbf84a95c970047457fc8f16166720b0667a28b50e7785f27657622bd8324aabc75f04ec5aedf116680ea1a5ff077fa79315a6dbdeee1ce2ec2dba78c38a7eaaea7b2adc6a0f6dbe3a96e931bcb56a753501773cf4040122d83d7284662b5249ad4ac86145a5a79f771bceef738f5630e50399b410b39e28f0bde2081d3697badc5211275df02723fd840d4b00bff30122094179b72189aebecc0e07dde368e14ddc20d84e806d6ed47ec510a91d77ae431fd5aa3440247e0143cf80ddec920a180ac1f810ca4ebd8e3a6a87d414c8ae4882b5de00a5eb9b043a5bb5dd5102171edc8b79e3c380383aeae9541be51aa8bc8170e16a89f6422b6f15009d78ef9efeda7c846acd58ff49fda46c09a6432103c2ae2122b3b24eaebe16aa6d70784796d12a1c023f082c61ad2c5e5daaa0566a21d61e4955c4e58bb08581afb840ede6ff1d56797f953604bc8457aeba7cb6a41d0f0c64982e9f6848af0790224befbdfdbbdd9862e13632f0f52925b64738169b4aad55d065dd02dc80e65ea5edbf2fcafc6258d69a37ffe3b9143fbdfc418b0cbcb1f21b9548d18b13961fab7d00c97d867a19e5d95b6e718194e888eca1e76ea8de2b0e861acb93ebcdee3a501bddb18d5ecfacac35d6a18e61da75e40f8c967541c2d6d003c5ec394c9455ee5e1dc4c13462b1d796561a4efd1ba30da4ef2afc506137dd809ef7cbdac5d0186b8a03b1a404a9b830a4b12cd1589e95bbc39d9072798b21e8d0f624ff4fa7a5d1fe43f7237c53542184a6641ef6a7d7388779d483585cc2fe73ff1d2bf973da8d8fba808f0fada17364bfd1c42b6d060cd9ba72dd77cf6c172c39cb4368be28d98f0717d3aa3345590722e3783d64713e29362dd7856c770df19f30ea2a30f2419f69ff38102ceeb5015a1b2c88e2fefeea54e25f063feb18c43f289e347562f2f2f296d0d5410883b1e153f26fb5d14abb8fee3ee24deb11f0b16d75dda51c17c7fa7a4c211033fdc419c67169afc61ae902d6791316bfc4725a4510fd85dd73217fd9b2665fc5324fb9b1aff40fdb5761f7b4e942e88fc913484f9acd7b04bb50fac222f1967a51f5a0699888c0662bfbf242bdb57b9696267efd7c3f5de8d29c594f88e60abae3dee9a3a6df58172f3e062d17378f3cc8dbbb5883ba903910db3bb0c97be37d5032226f63caa4023fd51c2473472b8802facc7dc1a0658173dffdd41d8936633f94716442029c7bbc9f1cd48a5373e4e3abc4fe829c5d54f51e7e5c8a1e1b8f52a725434e262bc6ec58d6e4200756c4aa354c450963231c1d0d80917c11f24e81ccea11b23cacb0ef1b0ee2a43bdd16619e80c3ab649f2fca8b9567588bcffcea7d87be7f875869a852fa3fc145f2402365306323ce2449918695363776b190d722fcfd42ce72503df760483ecc655fbf9b65cc42b5620538d153efefca8a17d64fa0f2fa5cfd751c79c2d9d237b7172f726324fa44e4017c947893eee7e15a3200906306b0fac376a0f2be47335335e84934961c8f8b30452d481c9e89a99e0f1561e3880d8e88cd7fff1cccc6062e5472bca1efc52929fe96b6f869c0d8f7a62d734567fa420ac7519af21ecb4e2b29782e3afecdc07ab982a3e93e99cba8d446c5386f5015093cdabab778e260fd18decdb496027e9e3fdb5c7f4b0b0267a21c0632b7b56f4a9eec81935d3aa2723b7b0083882b87402e953d105520896cd7fb1a0f1d799e261001c39d959330babfd4613c7cfbeb6be712d687b48624bffbdb79f13a7837a817b274fb06392477efa70f0078fdd5beb5c7349e732fbd90c34e9e367e8ef97524c1edc7de7aa47fa27093e7da2acb9e3da66980a34f1a2f606a8e55a824d143b8be97b81a86a9e436d6baa10163790fd20d6108ed12735ac18ebff879a248d5bdb833ece6ee6459393a865a98b5ea1da3cddad97da816198acdd932a2f1ee1f2f3b84bdcde13069519df568642085a487941a43e5308d6ae9aac5af34bc2827268a9a4ea0bfec68165e7f0e167268270dfa7f5363c99468ec7c390eb4a92d54c8b42f8816a1c4353af27179335ea42f8336c85ea0f5fe31b86d16ad8159593436d500611eeb4f8e160a1bcdc2593ea95d5b16f00ad706d924a5030dd9d12f8c5db99f87289e1fd99590f533625f4b10932c2de2fb21e2f1ba6f8656dd6c4a658f60a4a876e4b6d49bce52eab0cea394c9a38c9084e39e19c5b9b27cd32ca40fdb3153254725c737d215d64c16c790affd09db11596f65742fbd43125b4c5138aefee76126d2d06aeca099af08606cc5349a6175f1d9c6fd99a9b6031cc302f77cf26f3a054d862ce8f04870f4ab91f364c2b2b8e75e727d151f92edbfa4b1efdd501b1ce54a6540363fbb5dfb082b35c2657741005fcc76a5c7e5ba1849d9c8e8768b2dfb6f8cfeda87cf0b0782046ee78821b511e237b715d87e7ad12f78d111bab420cc77ed18e3d1e2fb39559bebbe472557c5d1c8a633bdefe97902889352f3e5a19100b3b28dfde60726171c12b5cc102953d1244a8a60fbaf7d7b7da0bbd161a45cd74c96dbddb785b06c6375b66b49ddd49cc3e9b4b10b9e1ff401c99edf0b5073e044a0b1e69f5acae0d871eaa016ec852204e93b9b510ab8a2bdfba7851b8321e667e06a8968dc4f9d7815611b4e7181cd40935a0d83b18314a2bb7df57ed21756c8afd800665e367c7eda6c543a6f8321bf3913a23071fba72c1e173be1c8789ae7d8aff2362da565ec42d4959de6c372ede1c0fc1be8cec9f5939b030e8d841c4b0c110a174084bd31b3bfc65e0f4bc55626dcef9f5f5970cf9fe3b0aa3972965debe48252247a91836cdbac38cf86e953e9aa452177ca587635040c46938ff18cfdbeec68ebe0944bfb99dac4ddfc6955f863809d87badbe660dc4aa6f8d555d27bef6394bb45085fb80eb4abf76a2b492334f9af2e874694b4c98f5714c55239b35e8f01c3f7f824242a65e725f9bb2e6b3be4028152f71dd4fb814c1cefcdf52432601ae1f5688d36ea0e8843de6a6e428cc19b1eea0609239470056a39d6bae2b86580e41d109fb0837ba114c543d9d6fcb224f479f07813cf22cb4659c84ea74593d9157672b41c892bcaee1b8b1bba08d80479446ccfaae982549841429a1965e1fd9a3110b1cc7c889e15e708bfbff4cd9a9b28de8ff86d969b8c0312fe7bfba916ab19a0a7a119448a5dc558b289cdb22abe9180a6e1372b581b3b70aedd77231a8e51d08836808c73a06c1856cc1605c6427d66614634605c9181a7d6e1f206b74cdf6e67bffc157090dea1edf3d2c3d304ff2f6796f4f800c53b667dac296a5b1cc877bdb328ef17fcd66bcc1746579bb8b043206cc9c237bdd22ec8e3eb4921c0b6028fd8f55d2b3aec88d55a24c8c6e67921937f510d37a254e10539c54603473779bac28bf513254eb5215fc614359bd21202354d0b939edff3851922205d3496f7779c9ce2a2fa2f22e6a7b5ab0e6be0deb9d9275f0eb0a06337affbec6b2a62f3cfd34e26a445937f0977d0a7af0b1fe626a01899c316359f4965be333c3ff97594f7d91ef2061b29cb1f52c0c1342e0b490e6414dbb47350daf288a5570dff52c22631020750cd78838c8277e7a049dc379398334349f0b6a08e518f6b3f9695382c12b903742f35f92824b1f804f9a11ee368e23056c14cd6c668825f5dc27e5076218a0f1cc462a12f5fbaff8a5824f0821eb5311fd1620ff58534b36aee120fa68261930299fbc5eadd13cc16e67e3b39ac633738e17fb4160288289ab1b115ad7dcb3681b5aa99cdbedcdbdb2b52b601c3f4b3d65d7c1833b4995cee7e0b84e238690a2f12a4e17b97f2247a848aa06e48e3be17a57fad1a5d91d655074f28fb3d397b1d6245993eafdc65121e8e56d610b02fd1fbc54538c6c297373201152509f44a739c2edc3c635eed7ae74e2231b8398f6d6c52f61684d5d493deec4005c819d432f81a4043497567cb66a39eb3e44cb76ce264a3d6651257f3a2c95e7fc7bdda0378fff6a867d61405bdab5f9b336ea5a324e71642157e1e6eb8f52aafaf245824d2f6753330a669752656c4333c2f6fff29df2d071e6f5d697076c036788929d5655f4459f29a0e9740c553a9d01c1c8b5658b3c3dd56a534439b0092724739f4c291f2725f2268e648deedb9cd11c404162489bb2d8ffa917f3e00f3ec4515c4dc7735517bc7fcb610a9602a09c79a63af3010a76e36fb11c81efecb64ea9345283b1015e5a3b35c08e18067c032e5578b6c75d947a8b022767ba89586b80b39c20d037ac19c52c680e1afa271951ead7ffb30904ec679451ab52fe20bb19eef064db4e0f301d812dd83b9b3e2f9aab94e0a6cce38d47857f57eb0ee0bc87a9531fc5a054a42ab129c0bd7057753736f228c54df35d9421a377145970f36e1fff52a475c06536db57fca4ddd95877e62721d53ec19bccc3b7d0791ea7a952dcb84075d3c307ef86d438e857ea9d524cb4e01c609c1bc0bec78781257708c142318b074f94ddb6b40bb2a0d494867db53074a3ae448f80d4726619f9e254f44e27c1275651122b992b49f345ba5490b5c29347528a42138404d8e580ade345c46eec81ac3c79396395726e9893718efe5bab901797191816c5fa4692f74db02be77fe8ad02f009d28a37bbd7f444ce39c9f9a677519f6763379b3c0353f1dba134b4f8d4082dd3f4784ffb8fffbc82415728bfc79a103cf181849d680cdfa07c4c218a89e2819fc41c0c403d7fe293afb1a51c87d2e9ac0407bba679c34e1ceb67b12970f3f0e6d1e9136b282cea14ef344145835a8745c65c3fcda0ee027cb8315752c4d14b778ee259dec4f5c6eb563db468c86a07737d5bad245c39070c16d04d8e5438695ffe684a5452b301ac3f8cf9ff4d7703d7b1ecbe680236761c22ad6574eb01adc1534b60e69667081bc408f997e1f4215771e9a7b8d9981a06916d07b2fec062304fd7df532a294faa9e70087b1ca6778e9f1ca86a2b792a35594c506e36de09ea8dbcec3c46c834c6338de6e0bbb973e506f35286a1c563bb67721bea6a02d1f3c4904cffba6a99659528de0c5e62f1644f2f69dc9c98596f2bcf238ac2852b19860d12dc30cf03c84e4c03acaab17769f732f2ee952084f6925ceb10876852034cc73157894a75c656fab92321ecc81bda21c97736cf430ea17c7678d7b7ce0e457161ec92d77683f59b7c647b70016af68bed56a1f412c789937420eb414f31247bd9f43b571a178162fcfb6266512393a4738dc2f6ed0a0dcb3df844295db242d85cb749f38e9e4d42bb5ecb3cfed26ed478faf5297af551b294c49568f542c89b5687325d93da44de7d304be5d61869a196e1518461bd7963f5924d9413d57e06bf182c36d539a009970e0858a5a67d9d956250e08e063640f5dc29b7274753e1b87a82756ba75414ddff0781a9c4e01fa608ae5415da24e8a097d7833094155788d9e3b8def99a68e65c43b0dd46e45d65daa27f40f5639a7b454b428fb4a3538f20b406c9564bdb889895311ecf135d5f049096bb6d0f060154c1b754b4470fb29fa0d98fd4e50cfbfe707fa9654bf8e3cb4f0429bfe62e7a176e18a1244b7d29773214ddb6c7e1e1af313141f41d09b5eea83b881a3177967ca7cf26eb79dca6eef797b1dba2190870e0b746f12c6aacca2c5276cf0b07c393e69bf4571318416e040554002b4f33522df32ef37d8819c61cb1d62b96ed904c5b9848ba02b009abee4f21a3ce2bf7eaf98b3467c44d9ee3b16cff8900c88dc933be699fede86bed27dea2e1a6fefbec57278ec4e2faa46079f60c3365ecc9812e2cccfa0c5024afde4760e77e79a0be49b13cb57c5d7ac80882e5397ff8891c28537b1efb98f0d210d9e742a158625845e144ded75bd373dd8becaaccee608d0bfb5f71335254790a6234c6c5b9ce03fbafc2d2c5dd7be943ef3e06a2fc971840bd5a11172147112bb4a12d0373085b584fac9ac3cdf14afb3a4800895be5eb6f42271a3e270efbf13ebd6935210b54e4d37a6807fa395158fb721ed374c78a60971b4b2881ef7e2fdc7616db0a7066deaa752cc295d0e5b05734da1f0f9fc209b7af63aeb50b07dabb7b25f749cfbdd9151849aad3d17a7242a33bcfec399b3134871ae27b6316f3ead7087730d49e5baccb87475fa62db4ecfb92d93d30fe3ed94e3b2122a4aee347ed47ebe6bc89e2884a6f875ffc1193277097e2326a560a30479239b806e34d7793b06d982e1e831fbe5a0126263beccb30fb4a177f9f7f4d555cee044ec52e4cdcd3e355f8f302bc0c11ba9ef9e5a25bf075c69328c47c5484d34b4c7d9a171599f3ef7432a0de9d386311404689eec6102309bee96834f58ea0f0f6d8cec3fe4a1c27c5809afe04fec8c94a3564cd2e91bd4d4142fb1bf4080c223a6e3d40165aba47ea3ab473c0e8060c14b235356bf9b276b82cf33247ca4c1c6360310952cce0500f65338cffe6bbaa46c6da311b848bcf784c391335496bb88017dd03739f309c9a259acedfaa9b610facf9cbbfba497f7db62c53e934e551dd9c68b741a8bd26c778ade5fec5291c282ae54324bf8b42dbfa1d9a8e0e24db70b2a2608e21be9abccd4dc008f4e585e45a041fff6fcf77a26855d334b7e5bd77348459f268099259ccbb5a72b0d730d21884f8c226469f9d58b89b8b8f6fc808b4a6421b177214935e93a4e716595a6bbb07ff089107cd0d51cedc52bf0197f19f9","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
