<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"0c4c1e0f81b604dba79cd67477c19b3fbb07867767938915efed94d71c4b2f2ef9c0cf29bb56064e3cb0f2f14b15cc2227a6302d2c0b8da298c5999bd5595ec202b862b6884c8814e722e4a7c7bb0daceae5eb75d90751066f6ed63749c8e865a7908125016cc645784c2444fa266031f56c80a138a84102e12124d0eed3781352b807e60d983054b9f07383b67ae06250fcea2dc6d75436a2897b7c1a53ee13d6d55f3e792afccdcdec74876140fda99beb4d665223a01d36095369ac2a70ea1a90b76bdc30584cd029e12afe40d6214fa1fccb13d010fe98e9cdfd8530307a03aba9fc178c7731539f568ad5fbd46a5bf9483f67c0742680f1bafcb7dee6edb661f7a26fd8bd74359771dcd9fac149d738b956694ead470281e8e20f845a6a1d61d88f8f6f650191cae1e07400b777ce4b6e4666a799fabaedc7a2db8a2645acd9c4145b1e476c7ad7241f8f818d97d9919eb6cddc12a776212723c139ca01dca4ecb2be0e3f0260c8b0ee33e2ad7ea0d9b978b72efc4f8758c0c27671e22a925aee9609c1fd85d8ff7c3df565def50ae3245ae3cdacfa38dd9482d998fc542d149e05acaf084f76008660ea15a6e70bda57d15667a20f82cb1e54a78d2d51c1ce2b5622bb095360af0c79570843550cf158b887e58e1e9fdb925cd7938537ecc0fe2f60c8c056b254f6a1fa0f02dc481650a7f2e9e3931e6ce9c00779cf001854d1605ae860299be36219682633190da54668186f9c39a0bd10c2b1b7db3e853237187629983800c36986fe38c0e8aa7e4d1b753ddd8047bef749926538e7553440af7c667ccb96de724218f31ca94344e994972086b8e7bf92119c670cdde63554ebe84fc14158ac8e81a252ba090110be6a2479bbcfa9b2fdc2d93dd6c1e3219e2517ad46ae3770beac3438fda24dab25418b9b537cf8577e619cca5f67afd92c03912c1335b86325388524729d955340a03948c9d5298135069f57c2b2a0d1801baa71407a72df154bcd1179aa0f05b7cbd3e766f47c57d95ceda19f440d2115e52b07b6814c6dfb608f07f9af96a4ab2d2eaf6d7dba79cda1c73c76c553ebbac02d6028ad57c4ca4288e5765d91e797a71ed523e6a0d055aed1c050c82f983775b64cad6eb97c376136f398bf12e7e441d1ea200d0e192e408dd33666748a415b1f6da88fa6a7226fe1330cffb018ef69903e78657f3769987f581223dcc05634c5a16abe45263a0568516740b456348118e8af1c1589fcc6c2c82edc982e551f9810c09707c401ef9a07f515d84440edfd9952a18e69479825640fb0f1870808c20132f50334274671619fef8b4044092b263fa707ba25887b5f51d8766b8ba6ffb0c8f51f427f85068f9765dbdf991dd15a2383f9d831d61dc2d36672589260ea6d0187e72a0a1b3048a9b4f4d17cc236f1e00fd850794b278cb2ccdc589e20a30bf5075ecb699b0762a223142a6f45d58580ebe5059694b28009956f1939e67cceac5983e8f20a68c48cbf8bad76656e403d28038f4f370e84ba265eb9560c196a4c0d722b214c82c07354cf52598a3f5ef53b3c91f9e3d291737f22ba4ca839fb0ad100e291d2212971a9fa371f6dccd6ddb5f7a2a88f489da8b454d473fdf1f6f878aa6d83af2a63314bacd70550d2d5427335b77a0b3eb0e079f57acc939f4c79d95908dafa8a5a6f9228cc0f8b9245b849d215ec30757af8543668de9cc0e34808696e6163f8890f6e96adc1a70934b5a02c6042f508d3413cb4a96e0644210edba5eb5a5ceff9e7471e47c2f7e562ef7090a7ac2bbeb6d9ce8872c246f53546d488ac98a7a067149003ee4dcbc3d42d9d468f1f3782f200392a748d16dc34d24d8c24197da266dbcb8436a386d429a10c05c4daa058e753ba6be8618fa7b569d91f53000497c6ba10d7410e4583a8ff59bd69110442c1070badcc822202d352c4406a386338e5e6205e64ce39de0dea626521e30b7185231fa44d2e03b1ed0ae56c9867d2fed2ec1f723b6e5e274425757b28e73bdee2b064126980bc9baa54c6ca1717d42311879e24e75df56fdb07eafa531ce5fec6f495dd7c9a103683d03aa218965374fa0cef28f4f0517befba8ecff16b07acd3d4026ccfeee3866c48728846cc3c4464b9d5aadf2bcb867dc5d5f510591fdbfc6f45eddf676f1f238fb73025ae01fe76c49bb0c02c48b186242e9d49917c934de33f884a2987f13cef3fda450f85eef8c03e3a2ccdcbef09e1e875e34e6d486eae5d43a4ea16d8989c592dfea1ee3b51d17a05c5bd393a9460c97367128a00c6197c7a611c99e8ab449ead5868349adc03820d9e4f8217a313ad7a6447eeec860f35f4f68bda13dfc2503a2ffcfa0930ec3b0c2ac1777717b12053912c907d73dbee5017ee469f6d0996d6e8be0c14e8fadb06d33a28667d866909d876180d61131a0d7016fe8ecca3b6d049f7534ef184313f7ef532c902ec248be3018050093ee7eaec5d913234cd94a1cea9b50ee2de0ef110f17c45eb56dc068df3b365ecd39b91ed6667e610d0b5c0db26a89690cebbbcd107782fc5d68f473c7b3f8444f3938b320d078b57dc84a4bc562570a72d96b01b220ffbcb176ffa7cc9dda44003b470501a46d8fa805d7d018f040278b6a11b4b8e5c518e3667d39f5382651f15ed0c50d005b152e8a6a72dbd216781a4b87ff09c17ca5522b27ec8449d5084e6c88a76d731d1be682b482eb7e51789c33e37e99b9ea1ea3bf7768c5df0cf094daf2996d1f86bb975f34db7219f4ff3e5d6ac5c3f70964da32bf7a78bf5035ccfe10a7a5219428c9291d57764d36f84e08350675be61e245e4958369b6c22432e4f3d540234dc237af73a0667f0f65fa8be1b7675d7097f913d376e13b4073c4c73106b304de0665583a9a9e426d5740dfe3003d105fa0215516a396cbacf38951b17ba3e9d0dc011a7e25fd62f1427bae0f3a0525c31ae6e99964b4aec0e0cd196e11ad8f5c49d13b6ff9189de05b6a37d381942849518b9c1bd2061b79f77335bc172f28e8378ca3d48aa9aaafff6b549f4d563cf50267ad8972de401ee2a83497b73b5df5364d50a1904bece19646588dab1adbffa2e2f78be3e3cd405008ff7155dffccf0f543bfe1a127d733fc225897e33f2fd85981fbcc4d8729b151d6336d34850dd0839c87605294052c213b9cab23b5f853fb9f3642c20ff54f19b9b134070a06bb8d5a7ec56f2e25d7b83158224b8afa14efc8759e707c2b93f1bc033ecf09c81f1647d954ebfb47bf5b29481491e74fb1a39f986bca0f2ea883a538c0c4953a04ccad9ad20839a66918f40963922287594927e8ec8dff400dae3458d7e2768f7ddbe8b4b96fa80fce5509203d973c4ac94fb39246a0fb6805e1775aafd1f99c315702e394d655e360220b66104ef27fd6dfb7d4fa279a25c77fecf8121bc344ed84a7ed63e628527d3002871ad46cb762062e9db7a7a63ad0196ebfbb0e84bc108a5a95e0e4e1fa2893ed1fbadffedc324411c3af3ae147441e1ff047521123c14f125a243518c13c5915fcabd4e80e0b446dbec8be78b069c0edcc1ecd79f1316098bb8b9807464e75aa28cfab574a8d6cd77e48c967cb8fdaaf73987fa58bebdf23176ae9239c9030e9f5e12c1cc2c8f2f2269b599a869cf03457936bb7858207b588792556f0b92b7d6eff82df7de3630b535ce0f6b6f4fc6fbb9e24a6a5ee3e1e7622173b27504daa0b29ac6e0e43b960fc0bc0d382610dcb318e59ba4c193e03df825cf8cc137b9737ab6188875fb9313ddbe3116e3e3ffc8fd14b72451158930439f997567c21911a7184c6fab659a950c6fbaae4f0b24551b928655ec7781093a5ea05675f4cede522ff4cd1dd4c2c42c542c74073469a34181c2eaf6524cef92c4301e00922ea68ae0143da5211105bea6484b216b2988d6c64189bcb09ecd07e2132656c6a53c6e8852a6a434b1edbc842764c3fccf684ea1bfbf98a05ae0563590fb10ce9ef8fd4e83e6f9228310f50332ef3e31960033af25467a00d10331447d446101fa9ade8cb81b4fc632d5cef07ee000d1a2c5f871ad90b74bdfd2d02168965bb65fe26c4b0c707836078152a89faa06c95d0a12d7a8ba64d3569a9ea60ff6d43f9b22704530f127b5e908ff59665c02ef340990a0e9484693ca07dc4f8c59a0f6b0158972c934aa60c9e83e2f4b3efe9ce1f520f2c5e4974a152c0d510c288d83e338e735b8611ed7664ea119b18ce47eaa0e82c62b81077903c93041a46bd697e48e2a94089ff55bbc9cd6ff459252e7a29b7b0e191ca5e876f16f98411c36a2d744adb9eed726eedfdf7f7e79c1ee2cb6854f5814c9788895201bde8bccdb40cd1725d212c9cbb8fa60553771e94df8e3a672d496d43dd0809fd32c19ddd467988fec336419b1d70b25f95d4cb199b84f8d6dec8623a1f716dd65ca448a2a384d290a74d1211744a258ca54d443a2af9a46f31830855333ccbb56b6fd377f538f65a4fd8715a2814799773d0db6b68b626b3ad4f50cabbece4ba7bcd668cf9692672773ae05c5b504caa6c4c21aca87e7714798fc1e3c8800a99b29fac5e47aff3ff1921cc8ba33ee850aa8288be711f8f1bc49faeb08d214e0d4852e2dcc9e1dd703ecca67ef41494e479b828c46dee1ec2bea32cde2876df1c55660583a599e932a9d591892ab453971192a2f7dd4d9b1120406b78f137bececf2179c0f32237cf4ac01d4d6c29975bed028198b1092526fc0fd7e88bb18254dada6e48db2afef20cdcd09a7113dc38d10834e11fa5d196c8642f13f050c5cfa67933a716bd4dda6bf3d85d82f771ad882cb12c6e40ebcf56df8184e0b2b9bc1a5c0ebd2df3212d5217cc78c6d506891798f0dbb68e698b4cccf9e45c35ba3bf0017e75722eee5f2997c379b5b91dcdf546d5d372f3e2ea22080f2f235971403d3870db057e4fcf82708e3a9dccc7192c7c53a54d793347c467efcabaf5383cfed84a3f1ef5573df35f1d1154f94f120a2e199565742978d44cd0910081523b6aaddee07a1108584d6575581d1b3196a3050f5523a7663e297174d22fbd94dbfe6b02485679e5b50ce95becbb58fea16311c8bec29afc6c4cd6ad2c23a71a418876737b083e0b851e3e90d6410fb8e03b3f607e901a66dafc4b5cae3c1a7df4d069492a2df454d8db1974b866d0dae43ad8e27d6947cded4283ebaf51df81a73135bebaf697ac490cab042b100ddd0a2c5d300ab1f069edd2559f0adb91e0a56f94e184222af56e566f8309654ae58e9591944d6b346f55e3f483068975a69290c059276198f5097b61baeb9d69ddcdc26c404fd39d7ad195fcdd69f0f6a9d05aaea67e281d38784aa41b67e6181c86c0c9ad5f518a0cb8c914ae17d4a4fcfd7d0ee2be5a080a89d693a7f55b285de45de975dde3006ba7253451cec682e4f375f18cde83535220cfb6680866bd62fca29bf2d9e4831aa7566d18e11ec9155fb81d3c135bc8a98781b2ba8c09309806922403db9f2cc878763930962ae8ed42e1e80bfa50e2de9c5edd0c020928d4b99ee08504d5fb2204a3b64645045df310f6aa3a9b724b48dba14b784736bb5ceb2fdfb63f34cbcd1d04467a2f46c79cfe09e3d56347515659e2ca978976b4cdcfbcf7515906009553c13bc1ce225d1fc59ad3c536e918d74c44994a738130632605fff2a972304f1757e3fc8e0830f6392e00fb9f798b2f1af4e3c4e661337a74198e85599d9c1c3f70c50840f4ddebb68e089c680c13d05c7c12b2f6f630efbaa2fc544f45602f4bb3df2d59bd00aa35a2680cc033d56e36884bbe50c97e77de9db73374b9691966340f264acb7fffa571de4a5c8635261ef646f99d131925f2b8fea4ba1819f20ee78af35bd9db1e5d79bb196b85fcd8602c46d1a55b1b634dc335529ac9284acc5f05d8c5cb3519b2e2050027550d9d397e2962f809aabce9ebb9d271fa9b069fd365d8f11606b0e81d9cab0e854c1e33bf27d9bef7bc89b914e7a2932d3c15c933b305c66b9e64acc461bb41166795e727753441bb696b39e8b555c56a4b5215aaf4981e83e5220f2387a2e32745b64fe38903e26539b3cbe6b183d68894a9496ee3480709ccb97d9e4cd65d138ad9507ec5d703818d96ccf49b925b079a941cd0f789607bcb0e532bd631da46513d79b0a4406254c3e8274929e5538e217b6fa32ebe2a02bf1744ba4ecf6a4a18d3f58ea3e4f86c5682eccc9714871381b47af748c3e922ba76419657605dbec25f62112c7f568d173f94ef5f6096d1be7c27c1c827bf5fa63a4620c7ae6988a04268d077679fd17afab335f22021760398362d9a948ad216dbb23027886435dd0d8a92429362893b6af8b8e874097a3b15be99a1880b2ba27adeec463a9afcf208b7c93ccfccb6cce56087cb3fe0860d83bf26d7bf695b825db58d8ad8984ec32fd9cfd323dead2bc7dd6230725946fbc50de87779c9286a4e74ff339a94e2294531c188d770c0f3072c58fe4bb025bd6131c7e9f5d7bc19aed21d0cfd00a408cccf820b7162a1ac59e1d54b430f31bd6dd654378038ef12905f4b41ab399a2a5e2b6ea7d8449d3b859cb28e4b166dcacff5244b50d414763636705860c3f0c1cbcf119ff8524505737c0f9c6fff0d37ba146ba1c39a8bc07897dced1acf2901a84fc41b2d01835762783fe4d7afcf2922770b2ae39a196b3e165034a4f956576151c72a41abc2bff6522dc872a9b5c83cdcdcf435929d00509e575853c3fd23874bfa5926219cffa10e04be4938bdfb0f5e882508d801f676f92983ed1d0bee240e6f613e475b67e5d1fdd0065718aae90d4927da2039c857cddc16db50c58fb8be7410c96bad0cfa32e43c78366848efb972cde63ed2d8da203fe01161c940519815f5934081cf36a66225bc4c0008510e902d47f94b2681d5243692a4612fa201cbaa0a5d5424752296b6fc003e0b137c2e424486bb2b42a05cb7d529919c0203fb2e7ff51c50c7aef0ba038738e2041a91206e90c431aafffef0ddf86be140aaf66009471ed0af0a4aa838b46e5a932fb5cc9c6402158d4cfb1a5f45f20f2fc0f4e74083fa74bb3e9f858edd9b6af03c81ac56b5cff85a2a0cfa55a2374ba5a127585f9f0ce93f7bcddd7b2bc2207b83cd455b42f11600c6572518311c49e83e53489f6d6163a66ceefbc8ffd3226bbcd2ce08379f28f56dff05911d30dba095000186719463b4540673caaee4bb7757b00ceb9580359cd93a5ae93d9aef3f7a2beb2344fcfa156ddb92cac528f1288d54146b07e058d06c05b28a8e237e1b4af9410d351753341660ec73ad80a4a8b626226649cb527cf0cac0c94b1bf332b6635a7ec47d68c52f6667319ad0a5536ede4f17f05bb4b80551b45ea496c011319eecb8bc61945912edcb0aea93e2bc63898207d2c05d31350579f8b16ffc68df616f2da30a4c3c74db357ba4116e67f517de51d99f3d73b40a3d7d98a13c395444a274cbcbee1758b2fca81916629c4ffc734d71bab48da85704a4aca18e8e9cd6e0bfddc540eaeb702c770a140a202fa3f470c32cfb62ed35dfc6189da7fd432f76813a72de1272d9020f4c9a738beb8bac01cebe0b755b9d870b5b7df0c88d3aef9bd84b0507ea1b64e16ba05959bc5a9eea58110d5bf846d622779385850d2339e6fd43903b4256e4d6bbb67c92331d0f3f279023ceda497ef570dfec1ab8d364fbd632fa44d54304abb9b3225d0b037f7220e980c464fb7a410e8b48337d20629b882e5cbd2d8980da6a45674a5785643f6188c18f135b311b8209e70b8cee4273cf2e440310706825f5747cfed1e5547d8ef61ea04e06d1531a1a88f960f30225c0b87a0f2d3f8435bebacb441138097176f8b625062350c9bac6b05773f30849dda9a4cbbb812390b2d9ab4647e6a818cdad870c006e2bc97fcdab93e3e5d538352d03c776e1d5e323bf34794aae2352fa8a4fbc35e930e300cee034fca6c726bbafea566b58b9a3e9031da5166818d8c4184b28e05b461879f799ff609efe9b232b164706a432697c6d90aeef79633338548909e915ddcfdec79115a03756585ac0f8cc00c49c5545229c648b822cc0bfcfc6ceb3ba1ac01c85707075966e6d04b09c094d683d98c04fda4390e9e554374572083ab0d51cbdd40279a349a44317744d283cce2de17c2be1f40b512f6b2dff93ad042f4d28440674a659fea703720f8bc135ca3d3b51eef5d420f2c9f84e18db4bb95f11a282cb16328d82e66dd1126a021a561661f16e241cfeb18a2f846e021faa449ee1ef34e91195ee833be55ab0000eb3740687003ede49ba65fd76726adadce8dad6f7c46308097b98ffbe247f63b49d4d18c48c182a750f28959dc77d8e4de4aa4e3dec759c97b648951ac974bd4bb14f2a49ddae6ff15993e778e3726429f91e8c09e87e5d4f084986ad88267e1d0a768ddca6c9d6cb437c9ad1bdf2035ef505c63d8660694f032bd2143e4e74e010ffa75312aee7fa7652f6b3df142730376d00be8017e5cc46a1217aad2edf87b652175d8eb2457c8c84fa4f25ffe588cceafbebdecb421da4645d3cc02777e316cfd37ba2ffff6afad92c00f11ad3e43fa26feb4cadd78f8908ea6c56c2098ed76d3be4ccc3e30bfa264b97d38c3aea40f2b72fb0bfe4f1c49262ceea00d133d8698a6f9ece54ad98efa53f6bf42dad402bcdf26c9dbce964e01fabccc4f6e0ca12ea673aad4d26f33c154cdf666314797345bd07b6f7b748eaffd36c6dad13492a10d8a647caeac34ef8d81d469cb930529172209c3073ee04eef4689d63b4af6a4812417a78dffd6fdb00423e5615933a961dd6da7c7cf54de235ee7f43d701d53b4b416fd6e0ce71955d50e68fcfe0ebfe1db743d85b45e9d7ed44260a7c74cec3d15475682fbf1f4703ccf69068ede01347e2baad04d6f30f0d3148651a1cf5f43fb0dce45b5e15a0a7a2a57abd1b1e143d3265dca27c7479def13a513026675fd495af41461c25ee50b0a31d335a5094edd6f2f4e7814fbc151de9bee5428a0650c8969c6ee5859fce31f15712dd389d9c4a78f32e5d79af7c338bdd5a08efe2284ae62867faf4aa0b4afdfe82f61d9d7d8b03511afa3b50bb41d1ec122fbb38c43f9c23a5f22b315b7d716e3e6fe9d3c9e9d8d7544e3f3e058257ca145929d00b808ddab6a239063e7eb53eddf67aeecbab01db0a8345f729fde4b4383752202061a155829f43387b8b35267f67ce87a46afd797495eb19ae5b63b67dab346a2401f5a40493d8c1382f9bd78d81f5a71e875a10d24954b43b9d4acd9826dee9d6b165f32854b8ab9a990fc2019238a8b291950b56cf085c39fe5e34bfaf240fb04082050648834c69e827b829f59c7eae33af28966ba7526fab9d48247464dccc2c8ff1426bb976ffa8bb5ebaab682103723b30b1d84f7b9936818d6ffdcd1f0e4739f138663de098e2ed20947122735ed970f19625b0b3e0cc12de9b0dd64c6e2873462fd578657a0d8e1fb427a45035d43cb2eda97e2b9ebf8ebc8412a4ed3d9d60777c7d884d6b20fbe2549078a2d4d588e614ffa82e765c69abbbc4e447833802590660368cc5b571e5624cedd2f9b977132495c38c572ab1f786556726077b5cced4904e97bcce75559994fbc9727d607970c72c816ca7007e1f3993cf441f393bcccc84c07fff388f5dabc4085ec1f422fe8660b21218f66800a5ba46b673cc3bc3da1e8018f9694cf1655cec6999aaaa68cd2ae1303a6289d70cf62d0cfc492a25154771a8e9afa8e29c1afb178ade8e012c86451dca3719c359e987a436a3cd31772e8d71ae21c85bd43d6f79ad841a792267cbb60fb00cc9a568cf904a445fda9586891551a03366b96e3cd60bcd5de23d6558ad379d78d45725845c44588947ec4b31c55c0ab21dde76451fee50b2c131f37bed69b1e2acd7ac04435a1ba0e4f918d0e490db710f8bb5936732fc332f7c15ea3ce9ba678300e0dcebfb03194ec79b8b36b00b1f56ab1e37f635cb5e32effee283f128d880dcc4a4051aa65af955ecf6390184b5c1940887ec4109a978a12eb86bbfabb4c8974d4d823fc808e27f370819ebbf4febaf215ce99245740565266b725f15570317bfee7ff43733d4516d4d08286d80bb7ce224330d2a7f9987b1f9cf656cb333782d96024db486ba4280f893541e4ed5406fbd54c9baa74ab86e902ebea087197e04ad10344bea35b4d5a6cba7139690d49c04e084b908742c36cf05768c947cafab1e589d07ad31bda5c1604d4c5bd13e4633796b8eb17e25f7e8b9abfa3b821c72b01f3c27f4573698e5549fb64f23c516b8d290ec92119a70719c5f33a260e4bc5089ec6375b2f047c65bdf1004b9d03310b41314436933e209c434f9fd3864f8ba5de8ac6a4b86eebe52cc2973cacf01b8a4ea16c57d46ae24b20c54b5f1f5d14177eacf8fa695a7433422d247b00ad76def7fbf5ce678a1acb3881dfaf5ce77088ee24959c60b8db49263b21cf40d44bf79d9ed39f98ec8533b17638f2b11665eedb0195265f05f33965118ec7aa583fe7736ea7bc56ddea51a25a9bb6cc010219055663100acb4c3640bd682f4f74611547067bd3493448e9664a235987dfeaac3180f87bbf8127574a93e80d97f7cf9802859e2de4f87f6fa580d7153a4e28433abefcf1c7827e260b7e6390cd0b84ed2fa45c70c88e8d7eece67c0fcb743eb33e5d3e84f995d26f0637cdcb55b41c309a240604f05bdd1371bd42aa0c6b5005ce1d5702e8186c2936e27cf1ba9f4017bf5167eefbfa168dc19a775c022ccdf421f470ad3a28cdf6888a072a4f05e728545e5cecf332b578eac0b667f320ddeb718dd78ea55678d954df1fedde25fd59cb6bf730ea3f3966b46faa9d94c72cd7313fcda40f30060ed740c8eed8022e42f2abfd7e359d1d666b9f00f17e97aebf8854ec06968e20726e1fec94cf89e91eee1be330850d83628c41767b5a2b561b4dc98a8d63c833fbcd968502458f655c9e04404ae33458751ebcb55d0eba258fd4912e329b2acad1ceed57be8258ec01ea1c5762101c815d4e8c8b1f8d6dd12a3b5017cb0803ae1dbd1d40f730ed16bb25408fda818b7cee01ae5c31bf22510560cfc53e6dc6c6c71d1af96573f5cce27ab99237d0a57a35fe7847cd2b10cd325b3052970ce5333ef5c597308b5678e00857e5ea766413cb2dc2aeb4a701443476c6c92ffbed487c434b55e368570601dd6c94b729f22102eda5833cf5416c009881a0f06ba578c42964e297b5da1dcd125c246cb3840632b0108b62ac9e549fd397a9561d46a0f3a6b52b5437d3d3f258575c5c935efcfe81f3130f471e1939739fbc605bdd23dc7215765e87b72c1148ad2568df7184e130b382419a335357542c7db775ad69d7cde9c9bf1b9f57d5b5ee9d797e3a09368bc2e0e6f62d9ef14455c53b27eee289d7a36086d45066abc2cbcdf66983b3cbcecf641a805a53b2931296f450cb44e9de20b34163d1affe027feba91819c5d0d969bb2c8d2fb0b84c034d769e6e9a552edfe1868fadac3923972b9720d88c70f03af7270914810181fdd38f726f393431eefee37402510a9755ff1175f189e456a514229ec4596f2bb2219890bd0a48dca45f40a49a571be20db678a065cf3c2c109b36a18252fadce46d2b59a55c89ba98281cb5016858171328d260f5614e336f59fb17d77d0aa1b3c343fca1dd7d7d218a1342d1a41da5047239894b528886adb118eed7d12b5f5bde570a092c445ba6826b1a8f698067bd33486090464d26e1c69222dd68487b4883cb35a199c2cfb28089154e9bd178468bdd029972981616c01286f475db9b7b55baf3b2415e4cb4ee2ada189e8404cb981de05664e614e9110579b65b3cbdc39f5edf1719f115813418319fb967a531d4d80d50555f318bdce7ad12f334e4aa1969602eae9486d07bf816227c3c7aded344a97c287ab94c8a269ffa6da8aaccba05bb872ce9edcc43109d2dcaf189c4ba78e01be3917e4cd661800eace10846add187279382914a29615354af1a6f386235540d7069304d1590f85f42910a6ac3fa35e2739913374e69c01b9a824e284d2485d7f30de74dde6d5fc7e29c9c7383a8562ebb90951424ad052a877aaecd91ecfca10e727107bbcef8f49ea1ea28270333e21eeec9fa1222736aad27ff1c2061bde9d4a705d767e415e6b4656337a40959038bdba005c2851c3ad137faf571da84702d15d48a8ad20a25f4c7178c13f910f74b7e9609e036f0112e1b72ec226a5804a60e5b482bc9596c81e08fd1334fcb01ed7b2aa2c7f837a6db9af7a007383511a9ee8a66b8fc94abf379f1111c73b1a9e23a2fb48fe6bbe1e9a3a13cc2b0e1a5c95bc88149bee86638fe622ab4430b88994c05395bc31e0dc116c6b052b5d4aad67aca909beede0ab3e339d83d46b3f0ca297b07c3a6e731329d09c93cceac5a8bf5f810a71e5c33a38acc36fb3b242449dec6dc03d800e1b0be0de471a51ec55cf460b86abb46aefe62a4370e4e0b7fbd987b0d0be6803b306bb78a50c7870f34994585aaba686f4de936dbedecc27be882db743f4f6e705e49c7ed7d5479605a54ac607da1abc944a589bf18562f1c1cd69a080a17af6eeee7e2c1560535d16cf2d077bf16cd86bb0202c77051cf9f33709f8b88961fa2189ce7d9eb6e48ecde4823a44968b200bc8888b58f1179c7571c8e5ef9e048c2dc472af7b4b994a7f7715eddc30b3f4a6a36b50ebe51a91a8fdfb382f8df61290b465347d1c7f49d244c5da0b50bb1050f2de516a8eeb290097e3967b499148b918402cec0ef03b94b71c8835c8f04f0eee51bec5ee24906d94335b693206545f8eaa6232c835c8a930ecc6f04d80cd0bc5b593c6143b5a84e1b191f42054d6f91affdeeb29eb24784ba746eca81176e453ca453a3a7485d100005c3b25064ae3ed5e9638dea09e9c31719894eb20919a05e6fc15609eeb282e01dd23d7b23d177e09d23ebafda3acd0ce1857d6e9ace017f47d028fd627b84e390a1018c9c62f21d4bff2731909d3af7c7ec109bc8eb366c48958f2eb8431cf100da38cf080e57d77e3e7e4652c0f5937ceb977ecf20edf45f3c04087f31b304cdf423c95cb081b799234fb9a09179c225ce1f12ebff188f9f766c25ce61e5c41921575645ab4a7604bc1ac0c8d210edbca6ca8f903d790b2c52ad1d77054677559a8c01ff6ce00e8eded975123477c175daaff9187553dbbe4b6ed1e5a996884078674d4d1993a46e3efa82808bd69ec767c9999e484742ce9a163a7d65e3e461906ed15dff4a2c6da1b6d8dbae290ed165c3d287b76d047e26d969b8fa084463763ecd243878c55b166360412b790c7ba79e88bb6f0345e6393adcdd563c7f5ffa6b529ea2c372a9ef64939824fdf80ab49a01602988d35fccd1ce13c5c4bf4df1ad941c20cd6e44ab10eee82c33b580257bd6e56b66aebde92f9345c18563b19b4a839101c199627eb11f057beb9f2e875f219a992a1ddc1b4ace4e6778e1f67fcad159974c5026d3919971037fa86feb5f7e9613614e46822ff0ef1f7cdb973163532e1caeea922a43897a376192314a1e525032dd142992e9dbbd267d7b628c62a973f4119b609de0ef327abae63ab6a67b0f6c7029975336a8013f4d0867ed0c8a02322e71689bb39d2e1cf7ec5d9b16e194c6cbb68df6046abeaa91caecf31f8ecc14310b80a95d83f8526cbeb9e937ae6f375966666d45e56471cc3ff52f8418ed649c6ccf85b1e90d7b2da494b2b7cada56aa4adc4ecec06a9ce81145902d9ff3d03e97f5863c5cab54c17b243145f96a15c6febc710affcdbc426aeacbe6383369ecdb908857e0fc75db65ec0a956e1b07d3fff80ff639d6a8efa96c4c66247440dd1e7aab9ff4f9b9cc2422a08093e7de2abc3304277e7c4be2d12126367589815c5629f3d511b2c928875a200e7781a36d5e4e4de9fcc445cb2a35b99afb220bffaedbabf7636cb3d4356409e7136a3de60c4a0aad69a1bfb019ff2bd507ab68970ec42b3d37417b1bb040969ab16cdde8b69a1a9b57e4c79508375beb33047f5b81a9cc1378f2e4f46e9cc45ad2ed496b15e6ac39ff64a33d2a4f7f7b3136f5a447f0b7f571ad34835f1ae0a90a13571ef9f4408e6d061be465d22ff5e6420d39defdfe9026ad0fb5c68a69a59089a173588066a5325e9243c9aad84d21eee86cde011375ec59a731a77261ee79a643c68d1a900462392d6ee8706369bc149311c220cf6614f0eaf7ad83749e7b3d1e87472b01d1e1e37df77e4a3d245e657d572272c2b7a6e4e7f99f1576559378c563762150a68080823179bd189346adc1d30fe1be39b3fdede6e97f48943532241da73227559cce292b1db66ac3166c36cab93c7ed06f64d27bbc08e9dbabbf4f4d7f8a60117616bfe4e5c426923a4d98c1064aeeb2e32b1b1f26e93bdaef0ade91a5a05886a9e85e92da0d95e7a1a5bc0d2a6c636316b61785fcae3c483d9f9b4e99b4c3930c99216c96a6da8fda470ffb547201399071ddce9c9e7af98ff92b0c598f59c2cf177ceff42812e41a9ebc7ffdfb029eebf7d74bbe9c484d9f87280e81d74c30bce2a473809a1c354348ac9c2291e51b3130065e724d9bf33966d3bc985c78ea2adf3c0a376d580db875f954104ef0ac3ce7a94ad1e2be0281a4d346e7df65e92a2fa6338105bf39e68aa0bcb91048995f8f6fece33c565a0d002c38e7155a6050f7bc7077cf091eaec4dc0672a81103efb719fdf41866be20103d2a3f73100711cb491661dce09b730383fe3d44283433f65ae92127298f5890c100795d455fd3532b7cdb858024409da1ff11cfc6e5b172cf5d4cc77d86986cf0cf2253e7e5fc7a5600864c9c043dccefea7d3202043f78fb980f625ec2360db482d712e91afb679313575d22bc844166ae8aaedd10f5b18f00a3f4514c455931a63a58739607617f147460ccaecfce90b10e32705d322bc74d28c7cc8bd126fc3437a92fd932484522bf7b51cae897e6b22556177817760d9b265e89bba2008e3f7ce3ed8ca5f7b09b16d7aa7cc9e419f1e3e0dff3c578ced0385185872343e1675f86c3984bd5e34c25f868cc97089ae73dd35feb81052fd89198c99048f7248bf82383e80b17f3fdd17d2dee6fd05e6426e67bf8bdca36976931df7c7d16fad1625603812f962090eac4617457b71b3b553d59b22e10a345d477bf8143da93acce378b454610e20fa4a10c20e5578b96565921982e3edacf80e830d77a5a969c07bf25098d7feb634a68d2b6d9b5a55a9bcc786263b2fb43bf0ebd1847c2b3badc4d137c44275f3acca765b27cda472401f6aaba90cf48f2c4ef3a7cafb13f1b0a7886056484297fd622392b1572d9c23507bbeef020dd79a507dc3ce9fdb5da345e15bed27b937818f5ce4122a874f25e0b9d22fbc315c9fbd2780375ff397e13bfbafd905ea4e63d8be75fe1e0e147c47186ce6531e1ab47b23109b7153035c46f6e533e704428458382ac574fcf541e0fbe472a0a80dfdafd840c8c48a6774b9dbfab36fa3041666a251e87c426c42f69ad07c5b6e129b7643fc75f4b5697442ca2fd04f6d4ca4f99ccdacd8c12946e9274489ba4971aae744c8a6ebe47d61adda5e38476bc90f4958aebbf2d1f0411385d0016fcd0d9ca67747f71f3c91a23efec3840bb35b8c4912959776228bd64e62961afa8597f216e2ee456c1d951d2c5182f2d47e9b075044934c9dfd209c593a51006acca5ba631d4db598301277af02561507e679d842323909cf779d96bdaa7088fe23eaef899eb562e0b12bc7c565500ff9e31dd0506c4846ff4d2bf83b78d323a525e34df91c1c8d94cf70a96fd51598e8846d426fcc28b86a8568896dc173a0e342266bce77c6a686ecac5b6a97f363820f935bb86993f569aaa1c8a321600a3bb5aebb46607d13ae6eb17e9cb79a49126f84ffc46dda6ef41c69023b3c8393e7f7018a382ca858b9dd97b5f4fe3170b43dbae852ff03f3912ba634304fdf0df61229a4c2bf52e215cb339b39b7fa4ba37e05526763dd2614377b85f49e548ff6bccd99ca9b1fc86467392f5297240fb8cfd00bf344a05adf2063129a27db60c26c21eb600a995fb2da0c521ee248fd7b761960bc171cbd1ccedecd83054f8c1731fb607ed3e4760e9f3d8dc389f4f71f255bc34f8a83e6d28fbe59cb5444383fa4e27adf73b71fbd1823500d02a2cb030e3b50bf24123a137975d5e1e44c5d4b62b0e4c69b52fb66b28bfbb82590a2f6fafe1b181a4b937c6fa2614e34295dde85882d831bc53c87acec1ab11648d4db2b153dcf635cf2562a636eae1ebcca224ea567667eeec8c5fe792f36d493719b542cfd73772e4752742ad8a05a5d568fe339c745b4a1b50c4088cff2a1d93ba66392898cec149336a430fb9801a524a1655f160a74468f2ee1da694ef4b89839d0170329f2b1ff94961fe8e7108b08ee9f9eccc2126a00c286fb6cb878940af5fa73988bbdac62e179e91873b1a66fed2e000861b6f5a0594c488be408f9084556c8aaa13829eb2931ad77d5db2728f4fcd7ee382fc2ddc72dfbb829e4a46108a0675d0acb7fcde140ec56db8e96d8c39924583277059d6bda85f998596f96df3187f6b6e2c4bcb8cdfcbb9b09e028c8d3d38e5826e0284f468ea46e24f2a5c2c1c2b42e26a67414d96e0eb3cebf663efbda4b6873585262b8810376430bdf2669e0a19f5b40df4371a7d585f0e93e1d17a0db95c9c970e073bdea000e2dc967f3fd127819c0807b552ffcbdd66e4439660f60100098907df92321433646965fc9a3ba6bf777d84270cf299d6df9ec7d3f4c50e443b9525c5faa52cac1d2c3e5fc7d9d197510c14299730b0ee9d3a0a1e75ec45e0c983fc6acad00be92704c75cf954c8f76bc5cb0f958c4a6bef23f407236b38b2ad67136abf2d587de9876fd179f2b457166d73454b9ec81ab78dfa165f254908b353614c9e528ef82a43b2e44647d3c93ad7d0d5cdb738839338df8b4d19380abd6abd460f90bb915c15ee67c4bdd40dec9c1eb6b5e506573e8c6e2f41296539449f409ab5d02bcc4356b76a90671fe7dfbaf3145b4091b64b59dc72a74c169787852b565e556414cf744c9dd78a9e241c54617c3bb2f9a1946d1fe122007a422475be099d333a468989237afc07adf90c2cb79896e6b5bdaa6979f7fa8be12b99f2e6060b130ac7211fbb0e86f36a88f3fd32ca402ea8f0265ccde83469764b70f66d4fa21f01ff8b3496271c89fc2c5a29149c254354778fff5c2921f295b2c8fe6152cc3e4116ebb75fad5e56aef22e4e79a6139631c6d39313fb3909644f4d1658f1270b593c66d8b31e70974c911237fef3352912b0c1ac34f3f4c9e0a057fd92a4d995ec21292a2df74b61fa52e80f99b24d639c9b248ffbb7bcd9e1980a13495db52e0ce59ac4599faf69603fb3ef3d4e9d36fdfe616b6e116f38649de6da275b37369c2630d6a2a979501199fd0f1398bc3f190bde35a190474dbb1b11ba5f316a73dcf73c9f0a8356a2572c45b4277857c9c773933ceb1f3d9458e487966c243c64f537efc3e02064dd007d477f3417d2a38266e79ffa3afa3e96e697db5fa85fc319bb56845003deed63e5791dfb917de83d28608d44274e49fb49f540a42cace4b89abd309726f37be77e6d23ec22268ca2e2c853a16e7dc19d4f577a734831a2e3dd8fe54bd3d514914adadfbd447538926b9bbb6b5bc5b1545429b3f666e4b2f6eeb8a1832e5ac0ff0a847a70ddbeb1fc50804650986b7f3fdf4c9f94c375d325a42d432d0ee2b593b115423360860180beeef1bd0a52e4ea49a283cbe5758ec68d5b0965ce2ccdd455801ecb9abd9cf1db3c33218e2a381e1fb7fae9c2b7b7b40e969bb736a1c2fd0d5efd11a77bcb21bf43eec6437b4f0f052be35436e5f38af13a1d91929ecff8112d1146eeeeb1ae30be79116518a1b5e0006f891b48fa6b77e521551366ffdda1505c7a35a383f9a2041bb3ebe82674efb3c5142e6fc73066b68c9150b69831a4babd49557d9fb06376824d2cd142d7fb3913a40a6a774c530e36b530a72fd1080373d7f69be27b322ac7538d52f8808e7a7dfc6e210595ddb4c5f0443186193d911bf0729ebbe636304d32695a56d5ecf0983d5d6edce5a55a79ad384c3fa679367929690db540a34666bb459f7fab28b6756924b1abf6fd24526dc728f4853949d086cec2a8ea5b2d64cb927843cd6b2d6b87834dbb2f267d7414e5ffeb6e041a46402ced2a6bbc5c09ebf333c931226e9103b31c32e23e5de547e4f91201ef8d653ba315a0730914404a132509792a2a1bcfe1d53ed2f97e0beb26d606dca59cf4a4c14634ecda6b9b52b8a4844d491c8e5145a56b9c00637861424e036b2b6cc6b8454f678708ddded1038e8388454e2aec083beeec69ce85ba3eafbeaaf292ff3c7a0e18fdba26f3a0e987091a12a3d57091c5b50d5ea0941c04e79e4b6f0007bf49fc62a0689600cba56585e4e9a03574776decaab9f423beeb56a5ac4f37b6e22018dccf361f0d1dd76574bca64b42cfbfec0623a1aeec037f6d1d63a48a563d4b7e82bffa6906489664bbbc4d3be2dd9ce2c16a8a07a52675fa2906aceba4452976646b03bb69c6aabfba5d6535c244593a1a97a1dc1b3c256ab2b9bba64503c1154146c46fd5d756918f9aa879225e032d2cffb9368bd8a1074ddc6c0fbcf06faf864354385450704132f6bfc6e65658f340595767c909745d70e81da384b302ae1c220d35726776969a40165cdcb47f6c363b69d104818abffaf5d911b6116991fb78b59b040b5965e8348507a9c00fe4bf729be846c879dfe79a215d4d78d02b1a1f741ad6b76c72195f4c3087ee8327dfb16ebc8cdaa3e5bb1c206f7a9819c435195c1cc78a92641583d42a84cbe42ae611b90a943e06dad3c8c2cdfa6c83be0bb286c9aae837d7510a553cf8454b246d343fffd7a9aa70e6a5dc37f804cdc2f61c71054460834cb1cb13af96659dea4f56d7bc4b37acb623a864c7c7e63bec1dd562b942032a6719008ef3e78618fb0a98938fa44f822acd2083c98fc29e814dbc5973dfec9cfe3ae98c921bdd1a8a0014994c09ca895a9dd3d31f6fdcaf35b6a1e0887f864737d4f1bf24d3997b2185f8e7fdb918a25cc0d3e0c40298ab4986a1d8f98cc3b44551b14e93d0b211630b3b148e1934868590d2bb142b9e9e450e964409e9abc140f635900eb57e1e3e1767ad29c9e83b1a15b246c6f903eb01c37056dcbc46c59560585f56cec5263886da6ef57e09afd244a279063b321a283f3c88340e9903ad335427811a06c610a690494178f10a2949d4b15427a74561e242459a509e11872b3c04d99f67ed042456d19e8d7f78ad49629c8dbfd2cf6eec1f8c0ff90e0f1889d8485b916f8360d140a3bcf0c77a2547f51b17f7c18556ba6569d4c567bfa2cc4503611e0b40dcd9e31f5d5f124da1f8e6221d1bd1b67f07071e361757bfd86f9c07e6883273a3092ceae0dfbc410e17014b569bb08ac99881b1e4b2176a76cea04de8e51cc03a15e9071bec98b32b71e162911a21fb14554f2d563c9f472a6f06a605acf35c8f78643fa682a5364541754f143eb252c35cea25bfa6178b62b9ff0d27ef529e337dae9f2c322d483338f968644ebf4d2afa32886a1d47b27aaf3d423d4a7206887f5ff181a613b3760445c867250f5ea5c049fc05aedf5aed4c26213b63b4a8a9e2a591ba0346baed38e062e7198a87603f7f881de94ee2b03badac0f2395301b4c0eb3de32335b17185a7ffad93fad93f3c5cf7f3ddd3ff11b8fa7c9a4c3e6f3b68cc8b3287641e682ec53925108f72397b6dce6b7723860cad42e43378717ca3889901b99561b64790f4a3ba7130845c36b729b580ee7522b30beb8ed7674363e1caf0194d6715ffe5d4dea1633a5989ac4983f2bb4ada604c5c58cd26d7a6ea8172513a8cca236fb2c9b048004801e4ad50d0b7fa585095bd3cd76ef0f73549fbda6c5a0c94bec67af1716cf870f35612e3ef57ef3b9c203f50d8426dd344703e18d4c9e7b9ff8dfaf2ff60de0546f3bf2f7778efdcee8e4fba757a2c3cc2399531520fc6ed2424c93d354f430fd051235e92cbbd00c85500de39b46377b7718336490adfa7e8944d8b252cea74d871ea954b368d52a54bdd9527043c6287cf043da628883cb1ad5674461f362b1f950a209d9d897d8e06794a1979ca70c1e23a383836ac2249a354898ca874ece4aed50655acfcade7a9dbbae4d1db4c61cb773070a9835286ad75f4161148405ff98ef0b1e3b0cfd3975a509c913e45bdd077877f61303c5bda2279ba94ee1a97c82bacd19d3311eb68bc0b41b295771b5b855a81b01058d01ed9b87634e8b02931678809541a0e62ed025e48f29ad96cc88d2fbe38373d99c91b94fbecc63a023cc9d0190707f6227be1c0bebdec8af8c9c28dea2eb48af0377e0140ac77f8bbd81d1c33e3cde4bffbdb266b353bd31e6d20ccd14377d93d860b914e625c6cca8c8da96161a9410b7db88eff371ab1330db3c42a3e577d52c4adeed0e7d0f6229ef400ec96a96463aefbbbf9523b36cb577a5120e7ec88647b932ed9f23099abbc52dcd239b4abd6238af4e010a3290fbe2461693b9d82956440664ec07e52a3fd0ba3e1d6b09251cceefe258d34e52fe911b59a6d131e04d58466e6c61b421b92a9314eb8031232ff9604e24fadbd3021af065a95f42357e53c63f827daab4869296de7134fdc5eecac0354ebf0d8a50d6c41fd3e41f848a67b57e6406cacfbae89fc744f86e89bc6cf42e5e941fc9168c3ec31dd86b498af875d7c16069f949f9224ff6d312207f1ff91199548098cc21b68632786d0f8bffe267e7bce59426ca7f9c046126cc5fdd5f0d46c6ebcda2372821bd35187df717fd5970cfb4185e1e031cbb1956ee0c18ea610610c67d3a744bd8f6b5705ffed18eac00015f45209338738b6dc7b4d7f9ad96ad26d6eb052a8dda5a5a300b3dfa07054c0e612840172f425de9aac8c824d70125cb9fa07c897879bbac5e3e66bf143b1641cd8acf8b70c74539c24deb69434bd90f84651f49e067e0e68400f39efc713a5e87bc595b42af653ec20467ca6108ce691e7c541c13b55dc40454be3d07896ab3593c2e2aaa3d3b3b6f5212d1eeb4211a0e0ea7d6fcc8d68f46ec006d854df1b1ec68b778d83a03debf5791f748e9fa038451a120f7c9911a81de638ee2c8a38035aa3e33539eb286336c69776f668c7c0d1ee4f82c413cd610afcf73d073e241b83b4bc60d43bc3589a6e2d1c2a9bb1c03ad93c419bbca79da97fe3b52fbb2f0054f4f42231d6156293c89d477f34fb6a3cffecf23054f22096347aa677cead86c9fa541d6a3fb2ad8aa9f08cdeffe843fb425dcd6f7e8584c8d69b9076f5f2c862ed84a4122600ecbf","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
