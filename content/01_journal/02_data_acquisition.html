<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"d8955dc20a42b3033dd8f4671dfbb8315c3bea9303c84895d1b9822a06b2229bc88433dcfe60b8c1754221b5a6e53be56d4509f4557c48edb5f8d08b2236c3df268aa9e5025993eaa9bafbdc9dc1546b7eaad1bca9130a275f808c07ce7be3c9c85431206aeb41fe82589c5529f6e4354c05aa27863e6ff329372d8afac0f106bcb4d05ccdec2b78dde0de988064dea70c59a27f8bb48bf15982b3d2c94f19551e4caa460e45fbc72f45a6c918cf6794929499f58d05bbed6c3be2979ba04cdec502febaf74efea37d7a217bf4824540b0209d3564fecbcd4044ef85c126c9720e7da3e90dbf45596fa11594d6b75a99942a418be73babe9e0d130c624115e9feeebad4c11078912c846247f6b4bf5992e3f2bf01db78e8e8f989f8b9965e305e417013f5985025929dfcc818c69299cbfe6394e44fdbf6a29ecafd4137479659e592df410fe85227d38b35fc71a0745b56faffc37378e9f7a465b3471f913569a13f4bbc1f6ea07ad965efc4c773ded87924783abe0c4f0b05ba8ae0eb4d978f8e6354bacb1728f553f8c8684a7559613926e09ffa6543ab98aeb0f919949000ef42f6a9d6e69c1f8acc39178480e72ee8024ce7553e702d9dfd848485f33e7756534e1f432cf0cba84589d4c1b1111fcd19b33ac3e9996aaf116f467ba47161890a1ecdf625b6244b736574be5f93928179e36e72ead4f213f8466db4d7268a19203bd40e89f06aa478dbe9289be4ca176d00413fca9d3ee4f45636b277d94593d0904bed0b88f7176dbdbc3ae800c5ff55d3940f0f91646b8dd99c910959230c29d859ea783355b1db0b2588c015cc1d801ab21a4d0733bd953166d2c0b9d4a089c5338455314dadcb1cd5ff10fa9514648441fb7484e092fe1c5539c1f4bcd905ae5f5731d612f2a669d28a06cfdfe3e8f935067365f21a7cfc5383a8bb686887ed24fcc049d23142601cfa85aceaef33226d64a5e6b47931abefc492102e9296fe372f31cb2f636638c41b82e913a1bece00b8bf5d754a2c2fb769f5cbc81c88444a781f057e4993d765ade38eafa5e7f4b35d6ab615493dfdea154f13428a22ed4c0f2a5086083a9d2a9eb7dfa50f357bd43cbb4f341fb9e430a9cd259833a0d5269b76773db772fe8f57de1f40c1a4bce2ac49671772d21048961489d74b297d5a109c27bd9049b3f7287e902d0a222cddacc27f7d4626fd2b5a2bda843bb60dac82594effcb780dfcbedac23935136bcb893737d2e42ef10b91508dfc8713d3f7c99850a7541a25ad99df0954434e9e5eaeb032f7118ff0799e3c5b9566c6e4548508128a80b568148a073228c7293daedb1174e3d0f59ed4905558de756b1427b452e0d8fdf1e46bd2024e98609897dddad0d0333f7ef131be3664bc1533410e0457ddb75c895cc1bbbbfad1445ac4be12b54c8165c54b9c76d102720f7249f686c1bcda69f69926e9ba34c7ec2b9a1d08f779796cbfd33bb0124ac332e121c75ff28dfbe2b376d9a84f1706a4dbe21733d197c3b0702b3d1c90ca3cae5e87106b577f8badce7e2cd9a95ade15a2c4dec05fd9c01cc267a6a712d32e89d48c4085e855b7d6d2b27ea3b04ebb27f3173cb0e42ca3ac615456a322b9a8c7430229241b61bb8eced01a668e67a5043d8ed3bf11a97008217ef38c3c5cd89cb97381c4871b8744448e298471b987ff0b338322e21c2d47c9ff4dcdeb792dbc4e86a75163332a2bd43fc1e094fd74ec8f4a0f24babd3ab8f3ba57fc5c831e0f05af2c5e2ff4c445e731420035bd5d542f4cdfe923b7da66b64b5fcde9314dd3be0a01bd2b0a1c46486782d951e4ffd1b184a70fb305026ec3e38f17d7d15c5f07e35b272014de68695efc02244fbccbcd97292b77787113428de5dc8481523c23ab746d9d4bc6208e3af399c37b53d6001a6c60c06e254cadd17dac701264a220a133b1437b5edab217ba3f4f1a751d07f8d2c05d4b1c19e686610010d69e0bf469e53835026331352a45a63aab0f4b1fe6152b2dad1333dad0533e9635b60cf9536efec54952a03e7d4d00183091c9839d7b2b030e6ad2640a584c4815add493554ec1c53518ef47368337601ecbd33e96fb7d071fca010da57b24b56fe65a2c0a1e15d6f8a4ed6d8e3418f7c6e1953d283ef94d676a073bd1129670a729f95178b3d77afb5538f7e548b2733ac5b52d249b8bb76d803fcf3311a22c00ac8eb1553f40892022b93bbc3924a2e9d1b02c68032ddc70cfa2f547beb2a2cd663475f8cdb3417d8a8d336ad2a1b52970db1281ff53180407c7eca3dc7db112074613204601f1b4d5632dca6254eef79a7799cd1bb684641bed6ed6d4f259aaf369253a8c8e1560d89a4f89c5c0b48a33927bc7e1adedf62fbf39378518cc7be994ea9aa94ba7bc41ac575b93aec2035e97ea8e74d3c9f694a8636a0e26d868d955f9f885f4f87c0f48624646385bf80fe87870ad82c2437773909cae38caa6c31077986fc683391fd69eb9088a35613ed482c7f590f2ac664cb3438776f865b62c671053f380b5f5ccd8eee465e7b03c4f74382516513c696284487b481f2f1e1711efeb1e3ab142afbda2690afb5e3694038decfb61125d899a2e16251059b5ddf81130248a4992dab5d41e716baba67b34921d4203d554da9a839210c8e7f9da7e20de8115ab67920848ddf67910c456625e27878e46a41b5f80f183cdcf4d71910242a26eb018bab179348b87670e6c1f31a12291002ac5e296902a4939b1eaa47317c301e06708337db7792dbf619eb0838aaf1b2a08934f50653b2f2011b09043a9f9e366d861af534c742dd6d150e338a72c0529acabac340b8255222c8aac0e5d3d78c427f30a6722d8b34e7a7e81c0998e038bbb7fdbd5db3e7fed093fb1233febc0d1b66aa8939459492ee5b8810ce072f0a78803d79562cab5d7b1ce38a4f983d2b276715e1efbb420fa36bbcd5d52ed5b9a6fdb1e6b2b7fc8150761f620bd8de95f059ffe09b7c447a2a09b09ef375fb64e107e13751be5e21853839cb72d73fd0529f716ec52e817e46f0bb676ba8b8e8b88ae8756b47dc1e175dc257b6750666e7da2584f324543773cd453ea8fa918cb415198ec1fbcd9f67fcd2bee45dbe734806e12c210d33a3f7c9f40ad42f9d6307c2222b18b3a156d4452f004747dc43c80fed786be6a991bccd8536e274c8d7ce69cf55d9c679bd18532edeb9a11d6885219d57a1d36e1c0dde273900d418901d93a09b98a8fbfba774230da258f88f6aba961e303f1e974dac0f07525008098ff78394faa7092df9915f071824f115e174f7970b4f859fedc60e85ef2aa3b870b4861c87b017ef2629e45577457aa2fbeebf7eb20fcebdfdb23c8baab19c45a0923b8d6da428b137b294d0f175695c4df9ac00d76618263f073a21721ccad1ad66a09bff618b35a1ad6eefbaa75577dcbd42c0b35acc1959840e733ec8f237ce603ea940fa046eb9dfc962446b16f4be7c59e285c3907e94c721d69c02f6030956a5e0ab8d7d98ea10fffa6948d8978d1b2419f911186bb9fe35f2b38e5a61e51be7a89cf8ff58e4d9d5d6b3491668489f3902fec5f96ee71ce2aa1aeb5fa2eda6072e27431c840fb81803b89c1703d00ee60277038ad66fbe3d7b5c12e02fecd5c060eeb32c5e58e385ccec9f4f7be33347dafe03e2bff8d0b9b3126b76a9b4bc5ef8739a6a6e57c7723ae65cd7871e34084695ed57706d1460c26537bc48f075beeb32d193adfd85f15f5219fa89da9676e643fab2ad5fda1eb7b5c0d3b5230d7a817d175e3398831b8c55fff4b7530b1d56ee6eb1072db2477b1404307e52d0eab9f32c9094e85e384533a76f7771f6171d3bcfb6df227acc76f8465d39cbffde8eeec6ac2e13c1d98b319de15efcb26899726238d3f9d98eff00b326e666df52b95604888c55ed7de1096934d5f6463e92c670e74f9dd601e3d4eb6f1de7792ecff4a86ad881abb29379c205a30d69dfae7ceb882dc4432865f4fb77e4bac8dc6159c5f3c6a7d4bf044fe69a70f55ba3efd9a5aafecabf6f2cd423fd6bea34038ecca5728de07d1de3a61f09db2cd323214999fdbe46d8eac42b5b77b73af43f0bba34dae9f5aff4014678144630a7eb6c571edfa409580ce403105176b22af4dafed549357b116f48485386f68ef49cc41a4c68605c3285a7b09e30e0e9e0cddc6a53915ffab12a73b697e8572d13067cf6cf4722da40619aacab1ec4fe4a4b4f8dd02a9de4e8d1e1f9a95ace306402ab73e59b81cd837631dc1e22ce886e9b3777470d4026b3b5637c2e15c7c8402b3c29ff0d80794263031b256fe7294768f73b72abd1873e6980709e9cdcec8e4dc3c3e247f39b6f774dca949d1877c45aa18f43a3692b66b671aabd18dce4c698195ac91a2e4ce23ea90cbb108c33935fcaca5b71fed2d54a50ffb449f509c877a5614c11f862efd05fb2cf53cf70c10e28f8a228439805afa17c0a8a6c67486af6d727a70a8901028ced7da61d58b0192b6a1c31f265fe22b0debc6ff50d478b03431fcf82f94e9b47ec729e2aa4be008f932762ddf231823bc22fbcf7d04fe253b20cfdbbc3f9ed6309277629c3fd0e90dce54cdd8348e875591509697550a1eee67ae933a2012facb93a63fdf20a7b49ddc61f653cbeeca32e7569df1a01b137e93f1b4a922d375fb15b6e6287d4ab7595f375e3daaaf38b75d1db4eb6da98047333087d2e13afba99a19c5218152d46f0c48d43f5f51442905663a053b31b3b5b983f799875d37dd142b37f8ed910c2f69f76547dacb672d5f5047084381272bfc7f2c4ce86062af10bccd146ebd849e709bb582d72280f846e2585ff513b6c6088701bd817f10db9cbaf7c0e6a79d9a407babe239bae1f890a22a6757c94aee15bf2366d4ac12d6c5d9ceb0ed809823c3020cecf040bff7d1a54e525fee3f57f3f2d751c17ef3a08378c69926262380033f8f3242605ef2dd40a297583401ff9022956f45054fc8e3f1990f8fc6f727ea38fff93530e076cd9192666f1ee330eb7122a9dc5d6e7e76347fcc71b7a1b1db413ef3396e1671052f97200f8873221d5782adce161bfa7d37bd048459a8cfa1a2eaa7f287829390f89cdd2aa64ce8ddda599d807ffb17efe25f33f037ce807ec0bc5e1110eaba0ebaa11cd1cb4c4a8f8dca3b203fcba0f72449895b4f81d45c1f6cccc1bc16af80e23894653eb35da51624a4c64c5ac68cd84e4b7e876f2df2f32aa50c6e9866b9a4a32c5bd81dc122dced1c3bdf9d7282d434b87152e9b543c620abb9c2d8dd385a4482093d91d81a885c2cc51957f0649f187a9ca3b627a57432b6c20aac1af5c6e40f6d4a821e2cdd378a2f38e8212e714c07ad1d396eb06e466cfd34989bf2ae81d3753f5e068f747347f209a62126d1d8564cf8818f9593253dc7c55da4fa8fe7b69f8b5ac3631120f67322bfe301c2c514777857a6c944cb9d45854f83778dbbc12724042cd97f3b4932c4d03f471fef9ba82e3fb3c737ef5e69947902a71e2583d89ebe5a8781f61b02e7ecfba00791b35579fd3d7f9192e8d4de02c17cf20f6275aa2dd7b2c59945ab3639e81c80014efa2f417da003e47b38f184019e15f72801c932a12f0c472ed43ff14ae07ac3c6aa9c4279c6df7da4bc0a0aea78cf9dd431fbdf1eb401da8356d681a79df733744ccee3da5cc36aa632e016faa32036285a7a387736bfe01174005ef922070aa007c2ed0213d12491d00ac4d9feeb969abd382ccec8db6860c7ec34e2fb66fab1069b2d78e8c0958410ca922b4d7a9a745a96dd0dd5f4d796f378c4ee9d2a9f69e758264b94e4aa4cc402c2f72e3309c4dccf45f84379adc3a35b993b014b0ffea461499d58ea67dff0b3bcc35afdc18dc1cbfd3a8f2d225770eb9023111bc36b18623168a968b02928e8cd9dd085781c9fad7b01265b171667780833d50906996e4af6fecf45f2e9e104ebfab059840ec9dac7551aa5c6e60d6a253fc64d7a17e52c0bb5d0f17768096713cfa7d6fa9314c7661dd21db0fc470d49f3ad47c07919f7057291714d9673c34492ca1748ebfc6fa7f41ae04765d705dd5aa041f5d2d04163e3f9ab5e856f910683c5444e561f2418587d1ac91188c63bcb13598ba8bb9e772fad8160b7935742212e4abddad4c8f601e554dd9066650cdbf4536dbec2b3d46b0365fff0d78c0ef10592e3bb251456291776f9b0b811240fbfe1232b971b55529472c573eb22f1ca11077a195e84d1034fdccbaf6e18b1750bb92cdbd2557722470735b65ab4db715589d5e235bf85280030b05a44c0a2e4778d3bfca21592b508a5e7e222b32dee63bbd070a753b6def47dd47c96b5d58dddc3eac8be7a3bd14b073b500e3fcf111b39a64c3d734583a50d6430c7ac9b12a84f32a81bdad40df35899a48b66b378140fd5f218d6f6ec26142b591f666af67e6355057447ddec6d9409c2a163214e40459bdb71c56e1780740640572fcba11298188d137ea27cf962bcf448a357e5bd2c850debb13bfc1fc4ad15b59ef8ee070dcfddd811d532bfa62e9053c223ea315dc545841eccd1ed12a3fe5741c74114b0ebe92a94896a6a287459ca1f7c99b61df0408d9de4a0d037cab61add34a6908e0779587e5921003c7569136528f016ac1c98dd95602f84b3730d19fcaa352b3c4ca3ebcebc8ddcdc8ee03ac2f9b9a2a53460e018b329cf8d254779c4537e20c6e2a00d317423229774edd9ee716287d2cb1b07cd0dadef9260b5ff3496b1f833784d8510c9246be51cbb6867bc97f92b21f67f3ac000e4ac9d121f5867d0d4a9c4c63e8ce76c3de32a323637959f01e656e7747ed713a8a513a87a43649102874c46bbf5ce187cef8d1572265eaac70b29b0e178df8ffcbf63fafc0b50fc81eb49753319cde943f1f1d8cbeb400edff4fe65f37d117d8c87342a608ea0b218acd14ddda95ed1d9f4141a212ea8ebf2e8325dd35409c69e68b711a70a45798fce07c4f3423c188a3232dfcef3932c5e782f0c11a373acc961d97749c2e261d30b40ac8fd58f516501003d74dff8879dda190922682cdf3dc4bd299193903b104ecf907c52cd8d5f76aa97a3e591e1ee649930345af1fa08af4c99e0daf53d97c8329391d079bb93f674ca5e64770c81d1ec4143424f10d3d8d2dd4787f4bbd2362a04dc41ff7e966acce0587c17cac0b8c2dc8a860d4410558a0db97a7f52c268ed34173c0f9cbb8d9dcde89d78257a2d86e8dc34b873848c4aa6521920e5a10d8dcd894315ec391ff08b2abf7b0259cb90d0fac275ecad43aa1a0569202859515fa95c0652d26019c768a5c55f2c968fe59b06369aab63938ed826e97baee43b545e748db0349d0ec253f1b63fc9daac70b8cb73fcc5c3f5aed8fe9622b88db9c8e49e39212417eaf36423f8b6a543767d03be42f8bab00da80b2bfccb25d25f4b800ecd355e583d688a643f8b6994c0f80cddb5507f5bdabb8f64a8c48164637881fbcb90bab5601523d48f29231ad45e4048e2a3e1c2a2c218fecaedaa0abf40811ed74a27780234aa4c3145e0e6ba27da17f9d3abfe299d17c0f6f03643103fd482689ea15ff8edadb94ba8105b7febdbe345b220e4c52f968bb797fe1e23905d9fe96270bca2bf3037e81e2e23fad047730b62dc494769745d35df9303fd28d159d0eeeb0ffdf2e6f8ae8bb65a686d07b76febf17ad97a91ca3eadbfe94876eedebef562074e6e850eb9ddbae2384c464cbf9ccc7bc3af340c8645b0466c90688af1226c5dd35e2b1411c74560df44e0311e8acf1b7dfa66a806cb589f82e153c7326c06685b6c734746766f6919a607312aba593325996e28840aa8c342fbdb2b55799dd194fded813eb9a15e884dd3f14e82705155997d0a64c2eef6417dca234a0eb27ae7f79174f9a95cf364c9ef0f7969c6bbfe7b9810309e09429fb411f5c57f1064bfde64e14d804021939e807ba02468ca90c428d0c2d1c33e1767cdc863a27e6c679b522e13f89ee7b33e8529fcab20e1f396e8992fb069d1c2a5ec926dccebc9e7dde789beb9346819557c19e3b65459459a9bad544e2715424e38b95a78950a7b91ee491ab028546d0f714b4c48fa65eb8af6f770ba24205f035d0b19aa523f4b004813625a8faecb992074f91f3fa98fae141b7e2625ea2b4d15205ebe139a6a93d2b087d9bcdd804a0e154e1d7dcbe3c3407424f4114921a870fd7da98438354a981cd6ba525d73bf97f753e1121b20cc71e3f886fd1a45048e152eae03eeeef31c56fe4dea5c5f3f1507225347b77896578a6bfb76aa94f2ca8bc88363bb2aa4f893abbb10ca8fbb61721090a1276854ea29084f926912bcdb4e7af1cd7a5f7d27e2a670ffb0d24f904aeb83ff8de60615da9d9d24c0d74b7727ca206382ea64f008c9b8059c003718e4c5ea9f0012b64c1f7d2ab5e06a71195922e89acbd01f134cd7438f2c8f649e1779cc6e3df8b7501febb3ea72e9c4fc2e52e8c551cae77602b660957f8d1cb68b6241d51d87748895b2c81d7bb772454ac1382d266fcf903affed2265bdcbb2a100abc47e492af25b7db339230b52498ef8afc603428d5edb44997ae452c8b2c32474dce596e7b7fcc9cc1b10390524cc0c6f425e14052776e03dd514440c9e81eeffaa98e6230a0073170b3b2a4dfb58e7eaf73c84dc9feb3c174ab04d6c91a654f13b2d85a1a8025023294a2e7f202630a25c2612f0ce91393b66ac912302f7934204dc0ee51bdb90e88ee9c4a0ea8b735620cae4864a6cbf07ada55906254167dff86bbff892658a177bb996e033c083511c75be3b88401c65f813508ec62557c59f24fe4909ebe38566a0a2a4f14611f423a7651f7a0d9c4103965edd135311f4cdd39a1ec95a4896f7d603e287bed84b08f7f624869fc76097a6514c73a3dd9b3b11c2b4cceefcccb6eebf03b1559a71315d6d820354905d6205399adddfdfa06ac895264527ffa60b8df94c52b724c344e081c188e23c56f2eb050252c0ed5bb307b65b11a50cc09999c921adcbdbd7081fa1f78cd8773660b2e239e83ac1563b6ac94bd12bdc4388075ea11127097deb49204648bf3c78b267329ee119379de789e8adb1f6d1613becb3a7978ed06eb1fcfaa8bb9bcf685f448ff2c9e503f925937f41c056859b9b5f83387c88e6c78dc8f4ad3e2ca604111b07c30799f1a9d394fd701fc3666bb655b51da388abd5754badf29feaf58260b0d5166d83f3fd7b93a2a34b43ef0a6b222dd5c86dfbd8137c4e1a8e91b3e58c0f63e3cb1cff546528402d8d8e3a3cb9b083cd218174f6d5025f339070e6c51398afb263b42fc738c2aa5d5be6b52e8ba373a23cd8a25ee12d97d21a666dc94171ab73a14a1e4cd115646c1667e288b2fe7b12c81273597606af0e5966f0a90eb9481535f020ce9368aaa59e93143a0f5ac3c3ba2e842744df69b4c06ef89f4847f06f89a5e933ce3e153c08c034cfe42f5e8da40e1ea80918b1f355ca0d8df63d7309f4e4ee60c6ab201f7e7352cb881854759657af957dd6e12d7ca30d811fb041e916f63cbb289362c31461b8d55f21f7afc55c0b93326c0807937c1940223e387bca4f702eb82a4b09e2fef49b7eea1c1a909b93e92ac7add89bf5d726bc4412466d0d46485502d975fd4c0e5f1c55425ca0cd85d0e3b8c58d0604fec314c7ad68e8d62d37d3b65666d2b44ec7c40d91fd2cf83c7f57b6056e70ef29bd69a4e1e86f17b756c7902229784c6b8e175f95eadbe39fa3fa0b30dc0c3e07ac0e468f1b816b1934ce05f0c9efb1f7171731b5ffb7248eb84388a127a17558bebe915e93bd844d60b761d7e369210cdf7a0da27e5c26992f38650914a89020442e689f72873eed65c86f469713f0a755df2bbaeab02b7b38884df955aefdb1be477d8e4fda8b6eeb586d99e9f93edecdaea5232cce468546150c2a75cefcf9f232cc0d59662db4e463abe9d9b67667855e5825da8fda32bef9160e57d9da536bb12bc4ff4d70feef71afe35edf2e363215449fb441accc4cea900548e0d04fca7ae63c1bf850eb69dd76d2097d63a6e5fc0dcd5985b46cc3c843619fc185ebe2df78c3e6f22d620c047385591bcf70e54c3be851cae747848c4b6abd12739e15c2e9743eef091b8032597dffcf81a4453f97bb749f60fec65802d581d7818db850ef1c8d933a5a7903043d590eed22ee2265cf13bd37f3572857f80e9bd645aa84e13cb6be9b4405aa9f734388bcd034c208e9d69f8b8089bf94fe5f603c97405caee47d6c1a355b5ec9240b324c48e322732e686b4784bf28f26576f65f1d1fa16f6b1cfe08be328b27ddf612208d66afadfd3892c133d7fe3936f0cf0d3b91abc11a56a569722473440e558ea7fc015d1fed79d9a9ce9e955b5bc5202f2096dde107c6c6f70ed01add5b9141edd9c44ca79406df8c5109d13e94e5910061fcd8dd043f4e75974e7d154be2e06c003f09742fc62d1d1dee8fb430b740b6ee78b1044c1a2b4a984aa0959daaa16b14bf919e27cbfb0626f29176a971826c646cac455802e8c879cced7265999e5f3112fb594f2d785dd18c722a8781051422c2bd55a25c967ee98203bbe3eb171491e426bb711444b5e19ad03e80681d69b4eacec7feb7f6741a475154d5fe3a4cd3027dc57a34df20891b0e1a4ad317bde1fb7a3a1c8a7479cd4893dbf2af2bb68cf8e4a9de42f932dc1cd5b53f4dff7ba02468332c006255a8c4697199b3536f769fa0ee14a35459d1941ce73b28e09df129f021930fbfd709f0672022b981353a207cd270cbfbc3fab6fd3276bbb9720e4b55c0b4dcf2962295f8103541a5f5b957c56493d8bcb19daca9b0a6ca7db02eb999dff0ff54f922457c97ec90965a530a37028c1a6d2989c70d54f503212ff7dfd73042d7ef54d201cb373afc0215d7e0c8576fd3147db6c392099522c3e93c4e181e0431aec54d3fb822db66e6d9f71d5d5b69d9d1b5509aca1f27db875d457f0a9e762c9a2a83aeafe687d02a2da065c247fbfc40a86dbcba6b2ef7715ebdea7595d9e97b3fd6d85e8da0625298caa51e9a180751924f98ec5c76a7c4bd0b685449233817cbc2c39cb97de4f12b3181322a394ee1c3733549acfa2bc0c64b6babee37dd1e5c1c46861bbe24c21696df607fd42e636fceea6ff744ceaad0adffe435300fd6a91af6bc5dd9462ff26748080bbf305cd3e73aa3b46d9a2219f1626004fbc19fa397a3e09ea3775630c30047a67ab91cca5b38f59a955230ce133fbe4465f1bc233fb391ba521df73e5f857499397b96d9e12031567d5095bb363e2df525a90460935120d2d8739e95d20459eccfdd6c2a4c9e8a6d840519efdd01c5eb15b1d170ac212993226719bed1fe79111f2414da57b04e89dbd6e481b09e52a7ced04830235f0235bf2e80c989dfabfeff57e75f7be3ca9785a0bec76dd3c10f034c9bcf0aeb5254c38ff6aa75f0e494ac92243c8e584ce13a7843bb9ed7c6b77e6f7b6ca36b06bbf03be23d92d08a34c133e6b2405b9a751cd478d1f48a317d9e5f505eaf1f287bad3f3817cf7c397cfc35e16872626ee2828d68444b4375cbebbfa37fec4e196e27f825db0f5f20c294cafe20d5c45e34d847590d47c49fc3aaf3cebbd4ca1e8bca4aa01df319784de79077ad2536c1e23fcab032372614251dead37aa7da7228445199f8401f8deaf55bd07583122d1624515e697eeeb753be3c0e5230830032425a923a639c6fe44fa47cb9b87aaef9634d0afc91709de89c3d9d29e7cacb4a16e17d2904f7ef4530d657f96260c1ed5f79079b54deba12505b28c1cc9376207bf801d22d677aec87bc93260273b31da6ae5d19c6f963c2ff8afd719c27b3df5a82739cf90a25017bafdaff3c4f294c37cb12d66a6ea03122b7eb540f83a3af15f7233a647ed036bf4a08af9f4ba1c33aa9aaba5a6dcfb9aad22c8ed8dfdf5cd824e91b19d6f08e5791e1227df23aa8cc1f61d6b22e33b296e9b2eca257935c4076a760b9ce6013eddef08d3096080b9dca91889038335de3aa0a43056b8234340adda19a109eb896df3e6bc4c51986b872cc97e28e29e6da80f360168426859d793621664eca55865d0c9aac14a74710637151b4ccd1cc510e25de4d6e379c0a832e09c6fc175341a6eac89bd6efa9da063b078f606964e4b01a334a5abefb5a0a8654870955967038df1780a63fbc97661a95a4ec7559106c7975b343623baa9a60e8c410b0d8cfa80d976abf1691af56158ae50c1d88e5966b25efbab091634bfbcd24ec01c39c2d6cd5d0b34b6002008048b8579dd2d5846897477b5c4878321e3f70e5f87ca013dcb221c926692fa4947fe290f617e8a4e92f95ddcdfb8d73d62573df307530e0fba8bc026c02dd721f9b55a69f479430b97fcd3ccdb367aebc639c19529736965a1efcc38d76d22383e53781cae0021ca98f974a17ac97653da7d41eed18ec70cf152d117ee6119c27466f36a831f9a5f0c4805c46b4bda9c39f5d3a0b886adb0a4f57cf11e4efec86aa80c722a1e26f947008cf4b5061e9a527ed7fd1402c873b1ad22e8352fb545a8e859939856eb853f964814bc293bee1727f02aadbe9c966c8f3f3a3133742042e9e778dc6d2bddff5311f225ebd412cf3a0aea40de3ef0027df52675e29d9b14e2493d596b75072ae724845e353079681293ade28187921ac5d2373a445a0dc9e29a1ec9287330809b9fe8ccb647286f461e3ed6af78bcf39b0c12c8f607c979150650c2b57f71c3499ce7b4e43da895769e5bd159b5586c1449221f816eff3f91557e92b24ab8ef97ca1bf357e1721eb60e38bd201bed8a9b6aad482cfd97c448126711c9dfd6e6ae1c3c1f2d0a4686b573dd718ede4b8b039b2f8a6572f9b7b449de2e8116482d82a2e8166c54f04526c509099ca8b74f07ce1ba9d61d59628a0151cd08db2f0bdbc4a148688ec7b36f15b251d82377895699c875d87468cc6ccbf740320a15266e0ecc11c6ceb1c53e8d8c496ca399ba4d4c9709f254da76ee5e452fea4759b2a35d057733c7123ac850a07e8fc86d5660713fd4780c59e3a16955613273521946d4ac9dbcab9c4c8c26b275766054d3891e3f98c1b8480ca574b017536fd387c7f23b971c850c2495a34044dee01898905a935de7e23d09db9265a513e143aafdeebc8e601f2acd61c7efe4e3d25bbe0507729f5c6ac8005959c7a84e6cca039520cebdb3075fa1be2ebf8641d73454e5de207fa937a9e9d56761f622cc4f9c11c809848ca81b22fdec072a580ebf193cb76f09ba0d00961e1409b18b0d9d8e2fe626099fe510e1bcb5d531783bececf0339004cf3d263a61712530e076e9c77751d199486c86899fb69b259737ec5c2eec3204220ccb2d596f8ad682c1daf0b8b4a97792f7090c946b8a83fa53443c798cba3ac1e400b99a4419f9efdc169dadd5fc22d68c8ca93fb34b593260d0e50443b1f649d30ec86e7fed04c7c9530ef1f6e41157553c3f5dcb6d41d5545d098ff0e854198cfe62ff64674943992197948e9820ced4952ac2fbfb450873f5b81a3c662f03a9a30d8a673a728a0f05c23b68fe3dc0829ccc6b67d2336c6cb5643c60db685607409ac1901d34ce9fe64a9f1d743530833f5e93a1bc518801927d50a4e3cfaf0baba386605cf5494f25c593f6eba259674b1e8348f27f684680f524db8eb1e8e9d3b4b845e3d59819ca02d3087c9550a26fd99587570e07a1a792218804c534c176feb203c81daab1ceed1bb73c90da4bf3cffb56c2b5ce7ae29515ead372cd3337d00676a10eca25abb82045a0c0e2cc16cbd396491abaff2ca2e21db93c5c4e85cf9f9f197c06de69a629984e7bbef033199d3d4e1a0a0d950ceae817026f00b8a9dfb2e4cb08cbc83030c2864ef6569fe08a5274f0efb35ff2abee198f7d44a60c36ac38b716c892cf14864303d64d2f1e605da5a1576e45b6adc98272f69f91da9763d5f2ca9ab162579a399dbb5a5c81f821c578bf775105f527c9ed25e7c3d877e2de756e8c1eda39b1f597d709d8b531451798608fc41f3861b3a4bd14ff3ef493978429aa47293882eb470e14ce7a78005602df4f6affb1e9dc507b1916509e643081a5732c4f4bd813acd999bcb3ccaef133cb717b9db947855efc319a84878bceb79f60fb40ba8e7ce8f8595bf3deee1098efb0dea8bcfc88849bcae934c00010ddc6e0ade74e817920bb4942d0eae74fa66a586ec8100798fd7eef7f0c3e179f80295d1399fb8bb9b3aaab16e4e8e8148ead7e555f70031b6bc96757220665d083d546428006b47db080f3c1b41d01b9afc48b8ee1f2d0885457d8f1cec8bfe09dccff0803f0d62f6e6ce5a221fff4767f7cdae971ae55f06f5a052bc66909cc8128d37c6edbba57de5928b6c5bb09777539b6a873feb3980bcfbec8a8d381b03f8a558b39cf6a892fabe503bc67d7f9733e0fc1cc843b78ab478e46cc92f4a84eed6ae79e68ad773aad6a06d67bf421fc86129bb697cfe8c488c4c6c2f0de29e48d9081d379b68745ee2f16457fa0c123bef56f09909bff46a170bc5f06d1a10f52697fe2b8ccf9e5601c751d0973921d86d222387546e650d5bc50a900731f319b319140ad879fd787d5c8a778de7a45dc199b13218f107fe4584db0294b62e65ac9eb16271496428abb821e9ad5bec7d32997389a53fcf6bd75e42b4e09456a61be759cc77515dd7133fc29c2ef1d055466cc739754b5885d38b75b8e337ec75dbb99259e613bfcf0ba29ba37fd0c52702cdee7c8e7758301b7293a6f62ffd201623aaa311755f978f4698a97e6bec3320defe27120be780b9d812edc56ae05a8509ada34a7c4d7bed2ad3eaaadd18554d3ea62c9a02bb1f2b571bdf6695528a989ca700f9b11f75cf8b1849a1e3a88ea3f863b2e858a1fccff4ed80e0433ec8eb247b38cf5e793f0b3a3af1179fb4f9fc658e020bc56fc4f7d28a27e8750f00fe7810e0ce0dfda85d9686398fbfbd2ff4aa9b9e0a6a8b7e472f704c648e0ac50aa2e7c318eb6c1bca5ce168eb862ec36ee362402aa81c119a9aeb537be83e7b30bdb96a780aa94d8ed379b634756da5a671bc149316bb435b0c982796bc79944e8065df41ed369b1dce921bae478bf091aba8d117cea219d86bee8d786612202a1bf9554201c2719ff81b2aaff72d486f0315438caf8eb639cc8abebc5bb08e0b3430bb4e6c03a8a19a64f97b20511f70c8d670bd8386fe00da7bbd7583b3a9ba4bb0edc717bcdf7e61803639b2192338d4deec32d03c8f08e53e955d239f6fba8b534a575055260e7a418b298fe3ab0a9e84b889948fea86447b31a115ff9b6b4620ade2a60b31fc96557e8e3d72514a5844a864002df47010868e0587c8a8ba2409623df10829544a7e9dadb75ba7bf409b19f688844a749771240f0e98efb60617bd22611ddc891e3c58755fba557601fafd27407d158fb5bf0efcf5529fa2b6ba64d034253e66949cb161912fb676de7ed489df1ae5e662d153f981057f89858f9d84efc15074928c0058da5e94831c281ce6e4779b44c9ec693fb618cd88b56b341f9ded1e713346a4a93d6885005bce146edd154ec38f3fe6a93c6dd3a668d8f7bd6af7abd277c6615dd8a7742bc05aa56dfc366de42b1e3259866ab545d2daabdb4b8cb72740fc38c283c9470992992216c6c9c31facb7361018eb0dd341ca1bfaa4112a75a53ebe60bc1fab9ae4b6292583d997ca3562df7ca9a35c1490b3a75caf8cd4cd11528e1924de7f439ec262094dfec680193c184a394c7f715ab5afa3fc5f841d9067e66474d8f3e7a6fefe4e23587f4ae65cac6c7ad771a1ddd47fbdaf52eb49da9e5cedc37bf098f6dcd8bddc6a6b9e9ae209710a9309780acc2d86df37b8fa32c713446f1e1053e0535032c1002176e08b5108da637b54c4f43f5cb08eb793a7cbda6eeae03555a2790a2bbaf5efc248591608845259fc12623e27119168fbb8de01ea2fcf69bfdc4d042405cbc3b517cf3092550edbec11385a53d5a31ed369ccf70366aaed776da0e8ad13debe2de75346bcafdecd811a81fe567e9d8f6004d9cb622728fccfdde4210621749bed37227e34fb37a172872cb6ecc9045bcd5b741cd962b366c2a0dff46b16f6a2a246816bb2481c9edbf774478b6c29002eac2fa2b5cd8a1be450145c4059c4657c8420d761ccc4a3da592309de434c7ff14b6fc569863b73172857d6e638b4b88adb98cc8a3fcd68606d4f23ac5acff996613cd3c58273ec32b0a112738fb841c6d413c6dc77fb57aa2e3e976f65788162636c62de71b3a40b73a8191c629425be39a7950c82e170142e82a420f5cc44aa96b4ed54397afaa5d0dcbdb9cd4ab1f868aec4bd9a6ce544b4fa82fa347567df3984d5158a139aea7e5e08c0af733a2158af6a207234b8975bf56a2638fec5b9eb3371d6e1b18011547e07022c9bbc9f0a80115042cd617fd761bba27ddd9d9f64d217807b927433119ff386dbe45cc3a74fc36c9e679de28630b12be696ec70688d427bed1d197572e6b0093a56c6af322e3504e24c585dc872ad2e2a87c7a541ff1bd3d9645405f1293e723b4ced02303cc4957f5e18a1af1062877bc09ca87b5855a75639c82dda0656b9ad61256f211e5441a992eae9d7017e7b679929157935e58040dd4385b41ebebbb58dd9e2c10f87f0b9a0967c6b69a02b6e0a0a9b9f652dcb8ff0485cbc1a3629b462d1f5af738204f55cd540c8b71d4890a5fdfe04c35c4b24146452e8d950fb2bcfa928790575184daa078263354b8fc0981ea7af2f0c40924f724443ce7ee0af57853f1f64c21e2ddb8325dd47a4897852b94a84bf5858acc4d3035c65f9963450dd53fd27f59f8eceb207e7abcde3bf3cd2d1014b62b88626fc0002fb6caf39366a2883a7e6a3e57d137c534f214c02e262f1aa4e0f40169d72b28f4a2197bce32ce8729dd3351266f20992ed536e58dc914c90c6e6e80a840b0dd24b71ca55c4aa1371ccc731c2a95a6883d69be3c7a36556897135643ab49e22f75211e23d7e4f5c9ba3951b21eae68a325450f7a43333584abf79dd9e1e6deb3d4884d60b302b1d5c059f88226313f0717104772f849a98babd6dfc1a422f6c5b9aa401366696ce40bbd25f8031eb2955869794d798f24004317a18cf9cf7ba4ab56f2099e0a6ae4c564c85f578412d9097b721b1aad1e4222fc2e151160a2fa34a37199bb925b0971de44ca1b99e6b2e8827851e00d1a99a5fd4449b51e2c391363ce146f73602b02fbe862275d50ea3174cd1d25e20f8e4805b16ccb89c913eccbcc9ec45076e59d9721c6a4dc85f94450144cef4827e8e080b0d47662ad73e6472e903f31cdbe7559ad359fd0312db3fb08270d3a6c7e1ab833b4021e22bb3b7ddffb443de62fb990d064a8cc9110801b2924af832b1f3ea673df1339ed8b2f33d54ecc548a2474b90918d79bfc536bf0703c5251e65638bf63a15f3c76bcb045f1305819a7b34cfd6842b98b1162e2ef0b0ada1742c8f7a604ff0ddc21a7f7ad5225fa2f8ac790f015f236b71beb3c2215e690378a938446ad3d1a8e6fa19850c1b7f19f2dea7a49668584f533e7d84b7d4258ef6970bf4574bf0c1b625a19e53811ccdffc5fc89ee22106851a257308d8c42a67a262d16ca6be545908cb1d835753cb328af904a5d0fbaf55997ebcec80bececb13eeb32f9ee44b792c56721a84d241b46a50b24e6b6fb91735df6c7c0dede146a4c9e78c59d0de1b14a7ba994a1bba6cca548e2f39f3019401579d97cac9820d3b3e777b6b224733d1480baa7872488708a41c2f26eabae4478a4693d27b4fe728882a8a94cbcf988b1145bd90456d0f4f707ee8f2365397877735ca4beb7ac62c3100bf60bb77087d6f99d431c0844a0f02a9d65395ae8f7836fa9cda962dc9c481c7d4d7ed73ca66bf0703a1cfbedfad5f3c7aa76177b87686691cb910bf8d7ab2292f4518779d7c7dc5ca62a89bd146c91bafaa9cee09c2c920454beee4e9d57918030753c3891fbd33888fb8832bfd4ddbf511eb2d9f4c8699cd7a535a89fc708b1670d11852ad017c54e5eb49fc7ac3cdf969ef32b0404cc52f031b72401cf41df347a23e9be994947123d53e08337b619c1291cf96892023e97911e75bb538bb844f4724ccacbca647b3ec9159feeec97090316d3837f2efc546176684ee920997b97d31eee5552af2ef3643939ac5d5ef67023975d647ee762af355744bc1a3adea2a3974bee5b5dc7aedb8c8c5f25b4c436eb26a1adb63307807e0af53f3f0c5e766e31a64c43d744f968e1ec0de03ca6f18783cbd7cecec86b050f2da4cd8c131c707ef919387072e0ea454bdcdfc661c5633aff3e16fb5c7d15bebbe76738e5a172ec8abe7b0356a67cee9bc7545d6b2960e1f01be5ff418c910e4f71811342aa22a300d38766fa2a388732613d6ae388942e4160930ad6c32dc3df4fdeee93d3392db5c39e696a69e9d0a00c078d0470ecb07615c2c62daa36ce053f6ee1ab1f5e18aad899c32f895aa5461ba7a8f03cba24b66e8d0300a8479d513e94cdb152edfa0a363fa9919aa9bd0c27e399b4ece75fe852ceea645b9e6cff564c8d4ee207562ba5942dbc398f61e4d5adc2bc7b3cec2ad2dca778716de0171e2bd2cabc2a2144d34c534ecd4ac80221e5f16a48bc87adba45225c097bbd7741a6ac482f4822c3f9953385313e59e0e308054d178873f0100a2c380a6e57c49ed2ea3787c250cf3e186ae9adb6bc73d1f47e4618563a7496507869e82a299200063466058f5cc9f3457706e2f134dfdd487d9e60e8acc0eff02b481e012dd108901569556bb691419659f4f5b4a53abf94e5663a70a5864f13538eb8ec7b218298da1dc068ea83ad67264cecba04904501a30e4f8b9654eaa6399da18090db7999dce64e5072fc64563200e10d1eec61bd4dd5bacdae119abfc1dacd355715e16c0ba20522e4bc1851384a5c40d59e852581811bff36a2e12bbccb0b20f3fa0b01bd7a978fd80dbba8b8ce20cda54d6510bfc523e17d3b11d5ffb60a7d82c5af8f6e939312282ef0f055e6ddd0cd1839bca02994ea6e829b698836410029fa431ac149a2e9999e1054f72d981e51ac30704faaa81bf34091be0d094592792ca9539894a9cb7915677da37d96d42cdd1fb70760a03f8574d14d658064368e71325185ee8da06e039b4acefd854914b411b51e871ad8b1c6f82811157590e05056a4980e131990387c0188a569ad98cfcedefc63bb8391e22b1447890bb698832751c5da540151f4490927198b96e9b0f48bfce08b5b9198c1eb817366a8275ab64f3fc2bc03fb6e0f70feb761ced065849968f8221eec82c049980f2721ba496439e3d47f6bfa61e7a275e52b9f2d03b0814e953fae0576cf9a848312d9fcaab9ff608ff67f3ba863556685d7f5306b89785393a0f5e33308845e546040a774e45087afab2012b5d697cc82d9ac23d016ca72cb9fd428d674d5ea8f3c8add260101d57862fb47f289fc75807180b6110200cd9e4b3b729b04d5a28689e6c122b6734ff5efc2064f3abdc43434a7f8790f32996943691e88f0752f05b74bfcdb759841ce28dc4dda2b91ea14ec8a0ca9458e45098366788ae368f3c805144b9073dcb0caf9bda20d954e2be87f29b6abd2cba7f9a578278be1b7a14b3d96985662a2c6bc9a611eb86e02e010551bbda0783781017c8fdf88143aa6076b5bb66da2b0dc8b2b9319288c159c7aecc1e27a8307e5cd75c72c96474da9ec9c8147017bb0f3314d58fd418b291a5a6803dc8577c4257a9f497b37d3d64f1b181a18b106740a0806b36339129c22672c9a30f22a786c69240bd7b82fbef37f253f601331fe9891573df3bdfa4af510afd797c3f864d7b08f4fb557e49e5350b16929875cbcd844fd79ab7711263345d7f9b6328ff73757a5889b714f1c4675988825acf2d60ec2ff05b614d149600152c2143fdd92e37d16db50149432c50b0e2a78076ad8288a8442c031d7fd3732fdfe3feb8edd1f19c7c19edd9d70480bee808a547d1dfdb3682b87975692b5514c63ad646022eb85a6a79bdb8de5e9385cd566af49b6287f8c86c79facef91d9202f6be9092c7abdb295ada822e756eaad9434e4bb5af839157eea351bfdad7d999cb532981bf1ac3016fcf3cfb57f6b62ac04f6663983727c983ebb013a4f9136c9b2d9052cb8d3bacf57556f6902e0831e250eebcb1a6da314a2997007a9e38c53c8ae179af9f5527c89bf2c723706ac524418c68c695ed2d1e0acd28eb00e403e905afb3814ead6b4297839b9b666283ad19f2ebd5d0571e601e27dfbeed299cb07cdf42acbdc9586c43a8bae69b05735d11119f83de96f14c5fbde0064347946335dca8774a947f0b29974f97975f37045706e572cdc383db1e1ed520430fed0e129d993f91b5c1dcabb7f7f1ea7a1449bc00953b92e785abc792c84bee252c9ed20bc196286ce15f6584f5102d4825dc5bb552078d6b97f2ca4c4a21a7f7c2c6bca339725b7dbe7961f407bbff6d748ab34eb0767bb4895e0a7840a36afdbb6c423c4cb54682c5f84a20b653a17fe8f15f7972bbac6b15bc23b832ff0a62d7ea6d62ad4579fc21b0a2700e2f1f2f61f87ae44d7b0f8e2a11456af798792bade18135e8835a8c5d07a51cd6c64f22cd99683f134811c3c192014d67b9cbe58bb6b534f6695619ffe348a313143205c7be448f991c48d5bd418a7b2d49af4a3159b5d7db4b22845890888cf0ec1b8f83e48fa66eb80c439b2baab19cb6ebf507a0ccdb952e63de18d104e887aba9a29f46fd5cfa8ed9b05c3422851a0b7315340d72ca2e5cc3ba5f4e8adf877e63c52f3f54065a712134438b0e52439202a2a064b80f92dc020c667962f6cc90a9f526ba46b7cdf4671d9f047a1f5f3a25d219762df3a5b853f52d9e904859869af5ec183d434bb300c96df0d0c2e275043542c8c56bf42f6c262950c6ac560971df7348fad0e4b09b2116344feb31e86c9cbda17560151ff3f508aab4f7e516fff0466a333cbfc8e383b4382fbc573844005f7627cca95df600d8e797439bf536a9722e87e4c6ab3a2f25eba3a7bdee2db67f012aeda1905ef346f1a976326332b69257f6f02cd2a7d0277bac02f30b1e559fa780af45b2e9a992cb3482b26034f43616715e9d6c00720b30a602748f1fc743b6b88968a0f9279a7e1c1d4c104bcb2a38e1b07beaadb100a15cde0d67fc3297d996aa67e59bc0a8713d2d3abd13a0b7a6a135ace03cacf6394eeda0d8381ecb38ae9a84d3fc2ce7b1bdff149de5ecb8b8863e6504795657c96d79ea54e076976f583ea1dc78e0aad17927f47e814e8539e3adaeacb13d939690f45e69e8c823ed5fa37ac98a926d99b5fa8204bd38b83e2eb0b65fd11107d0da42afb628f9557b33c07e6cc8e439c9932e5706d28c28352d028e07f2","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
