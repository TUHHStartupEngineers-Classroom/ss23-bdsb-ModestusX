<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"370da613b032b0cf8ff997b4d776272bdd920a14e115651cd7ebfcb4bec091133bf10225cb309b319722c9772a0cfb37144657f7feb568e15b134e751f8f5a8ee8debe80dfbfd9d5cd5398f57651e3b7d0473517539af335238496bbede1e2133515a1e9e755fd9c895fe919c56ab456c4a247c3c0c0e50aa648f6317d67c281c22a0060649ac61e5b8c61a7234cf41c76fbdf0275dd389cb2372790e90132cc383a7d2e0df53fbe407179fdb1da6392eecd02304306436e449ab3738f2b9c738b1d89f23a61d2e71454aeb682b49177f9eb9f34e6cb1df07277c1588a407548a605a9b60b4d77d934e878c3a219184d473631d7e1e54121d35731adbd4506a3553ba5051b2a3a335ea46f0466c34c75802fedb859762207ad32b03871a47d3dd4d38a6273408220d8241c1d244e00f97790556fc1c9f5f97400e1104e963cb160410695f65a7a3c92c7dff81ed0e9c7aabf8f85ce5f6549e75a6749ed52f84d656808cd8efebf8d78b9e5da9405702150e1c0df9647fe7ad63ab6a670776e47bbc3562a2ebec23e43f530437c9ecd6fd177a9378f96e93f2271044a7c9f3dc80608e0369859a9298b05d1f57881e7c101fd5c4f610577e8c6d38266022359102844b7f8008e73f5c8926bc7ceec05e52e889e423207f19c5ca9f17c734715db9081cf2b900bd2b97c101ce57c09a5fb0ba26a99c5c83096920d2abcc6e4a3018bdcf5c770e059fbf276faf2093d566894357a751221a8d45081e76379bc4b01ee8146fc03254edea503fa8f7b49ef4cbc9718aca34ed89a0ace76ac9fcc0d6b7b8f7bc68126ee2c5e758b48c1d0103b3ddab7fbf0a9c292ef447aa955339eae473d85dea44180d73f269457c67cd95ac9662eb9ad4327d10d883ad98819e4e68888b17ad06f4911eaa8715a111ca1d01d120a898c73fcbbb39a3c1d99ec2d8dc8590f23b15396582bfd78d0a45043c064d875e024da2a7d9e191074fe82efa56c968edb6df46d4b98367a766447fffd30613829df58e81e309cc5965b6e0f5aeb937f480dbfedb6ee30959638a0b528c5d0d60709c780b8c4f45a6fa43832e9454340d2e282a9f1ae429eda497c0e21e507a09b3e3c4e3118321630e991fa70a1475ccf4a9da6c8ea2937aaedbd650b75a91fc3415a589d359989973c6c270be09ef0577540d4312cd15de9acb078dea880c18dad6960e47c41a52118d00803bf4bfe9aeea59cc4029671684402973c24b78e3b9269c9bd865fa020a146bcf8e52064b9222d393cab883623c4593dbc80a70e0872dc08d898ac37d91921b0943fdcc31916ca2123cc78b2a9a35b1ffd7e6a323976998c6d13620b4ab4e9f92399c94356f9459493bb309e85c54463e6febb1f5ad3018785bd1ea44a37e0ea57b8779bf78cec7c4ff048a7afaa2f5fed2f5f1dd212daf5af40115f51cc6d167752476e71c928020e6234b1d31adb39f5ce08f7b9e326586d912428631bef70aa13ebdceed4cfd45a2c853522ca59d196c0bf7569d8e7db16a467cc0af6d391f4569d957115b6aa9b8867c775732dc7c4764ab9264237b8fdeaba329af804fd89c8b8fce6ca9e50d42461a3e45dd532cc24b99fd26f216616061706780d93b6648ae6d769fcffb167d4dab1e2c752d44398e567fda0c5362a953aa319922b2cb21f0018f38c91d9399e26a5d9dc87bac7a3ef065e038ad53c4ef9e0ec8ada8cfe7f1dece167b8ea05ac3dfda08049e68522a9fcc59b19987b3fe22bb24ebe5ca631e909f10994aba3aec6335b4b73c48b8117e892c613c42528fd4bfba6d1b99a7f88f40d1599d0177d1e785accd587a1470387776ddfefad8d865af48db80b468a1fda37beb64a52d0edac9ad41bab961e7d0a7a12d562070b59ee3b12cc66f6d888560f9162ed781499439e5e0509e7889dc609d0e086ef3a827ddf388741da3a5b425ebb991744918e63c670bc266f2f29a6747301a12b2cb67ab3967409375f60a5f4cf93e1ea125c4e84c11ce784b71e61d1e9b580a0a6014c1839e77a910400da51859fa710342e9a8b277937e1584fe128ffb4052537023cc7aaae683b6505aea027ca172b99fe7a75efa31d9dc737434b424a43ed81092d3b53a8b2b19a2e04f7db0c1c9443d2bc1a6490d0282df3df1ae1c71d4e1f021a9c891dc6ca65c029be82e5ae9ce406d2f3088f9b72d35edbf5e5d3e9cf95b769fc8aa206bfed95625790c17420af3076f6a5f01a17f1ba51a3a0104a2a944b6f6e604e0132ae277afccbf8d773b980a558792adc682d705fb2855cf17d4f334042cea56cd80ce51316fd2f3ba531289c8b66a5a44291e2e4039d2a552344a06812e67dcc4fa6a9da54be105c258b64f3f4913cf2830c1e2f1b22010d7d2441cd312912dd7205118761cf2399cc43b63f43306ecdb31086f97b07f895086bffbdd43e601f25c6786a8c81d3b965ad6829b65749231ea1289447010f70015a4bb5ddc8a2706d176d735fbd5f44c9fbb5a64daf683e6e1367ace20c346bedae50355b8550b4c152ce3d3f0516bc79433b31d41e8448722ec3ca58a13a1f4cc6f6d85a7781fbdf1f439fa10ec07178557b25e7e8436577630ed393ce6774932add6aefea63e3ad44bce6014c751d24aa6769353b5fc825520eb04d52faa6ad0c7b0a675fef5665145c8c3af30ddade17006a2c453591c0630f4deb2717a089bbecd552e8b226cb8e7227afe2778a68c811cf2dc0c5e77e029c0613f3b7f3e6328a071f87327141fb1c9a97bb87a61fc4503a4e5bda3ce48cf37ffed5c6dc313cb8803e3a131591ea4802582e0d76688b33fc7ba8a13b07b849e9dd95ec104c68db0782316243358999f0f8573a1b0c79b1de129fc9c2a1df5958b74b31fba2f8c16026b64436086870137256ce71e46020980afef3a5faee04d1e0544417311e76adee881c6876e9ec33cf54d5fd6d7949f6d478ecd4e0696fe43ae75c7b3e86694f24a9ea866f27a712f2dce78eb2999e86fbeabbd034c4d47e07199d98e5f68bf46065d8c9bdf86a7caebd619f36320babbca45d6955698fc32a81b3126e36c99ba402293e1db74949fcf44d9b153e395b849a91fc2252f5a8b15f233297482f1ce10e5291ebe10e62acf8eabd9419abeb49f830067ef6e72b9aa8f83f07ac94f55adf6b6be08404aa017f2aab568e7a679ec08ff1be33f3e4d0b08044d0a51f3266195fa98a06997b98918142a5e0638747f48c15721ca2d9c985e1c98d80af8a9422a01a2d9d59d23a524d0f0bdce7bafbc6c9acf1c8b2bd677fd6e1d2b32f1021a58ad6efe7844564e03fae3825edac29c65693902a407a32af7dd03b00976635627ff4fac825e07ea9c6f43e9531152667c2c400601434af75709ad749395e1578440e91093112fb192ad00e12a5dbf18de80c9d8efdddfa4da69b68e23fe8f15529a01879cf7fa6ea39b770d508be61e43da074a186a45b584d47fc47474dca0eced8135556159a23a6163ecf0c5f39830e4e25195d8c35cd21c0ede9ba7091d03b4393500c4988f64291b0deff6466d5686735f6f4ec58cafee49961c10c7a092ef39bfb7154442fa1075d78a6361a64e2d5a0d5a82f622684b1c09a884723345fafaff40633e47cf67a4b295dd05e3cf42ae316e12a096c2e7bcd52f0ea6720abe176d217dc37b073dd1ca9ed2bf8d670fcbef9b0e78d674cd8b234e07c2e2d9111f3d091addf5ce11c6d3a3cb6fc86521e2823caf48300ac11a3d0beb13caccfd0c9acff6222a7555319602066ec817466e485f4f398d4d8c66efd7766cb12bfc5fc2c5826735a69a81a270cfb5db630f9ee46554fbded2bcda86a50ac761f18abb5c9bedabb134e2dd97db527dab8e1e976985df7a1a2b09e85fb846da7401ce0bd48b2f6a5a02d95b33960419d259f51e823527022654724c0d219eab7fe399a186aa346f12812021dd6053f36a88b587f9dbf2db3b3308684121ec07ec9b96bceaa1d0119897dd7bc583efc154cb352c853a1896775451260e507c2f2dad00dfc089886fd816b8a0cbd546fc0ae25197b27838682d7cad6d4e060ebad61acf9b3ba169277d675478293dff6915ca0e483fa9be6bf9e675fc8ea7ed8489760477e7763ca1d756c4e8dfc5a91831ff680efc8437908e2c496113a3c777c4116506b1fb0661969c2324843fec64584ec160c8c0228b42deaadbe336be0049b74b6d2050457aa49cd3d4da0fd7b71969615d789eeebd3cf2111a7486872c4efe5fe7ad26fe1aac93adc531f881169981f516c57d24ac8afe2efeb49ae4096e4de034f496082b1ecd7f08cc2f7dc7f71b09d861b579c9f4424fef16cc6be828ff145a6f3716a376e46288d229b5cda5fc28fe19746265b8544bacd5b7b02181cddf3b70a8edcce0030a83a0ff40781697fd47ce43830afaed426719f4a1c41f1096803729f294a180add46164fb6a720d872b3e32022937e2f6a30e816a816f172cd2e1ca98b54ed0e2521f9e15eb8dc8eacb94caf615398e0b05b25e33ccdc113c0f0ae308ddee212eac259b993f4fda40226ea7c6c096a2eb7aaa10cec47985fec1c9e81a83b961c35b81eedd92b2919c98523698781b0280d841bffaeedfbdd6645dfe134775010b9e74d43a780b613f9943675a97ec02dd576b0d58b36aa0783a7758643f07c43738deca990732aad954a152845b656946518c486c8cd0446b80b27aa413fb27a10295260b3b8e18f13ab485eedd36b06949d202fd9dff6ea0ed89b31a6aae804fa82734145ebb32fde9bfc7c2b6052935a658950791f65074fb307d13b4eb042dd726fa1927eb565701c8136cca402e2243cf78261a4f42e6b402679be8cf05d7053239d3009c25ecf9b94ad2f1f3dceca12ee352dca1dd170fd73370c04da36b64509e69273819a0f61ce4c099231a31ac6297d02ebd0ba465c2a31ac1a389723ff67da29a972f87ca74b4657eda1f089bd5f7483d841ec4f53768a0903b39dd23459ccd6d318a6bee4ed9876dea396bd22b2f15ff7d8d6e53f2105327d3872bd726a57dde6bb672f79116423e05e5dbad592f5df595220268dd35cdd388e2a1286fec7506403dd1ff581104527d4b806127f3c56d6a3f2f74cf989a19f915a577d9f957e4f91a013c309d75e4807054b8fff727e492f71e633fdc0efea1e04860bbf473a22012770165690a7ca341a4f08feac228db90ef704c85e789cb070440b3a4b999b141412be1752bcd0fcd54ac16ca99aea9859ff254de43a2a8856c7d6d3910f3192075433b21fd5870d16948bb47e016f57db8ee187896f7abb8d2b37c776402c26ac5653295b9047911735553d9c1f10ffb97b46cd2996bd2cf024242f5b2cea1711dce09ca35f7be452c3c77e50b59cc15be14ece481b358824dc776073b776a8b79184de096cc2e539e10326a04a01eb796c7b9f103258b77ba36d633cf185e9e5ca2cdf0446faa0424b64448bcffb7a5ef56a9df92edf8ac999f9aec109183a491d235c6adb61453501a363ad712677fe7cf310f08388ce0647d714f47971532e265810b0948c0d4cc5c90369d489fde277fe0d3e9012650f5c59c6a717c88424358aedca42d79c08d0f1e4287f668e9681abe2e56e99a5d58d79bbadff662af3ae8652fe41caad06981340ae5838b4c5cb7ea63bd201d07b56b0d224aee83abe3f5f7cf488f304f9584c6c91bf00faaa71549bd7bb56cd31666908d84bf241fec31583e9f8215b7236fdefdc7f4b3d442579493f20cc19cae7a2f4d2a16600d5ceedf0a98439cb724450f67a73e8e74a3b8ee5bb255c9094e14efe6e23b3797764eeccdaee1c388764b147ea66bfc1abea7aaaf9377fb86727f599bf8baf43c963d413df56b4a65440b1ba30b073c6d1746d1bd0f2c4543766bb435cba8596ff9851d61efae298545d45025498a43d976df8a3199c0b232490e060fb71dc1557711f5ba639e079e9e52bc18740c3c59d979a786f58a1e04b0bd583250fea6a2c2ba51da6b8e8e6bea3c48d369f5f7fd7d82bd418182328eb5395d8b77ac5d909ab180c2f9a924e9b096dc89fff2f36f848a45268e04fcfabdc40a52fbd2eb3702499d85729dbcfe3c9fba66122fd61bb18507df65a00f21c9e609a0dca82cd6474b4263821c1f964548846704c58aff0e0e7492e1bfb5904fd37b4f5c37206f8aeeae1fd8373697032c69d04523d29bfbdbe8068adfd9b18a41a3b0ab0e8c46dd75137f5d93378c1e354a940f494ba1a2328231791a573dcec6f0334a0a6f124dc3d3e74f8ace1ced90e43094a6b9b982026d2db7365a82a7ebd2f3938fbd6432f1c0be1eaafbb26a7cced6f7634c4ba1cf129ed6f655681502a5ec77ca0e168b328520a07a230f38409f2089dd795c64c62189a5738efdb1068fbcbbc021b0c95783b3e46ddcd744298bf54c8da9ecf55c0f373341a5c621340a1a070607ca5423ca359936d281863442db750360f0bdbc4e972d377a9efdd50b9d73ad7c97f5195484a5745e714b2f460f83ef76649d83661b0d921f2bd361b7ef2f401ba695e41365030123d614f7595fca50f93119df9372b8737bc51f3d3868e5581f5c56c3b5dc3ee419024cd0fcade7ec8c05b061c3c06ca04c7b8ee376d20a41eb9d78709ec306cb4250226e8cab4dc84b0f1d2433b60842fd4e2de8d9de973c589f551b0591fdf1d6cdfde484f49a858e8d199d274329e69bd889a1699f53e135337c888c4ae1a2479dcec747a7ad1aca851667230b53d55b625aa3936e11a71e24671c2e086092725bc156bd7fde40b6a89bfecc26a19714a576cae058ff977618ab8583923d5a6f14e715d4ee8a968a373e12448e5ff6ab6d096a52a8b01f573f6d2de37bf8eb77f7848487104249f35ed60e2ba6d6e8827cb7a08dffb579f44de35eca5ee455a5109025d84fe38f5ea5be6b282ec037e87262607905deee09c60ae9b68945cd3f0f38e9c4a64c28f97b1dc8f73b836a4b4bf3dade5391c59ef47029e2cd1dd11c89ff8b67266f4a5663a15f768caa3a3608b5becf841e65e8dbc1a0e75b5e261c4211fe1e841fdf0437f0e83cd0cc99a77961da266043df0be03df81851460e06c65f5aab604a12d549c8236cbd7851ea3f5fa72f026312ca37647d28692d05e4c835b806fb6d63fd0b214a9157fe6e91b399131d8d2237cd4bf3d2c0468dafc780098c7c5853fe3fb66ac399f377e78771efccd1518e8b0317345babee6d7c547894703f94433a1eafc36c8976218beb3f497c7cbd041215d98cf908ef7aa4369d4e663e4fb4a90d95d88f22f8a54fa3266eea4f767418813e8119357ec61cc7854a422eb1cc9344877a43693ecdf3a56466cd2d3afda7a1c7805bb9cb0bf126622c931a1426af1df6ea75cf854a49b4d3bfbcbc5cd7d5c5ddaedebb9eb7d0b175fdbf83ee14a3330e9f9a5eb007d8ab10ff2de19db8795ec66135bf653792c718a1e463e8f7845a7ec6d7812a12a762c58e75c744633bcdcafe5e34a49255f8c0bd19d07f56e2ae3031dd9d2efede92d32f9e3c6954b37e52be42244521a70fc7f3cf3913852459f2e4d0603ffc8564b7aa6083ccd41adb44de45de4abbba0135ebb4596113171918855d41a9c800659ea46972a97332eebc66b2567c967beaffd2cfb1c56c498ae21e7eeb4aea567663801c7a2ed2f84bb77fddac937e71f85fdded4290b96858058c3abe5a89eb703625a2e396d85983c66d6ba0315baf8a7db5b1904a70b2216ed0527eef92479122017fa5de0f9e1553679e18475c00beb80417b3fba2f1fdc9e14a092e247d46ea0ca542f1540edabac9fabb2be23dd0b9d3171828dccea0e4d713db49a0060cc088991de31b56bf16ff9c1f2e617677560464c96d27f6b8ec104e88045a41c610b461dc31cbe8b487700c1d3d6b1fb41e3b17a9280bcaccb5c110ba602c305a30794f8dd79e170b642f22d9ccfabb8a32c51063ca66a2673964f4aeafb948e9c8309b7f89968bb9d0ef128dbb6b3ec598c786505e81c6f5f1492a9349fb5b345930f3f7b9d1881b4b4d2645a9addbf38f79f462a292c29ed273d747bbfd8c14191c8ba0955ba63c2f346e293bdd3da3f6e4b7fe7016f0ddde56d3c054142730908374dffd25dd80700ec00541c59957dc3e9216688da70c154a090070972ad835d4c78c6854e7dd2f91b6c4ce165533ba3040832f769965e8767d7b7877d6602b03f237f751fee3bfe4cbc274d6b72e1598f52caa5ce78a0bee71c295a8fb9063ace29a76c100ffbfbf6f7cf7ac16818c5c863da334f9a9b58076da0745ca81cbdad8dbef65cde3014642ecc2f6cc6eed38ccfa183f6026f86994cbbd38c825482e82394ae103cb143c52853d10e91cb22635a43afe753e5bf443f3bbe9e6b7cefd5c4e9bc562683cdab791d784cd20cbf1e713c497bd7b2f375331392a2053e04c72ce4e5c88196b9595a429838a00387d5c6682f07c4d3e81ab7b57554828197c37f4ec614737fb8c3b2ddd3694b8a7f6be3f0e5104a8ebafa8e5b564beb50eaec92e5505d816a8a73ee94c4dea08855c32914091d89a5bec4da460b220df86c1121dff1e7f3b61916d5ff31d679ca588c4f4931788c661974dea08da6d42f32732cfbc78033ca52380b1473f3168215764a8fa661c74d2c87cd323b9f74a25c7583a221d465dab7c34efcbe9f451726ffa6741c727e95b6f961db5c23bee3a03a8ac336958c9f8d1c4ee9c7d6b74bafc8405935daa031764cf71c82b2cafe43f37bf50a6ba4353462ab7d85298e19387db9a532a3bcd01a1aa949aecd3dd556fae2d34333b253a626fd40b11950b8d38962dd27f84015420b716b1b09e2dfbfdc2451e8b2cce1afb154fa3d99ee39b721ee15bc84a33c4fc381dce529754a55c89673a1281870751e62548561833f8c6ac76a47e557460d694df6d09f7088641504ad917e66a504fbb3594e7aab0b01eb29f2babdb2dff722fdf07d94cfa9ada1f40cae985286399886a207e2e7a21cb55399afd610d06d1d57862fde59d5ba0794b3ef24c39f185559380b6a89247df21cd1ee6331eca6cfbd8fe264fd0c119583a0823ff568c3e01be01b640572c01daa9ead295e904506dba9aabcac794206d21e59f741c3df639c00d218b4321f15a2d74154aa6fb8bd4394d6d7bd497a25a874914239384e26c40c2976b6b9c0a37ab5cccfc3777def527cb42e772634db6dad61672b13cef48a9da7bc069e7041f9197db6c3f9ddb7d12c7ded5e1271d351259ba1cfe28ca1d30bd0b4a41280d52950a8f4e2a77c1797a6e33068d7ec4c194b96769f1014b5ddb99f10ac344d427bba6772aae1690833641498c7e37348830bf263ae165fff599d570dd334a11d5ac7ad33cd49b03a798cb3b64714f2f13b8824a3dc4b14266a00bbb70b9d407fcdb7afd3c55b5bce6857dd7a48add015a8fbe8fe10c1b0f7b8b9f4ae4f873b39834e45346ac1afb61488076a0be72a7fe39ab1696b2501e6cf53472ab9d941ea0183adbd4eff4996711a5817ece578e8b893d92961192bb7305f808bcb1936ff696c2dcd870226fd9145829fab8d55cea4e1e95e3d4d1ce444291d6a4b91717556b1f4df021ca29956232d7e5235dbbd19cba6a05d73123605436e31efb80379ce6791fdc3c8fccd99f62197ffc9bb3cd685dfc5eaddb588313144679a3be9b2059ee010c985701c61366184e76914aa92e170b4e7c870c5d34584616359a7e1b07fca078aab30f46f732226449f1e3a25fc0faa50f3ff00d652241984b9c924c3fee810cabee1aa16ce54c63ac318cc71bc2948a8c024deffa5a241bd91cb72bdef0cd7d171ba68f5ae0d5def7809dda945e6db8ad195e1126d01c1dd5d0dbe2d1a4d507ffd9e720f59fba6c92ce96fe31034f8823439f4df21d7280c0345d5b445fe8978ce69c5d1681fd970a7430ce361d4f8134b8651254d8a02dfff8b200aef5a7386d2b79bb99ed5393bfd61f2d18a2d28008c623d28722458ce3781a1a0393d1bd86c890794d03bc18766b4af7b9a2d87c3af2200e9ef288aaf7ba85ffbf5272177f941dee892e9d1eacfd4c7ba54f07961fc25a4dc8f455fb112e40d249753d161bcfc6d9ae055902d2ef003aad2c04e8c4bbb2dcea5ec8a67e380e8008aaca310897f32b56e4d0958fb32bb6bf2cb4e1220cd1a252adcaf7225028812d39afec8f99133aec55ffcca4fe66b1811bb464754807483761ca4aec16599f4fc2878dce7704a1e3bc1bca125188be274b6f1f1d3c5b9123b15955e90436e957bfddf1fb0d2f4ac271f5d82420e3e1a23a00b8428043995821d5e7ba2086737d51d3902e749b419a38d4d799b56c7870a31da997021ced2b270ed4b04be38c14d6814630ce9309ab4ae07834852a35f69410dd1d7cb7ab310e819e0a1ac929d496e7bfdbed69300d5d4198bfec6a20d8e126679a8be937ade4682a1722153e543c76dffda2b9423b0660b807881adfa5ea9b00adf5a035608791e064dbdd672867807be8449e928ad9adcb642ec2f770bcee409dc17be19d2b91af91dc78dffd04c2c3c1e45e5b174112821803abf7bf7fca281c7fcab3d022169cf7b46a60a52d935c67587a16f6d8c7501ee13afc8742892585dea403e1f968182c923c92419b68dbe46ba64b80cc09e3b8fa782474f7430560bea22786819934251414d0b65dec5393b7505af68682b32e1f48c169edb938d28bf919c517f0bb7bb1ce6cd3e2f79d82b5002b3d6d3ea0382afba03c1ae715a750429d0874c72020d06b05b7afd319cb456c896a24b39563631cc11b6c3852be39ac7982e80c20509d3f0b279296facfbdaac92034c7ba299bfd016c7f0b86228482dce2c9a4be1058385d3c832005200cb76607ea0aba7f2c2b5d4eb8ab960585ee9b6c7d52204dd8097fee90c1c18570282eed54b7762b127117d2aea365ff5403655aec5d5aff38d57d44b399d2f072ca402e5c38f26d9b87d4b893725cc973ec5cf74c8cd3f8bb61c37e527c0f9bee05be3fbeb44060cea760d7c18c0ae9967d6e356264d2ef16b4bcbf7ebe478e65635602a413ae9fef71d2c5ff798ac56115c44514f5af1fec22642bcf00ad13c93c508eb6ab350c7a825cd14d645fbad0cc6b1e6fa8d487aa76f13edca305062f1cb6c9ed9c2373a0e8399be593e62cccbd7acfcfcfa05a2a6082289c8971ea5237da7becdb07069c76599d11304bbb0c99726e52f8e12f4102ede0a5601b22792c39342bcc7cb013bba1f3111440c170f19eda8ff9b5258f29a22a12e054f75089e7e8a8239432385b522c6a06eaa23545f600d91d10ea02b40aa0f35599871289239ed0bb32f3e3a220506b9af7b7802e792f6253326e29ce58885a3f620ad2cd8f08aed195c7f52b439224af93970db21b32f2e68eb7569a8916232c2ecdbeb759720d5e893afdacd78e7ea0ed02e45c3ea1d5f7022acace7189a85ab34be004f09fd11490edc3f019d4dd87c4c3e4e0152c92c857fd2d28ca8f9f3cb9bbe13bcb7c47d672d5fd941eda438e0c52126008424159fd994ed7429059819d7dda1b2ec9d0a71a7871a50c8cc5e74928db96d9bc8fbccda915e9905d82c2e4377861f5d32ffde554ec04187a822e48fb59f7d673bcd16f1583f83c99e6ab45d0168c21fe769c391e3444a38a631ca492d242bbb162e758de14082b5017a44024bf1cf02d2f832cf5bb80202380324e5304e0ea7a23b32474c67a26e18f927fa7e70b17127f4c77078b984c4100f13e324c41727ab3032436d6c1b7d3c75e2571642b69aa0f93bcc6e57efbe5d3179ba2249e96ef267ebc12cd140799b01992d00282fd34298e8789d3bc310385e99cbd827d2a0633474f96c9b421aaa0d73e061ad20561e0cd61b22995b2b758b3ed579e39e1f072f7c9f6aed56d2a60ac43b5a5741bd4b9585edabd2477aadc35944fc4620111127f43e50527b88364e125f1f5333db41ba40575f3b220beb3ac58c6552e46646441a9a271789bd7e650606df3b10c92af9c43c08ff7c253d48e080eef9a65758af7d7ec8caa901176049f7ac492fca6341aef4c0c7e989e68bf697d8402c6b77c13280fefa6cce735713905afeba68409ba4c8745dc6694944c9d59ee177303c0a1dab0c5eb4d56fbf13c7dfa880f1745717abb144d9859ab824909bedda4d639cb15d4ee10abe0d139ae2572a3da010d45c7c09f6af85127036a146bfa38a59772591113e9dbe3e94ba1f24c6a16f6292a52cc388eee79f864db521d993a45530f2439ae6d8decd8c0660ad61e15e23fa9accdf8e80dbe73576d13dd4d5663cbea67ef5643a8f527111d0420e33a50eaaa2117bf8c90cd07003b8d971053a7dde5de203127b431c733771e638e64f1bc95502935be66b591317c3635a7ad00b36b69b2bd91f294db9dcbd423f75245acdcb362944b558b5471cdc8f65806de3f465fe6b6804df45efb3081950392eaa5bd89fd0a9afb155cf66f8e7efc31ecde8f041c556a1ee5232f1934507301feceacd9a743505a1eb5eca29a72d9f223fc2712ff7705ba2b0c31e3038282f08afa2ef995263de3eb7d01668e2cdb3f387dea8b6af4834dcb1b288f9060932901dcb3046405f227677a22773bbdf7c335de64ce85fe1da94e792ab6a2c11b1bc11c3455c4d961ecde3ad6ab63b573de46588041c265db1019772ca8f2f553001a5231739aa5a9649fc279c95e238028c93d0505aac174e48a065ec3f4d332ddab5ea43fad5d9f004d450aec4e258d4aa3201cdc4483b957ef1d4f8ea4827d6fe59ade9229c32151e36f87b8fee8d74e10d8044e0be75f4b07399ec5782c0f148bf76ed532dcfd18027453a614d5760f6a13a7b1e3c3a567cd9e023c6db999f7d9025220bbb0165c019b0cff658b8530fe8003cd3f17ea5240b196a77f192f57c938c0846efe9ca69991e148910bb58c881166166fb18ae47e51436d14cbd2c921b781381d8e463cb987ce05250a8101de47d0286b38e6ab3f25e113017c5451ea6793b9cf45b0a5de0542806fdf51003b813093233cecf84fd98c77055c3355c949f897957e20172a09d7bec05d412a8afca11af928db90eda386a45cc0fda6ac52eb2e9392e2b3e9772bd296a727b156dc8ee167b8337ab96cb320de460a96e26f549fcb68f4491f4add1264c790157e2887f425c2f0dc2a4450a5501de9db2a360cfa225679b6e9177163bab8de04ba6060108bc047f2ab23cb61ff658ff1824649604f495d2f222e8ab885628f6494c1fdd547733c3a367ae1343ea20b8f40dca769edafe63601029a3466792a3d0e1ee99b9e4d93e5d27d68f22574979778932d2f753b50e5e3c7c109dcd777acaf1a89738094c92c4226f9270f9170b1df4b55ff58ca26634105bcbf1b6108addf72ea110fc4674254af53727d997ccc30d9b211f200d2bdf8b147cce2eb6c1e3c98c48e1fdf287fe1dc67353591c56264d45915dbb89ba4b0439581a402c2fda6a7922683c7c28bd7702e40415943849386e7ffe8d83ff001d345c3c5d03d3a649612585da8c1b53de0e03ca1689b016899cbfcaa91043b21d896e47da057fea741f80038d0a9cf9ca15fba567fa1cf6dd98f3c272df10318af724bc1ae31b57e28dc4c64834fec1be7dd57b3f93319b5957884f91267f0f4c7b42910532885fe715ac7f92651ba45d272dede1403201eda1cdd1d4bed74b1c692f9f06691362abc7e954e09e971c09132bd5b16d6936e8e9a7a5d2de8060132ac59ad0499c06c742a58cccdfa2bdf202758008c80619d157adeb3ca96b1b3c1db34f4057ccd2bf49996fba660e11ffadf05c4a829db9eb430a154f5309901ab4377b5192f57b1855e75e7902b76dc241106bafbfea30610eb30f62a4a7cb37cfdbddd67ccc8284dc891d85c7c18bb0167139d828004222376d7caad69e914f672e583c2e83b7510b163af281cb964d2f0f361108471a513348e47469d34e7fc88f9fd1afd61ececb96efe93d895ccadc1e594eff0b7e539f01a26537515892fce579c1b7eb04fb3a92f5a964b6cfcf813cb2504d0f1dab75e378317d36ae01744e655c0566f4167f5e6eb5b86d91bc019539934f1ad2d8969b8da720f3b174c5d78e42a9a0f75b895946b407fec2826d40739f5e7dab324db8d0b150b65a60fe5512cf757eb73be5adbc363cbfbef99a80d89adf93bd8c120c5fc37196f190e5c05b2697af543bc376e57909a52663aece317b4f7be19825f19e03ef723ec6dc9e663511d7fb8abe2d23adbc291af221be38ddeb8c4dbbee2d704e75af380cd6442b61c05febd82b7190d2b72bb5b320e3aa0b381f69680a07e290c760f91e7c3c9bae6e2ff44a245238cec89fd20549d657e4ba535a11897639deff93557c7745d5e728440a658ceda56d27c5934973489f8f3af5fcd9b940d275cb6d66be061258fa96c770181aed66c05cf0bee466d1ed1e656dc2645492e4c64e49726eb2118dcb35054a9c811db99f6881e35205e594442e1aec01f3b189b851a5c89e994cb4b99181afc24026aea4ac09e98519f79903133050a5b2c4a9aea510f54075136cc7b74c70347592f60ede7a86fef4e397b545d023637630cf15572853bdc43541868484b5ab91f1c73db1ca6fc64c7111e20ec1a81f21d581529e746bd8feb3a28ef8d4d6ed5e01b4d31c6eb2b7a7a1180ae3c15b4ea00630389f3eb4ff1980e87e0a36c689c0475f848599f8c053327d29190dac27feca584f8ce7a71080a957f4047081dd2c2eefa76e4c73702748095bb9b045aca718f5586058cbf75a505d4d8839f7262b2bd17ae8ba2a2146b3668f05fbbd1e2dd19859d69a8a49ee3f8c656666480843ea63ecb0d70675eb5fba10bc04969237314ec7349eb8531aab4988df01303a44f30ed2dd4c0549fb0c58ad85cbcc7c8e329b224e4b96252e715d5b1b4ec85d2b0a536c08c10783024cbbd4597b467c5e655a2b4f277143927ca7af33ace783d3ed952aee878afd5bb6e9a392468a7e3f79069db9414505d1b512eed4655ad3ae308a28584d18c1463f3a1fc1c658412f045c2f7952b1e53a70c85d217809ebeb40738893e7e8c5c8c28f70fe780a9e776632fb7a8e1d7fd2913081873fc3ff877ce71d38401f332ed181cd85639a2c3300cdeca9fc88acbd2a20a2461278409f17f9bb658fb43406e8f50f5c7aaa035f231e621ecb66eff1a39b7146a77628e027d686ffe6e765b2229b36cd007b34b01861783db274370046329a15369769f6acfcc7f5538717614ca427741ad816e21aff881d44aba4c3587e5dee2a793f45df3cd805ebe6bc024881606352596a360a7f2da896954d73feaaafeb3f11a306ea49f7bf3e01657fdcdd1296fcaaa11e891a035c76200bcb3300578d03c573b14c18996f9e313a4b974d8318f35f47b30048293266fa647bf85f3a80c1f65e6c3191a88b71205c018e30cc1c910c4866e5341c2f0445aa297e546e6c55355c46f6c2c0dec997aa5bb38616a7336a5e8bd79a3aaf92474109c44ab773be3bcef0e15de065deceb193fec6649adf8b1753c207ec002a99420712eaae3fd7187ee96685c794bbd2ece56f88da608512249ecb62b335356fa43f5b207c0742aaf8d7cafd0f551cf392ed9f236f6944906002958211d9fe292584d62c2305cac157caf62040118e62139f15aa108f5f1d0fa11d2b16554b1ae87923c9244866ad9194102320d98bed2e2002cdaa191591f4d4c7414f043f6c89ba767375fe2c957883d4c1a7b877e029155ac3da37dbc5e1c56939cd0211b458316ef36696ee485782dc362baa586592ad0fcfd41645feaa5439612994fa3a4356405bcf4a28fc279034c2064fd353301df6cc35a0c750c5362b07660bf9baa986998f013266052abc9b54a1a212e46ab737fef6efc310d3345b82825538d1cd740b9d5044e3575e5a06294febff2b0e0165e92f9e052857b2c3de8f16bac1d0b8d7dfdff9d568cbe425b71f120fe65ade37112672a0e00bad060731050574084f1fd72b4b0e1108d3dddbacb947f77b0a15aaaac1953cce69c30063f228991bf58ce40b7f715b00522681c5f7f03a25a466c0af7e946b05060ebcf64824238b7b3a062b809d052b44de1ccfc031ee0d27971058e668127dfddaea30bca7ad181d6430d093c30a68a10d4f54b19bf6d589d50c280faf164d619f2d79a06539a2a55b11c232a4f5ca4450313ac14c80dd48b6080164648283452a492c4b7113503f69144989f16d5c475d8747d2d5ca1499497955700a9d5c71121b2a7cb0e2730ab9e986b6c6edca4503f76d387db647ca5d83d98d9257a5a570a0f700edb50b92893ee3931f5eb99421125352eeb78bdf10148a03a0b3c837c4eb0473a5ad0df92523365d336627da7739c9d1c5ba8f24077da01634b05d90a87a2b830a3fdace3b20c4734161fa3e60309dc866dcb6a12b2a81bb58ad031aaa26c13094cdd62307b2e22e376c1a5e9257d046622e0a6adeb14d594afe23a32f3dc70d07196824d2a1fea688e06639be14e72117693089075b2259195bee591c461219161df3d4c598519cf2cd1f13674d9abd96e4a1856b5d7539fdfff2dbdff518ca5d3d6fbef0f8622d8f9efde648e2667bfa008c5badd1e30415dd3342fbc665231059bc6b7ebf309c62f611e29eda90cb1d50438a17577cf759d27ff88b329ef48c22b126e476f6cb95ff905ecf71cd2b45e89415c02dd9dfc9c21d9952a5b51baf47a6b8c6b745ce12d97e119c038e832306ac89eaaf000f23319af9f0c7b5e78bcc10b55b90181d773a7c719dddfd12028a4a999901256a9bb50851e288f1d5f083976d301370b9cad03f7bd57b2555a0c154c2f1fbc2f2ae302b07d0d9c1bc7c1616db79d69caf4e51cee00d8a721838a426f4f021900eabd77633795e9a2c18439abfe04b50427c5889c6b0308871eff0f3d9f21e55c77b355796278bb01577c96fe26118b7ddfa92f3b0aff478e5b9ecb153e927617cdfc2a2f9b1b4271a5bcea6ea880bbd158ec6dd5aba5acda756645888276d32c79fc20c430aed23dc9df9b54df15729eec433b32dd15ee39c633ee422f5519b0219f4ceb68bc07ad6f791426dbb3657bcf21be34f056291e07a8ff4689d96379c46a792c8d9cb4a1a9096101269418763f34c6bf2094609822c7e41c01a2df284ee91e081e966d8c450caa1f7da12c30fa687ba859ba4a24288a503143ccacfea27f48d7cab0d5c1fbd6b80aefcfa5ae1729d2e613bde170993a4c5420072e105eea1412f5b10233503ee4dcc7fe2f6e08231c80d333236ab71a493d337c72b7d10c7f033cfaab2203ca71a44fe42a236c3c90a66402361e24b416245c3496af7f4678aea1ba3967cc8f52bd434f3792deb6bcb3286acc3cf979749d4ce50c4ec0059a68a22331a7f385712c54c9b2f0a654c5162acef17276c56c80a641f399b49e229414de58722eff4c3c6f24b7947a204670c3f43f63a9c6c06421ef500f089ad5c7182cbdd233cc39a9d921dc8f14bcf0891500cb4c65c8bf9656ce8cf5345a0f4274e4703ba1f9713ac82cd2d56b60a95ecdd0e47f5b23f58476ec882ae91bf2a0d651540ffc4481e8fd4500ba47eb43e5b0e93a785905cf3b34785fc5944379947f35ddaf54dd9faa40bb935440fa911660b9462107e35281b13463f17ba0bda0335ec8d3a87c32d819867727876de39827e58651d08c6f027c859961fbc9b37a29bc39e2a2c34500678ca56dadb8ff1a33d29fa32a952720c06035058b7bb3ad02dbe69866486b30eb27ebc3759b84a53c50c6711672158c91ccf29ac3f81e83e68da7c8f3c537a4de0e39330e5cd054a435ac9f734cc7202e5f38ee138801993d68f8bd1f519181c47ce635d52298082d67c0d33be87df846cbe7c39af21a94643950536148488c4b80a414fec817bbf6665b7abc958b014dd99c560dbb859b11264be34187131a9c353a9b3086afdd3e7e2baa189f549da11d210271c213e6a25e9f7eb8602b7cade63873bdd11817056cc7f5379e5bbe005da74a0bcbbd734178143fbe68bfc4f7dfc097e81fdb0991c4d2fdd2f278d2e326784fb2c7f95f495acf873f3ccc75e3b424016c15d61d144b7668b74b5a5c1617b62294876ade0e7501023bd378a274b401639798d1422e14cc34c88adada177a8efc16545819ae8ce815e1989551194fc03ea606490b7f72ccff5126696289cdcffdac00b9f20541246de51345b0326946de8d33fa88ccbfac01d812de3799a3907458f911ff9d9ae4d870ae1a6d8c1414aa4311e7981937826792bdc42113f322ecf3ef71870ff378a65afabaac8f4c5082f48598a0f6a9f22d9bd469077544ea5ec078d7c4385e4a7d44e6bf8c34a5fdaca70a157fef81fd4dd5be9ed80f4babcea0be9eb852f085c97c246cf21a5414a9571820db38a1627254ff057a7ff807ef768d602d3e11a7f01bdd10867d5c92496e0ab899a09728f7a26cba504d85bf038edb9c3772dcc5a2755484ac2603702fc3ddce3a3266d3c45dffe8349c363707891cee70f5e52f4a17d657ec10df4ca13d033ddcc6e7e2bb58900693fc75dc6aaf6b5d9cbfacb637c913fd90e20c300ade5d06a90f90a34074c082bae4f884369850a109ac18ffd156283b812dc5b816261d4c74506add0c5e51722d592ae9bbee05ce74c354d2af48298196a642313f008a59ea9a8fca37f185a9d260552902ca1c8613ac856499c04908a5c96ad6a884d5116e6a4fd9cb870de0d338522ab3174ba2493de48f64e0ba41907dc8a033b888e9d5b9699be4f944312cef33567f9ac3be04df3c65edfb0abe3551c53b31be39029b6f6f04799fa8c746be7a1c9789d84b1c6f1c46f18bd6b04444dccffc17553da49d3d0486f0a778b23c95c11a94acc468390e1f7d0fd701d1b3ee0cef3cd7cf879cc77a9104e34704a96fd32e610bd1269feab5fa29e427ef491c870ee4cb3be8d1166f487a4312bad32488b97ed8dc958a5364b72c0802ef91992ab443b59754ea04a9c87404463407579f79a783a99862b743ddd8a245228832cb89ceee6ad20aeb9fc1dda8f4b94a3c008bf085669681eb722deaa068af11d480434f37e4de6cd6dd8c68ebcb6dd35a5d5b3b320096dda69eeb1b3ce96c61a8b96e409ef90c844e1d48c58eb021a76ac9338cc0b004c42485a12732e7caf7d8256786e47ded08f600b66fe24cdfb0b65014d8fe7666ac8408b891b58e284377d2c31849743a9bbf0c4075e04f6345bf0e5db2235973b909b2640eb4001a822d2ac0b817acb530401c689dd821a04bb4ddfa960b47cd69f15d95b3b3db5d31d82542ce07698d54699837511fd51c41e2b37598862dde591d9d87e9b01db0c31068e8eb53eeb3cd26fefe88c343af08a7e8db3cf1c7ba200aef857c075f02e3e403c2257391487c1d0bf6eb7d6ae5a6d790c6500f5c8792eee03ac8fa748095106e98f0f9dfb6618d15ae8ed978c8f2e8d8cd236caf0d4669abb739f2464c99f567d8ffa8973bf2d2b5c1773ad7ad1ffd98e21071d80c868e8e8d401c8a133c83c17c9b666699f02765c524f092af7c0c24f1b9cb2748732aacd6795807f1332209532e3bb0760eb43cd22a3831ccaf6b8e212c9dd32126fdfe21e115d9dfb02d8273578ac1d4bcc98967bb0b2d052f2e06f306aea30bee445068e6d0da026f11dd5ce836bb0e6fc30680c7e53c5e180dc07b2ebcaa8db631a0ac9c2871ba691cf2583c76e1d3d7053f0ab1b9744c1b732ca2d92d42f4a7bf5bf18c5ea9ab69e899c3aa07e218935d42bba8f7aba000ca80ef5a782767874909ba44be32a2eb998072dfd4b4d686a9b8f664cd0e149e4913ee136ecfc8af02af4507da50684c8a3b0e383159c1a873892199a244e3151334af733982be93f1c12219ce36bdd43e6fc6bd76ff2ec5f38565ef05acc8812bfc1a64cf6eab974aa290bf9e0eff7d5d51852e4be688992442c586de6614872c0322d2a4acb006c50ead94825c79d23e77a925536b2f4f44c727c7ec299846a3d0602458ad6672995df9205b0a30415bb2b783e0d96279e2cb1eed8fbf009f90acdd0d3b7403e6c4618788d543c5a12e9536e556cef827a00d98914ea184b97d67b06f8d77bfe202e896b5af15e7f4f1c2c10cbaaa94db2bd6afa50c4bcea6c08d2219eb71686d21a37ac169263f6320fbeea4d935e5548cf7146d8eb49880c7c8dc6607b2ca614c2ab960eb6b8e20841dec72e0fa206b1603223f329c65620ba8600db33af5657089615093bdac80810a1fa22440d3ea00c6f87f1239baa24dbedf0e685fe03a64e02b205840621c5523ba83a7d06c491097fa5e5f5d22785d36ccf44042053bcb1b395b357e9d0178c5b8358de707af02a701b6e37e11e88958225f45004c53c31402412115ecb5f574d56cbfb7dd2a0236f3dbba4e2f475f00fc201af1ac57f69039dae18cc964a80641f559d394df9061f217889d1e233df8f6ed46564176cd12f9cd860f03a6ded589f17667ccc5db3f0cda609788d2a5448650fcdd94fcb01554bc228379c0db281cab060c8665c918937fd3e4e2fad174ba2d6d924685de37982b92d2eba653154914d0d6290e7c5bb893d2c6a29af5d0333388f5e050390010bb1ca62fa9f02bb6bf963d9cb106b14e9fd7895bacca1e40cdccabda00b559d855f707b1a6094909f3b326f85b7a7f7f686b15015d8e3557443788a84d6f2e0155f8811c5f1dcddd5e72d1070b4442823f0ea9e8231a3f157809e7f9c8fa36923bfead6d6577798f626602a624264e8b314cab17773543295cc61c49942d7cfd325510cdf99e9b17923fe10d367271d2a3004dbbc0e83001f5f93dd9c31c86f6264e948288eb5beee865468bcc8403da84a12f2e6c64f730d450e4048b26a2fceaf4d5d29d732672b02b5493f34f2c12e7b0725deb056872651d21befcd6a7b20716b205fbd30f7be2416300f03a7151f4cb004fdc85cb92d35174a37da6889cb739d2f7a97bd0b020029da6b1f078ce071f4b9f810deb003e2d1b223e405b72ce956d786fd10a34df0f750a08f88f81172f7ed3280a37f85fbcc93926a86365e649c2894464f1371a91c67f6ccb52112c22a93a58c7cf59d487531bf056faa10631210d3702221d889d7b851c1ddd462a299a5f2812599e10fb80cf10eb74e354f265f4b3810607700d1014e5257c5635233ffc4c9ced7b56a5b507ec933445ac07aa23c364812b8e18fe736828677d6843cfe2c83e10461fa0560ffbe6c9609a12597015445ce687da03caddf15f98e056fe9a7158ab10aafbdfd1cdf1cba79785683d8af0c3799d33ead0b22a3200aaec3050a7d239fc3231c08ce242b05878818a369ac8c9a1fc9d7f7efe277788853e89036e0242ee3b1fbd587722f051746a62e0dd25e49135cab78b08bc6eae2250dee537437fad3f266a5e8b2d1ba1c30b4e039cf98e7f22996992b31c9eb90615f66728bb01d5740cb7532a94b94a8ffc1616763c7d71b85e5","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
