<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"4a7c50f1844d0ba76cfe001a9d4f0f511052cb5a13227c65b1a6f1e8706778c320f6bdc03366676d20829b4313db3946d7fc9d6e8b874079b48f3631be3fecf6e87cf486a7064f62c857919a3046eff20de6248554cfb900510225168c6ad639af6b188ba589b6d8e466c7aea691d823b02068451d227a52508b16e376fd9e6347ed1edd07b86d4e99266e0b8c1181299e4887b329b1407bc4e754fee73eacfde84bb75938dc5fc44d10e8870816ec6356f4b2ef6c639fb8f8b2361a1f47fea62a69c08757815a5d241bd2e72cb26a50e501bb0c9198049762542cd45bfafb65cefda81572266758eece1fa5c719a37d8906c19f737236674d41e6af31bbdf254096a1387cd575556f5790c5f486522195807f7661422954711f03366cc2a8cff4c4fe88bb182b5e705b4f6785604dbb3c78696b6cce94a44025d0a50aec97f28a1a5cc68fcc37f29ce86616b2860255abcba3aaa3a1f4d19141b20cdbc68b0ba0b59b22b0832275baf7e167ad7fa59fe9dbda9092cba7724c074f8eea89817a7401a3c4de39dbb3032a6cf00e14549e7c056e6182c05c94b891d6631106c3c4c66955be50a617d473370de7ad432aaf97e43bb09fd1cda7db217fbcc5e2907e642e137044e1407c5c2c0a3067d0d5bf36004f1db0c914fa85c603ede6e22dd2b179176e1941d8a6337b46c0badce96e190835e062e9e10a7b0da19249d3a8445c0f9c155c21159622f51adf3239f0cbd861fb0c2d5ba2bb630979399c851c14fa3e67de81fe0957df756711ad3d3bf272768b9e9e117625b2c36f46c3cd1328f7fa01139b94cb938acf818984f253401e24a128694d37fe79bacf354e941d746a8a1f6714cf1d663cd722a20ebf41d7188780a2453556bd4021a33053044a810eb1663fa7faf20b45beaa4a0b93190c85bc82a575e972b495403249341e27c841d111d9cb16d772037b6c074c62bbddedf45665de14e43329e99de946eac93afec29642229f6ec2a5bcc96eadf20f2b9afe3793770db3aa299f76d5adf0ce7bd4cc752cfc0bcec855b0b84029c630d110857fb1993ef0080c593f61cd4e2f83f1b6500a4dcb5057fd8abb7b66bbe00b303844021e78fbd0965b332b70d067f786c456a5d1f8ce2733642b531ec82e1e8fb4f38def85f0359b2e679a4edec316487b97c22a5301886ef7234463b068efc6fd53499b424a7800f0cc905d5674b6bd1eaa78bb5a5f18061b97a44b1c9e4a24bca84492da3346433b698db34f180f3ce40b087f70e6a983049b270147e19d28f6a200eb1c4b3123eed944b07da2ec75fb5d2143b512f74ab2ba2fe75920f29316dd6c3ea20687726853a617c4cbab31f9126fe205affa18c93a8a0965e5f690590d2962d78c6a928bb54925bc9b2695bc3690e9a878f6da058f4cc185427bace4766e25f2741a76803f540d865ffdbf9ccfe8961f9a1177fc8a0ce40e4145305119b7eef3c543f7691726cb874729bd1f603b0c7313484ce81d92f06dc17f1adfbf8e770febb3adefb5bd47ba166f9bb14c5bb821430c1000a0ed71ee9eb56e6fa67a7adf76a5809f846d029fae83178c29e151ac659e363468ba0da157a049ff778f9f7216a1d3bf6535a9e30c2a182e0d343013d547d31c7ebb4012e09f84b740006de347d13285c69ac6faaf2cb8c44c20ebc2b0f06d4ba0938108d79489d69b613f4807f5639f3e9e4d99989a48229a917a5880d55de9c1fb1298e3c85a8e2b067840bfd4968421a95f693c6f8abea4d1aa50e6ed3b9309495715f56065026f7229f936cd5d61ac30184e207436f5a32122e37a1ffcbdba3d4f1b6dccabeabcaadd77a0789b10394ecbc527ddb4f392c40f7b8ac74442e328e341845af65bab5ae8821986428a229ef4b0df1f856e86816faf0e0c06e0cfffd9143bd1d1d3d8a9fbc3df3376c569585d9bdbf495770a759f022778b447708aad3222fe4299b7648bbae2a7d1f35e40c8f05d91cd86fbb13180ae74ba6d647c8a939e2c8e76ed75dd2184b9245e1e4f57cec740311e8be1ee38e15d65de23e9f70b5394dfa83643eb5abf416f6ad6702a91b70ce1048b38309cde07bc328cd6f267d07f04efa139bc45c001776a5bba4483b40cb69930d3e46c9b3ff7b47b7aba26a6377f1b91730db5b56585833e9a85a7cfe45ed8b24d65c71afb5a132d3d12bf12b47ea4ada52911c9d7cde9f7fb099b48f93e8acf671ef5ecc7224d6125dcfbefbc1e5dc9d097e5227f783b36912399d3ae0e75c5ef2fa1cd1014e8ba1f13f00c55d1151cbf82ea802b98e14dd97550a5f73920f28711aad2e2eec0c4ffc2c23a45e663667e9d24eb6b4cc27319b2b542999d3b1db461491e738705634be9356d65e8409ccb6f9a2b038fc328bb5873affffcaf7dfacfd3c5fbdc0e19657f3ad9596320ac05f6250a9cec03944d3b6f38e1e5da8557341aba1d35e7f1a0f32065c067598d09dc7d600639a88b91d3ef16affd4af9259bfdbdee90caf0d29f752ea28f8c16374ee224c6cdc97d781ad1478889ccf556736574086fa5fe68980e684c927463ff10e820701f47b7968334c74e571815811f9201de5fd1a5372ac8b39889c829eb61b01f16f395a4e53f91099027c0b18377050a709a4d2ea3fe7b44f196cee3daa5ce4aef3b65f39570283e135c475c4db67e2b006eef81abc3d1f8f469f9418a7a4a0fe19262468ddbaf6db37768c0b24fb9308acb3ab82222b8a00467046c1180e78ca4f20a93341ba33ee3176f3690abdb9116b29fabd756282eba56a0974bf4246433dead4677ab52f8a2eb480a17db48b540e1954e767124ad054c4818969c8e91b4f5d55e4d1a61e0affab1fbbe794b7ed7c59243ebb344b6bd19858b20d3afdaa410751f7bb4cc6375baa521792b895520483fac55c8f54989c7a01386fddd652a5f91ff29a0c3502541423c03867161fca9891dd37109b33a786f0ccfc5714ae0b273a82f7406f52ad5aa8cb78229447a3243f14f1996adb8ef3f5ae1963be412456ab0825ae06adf4dde08e5db75285b2fac651d6948e6fae48f1032955a887f86ababe800f81e344d08f89ad1c2166ecfe9ac5a116d46654e65b234a67f4123d260ca4e112b602ddebd4024e9dcaa22c687900238b58e965c9ecb82aed10f925202efb80c530368359f2b8469b135d80727aa89af66957c1ebfe9fca6b3348bec44f9831a66b4c62b29567e01d9814337c7a63458eb34c0b2c5cb38465b840737509de45ff60582e84658dd3e981e891d2473bdc068887c9360a1f11bafd17ee4e99486ef555daa3fcb88c8251b92f5615d30823971aa75c5c9576e7e06cd5d7e23d6b38e4481b9061ffc6145ce56987a1035429f4bb29f39e684c52a9bf77582f5f58d8eb8b6b28e8e0de80e1c610e8efee37b23ba91fb5169e6efd227fe8aa689612ab67bbb0694181ad54b0f991ca98d1409a0b2158f5244a0b632db8effa1d2f339a8045cd721063c83f08ced9dbaef196e5e2112fb9fb0e3a4ee27f6f5f568af13e44068683b0b8093d5a3aec4384016c03ebfaf9e40519d177ed59bf441253d0ca7bcae1a11509543585763d3fba00016809ea05eb9b13523e1009c13af53c2c094e4cfae790e500d766e421cc1617657b206a2d0f039446b3cc7da7d084ff8914c321b4729e9837663ebc30e4ea48b6c2dac8fd1bd1d30b5cd692e60b97a48ce5e7ba7a699700aff6c25a2c962af96bb12103384a3405aabc4869aa0d24351ca35194162181c8351951250c1e6bf6256a35b7ee33adcb9b9ee91dbfb5cdfa91b1ee87be1bce80dec5f249b500f81dc009c75e09ddffa666f055ca73143647e9f966419f2ccaf5d1d74df3bbb2de5c8af96200efb836076ce2476e0f8d997190b8ae7960173299f06e639d5d86e8c50da6e1938bd864b3d18607fcca63ac3c5bc7b64f55ff1aed4eae4f4b50223563be4b9bd575ce4fc7239ef1afe3a9d99625fb6555e768a0b5282031ae67f6358ab109f0fe20b7d40d8e4c9257be5ad3e05d16e648b8c7749d95015f2c3a238dfa830391a3ed3fc03456a307ada03a2d7e3a5c2f96d505dca1b9fa29519cb73ac1e905200986678a774a0360381a7d18d768cd9444bcb9177835a9c5b8b9a132f74b3a210daf25f4730e40cc4223495ef8606c77b0609d66c746e10a042e425b7dc4b47d9e999dcb1a7dbea23a89efd60481fee771ce7dc231f965d04f8df205fba151c23f65e864c63e8f0df5fee272a9e9554a370a5664ac4dee3b412ee95a6d6f71873f262ab7adf44a3192de21efd8e87bef7f4e6b0756827832c256451af5a24627073787935aab4bcc129d0fef12982433986c04ac5d9d35bd834496c841232df2b4f7235c260dc1f3beed6602ec48258b2d879ccaa98d95eadc02ac21be957d645bef83958c593bc7d3e86d21e2f81930f4131cc7b8555035262bb74763d7f3328bfbc3f2794ced3440e51b58762389036024013c0047335ac0df54d5e33db3bb8199a21efd48424f95849791c17e3bd5b13696174535ac27dd531da8fb329e9ea7426443e1bc67f6d57ed9deeca0bc0bfaf2f30b08827201f84aea741a146d024be2a9f1ecce5e791ae6021b0c8e7159d7be3cb55b32cda242e656caf9ceb48e309014b95f62f9106bb11f2bebb715ee1f96b8f53a123b16eed15b6201cfb33908ea04bd7ebe24fbec3c3272ca1ed9d8efc7e30ceef8ee0e867fa7422b9df31e68029af1d9ca706f45397dd5473296d341ef0034375c29ca06f9d9bfdd5a7690c63cda972094c9c46b8c0c7ed301dd0f22c4437e4244aa6f00d75330b292b687f6a9aec7c3fdab54cbea35b5de1aa0a177f262d1ecd0417a059653103a8a434674fa26aa4eb74d9cd3c9e9d378d635a3c5cf1658bfb0a456f22994e9fd9e9819d82507fe0a5fd660d2a051d39401e262031f4e6c1314216566e137d1435ddb4a11facb876d00f7aeb69189b670a16f2e451f73e7fc054acb199ddd525b3bd4b2558d6bb5f60fa78e3f8364aef2142b2af6f0fc3a732aa3611725cb79096b0f4be0db7e6582a5767da93bb7ae186190eb9d6e05b5ff36361148d67ecc6c2b787f4c94aa47058e23136fffefe7fc63e0decee62ad8bfa7ca0cc56b0bffc0ce13d44df3f784e6eaf844f1d270c503e65c4b71f2d4a34081a7ed6b1ff3f5903bb67fd5f6c7b4790fa15454cb35f10cd7dcdd6612229bc7d2b222dca250935b7b880644d5d22de1405d7e916ae5fd0dd57ee3889729cc37e6e8a07bf07ef9dae51d96702f26a03ce29cf4359d130714fef905d9aed99446dca487fc2dffb700907e241ffdfe3248965016e244f1a8cb8360d71a4d58c6fa86ca2e675dfe557fab672db3b14effbae812c6b99b9f6c1a1b179ae659e95c2025c6e96e890d2a513454605900629c80bc602c617ec949bffd49143759395055da867609e631f0685d61566ff072eaac4ed262fa765b943b4e0012a81b910ec5e0a89b8d6f83d135df9cac539c7a9038d74f5e59c9d22a607cd4874ce10ad22124f4fc7ee4f27af44ee84aafa081f2feeb2e422d2bdd4164156a66aaf3ff1b50c659a92c5f1bbee7e3cd39e74d555b61ff93095221c63f62ed1a496d565e6686b1d4fa6c6f313abe9cf4fbe12ffacd96c808859889a814c8701f0541d9ee00563dfb4a8a8cecce0ea72fa2df73e3681bcd1c9b395fc77730d1759342852b086415d799d0ec970c76bc55c81dce3c9feabcd61f9881f97eac7a13d96046f060d4e6a2fa9933dacf2adc658c81120fbcf4b73364d01e4dd7f28df59e53f3c27e2b36ae7dae85a038344246d54dc85f95ca028157bf3e421ab1caca7c7d3ef18ae651722269facafab0cd2958e2080a3a0aa1bf3ac9def74bcd23d3c48a61365aae98e2b8ec800f7d63291ca3f64dfa76e263641358199ee0a4dafaa930d1f7f7f93fe85febb6a61790b07e4d590db27cf0ed70efa8e6fdb933c17c2f7dc0f564fe1a6d6d2d5c6a12a012dc099bb13ad940f5ca1f15146f5ce97e3db8ea6aea651702fcece57f51b3220c461d1574d9acd72aa263c46ce61ab783a777cdec1ecbf39e502c281185c6f1538941286a0b749a403d65812e7e86e1f9baa6e33bdd2f6fe28cc12ba0e734efe74db647b38172fec7bf1851f9ab02d71105f3b626d31b2f99ef81cf26215585a1671861ec0b8e3f30c09eb24b8167671863d67c39d161f5ffabc18404c131c02abedc54682ece8d58c270dbf35a346a3c52aadbe0665ef88f2bad5287b6fd0dd0c5ce15e8c1129c68f6063e8874b57fce99caeec2ea539efde1935fdf044f7a499cfbc5520f4af2981223db2fdfe285b662a18829c096da52c908ed1ed5e7e6adb6d2c00d82c52139921f4f452fbe257b152206a6e8d4a4257e4ba29ad5c7a3f8db100fb0ea0292ad4ebd7ad73703a4433868a05536a442cd99d4562f89e62a3b8a9243a236a6e3c51ddab407b0981fbaedeb519083c7d8531fcc20fa32d7dc1b8ec89352667e212a96ae38651ceb80cbb47087e4d08a5ae6fe0dbaad7dddcf3ead915a2d91e963cfa0929da54da1780a573696d9328ff06923ab4d3fca65a9907a00aa5b48134cd1d7322283ddb30b9c53b7ff823284f565089afe2e1f052c32d50e43b418489f705d97ad1d34ca418b39ec2a4ceb3e926c5225c6b4060c8b0c406acda348a9365b93985f656501567a9df8ce287d76c3844797db4c7d76ce59a5d10db6cdc8af14e0c302167145f404745a834bec9519a8c1233320b9a265f93f8362792909f62fdbe627647f8fb76da7c62dbd55b0e5455c0326521f058e8666bc7c6394f9721b00ee9d1bbdeddcb05ee71ac5b5cf59c7bc6dfe721ade86af53e50bf11034b3fe6e465ee9b59bd173df6f31fc44c357dca2e4d12de5b4262233d6f958bdb8d21fe951abea683391a9299a7ef091c4eaeae80b6353eb85e9ceb6ea05698151b58e3bf9c3b215fe5f0b51ce7141a532ccb3b5b775e52d4db3f1bc8ceb1a80540b504dbafdb09f5747912028def145713e1782a712e897dd3f59f43e901f10eaaa47d37b8d82083599ddbedad876961bc172761755b538c2b45d4af7b50882c8892a4f69a452e21c67189a176f8e6939a116403602dc145a7d115708fbb04e8b001cc7edbba86f58ecd713c7f41d63d1d66b7ee5947ec6694bc3cddccb22daef7c1333769cd87b7f57a0dc0467cf914912e3ec9513cc9b374e9ae5df493188dcc32d40d440e8e7c5e2eb4675059cb92396ad97e8e6fce595d18cf1f408440aa3b1cf891da583a4e86de147d6f6e223708a0ae12864206f443126d9109d291da8635b61d26e1c35fc13042b4817cc4486aa8f6e9db6f0649e3712d28e6aa45013acfef8d47ea6adec1b286c0fc5f6df7889bb55592676430580e86386dd2cbb9994d9c1358f9d4eb7b9fe38e34b6c290885922a1359edfa27dfc4bfb41abc0f1b69488f8472ac97385fc04548033c9a21c0d3b30d1b6905a87d2e935a57b25a81bd359fc81b6de9aaa9a3a82b64e132735da6fd22b08419920fe0e42eb2503318bb11db8ca2a451d46c6793484fc6d8fe12988be319a6389e6f46ba1bc1c91cbcb8914dff224b3a0702665a3c6bb4ed7d4a604a07d53b8fc45d5082205b0b6978f3f2430566e753393fea5552652e77a47ef8266cd262a978b5462a3c74c2b9b8523b8856efe12435a5801f19bbb4106aa99d6e0461249c13fdd9db02f68531cc2bb6dc8a2d556c904ff0f5664031df7e529939233402fa6e7816c17bcda374374c7b2474ddb449d27b46a3174c2f40d2d94ca6b2f651a67a42a4b9ca1ba230ea8178897587fefccbd4610efab7c2ba40f4e3081323c83b28eeda9c1e5ede42ad662644b7e5943697e8019853355435b286013aa4f29a15cc846845561f9d459ebff5cff22e539d7a0ebdbd062995e4ea58467e7d451c8b1af6f4ad9e9d9861583abb6a70e136a930444699187b19d916f0fb0bd809bc712a4aa37bd5ead260d8868370b2255d8aa4511c3c4bf9e9157a98be612158b43081961cb19f97d2893f5498e010ec58d9613b800deb0bfef4b032be849b95c49b1e0ae72f322ba6cde84d84a66a6b2a35c7f9f98bfd03f8d986fe6bec9df3c4b2c8921752c76e1d5c5ba5fa0ce62909548ad4288fcb173f1b8015f5e7cbec251a8c3379ca2e5e82fda4b30d835df82561932d6e1e1a8a214897c314f5a436faca3be5ef08d6cf8b687c8c66247d5e034f6b63ebc6b5cd4ca566240d2e9e9a67f40ae8f4817e2dc50896471e36a4e55441d1f359ba20e7ead40888114d25fff71ed2ca13e198f599994b858a0ad1ffa396c6e258da22e8bac5f86387d7ca22f8456810e21a3b25a1f9892ecb2e08f4d24460b2341b29f35fac73a9611b0d1841db2e9819420faeb12e7df7f1ad73c5ba60a2a18158e26e137adbeb9c00465c411d2d7ab50baf80b9d28a6f3932a6f4cbf9d47cb187e3021fb78e2317d188f13bfaa823bd774174b17a83dc4d8a46b9a8792f0e161b4c52789f505c191880d25116e1b2d99ef2c40960d413c8ee7c731b82a4e727fbf581dc2b49e4bc5408939c8b805d93cc659e2fae4a8dd8e85240949c28839132e552c9163b3c15086b46b66c721c37438c4fce0712419989f2bfaa99a60a016903aca744597e55597261ffea917e27fd673b042a0f4329d9a5ccb78a375ddf4cc54c96d25ec8e741f2166d0224c07619e9400e57053c9f052936fb54715b82e87945bd64aac9ba5f70d4f80e1276797eb5cddf299ed07125235ad545e2ed72167fa30ffc2c16db47626c81d0309d8c6b618cfb93b9dceb6e45aa9f5c3e2011a06e3e29040da52a43c81fb871d708c7752074880ac9af2c01cf1cac710950882e0992a659994a4b85b8fc0816d751a6ecb640aa0fcb24e2a67f537c5663d55656e849c8ae1ad230453fcdf9e30901235b57924dda26deba75df13d89b1440c2310ed3cc1e20d85294dd42535bca242219e5cb0f3964d754ee521133db72e689e8452e09b029f54810c5fc268d134d2a1c904b35582e65cc5abbff5f5df1ad3e7436a18818e6fc77ee28079d0f2d3bb40f45e70aab886101077f9b90d1d98be782ba067937e4aed9ce5e6460e2a65edff12ef324da13c9bb1921fa11e4fc45452a21c6163368422d5fce0b0e7126d21af7be536da47c7dc1f99b4ebbb63c6aed4dcb7118ae919c3a8f164ed03a9bd087ffe5fdc25177a3787d0abb3c7c453dd5498a1fa2a225e80fced4d9eab03483b675457163d14e1da86c4d9edf067f3438d077cf54e8dcc91e136cc2816773c11bac915aeee759b7d8dad49810ad0061ab02f5ac2c1e715edc4dd6021defb462915888534ee33e2e6cf9acfac84e3c9403954895f9a1712b0f41539d8786f9698e934fed66bbd2c2af194495982dc78c971c295c450c27bf769108e7490cb234871d9164a16cdcb9bd7dd5c7cc7bf084f84721f2f6db2bc493d25c9921cfcea2ae8a4a25c835f6ba17d1689a87611ea15f1ed58f9a9e876e557d7ca81b24f19596b45cb6738a96c78da6c566f3b889ce1181afbfae8820a27da7a2eaab2bc5985506645b38d254e6dfbb7c3d43998f2c1cc6541da41f627804c7cb9f0e167d5fbb5fe55a8857799fb7e56e50ef9ace388d4cff1cae690e03bd0f5a1beec764c16b33c2b6d845076371549301d36e93e70c424130c03ec9fc821d1a2c67d55b65bd71877323dd49251c439b213ee723957ea1ef0f78570e14d20c8a0ec2ac2b4a2d9f0f26f4b5518130b66811bd1533ce19694f373b5479e37e921d161847daeee230a64ff918700d944a85b74811525205aa886e5e668eab292eb469c35f9ee780d833a7e4658424c8036ad3c9fd06ad00dd8c4d26720f0c6b01fa878d26064ef7510e3fb37656c5bacc67d5b4ae336a3594fcaecb517d20791783bd088e50c623978ebd6182c61af7c0ede9ff312abd95df92c40be910c65b88be51786a97e92605ee2d25b0fc5f4915551515eadb1f2721c701f8fd1bbceb70352ae22c30b59d6977637b8f9f25a4e55f58f1be74b784577bffe98832d2dcd36fbe19182c4329878550623c3bf149f0209000c93f30a603b44708619a30a6e4cbc6b8f476f4339f533a45ceadc798664884e80c59bcdada4722b751dc5bddd908890a4148c2c869edd0d1620740ec09a85d8e8507832d9ac9c1b4c10b7bb8782e31a37d35dbeba24c6d83a266635b83bc18004d907695d6ff827d2a05535587550f98455edce46dea646626fd87218106aee5332d35469c34ae6620179e94eb657f1253f27d23ec5551d5aa7a95185ab530b5034e474bf0ba0f635481734347fc1876cbf4040a249c4eac8523df65b2c75a909177af0060544ebcfb6f75a956951613fbc1315646ea4a5ebad96f09bdc0dbd2c3d7d444ffa5c5d3eedd9e062bdf2522195f3b7be477df210544cccdd2fa964e310d6f6d3d2f9b699e2ad7ce58d55619194cb10b534d4b6c019a90b136279a736811756fa54b4da699a246d0d5514b512b5c2f88b8c083202bebad1606c7beab7f9844b3ff0228e2fc9ff1d652b5bb85caecef9bd03c313c1c39d9d0a83312210b4006464896c2abeab124453c8022f4ad4d7a280c173fab93cf77c3c10859b84dd521bb8fa88c3d5df52b89738b9a015a07966161201b21ad50bb048de62b1c497c6b878dcf61f2434cc24babbd024763812cfb34cbdb69abe1b1b5e73d97823adb74eb23e1757f001bf76c33f513e705cec0b62086f8f1ff7110f000a353800ee1eac8cff13653663a8dad05bffd8e4bf990dc8ab86ca5ad20f8b39500485b405b78ece189e2d4c00bb74262c54b0fd431c136c674afe5c18aa51eca489379ec71ad9416b7cc7f7334735056f53fd664cf64c653d3b349abc8a75750107653fd76475c48b692808633f00a71e1ee33ed25911161ecc611db2471258cbc2aab983df797471f6fd85044342ef9eb6fd7f5f32984579491f15db0fe79b37399f96558a88ad04c2cfeb7d1b5721b8c6166c0d319afb082d49e6d64ff1336f339f220e4bd091010705c5ad3584e08472662933764d7c0b6d457b531f2dab2cdb8189afd35151f1c8a7b853af49372c5bae7aa90d176e03bd3975ab47141dbd61690b44a6e7223b5831bb8065717912296ea24541a493a79c548e3e0285a45c157133510f8c6925b7e62250a8bc12d9a0e2bcfef03ef24df43ba5af7613a6dd9f1ae439dcab9620324db5722e9deb3b944bbaf77ba424976b70f520bb65b69228e8afe65b95c63f9735f3f42073dfa23cfc06eb3dfa8f2abc0f476517d347f846f70155eecc507b4de608f8f32ac5ca00761d6637c44e8202ebbd933bdc40bfed3eb93b9db5199823e8c340a3486d62530f7cb3ab6589cc74fcccd42a0af6ae1b7c41da8de2e78b559adcc8b6bbe788f04c2f0121409c433c4d143bba0f5bfa97cd2d6be18322d7e57a8008afdda2077d8da2a180c5a2ef1ddd16b9fd1fa7d54663fe3857ba1c62902d41a025eaf309cbcac6c2f87bdca8f6870133ccd47395e4fe0a431f431ffc40b2a43b9da0e02f3884a0c0369215f1692c0c7bc2c3b7390d51b0011dc5aba26c604cb74b8a26d1e228420c9cef1a1714b87a9e7d7930dd99d84f3620cfe647a38f2601c87e3b7a3b4e2be177bea1b3fa82c71b93e0a1111885812be426407a0234fcc9f1781157202aa95222abc4f723404870af71bfc6daeab87ab41313e50679747348c7e51157496bd47339e12c52b969bc730610525693486242ef19a9dca7a94b2f1b4ab4dbaf78907d050981b98a94e196303a7602845304eb0c28b8341c6dddf39484a0c83d297a9d539af7da9725b3e46d7459f871463fa886ebd2437517a53958d4eaacb20117118dd905002c95620af0dbda5ce24d3af1a47c61c0960b0b46d907cacfe027f6647fdab13585a487ed8e6d160c2ca5235e980f802e573bfc71e368fbb00836755e45b984d7fa68ffcc9b4ebc98eaf3514639eee74a17f7d43c6917a7376abf0009614a1fba8455703906cffab201d6f12d283393fb4f106deb77df92f6e001af13c4900fcdbf2308b4290aa05c23264f93ec26d9c741383ccd7acd7ab595185d0be916500bef6e1dd0a6e06cfc18c6834a16f9482fb93bc5be61df28d70850949fb18e75c9588b3b8af5c59ecc69f78ca0ccb367b82e8b6b24d68a1971ca189ccd57ebdb88fc892ffd9d85240b1c0bdbe9ca6ffd0b559fc6fbb1e7892ad073758682d5c7fdb7a9eacb78588df321615045109b9649d0ac0bfd5d0c948483873ef4901a63d47e11cc17c7efc2f0fb40aca86862dec02e94a7c109e21dc9ce001f68b37dfad185af75301224da1a7b29997c4da11f2450e37c322014c27a647c10e634bb0abefcf69172a1b41a4e91719d9e45718190f65a1dc3c899ad9b29e2ed98a00be938a2ee4b19f91f8c604096e807420b7a85870f6c4a75f55d700fd5de7e538f701c9eb62bbe3a44fc7d55a0fbf381e18e00dfafa96d3f21620b4f98526a5f1f754a5315e57477659a67d3de58de7c5f974a1202546d8c5d1049e42239d9f79402eb4a515572d2a42bfb709e7522aca6089df9e0b7d763896a973b233f1fc970b6b243b6d29f308a3bf120f3755d094269b8c53ce6ae2a7aea63a887b043f4d3492f7a51e88d27cefd4c2916aa78f4be6ff0abb9d13e0b142ef84aa4bd50bd95219af4cfe90622d60dd330409d10fa3a64ceb06f4662f255c97266d7713e89535e873006ab552209f787f2df6590a0303da1b6126070f782ab6dbce6ed311a90ebeaf5c8542b477ac1697e75a1e172480178271100a420e6d0ff64459640fa65e7b529254b5cca35b9bac951a077dcaa1e83d189053079be2c6be4372016d0afb024d2f4ec2c6c7bd79b1f92aaf8bf5976b2581dadc2dbd51ef2274e8a3d3a66de0b63b664b32773d8c685c8c1fa2367a033fcfad66ffd462232b031b6d7fccc44e94406245158cd1ccf5e2a128906136c90977032b067279d2b5340b533bd92e6aca20d83b87ef08776a9323bcdf44981d1c60b6f82e246c11f23249d6235720df7aaf885b279c3305a39abae4f6c7c7ce8c6b97cd1f00552b9e0e7fad1eb9a2d3eaf1c47419601119841245d690eea9d179c8ae15593f6cd79867fa8b8110e2fe953388eb2acc7784930db284d27f328196013f69172bf90aa47f2f2434d64a4915a4110fb78d6f24c6896dce62efc3b2c45b6daec9454da1ec9e008cf98bec9725364cf3225684bf45e9cbd6a80f8394ae9fe85c4bb795dd1b876825cf30423bd7dfa857cb8bcdcffd638c5c6479c0b123851b4b20d62fed40fe99ed1402337483cae7c708046a6672128f1dd44b851cae05fa6711529a53fad65d8747f9b931acc97729c3a67a2c8306101ef3af0b27867ec76b974e1f01d92df1e4a66e66715312d8f7d30671ba644390e0f6b255092c75bb9c7d0dbfaabeecf8fbc22b32486f619ffa1d68704566d57f82624d9462e0504c6c19f7f0dad3552978febbb6a826f468892631495334b4ab92e75846603227ea1c49f4b531dff7753042a0b6fc8e5689833384a2a851fe8699c5db342c88af66760a63758bf03144be3dd0e186b6ba064c8401ace53cd9fb0cbdefbd81cb8f7afa79a5dad8f54dc56aceeb4174d820b6fa7dab821db68a17b1908d50ee97e50479055f6a8858f395a709c426ff17167d15d3b21fd4a9be7cb47c0ed64e30286d6065646efc64d22bd4e3dbdb67584637c52cb3f1764226e4e7f673060cb8281120f4654b8f9e7215f922ed80418a26531c03baa0d62200b1ee6e04f3f61534c78363f92494e0bca7060e1bf5cb658365f8b4310ed1ee123c3303c2dd174a6c672d8d01d476b77957c7b2752dbfaeef98aab555c503c0b2eb045298b40a5c337605ee5d1a9a55098f918b27ab0a62b588b0cff03c0661521731dd01c5fae0dd0912d57e14d990ce7615374dbf61f4094d30fc38f91add2edd8d94159e6e4a65aa6263f7b2cc5b60f8914d5bff1a1039b904ae3ecccb004263cbc70b1fa28511fccb6a175557c4e76b533316a083e41ed3eb2d65c057a0ae8f6e381665d5e7770b7b32e596457fa9bd0bec42d63dff25163a54bc5392cc2dd2ba459625301bc71698ef55bc87ef30f7d7f7fe6d51be7142a67da14df423a624803f32b7abf3da1065fbb38f5db917067fe448556f0e0769aa73f98662e0986be3d483db37f887d7f2f8176adc9006dff3f48b2919e5b46b7d36f96b4aa276524ccb5f660ae2ef11bf7b1ef297def7c2ddd34a07e533d3ddfd43782b24a6c736902f557903f260ea864c1a98678d749b0469bd6da19543ed51572b09940ae261c6f1334d803feb20d232c7149ce42055d2b21851103794b06c32558d9e720862195e8524a29a18d4c17ef76e2c440320f4945e18417bb5c48b3aedd16f3502ef1676ab682c642302792f38eacbd7ecc3abbf6814d08f6a88d205b80160ef8b72715af941a14728b731a740016e5849acca8e15ebd007717d20150942b276d64f866f09465d64d7b8a95104c13d370719f20e527abda66fd742e30761f8bc878abfd465cb62e91ad8e26000cca440ec4fceeef7a222bd5856c376fe1720adfaf239d3876bbe3b5f36bd26b761f1e5253f1af023164414a6f9f78d9f6301dad195126786ba8191c939b20ce8eb4a5f70547fa881b6a198d52c49d6ec97c636cfc593716104bf0c4f0df576f80f12ec41599eac8620bdace20dc76efaee412f8163190120726306ddecb143d14c69da22ff785c273482e01996a13917aafdbb3eaa8cf6088e91501368a2f7bf4767caa659d76e9e7a7156ee1459dfa50efa4099dcd563c82d6863cfa46f0c4215918192866f7859af481003cd5a1f49330143bbdaecdd0de84b291acc77e432058f4ad92c486624d04fec9a9b399dabd40cdfdcab4ddd667d77d75b7db395a6c486960caa674ade8eb2b82f8313775b73164611cef2c6bbd81450fa6be1ba06e6aea5bb26e70521512437389d3dd61ee0205909252115bb3401a55b5812fd71b4b77e2d3dfd76f08955860d43402085366a3d90bec62aeb4a2b3c7664dd0c8c9373b99e908beeef5bfbe28e7f42104d5099d7875221766fdbfbf9c0ce722ef790082b27408f95ecf35564dd4a0d4397d32aa093cc658c737c6ed3297e021d89990aa0a3c6a870bcd77f19f9673c541c96be6b3f3784b2ad8a3621be04cdb1c5a5adbd90bf3e9d7b33fcc06adb865124a5091842e7f8a1b9b7894a9c5a11fb13419418e96f938464f978c42ec35f6834b95fefdece2faecc56cfca4fe963e92849fe17bbe4f1ded027bb930c2da495608052e1bcef72c5e322e2838219af303a93b82dbca0beb212ebb7ae2d02641e4480428b3dec8ace186170fe9ba000b00ce375fbffbdca69ab5318af57b87fdcc1f2ab8200b9cc934607d59cca0050261366410dc8785a88513b21f8bfc3b7f5efc6e4172192761e81e883d6eb92213035d8e1b07daaae247ebf753f22335eaffcc141307a7c295ecd74db96b7921ab3341ff7b021e7624028252f601e63cc2c5a0f7c21e9c12b69cebfaab73fa9bb40a94abaf243cae98208e8c80640c73d9cbb86b9839f2207d9ef048814b71c852abd46c507a7df56b397d27b923f035c100fb28855ed9788908f6f14d84f7223e887325d601c01ac43d1b3489dcacfea9fc716d9dddbb5fdf67a7776d98305574983fe12f2c036f71714fe41adf947d08e737bc942a15c16c76461a4cc0eb15b919bacdf280d66dabdd445174192e7efc439de099158f6c7b027f0799ec317908452f14370a737f18beadf1b4712c8a25372aea355d92bc5999be058f993f44bb37dc365384bf1448ec843c540e636ca80e06518987840eb77d0f5821442cb47f0dafae51fe47c7f81fb48fc57ca5cc17952305d589ca1d22621d99bb24c0a1b51688e154a8e487e37636a1ec82a4390c7d00bbf5dcc87efe6448d6e40260a758631350e3549785c61d197eee7eb64f52d5b3d5c453cedbc20fdeeb0540733638acf1b15595f6f807b80c2223b618f2ef40635b6ba63eca5ce8e196a66e3b8edecb352689449ec416ef17fe478d74cc2f29dd55dd20fe49c81102d7007f37c538af930ce3fdaaa7fa185769c4c376d557ee7e64eb6ac83c959243607c30942a8093dce33f9616e35950f4ed2fb150c6187a6d4a925cb70e2af2462be508ad165ce4f2b1359de8194cd8c475cadca7e17e2756bc9d8299f4ac0134bf81bebdd914718b0aac362b3fb85ec56deefca1a9c3a1255709b4b3e3cc07e3e78bc3d984d8de1aa015ebb58225bb758d231ce310b1e1a515f120707fcd9e0c07bd277dc76107a5e5a918edca3b63498c7fe9e971640300b73b7db05bb36784ea6fadfdeda12edc6ca69da419110d8498c19b4179d693877be4a05daf5a36a708f11eb0ba66feb868eed9749c7927a01732bf75cf6d4f9b90a8c674a0d9e0719db5c4c0dc2dee70e5e3c1397877e1044b14e684d872869d7cc7e04e16f48ff2e21ce4c868724b78ec3557bc12f07576aaf9bf6848b494f2a7e5517ad55f1b5b08590cc74cfb88b6ae0e9a0484f83b27c93cfd4a198787c275c522e20d83906f6c90513ac20b066dbb6665e0e64bb492e5e699e7dca0dfff5174f7c777b2f5504184e4204c087012b4c84642195bf600cfb4e3652ac7d3c9e924761b15a3047bd04f6c7153da7957acd5a6d88c982ef216d9d0d3f3bfd8b2d222a15b7dfde66d3106827dbe065fd2fb6b307a02c9161666be7662c1f6233998c597deccea3eb5fc28ab1b520f23e2fae2ce8a82fe056fc8c508e11bae9cfe35986a766cebd212a57876fa6bb2adc5ef721e9c89cbc8ac676d4ef9c94069c5289b7b1b5cd1ee55ae5f0dbc515e7543ff789f4e0d56dc74ad36b5065b12917e8b31deec4be2a710a85fad9175bfafb8b1cfdbb297e916783d0b3ce3c5cfba42b1445ec5453f81ea5a552c7856affba92b973bef23c6d75d747c58ea2176023cf1ab0d5b1c5b23a4453006c5a73bbf3977a10e48d4489e6f6ebcf9f5d016bb0b0d60836916b6a96701ec28addc8770e867a54a70498942976e3696df4dde927d7de494dc0569722e9e5e099fab7dc22aac07eebb7e016c02a726de438fca999bb08481e1aee442ab96da698b70fd281c58c2348c9ed2a450cf877f69d7b110cd95f924ea45a594058d375f1bda918fc55fd90a3616f7b3b3e0d6c1a678cb706212adeecafb79f296f67d95e224c676c010c370df2071fdda43841c525af52c239dd10d2387ac949ded2a86e8726010c1f3fc50dffe76843ab02dfdbb12098552f97bd0b27d5950432a580e8400c81c31f705aba89b9a1cfd93cbce7887a8f3d5c09d6615713011d853f1e4b6c77e005d5733dcce93dcd5315f279f0d2445d6f4f1fdd73aa2c22ab5c1298191d8c2dde6a312059bf8344668715d746e9bf4efcd0202386fe1cd60fd7b7c529d06ce9d9f788ccab631958164beee2765b1f03ccd4b5ddf77a18fa5303994ea500b2b641078e0ce59f44f8136669e9408619b9b16340eb3601541b9c99d8cea985b00fd5ebc4ac799959d64592a24e09fdd56c0e38efc265277286715b1386efca2fa6cdf97a0a2dc822ec6d2307f727de493d28afc49b38ac75925d74811462724a2e2c34cda920b5ac193d1e67a119b9d391464cb8c196827a43a85ee5881f69624be72be436d6c6cf9ea17319662141f1ebabc3377984b03f9d0084de4f284697c7fa7a6a1f390831c242b130b1c59f9bd32c211ac260d20a97b98cb11fe1f24aa9d2753a946a6f4f5e3e3c3ec66db0700e9e8ad141167130623a15f2cee299e4dd8a639d990c1e26e4a057300ee16c98583c5d782d28bb22bdbc5f8808fc14a86f681598072584e6bac1169b3bd301e8c59202634bf6441e64572025c877955ddb6052b57e3fdf9cc32b58ee93f58d90960bf34e9c229b30a0dd90c363bc099d3513b7a8e637028132f525b54a6cddd9f775e3b80f295ae44fcbd859395237da14b844d559de5b3bf5d9d7b65db5fee6b96f199e669ed8a6c193cc43f183b9313fa419b81c96a372173a0c0e241a7a50345adb4c81035fe3e14bcc5bdf29b75ba7c30b042d86fd496a8f0c8b402ea915d7f8b575645c88952301fdc3afefaab90574505cfa8f7b971c05230d49aa6279d7843753be23da705b69930c2a352345209ab75c10b094b5543e37fbd99838f7108cfbedfd1760c053bad98fcf939a267faa0a7ad2fcd03d7b6edbf164b13072221dd132689b27ab28b42549e51cb510a24e99226915ec1c53e9fb65b94b9b159c7e5cddb623e0614d576960625884ec76b63d1b49c0a3b8d1567da59ad5757432f57840720cbade18e3feac5a2b73f0b5570052ae3919251ada8470a0a8d90fa9c2cc7bd322408e8c318ea9ea110e9b64921fd73c5ddd32abed6df0dd5e3701574852790abe08bf703d3fb8923f5a66a6c69e424466d7e29e0e1c926d891c60ef4ab214f7735bcfa9f310d5c71d3fcee79ae34790c929fabaa0cab8834d3e8ac4def4e61af2c7d50173341648b151367048b24e2ef8e68d747e926f5610638678226a42273decea62ee588f744bb6319e5bcd996a2edf97002de2c41e84dcfbd10bd2550e91df265e522793cf99a154266c0b5a3e95f7a1ccbd8ccf8df8bf2728a62ac2894ebc228181e01669abee67d235146980c7dc2666c5922e2158f59a600ae141c1b94d858c62cfdf12e685ebda0fd17c7233729b1e1d2bab5e48652a49947bfaee93ddd62494501c4fcfd0aea0b5ee01287ca02a05cd84d07720da3631dd023851365cfcd563582325b1896b31d84fc3f9a57bd62a39fb58c415cd5e6add7d2b994d49239a0fc3e8e5f8eb79b2aaf6fc9ef840e96f42f52fe332782996792970c1829a8776ad3105b1ab18bd31606c467aa4c7c9cdfeac2dc18d11bbb214b3d076d54b59dd723765e992aed3062f090c90c8d26a1477d42d566bf7e796eb72267961fb01e9c59e22869cbb9b2573feb93cc66b1d6676a4fdb004c67f3b9880c5ba2a80f7a13b1d34198dab6a634f40d7f6d5a0311eb27e737d39266727fd5edeed160fc5137776638d81654960d4f806d820aaae36a3c54e432280a5922bd84c188535c385734914f191b192ef77868d8ec31495da8177f338160d068bb741325a10c270239d6b42bf63ae75be0eae2ad0c82d1093231e509dcb52fc45950184fd5e55ab621e8a380e6976f27c626b56dcf5f05f75eff168367e13195ecd9b7cfcc89e605d099c0f1b453a817586ec119a238c5edccc6f2731ca8a242b56d34dee09f88662818e124ce675b95dac49b039ca0593a409113f99461c8512a6655ce471fddb62d2417018d008ff01758f8b8cfc32a78ca7d40fa164d8b4d7af3442b5105bcf073dabaab364989a3117577027a6abfc01fa8f198dd0c22b28764c372c2ba5c155a5397eab4afe829a894a21527409ce3694092f29704588e25f4d6194ae26326740a163970da0a7f1e6b46d683ee2991657ddca83e85678dc16ea3fa49e9ea6ae4ed9dcb2c6eb38e59f78671fc6aed94979083c69820f55e9db3368e91db0ca8c9aa378ce7d22e7571ab1d20c78be539447f8f82311dfe110709fc5e2a0ff7ea0753ba6e865a949b08320052e326ea760e46727987d53a40e2d4b69449861091e5fd86a47c6f24dd43eeffcf5f191fbe4b09bbc9967e0e67de06e26acd630a6867a4384872c7348ba944397de4cd789804e479912f6152ad1b2e47343e2aa562674b1217871249f0389090d60ead572298f854f66570c70514df59ce21e3080bfbfff420bfddfb6cd0195274112031023cfa06a3963a0afa15cfaf2f7e24b4438f3c67e05f006d471508fcd952dee8e75e648114539c312aec4f535ddd1604d4f248859bc2b364379b8ed960e896aea55ccdf59c07bcba42f3f2b974b8f8a9412ceb3524c705cad626f9f616b906beaca95998e286c17528cad7800238adf37ebb48cbb884a632c8a749194c8229cd6d897f65fe86df2e2ad901c70400b5c9d43f8fc922b6afa10607402bc3318065b1fb6f8c811f1587f2224d4af03715ac57081f7bcdfce938a15deb3877bbb2d63f834ca5b49d9203906874122a8297111eb5d7a0430390a72072cdd81bd2e00f79cf3ff69154f6769d819ffb506fe0cb0d7815c6f4fc25ff5e79e4ca53f11351146810fe7fe2ca7dba55a0319edee6b067d1140c895cd1a0c9eac6e0e8c19a317b6607143abe11d14ade6d036a5bc765dac3900dcf204366373b6050a754873cb27fadb368f0b80860d6b6894298d9b8d8436b9b5439c9c2c1d4a51a73c84c2abe4306b5174749e1fd1f41abff3671a0f5921173b3f886d8bbf04f483ec0e4c7c15a5b83520a8fbc2a45529cb81d36eef919495d4e0804452140f92f9133719cb65749fd04d8a1461f335633754ab5558816db6b68e04a982dd54332300b57ecb196d7ff06d7b50061b626cf4e165bb35f5e64e419c611027e5edd56ca0dc961e84a63f209dada7bb0f0841e83bd4576e5c3e11e71a0b148251ade43943c2ce28f406268334fa5756eb02e36b6a9ca6205eb1cfb3bb5199a2ed4e17efb2bdb120416e4eb0fa6baeccb4e4b51a3c4ce56842a8a3a77f9390a5efa627e4797b8613c80f8e9e9cae0dc290051b8ad04cb12bcef111b725420f853bb231c311095426b4f1b70b4d085464816b518eb7cc07f30875914cdc7ccd361e489c643bd6dbbd4ffcc664d38a40f6031c29c2d47d3e6099aa3a587b1d46adb12a2788b0a66221fc0990d929e40f508227d75d622f2708328fb427f32f8c4245cc136b7402253b99adf1783df464463936e7d810ad9bf476823d72c11a29aa2febad55e6212e3f95d428ffb3fe239c5a0107ae506673ec49aa7ec37d15a076c73a98e1c59489d2a4c34de21234192c932146ec86750d42b3da17858f55f9d039529a74f57ec5ef28a53fb2580dd7412afceaaef1589be3ac9c09d4ca3100812947ee3668c595ad55ec9eec54dcb53ce28388ee1a954e596e409bde99e3182a0395c9319ebae4ca3487220e8e00bf7fc46196a6f5c5ecc291bfe795a3f8fc3e5ef0d6770c5ae8bffc481750a8bb9fac6a6c360aadc9209ee9ffb6c2ed27d97dd0b490fcf229c229c1eeb21ef7d42d549477f53091abcb377393d5909f5a65c565dd01901de93bb4200e6e8bef95f525373fd8f5cc4084f914fd790a23e93ed48d91408488ebd33912ef1150ddd9237653d2f8358c9d39167c0589e3d18e9ef17214d2e478ff8f15d730913eeade55b14a70775cbd411a95bdf24234acd2a7390eb9843b94eb99f0d7904ebcc8d21f6c3be9381d946f42e30a88b9fb88f470bae41866ff78af1e7e04ab3c851614cb64cce7c1e933e3d089139a34cf1528f4887a5a7b6c604e42f9b137c50d8bf704ee46d673f00a7293017eef639c2e908abccd853293311ff11c37c6b65376197","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
