<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"e01fecd55f57d917394ebfc9b487d732c8fb2e59df17f981408f4c3320858e2a10e627e6f4776fd8aeab27d89db878d404c9b9d2a84c63d447f3f5238fe9fd98d8d29c49105805f254da087616ba7512457d4d35709ffdb231820de246b8e532547edeb6837afd633a3e8a125abaa16c193545c6197110224cf2a18bf42d70cfcd5e53cbb5dfacea495bb18386b953b00a6a09e800e8b42609dcd28ccf75b2a2ecf77bfa55df00d7faf91e1eb56e2f124d2c4c2131189bdb1d25b9f3e0b77e0c86606d6bf8c1673e5f1313f59c06d1a68b99f4f2108b9ba5b2fbe1b7dd7c6dd0a1cbdb171d0e6754d57632a2e3f4ed6d369e75d873d7978120aaf7bee5c1d32a01a6064ac52f0da45359a383c54f038d619738f0e1b16b56249a37243662afaf98e4099c454bb18a684f7e1150aa89c4e745403f7d511b31e80fb72d661c791e5214abdc61f3ad7f6e513871f4c50348e903dd913f1847765cce11689b05a0642b99ae25f9af2b73dda2cf3948cabe45f00f966f4d7540b13033cd8978626b50b3aa13ee7ef1d2fc25c4fcd98294c6baebc8993dd306a1d7d75b445c807c9609a50e38d7b97cf63733e12f8120be489b891c1f80aa30fd3d5157aee461c9887964560182c925b6d400fe16174876b8e8e8f11a47bb3676ea144f9e44952accc4e4572b07ffd6306fabb1cae7461d0dda3cca497fb527578460a5b2cd0dbf4eae9fd95c279b103b7a450185122a1fa443c43998be032d0d7bdd566c4f9124a7ae0836edd6f2a2c907ac40dbc4a5ef47673211513f45515264772feb8f8f091c59564f1ec075904e58cca7bd493985d17bb8acbb735329637a3217758fdc874c15a8794027eb77385cec9d56db8cf780a76025426379ce0857cfb55814fb58c94d0391fbf86c619b6a7ff18543cc0631aa05b0224fb9e16e60c948299c7d8b682fa9211cab3eb450314142f55e5aa68053ae66ff1c095d00def693e678976eaabc17c0dc6f75295eaa392f89c787aaec67e283cfc3342ae83c7887839ed7a70d82b8c80795afe36e4fdc426dc3e61c138e86658b410093ff7461e624e28d8c7c618f7beb0a6fd69f0d3ed980e03921ec2322d25b2633a51fcee862b4912fb15ebdb3b2adc737c1cf8a241fc4697bc8e03ca8eeb214c9566b759a2ce9e68caf763494379fb12644719766b30e9ab03d162e7948787f0303cd6ddbf2f0ea04ff46a2f97a0635bf6167c4b96563bc2e6ae11c47e6fad91a6312a462c47de57a9f3471a7ce30c199a375affef08f94b47934479bbffe1f1d39e616c29c3666afa18f4305b6f052c8c4722f6835a037fbb62d3e92d0b4dc53cba6fe364073abb044c8ba4e7023062e8c0e4d4d0721d48f2ef0f07961a7f2de59d4f4ef867551a733bdea641b51e615c56fe1276325ca71faad532f92e44cd79075d42e802e427962354f1758826aa4d6b1c72fb23f6aa5263601fc17dcf3a825f9dc239a069c2d01ac294e7b3d9acaeb6f03e3d569b02ee6b5f27138dc37da7dd725e87548f4e7810f33c24192bdea97be32f88384fb4870e0e95cc2786258fd911b6d6cef3e0312b1364a1929b8291faff652dba8701d709647090a7accc101f4177d8f7e62be1f115196a0e19bbb91b0f6b80f144aabd1c708b55a18acbb85fb1e32ad4a0695851267c73eabfa608fc0b325f745ede0341c3de76baa47f62ce961e42becc4767f2dae85247d2de1f75aebed883fd9dfd4fbbfb069b42ad7974f4d88995ac8390d36560e0bb89c762da919e234e1bd404d0688da62ee2b382468fc9abcb8bddb87a63a5b622890c970098804113ec2e95c4c15b0600fe697126af649dd64cff7d07a5e605496fd91051aa0e81ed1cf5d191e02e6f45f4053319f39baa498bdb088ad6ecdff47c9d7908cd3c4b4130a211fa02554d0106b6dc63d1b90af143bd01ccbe13ce0e39ff1185194f5b3cded5b60618e541e22933ff8d0f5d5a8c1c1d1e1ea623316bf5447d7e2d3707182565921cc11515cd2a69255792a145fdfa16c56fbe9fafce16d1288082643216573959cd2789f914fa838c5558c48794d141033aa4ab77f85778c284a4b740a8b6c8a782e752d8889fd316c2829fc6ca7aa15db89adfa0775116a02c04e250744764436d2c5c2b49ee01e0428d90a51b3d4969ab97e4de8b8ad329c6fd90bd5fe6e297a6e68875f42e3065555a5133d2d0e766d8ba72f46eb14fb7eeb1cd96c568788724120a26c812e9f92db12357ffc1414af0e551d215d54bbaca374cb02e01e012ff7b4a78a067008bb385baad81ff01c1501d1fa26bba24a45eb7ceaea4d1ee70da86ef587f239bd138e83f1074ecfd529bdd170ed40c84f343fdca587bf204e5beaca42b81b22531c3a468170eb9ecbdef7e441bc45ed4cde4677b93a3521007b0947899c86c6ad556b84fe4f238179ba976c2edc7c4494fe86a2821494f9cd99689f79cde4257773cf32bd57ab5fb26be0b7dd03952e21e479a2fc52a8b885cd1c8edb4287bcc673436036edcfbf330f16890c6eca97ad17e2e021f8d6465169958e7d1603d1538cb45a0b26927ff26942f61511efe2906e85218bd74d0488774746c73e71d1d8c4e3f1131f0cf39e723806698585fece5153b5a82ff95dc66036bad916938340a6c5aac7e79043101fbddcaaebeb7586521bc7cb98e4a2c09c4839db03252ca0929a0acfd4456e4aeb45fed181d553006b886c56a4e21233a96a9443b6b33be546fc16cc04cb23aa400531828994bb644e0bfdcc8734e5b3efdf0d330d02790f7bbe983a68a96bb771a7078edb1e395919cccbf45bb9986b9e4db01dc796c5281c1184245e9c9a62400fab414f1da25a835fb8c97c0197d37be2b47eebc9bd0e03ccd777223b1682acf968ffdd623f34c5d24c8fece06b2f6e905c96ef88eee08c5b181123c1ab259de90319321b94b966345a51054d6f98e3ef300af7db6b9cce6d99a69cb02b1c4ef580e808eff46fa324c393391010ffb7f92294becd80816e3ac8fce1966fb6c0757f1c0bc9a2aa545645126ce316353dc38d0f80d577d11c3ea2f2b073fab32b6dcb4ddf3a36818bc8497b52ff63cb1b2e33b0cd3488d9fe06ab2e7ba414d9ffe3a705e4a399ac8439526c1c4c901e06f039268c971f61f255298912f168e5112bec6038c5545861357da9a16ffd5c5a0dcafbae4dd71eec17660c9cd33365faf3b20d28d4e3356882e5e0a09c1c19f777f45348de2cecfcfc1c7c9588b62e4919062427bcda45d600ee7df0147e148fe601cfd92d47c2382ef94db9d1cfecb4bf74eba59491b9f7caa30948c254ecd0893e763a2ec0720b1dcc9ff700a06971091cc90af7111eb1524d0681bcad1afcc9c91ef8af921fd423351248a3d6751f96714884901fd3dc30104a512686c4951ee8bf33e8b758ffaf143d2ddeddaaacf3d6f5a9e70fdad95c40275c032c371ecd54f33a600dfa877026d668ff6769efa6597ceab082c27615e51f56fd05a6db5f368acf237d4e1905c1293219573574ea0a94313c7a9b246b42e484ac7b1d3c20a90d27f77d2965b3d8b25955876f4bc3a5bf357e371d2bca6cd6292bf9bfc6679ab25a222374f2df6d5120391cebbd0d59546acfdadbf2193186b38d9e1c72df4e6407422c50014aea528fc757c3e92c53e3b23801a73152f00bdca4d5ca1fcd3888f5764de59f81c54952e9f2107bff8c170d35517227ee35f14a1f6ab06b98e0008d0a7e69badf3784acbec4bde9cddec596a4573da30633469d61c375638bafa6ed0c8a366b89d3210821f17b2c653e5a0d119e0b4e08793790e96f49f064b6b1c7019fe7bc09db45d41743eb9d7b0852f7ee072dfb075f099043f18015d4e5f532658e0d63aea1728614e91abff4307e454c6c6fc918c56db77470ff93c08e782a9a31cd66ddb7627b7eff787307c6edaff5b37e020da451e59045767d8a519806a06d888affea767e74616f657af678e2d9902b00862866c1471b513aca99e7e9ee7f3ebd6df16819db008d4f9eb79bee14a8a12a448df8710719b7f692c6f31e2b1a322d2528741d83b0028af1e89517ab9302c134d348bdf62037872e47b3a785920535e1c3afff722a6f6fa582d4bdfa3513444502cef3e713df0b67b480091dad2f7f4ca952706b103781231d14640217f73597dcc0885e115bb56b8bfdc5048b7ab8b97ece145065718d26e4a328ed734293c7dd0a7ac87c778cd05f1ae953dc355bb0fe377105143af151585a7777264b806143eaef3fc1d51d3f5539e6d61d2dd18a0e34d486a33ee327b4f55d8e04685c560f338b0400dbdd1f5fdec7ae31f8bae41375a8af80c22e2a9ed0105ba6dc96f5f1e55a9f6e8564823e53b9adc8de26c4a3fd35cef9ed82116ffe0bd78911802bfd1209eeb08eba81df23f019828bbe0569b94bfd6a5b59fad1243a4a0c93fdcb974bcf342463dd198c01d97296a3bf0af1534bfbf9b455afa0c783aba0aa96a09bedf06668e57ddfdeea2f39fbf66082f0af348fc26138a0d7e1f9122a2073155b50ca0ba6baa20bfc4033126957325e31813182dd514208e6e57628f4241014cb686b9d5203ab208e7b3a76ed527e3ca9d90fee6f2489564be79d51274302abc531716b43d0887c04e48e449e9587a102beae0523a62a8cd07da1dcccb9f8d6cea969d74675d2782306dcd58fc92f7a85ee4fb657fe4105f7cdf8e72d491820a06e07d6e49e92c625cc6f88f8818856931a824f1d0bca6262094ff1a12bb592ecc11d63f0e48626814cc350580db1f9ea63d35bc8da11785699337d238dabd1e259747f8ff29ded6995a335676b701d4f1416beefd47506bcb4dfc6d49394402c0390a28ac1db00c6149fe131f8308a451666f761bdd0d7a4340db903782f6e00f0092150bc8fdb464ecb3947eed1ad0eda30680773b6d71758c01bd6e78863457a7ada90a47323d0eb19ef0f42e573722a1f6881d182298a6623c8b2a35324df1d51ccd7c5e2c22847ab3933b830216ee19eb5a896cdd202fe933edea3b944acdabf96bb242ca70e5908c612ebbd7050f4ab08209285a6e85ff8ecf9584137efef5f9ab11cd7fb05d177a0105c417065f30b8e23db4e4ec1e16285ca6f74d035c210859514c17095881fe2f1400a8af6ab70a5859d40a4289ed762132c71cf4fd52945972c128aa3ddc1f08fa98be6f64572b4335c74aba1bac6beca91cee060c839c98e8b889f7d801fbbe4dc126e504b064afc08208d0a421649fb328606307d6ce35d73a6ed56ddeced07143262a81772fd06cb062358bf3a3c44303ca223d515156541bc9cf52fdc56c3fcdeb16c35642047b36e74f4d73291510b3ce9aa8fd41c8a06b1f09a5991d62066443a697be599e081f3477565749db120b0f8613008859fcd6ddf05e364572ab82a4ec8c3a416229224902c47b4373471e0c88451d51a72cd92497b24ccecb5b363801b5baf1d7d2991bdfb5714aa07271bbaced048081f48ecd1edf7bb7315356e38f17ad2bfc650b4b37909c1cdcabacd72774c4dfaad3b88cb89695407e9b81fc1065f1f4c712745170fe18d8235c97d6ad2ee3c96b7dd3f00cf1f754438eb961a0ad3dbf57cef2a6f5cafccd37e15a777608db425ceffdd6de08acc068f8badda4a12a44209c2b49bf4478b29157bb0801ec657de3e0b008b91292579077c4fcf8a4000386fe00cb9a4e57e3bb710dcb7fd4b7ae9fd3794c42a6a441a0d2a3b8dccac324958274a88b037ac6a53fef87453ed0511bdf0ebc2d7caf94abe660ace9961fb2bc947089b60c6857d42f20f0c8b1b518704d188f2b0c19a6e4bbec2125499a0635bc45b5a58114d549822ca5ebef18645e59bbe82dc24f6fef96654c978ef6ee31e369b1ad7467c148d47e90cde819a7b8f755625181c3161c4a00a54036a48b87d8ce4e84dd1beff85def38fffa9500eb5a2db012ceb60f868c5e5a741e4697994e45962206122e851a77bf98351c60e050a86f9594b84f6af9d35e6ea285d8591d32a8d1b09404c37a970235c40b5b4815ceb903d9af17cec59f00695069fba98dcd75f8f1c41369ae7b22bb82cb09f9fd227ff4e7a553bc7eb44375266998de36197202617fa8d2e19065a94d77bf7ed6cadfd3bb33bdd242006ed7d76e3d5560119b8e8101005f9d2de95341ace3413f177974bfcc95a3d98ff6d34355ee27eb3b1f79bb615a14fa6b721c46bf4aab6e14478255bc3b499eff76cb441e1e559cb22ef836e13fa113eae50aea4aae03b712148f7fb26ed79291b95148d66d2a8b49eedd5a032440558616ca0dc5c67ac7e62eaee7c42c50a6cca1822fbec5ca2de1d6d5a5f02f0f7458d13a7d7a96fabba1d31842cb9c351f68cbb8cd8b740f99b161502c0b04b67ef519994559666831b9ee0ed8dcacc6ca5d136d3dfce5ce77d3e47311c71921b7975d8611428fae7910e6c7290f06b2a03c441fa7d40d4a5a3f777391900389331cfd301f9ba04d431f3917c651377f6c1faab82d216bdb2d3b7fe157937cd7ea6d10b0ae654e41d69ef9f5977ff24acf3764491b581ed875fd3f50b561616b20ce072061f57a09d475c362159b99c1e35e83c67457d1c624bf0031121566ccf55c62f24ac87b2f997766b65b1aa84b23b366cb3559b373d2a6e70d3b05becb52a247e27e319ed0dceb9d851e4e94e137b9727104a72acc1d3f7feddab50746614c83f5f70367e1853eb4d71ff856e5956f2c86c9683eccfe214e7a3f43edcfaa5ecb4c8bfe9453d4bd863466e0a359a38230407dc4bf334275acddb3b62ba1479ba2b55a4ef4a02a1ce14727cdc6449adf62a502762a7514c7f152e30304770b4423bec7147057532d1a04e59c383ad0c9534790ac3fbafe3ace5f3c4520dc5089418bbb9f1a16f27b88cb80b3134a0e672c075d47b7ca2577b1163e64dc1ab4e36ea9e029637ea584e69ba574e4c664071b1fde316e0d0f1a16fd36badf0b74314d22ee2df91dc31029129b778e11f33c16be1814f9ce6ed4817e63f9ae173b0cbc7ee845e51f8ce3a29d384c1565165f78ca7498b34c60e28a6d5713facb30a8bd3f662b7b5f7a4e999f9bb2e4d0a3a135de30a8b28ce5ccc222099a28f33a1736472a212a5ea1cc3f45356cb9126e005f6c674f2fc399d0b3cdec56f28c8e8cab86fedddeb807632d00d35fac0b0899d2979869aa4db7e48f311a5f1290c38a6a132681c4da27cc42f82ae4a3d84dffd49a2645641680367b33ca236adf56516b98e5ba3abd6c6d654f74f9beb2620ee5b52bd40082ac6116c3dcfa00ef031cf860899e1163f3e6cb6ebf28b8d6c3a101581ffe7fef712e7b6ea1b576a54a385645f14ebdfe1c6fc9c0d434d03adeb1922c59cf491a91271b562e99e6de111b1bd64eaa79ba33d568b379e369f231403308676644e65a8520c324538fc8bf6d6a31a9238bfefe91f8447492da446d9e0be43ba475ee4f7733a05e1f6e3312c86241ef0a585d881df3b8f8891bd4df235332135b63bb3f0426b84168e3a26a0fbc5ff06f56e53fd9b07fd9e5d6475b6bf78becc3b2660ec660c78b5072949ed195fd05c9afd2863b6ca989c620b6ca120cd345305eac62528c2f23100c5e4668ad11480be47b8b8e3d1dd37fca1fa6775b7c1c7bd413cc7435c6a109e171659b6103948047c85c98768a70fb5521c76e20cff537825ae31274db677181c1f8206eab8ed555cf2962aa7b0e4ddb741d668ffc0257e23a72747099545eb7084d9f4dedc46d78d7d7c8f864db48dff2ac250e5ebc99aa7edc1610532305047205c8b992983672d68ec71b979fd5c1a976a9adaad4eaa0e12628da99f2e43880335a2693e8eeb60077bd949d06b1be286d22e0733e85a782e0877bf7abfff3ac099fce72c97249ff748c81e7b0e713a433a05c4b85bd22e04fd5c6c8964fe1b9a2147a519396470970ab2f0f322ebbadfe409a4c52f8077dd4eb7a8118e2d73c65d81a1113f826c70644d021931f1c60896e3ff5363e2bc58f97391b8b7177464ab365d3a549c94b7a9f301f1c2f4443fc0b949aaadd8645888b558d233de55f82eb987b901ac3d6e5d4b36cf188430dd56685c8b0818ead8054c5b3c1841f7538fc0a8ed65aec70b27c7ef15b98aba5f8037487f0430fc7732385823c06afe0decfa01928a18d1d9a7c67249bb0e847f903c6b04db83d582e30ee64332fd07bd54947e0cf9a53e071621fb620e117ff9fc5ef63cd4c5fecb564a077ed844f642277838e58838cd05122f99e434fa7ac9a50c7d9a98f2b5387306596418a0dc2f61eac32caca78b36dd261bc24170f1ceab71e3963ac623e1dddbc72dca44262a07edbeba7817d3d0ec1bbb03a7a2e8edff9d475f3e74b3e3f7962189e4da59d27741e318d5924e5319c3c4fd91714a0ad6c0e6a94be411b9f45ed828e55d5d565d9adec26469f483f309c956d22364e89d263275d9929df50b6438e4747e208157b14044e08f5a9aa5f7044af2dec269f98473c740844e386ba5d9a211fe4f1187b10d9b5aad439d5c259fb84f9ed39dd379e5336c97fa11921f265be8a4f68e5fe9253e55c43aefbce079409b486ad980365a795b091824c92a517aa904268bc0d43bb84f7e9bc6682602c5c13dc4bf7543075750b5fae3beb983ffce1c2643cd81c1cf8368a9fb44024ab8b6231c261537dba1a6845a6ab232ace0a1d9cb51a43c82bd84bae009ee87cb7615c2a4c47895f35950a1da4db57451d90eaa0c06626668e06fdca6557544db9465b464de5407d1af31ff375547ce8397c9a4f8798799cc6aaa880b7e617e204f76211ea7992426ab1fe40a5e1bbad68ad6f244491c1c68634b5022c3044da99cc34c457cb7601add905f6f0bb1b35640240d3f82b5dc797e5839ce28da7244917f64db441ce7a57adca246c75f7a668a90fbc116810a584077c31539d7f18dfef5d21c76e383679e8d714f90e91b9d67dd8c153bdf3b0ff151507f242081e9adab681c9343550eae42fcf876367da95214a438ea2060d277729715ad256f82fccbda7b3e0c1cac8791c2a7825839369c1bbcf45d1a4f6116bdcccc84e9266c18b44cbec76392db8b804dad59a48cc6265e21755d9178f7f1339e82c2864d4b82e4fa705bb814cd6b5483f2dd1d6a978b32537ece279ba94cbe08a03441726b9c2b6eda71e87662c365dd50e64e71c66b4faa60281a1eb2e4fa1522cd47d201c2c7176a73110d6298fa6ef52fefe1b53c37775401687b5a82ef9d864f4b01eae074b71ca17e2cf1b89aa6474ac3a8ac5ac6868d753b0040b6b2fd0b7be85ef6c3dbe61013273559fe8eb876e28dc7ff3e36f6b5437b576734cdca588b99a3acebebc260f3990b91b3a9fc74062808bd5f7f8b0d79a1e025698ca4b41b278c7052c6f191e1d148bbcda8544ae9cc49391b6640bfced149667fc659d3338d479ef8a5af241e71926eb05fede6da9b601421fe5a2c170cbb44b18f3c6dbe40359b3f64d81271d4d434a643f5435bec0c72a37e960912b43b49fae92e7684d2ba03501ad6e2152185f3fa1678ca8a04059fcbc71d672ef623541b20631ea7afba5b2661debe950cf2d7c6bfac6b74dd4027c972eec5a3534acd596f465cd147b14638c4f43d263fc73b2fbbef3ad3b4ff0ed6caed81a5277631419aafa6838d1f01298073bd9fdf01a39ab00b1d23850aa040569c8813645483496a6cf88cbb3545c30c7bf493256209fe1c15ac744b490e16548ef89de71d9820b93fba263ef166aa4457f55b6f7ce8271fde0d21727cec4697f70a8802ad5ee409eab730078e3b66e509dcb6f4732afdd48577b90f7ff746a9fa3ce3c74fd72db180488455494876174ae40cf7141655180c09040437f427a90640ccc8d29c95bc9ee487fb41bfb27fadc8d6c40dc148c4e8fe730e64029c4e7ed78e17bf23ca355dd1f97f644c31b8389ac67f582a3ab8fe2003a7587f01946ba06378b568d448a013630a42d860d5b27d3ca1cd92c21e98eff79ee56b01c48277a116f6b25bdc7ed6347ecbd932fde179eed81e5bbc18cd40bb15c936b55f4f5a606adf41435d3cc8d1ab385331c2ab034e520b0669b299d21b76a67f366e4badbbf26e0250417dc8bb70d84ef619410fdf6c0e6e773e172277156593366b95d1d6e664cb5ba3e67c2ed978db38bf101d05c96c0fdc62d1e6c2a4afdd825bb1c028319cb1643c57c942f21d7960fc62870e6134206c950f4c91b702e490a57c43e66d515bae414e965070c4ec0846ed400a9d56093e51bc81572828cac15fb352559bd84e799ddde7adc98cb0526129d24e4f827310a824f83d46e4c11368d5e72d689af6efa42ec2c0c41ab9ce506875a1493f17d41469a31e11e346cf35d1f8eef311c4cb44dda0f57a060f9762e52c932b0f5e4db0f48c4ff6b22e1f7fca20544a09e1ca2dc264d55fe7b814b6ed756c62c251e41aae9169af52271d6d5bdb154d79b2f31fa89da7bbc142ce2cde87c195401b09cf66fa32a55f78864f28df609fa7867436f3810b6e1b1348ee81254a08633c439c46e6203cc9a604efbc80e4062b7a1167b89c32cb2092b8a968182ef5c0c018384fb88c7e5f62d3e1940ecc479f68ce4bbb283209cbd5809c8fcd5bd9fef3ef2e055e1547f72191b05195c1daeac79c799116a0e4c50f6b46ee9814b090b7d463367c33f64f3105c54fedcfb9412d0a9c74f3326394d3424d76a29e55509a73e170a1a8fcf087254553935eefe016a531f38a66eb1ace238807c97480b815b2429be7d4d2014a2cd5d3248af83a37c3100d17bf8575bcfc0fd6763864768b6e31f545281788e04f4364da0341247da3e9be93a66db5a1b4238c610bafe67aed44149dbc9c35477d29a880c27b12fbc61905db7fd69cdf44c9f3c952335396df0c8dc398d2ad2b8c6170ec0f61278d73db44d20ff359312de2828d9c25a60bc19e02dfb218ca411a5932932125c24d10bba5db699a411c0f4624a3f2b2f7bc11be242fa456d0234a038527a1772251808c5f1203876d5fac5bdfb2e42838daaa1e429fb5ca1a2bee885580b0c743e22aa431deca6fbc663f95a86617bb3b6cc4eaaded39911ee9ccaf27eef33b2a8bfb0ac9ea20523b428464ad488b2f338b7ee6261a6538698a822404ca27855a056664ba76bd794004fd66edf869ed0ceee366c983950f9ae205d7a8cee58d291a399e20e423021811e45260923fca2ca6f6b8df3c89035aeefc03266169fdabc163ae2a7ddc0aa6efa7ec9246dd5beba5ee51b5c5b08ba9ea72b703d26c09058f257c3882417f144173074348dc5e89a36beae05c7cf22e826b9b3f683ffd803a70e171adbe11cda02cedf4b793ea4e48cbf88fda4c4d7880b26249b3ad8acdf2c162217fe630a1f61e8f232ad255ec1c4d50bb9d94cd4095db5409a904c794ccc230c58d86b54446f0b736b7cfc89c5aaf86702df168e1288e434b865f0e60ebb87cef51898d1fda1b06019a2f98a6a72253dbb1d5379af8570d08c57dc2d2c9d673473ebd456d28be84dbb3c21f37d3441b5d3103f2af8daac6d7f8e76043b8f4aadc8457f343faebcc1870be50c8136495e54b14d0a94896865de29b9aace828072f32dc7ea868af69ff469c065e1398a3cb7c3de9a0edaa3b297e9a51d55c14d64c64baf316771c689a36aac96327562a8caa1e8a4e50364633a96507163533c278c85e1885ef446ecefbd1c3cc8306d28a9b0b0c588a91cf4cbf3e9a005b7ad346eb856399f5937763666c8d2f61998e1b6e66c462b954820a7f5366382d814aa5b36c5d2877ec7eca02b5d36278d87367844cc047085c806c3ce5e95f1e883d77158e5d5724cdb7d1f957da1c686c0e71433032d82dbaa54d18bfc6a7090b2d6af079f6efda30d6a8c5dc5019596dd99676164007ef65a70fa78adf537d6a77a93f3c401665c10357f763b3f66ec5103373440bd3a0948528ed3d27cd72d75b26b6cfe806a2fca3a5db3012031964645b8041724b248ccdd1fe28f5350a05ddb8c5e397e40290bb05d04793b9b992731adb7ecbc69ec59d19ed94b82886ff530d995f6588e1867c92b0fc39dbf897597cbeedc49f2f69cf273144d0444ff8dd2506cca26b1f961f86e8aec4897465b4b79a91fd73043e8b34cfa4952c7498a680f1779b7e3dfc17dd7849f35393edb532c511d4ffdf435cd4ec8a7369b314b4454f227e36c2e06f834a81454d6e05edb523fed146be9dd47e74ff5195a50ce54eeef191dac21410aafdc790927d4d9cd5e48d3fa80133086a907de9e2515c1b59b32a2ef1fdd88a5e28668e93692ca4750deac69585ddc954acd94edc5493085858b2e550e218e4d64ea2fbfac6a752fc10903e45caae9cd91846c1be740b260b66339984d6dcf4609eeed45ad50a9e1ac03553b9c99c9259eb9737b2e905a6fba8ebf47781fac024ab1a1287de635b51655813b5dde25122505e787091db6140b47fd04014a19543ad28f1ff42d2ffd8d1aa8058534571ed927901029aa2cbe0e883fa728e2bc9ff752b26273b91cb095417b2e6479cd78555874770d94e3ace25a7d710a5fc7f0c723f57a3b39a78a9515750a50a2bb86c5a1b4c27c2d0eba0dc33ed6d24fadb5e99aae80c3c4b59524ca448f073022d40ef032e37a226ae57d5ef66ba72be7dcf25ff720cc941fbb8179917e05edde2305e5b3ddb1143dbe2f64d1bc804118d4bf4c5f53d43a074455db364f54bec25b7d2131ce8651fa2f36a3b0f47023ece29ea3ba45a8c3e861169ebcffd50caff55a479d6f5f740e2f41a242a2a03bb0252b48def41019093f6139134db2ba4f3b685a77129d1aca5bae164b995fad841940e5f23f726954541535bbb1c4908b9b3be13c6b47816d97addcb9603207409bef5700eb8cca8a730553b15e0033af9030b507b12ad9d3ead964d325dafa36261a36f6cf0024a476ef436247e3eb39bbccdccc121c8c37b4be04aeb287747bedeac8d0209d2dd0ab86a893641ce8c30e92f4e82d64750172888f82d0af9813795b15c2331e2070a64880ec939a99aa9932edbf0cad1a31cf075f8e107d909390a9fe4f286b33e55c093e1f1acf5d885b013009edebb8081f391a63c6507fef321b19ce5d9453691d66d0a639d374c77937afdf366cf9ee22cbbfdd85909aebf31e8447cc30533df62328c0a4e5aa4b7a00acb40fb9f0091c0600b9a1404a0276c00973b1b495410c319940e3d4d0438c54c4b4cf64ed3b799529e77ee484bdbb48de8c8feb84e3cde93dd418c96020bf1dce586edfa477427dba02dd63bbb57477b664b463e28958013a2556229bc6f771c68180c0ed9ac3d80a9a9f7747f44be2458ac34c851c94994ee8181acad2a48fa51a1aa4dd98038a634f55c6935acac3c305ef92845a759ada030d0cb8277d79c6bcc0a64808a5cd5ad3b3ca07eabf545af9d21096f4731f6fc9ea6bbba067b3526eccf8231cc809178f62372d44ce6598a09f7b95442d2ac3e38d48b0cd2f3c9c83ecb3ef5caa1808c8b00451e43ff53c48188874ccc0fed9cecabe3e4afa55cc0d688bda9e38449553e47d6c3b0d4cd9303f918a2f9779c4655ed082d065dfc16968bb9383600d91d481a13e7c160f54af3e90e2592cf06e3292622611d6254003c3186ff2f8f8c3b61c1c971ef702e8efc699d742538cea2f98f43586469282657ceaabcc72f294707373dc241c3bbb269772936874b95013baf5d9c5df95ab7d40a2af2cd0bc2a627dce9f36d403b6fd14f334e24f5706cc34344c0257d48fe5c6bbd24d0b8a53527b1869f34b4a7771aebf797b5fb13ee4535cbefc238583f1ef62869ed93c99beec3949ea66a661cfa8cfa19e09741dbace104a168debcdb85bec51dad123e0dd50a8a3f4bc196f080167107b7334595d8bd2826e007710b2b65719c772fbdea0874f2f193bbc95802688c2d21b9cfc6b21274d3afa490fdcfae59788a9ba809c90360c49645d33b144ff896ed671150e2345f252fa9cd1dc3be205af70c4a954c9517247e8ebd95112bbd6acdfb2872bf681087b76d49214efec3ea9fe5a8dfd3f588a2b4d4eeecf0db136b65e6fdc742b105bdee55e5eb337ab40bfcc65fefa91af4923ee64965b3c98bc3ba4a997e5af2d7e0b0e82e03c951f87bad2dbaf4b6ba8134dd2c9f1e0c4ab18fccc561197b494c8c5dabfaf9860b49594cb82e97ae23fefd534ed0679442b8baa72ae2f04ff626483955d6d659e2c42c49ace6fa358ef6df4f861cba806f29d55c2245a7045d1381db2ea89c085a96c1e3bf922ec703e812141cc08244a5f69254038a52f895183e8bf5d1fa96d1ff80135831bb81a15b87c0a791374eed6f65f390dbbe1338316f2e7eebd173b23fd1928e07ce86546a6db7c3a994dd847ef08ea94f0ba9a168a4a605a7febb6864cc87aca723c835b9d13f737937b55f8fad78b64aa56026c63e3f389307c254411385b4d9eaee7e713897a07e067d19b4d28d0c2ba72b284a25b99b92d01de58e6772a5374b6a325f1f5855813ace72e15d443fcd45254697765b4275b62a9351da1bfbcfc5a8f115530a5c2d67af745f11bc70490454e37657df0a93837f5ad2f3e0d4f5c3269b63fa105f5ec1147f712707d0073b285f9cd682d867e07690f0c07bff0115c6a4718ca25d8abe9aeac9f9f5eb6f05d615c2c1a56da09522ec25e0aea5e0894e81f1a3ce479889d23bc8901a0db46a8427b566f0d56db85575070536dfcbb0231e7eea4809415f973f5d299135c11a8a34d3ef8fece1af4de97d18aef8eba41f362bbae73bee39729325419bef8d6ac9421423bab7b366b9ec16b22b4ed422e161959e45d0adb675bd85689092b66cf6f3e4dc0628c427c71f14d96749dd5c3141bff9696f1282d409ccf616659378ed33be0f99efb7bfc354c39267a68b0a3711ec8292860775d5de414e0a0e50b2252d2b62da832259601581a70991fb2fbf88ff57f1d98e64a4feea15f72fb14ad2e802ddff0cdb236eef704f4f1d81e4bc540e999d105fe0ef8c266def7bfc878330faa587b511ccb4d69ec5d60e5ae1e1601d7e60b9fed7319cc8caa806f8c6608d13de561233bf17974a78a2f85579bba512bb952976513e9bdee04d520d592afa363d3f919fa0d0500ec2808052db996e368448a2f3d03977624ceba0ed6ab92a033d59a0717b81271875121e504b0268e50ccbfb1ebb935bd9cb46f493041c06dc2bdb6ce37ca292947561aa2c147bc2d0cc6a966bf34b0da9369e50c746fff2a014f3588c3fd0d2e232c7f634e6e47a9ce2e1738ea7f5b706963b4b1136b0488a87700a091b000c37ccf9e7a3e1face63c99fece4c56407409ec96ac8c149c80b62adfc6bd1839ce9f652393ccec540a218df27da8b5c4e8a6fcdb8fc71939701fc24d1816e664ebd7f3f0b3335af01af065b9492801952e80a881bbaeeb29551b7d7853de26b782b8cef9ad62ce586ba874ee8e3a4d9e132adb1a7369e7006cc73e92c69d6be114c7c9103ca07d40615c44dfbccd7b6c0325879dc98ee6578598db90bb976e70d0a41a6e3001cab9ed421c07a066a769a287990528a30a45c743c6fb89b69a4705e5c4d7b765e1482255516ca8246213523d46d6ba86caf5c8aab37e291a26603b6af4c58dd5ff2ab405abbf48b4b74b21fdd727c41e8e26ff6700a27f8b7cefd66074ad340410a3731d053d31b3093d04ec32cfcaa57bcacd435a20077ae75ac36d4472c3234ac2e62f80cd6b3e902e53ba0bfc2888a89fe1c994bca1cb39e6ce9b0bcbd87e7956d48036206c5d78103e4b382bc2d355f817c50effe314881da2f2028e4bc93c48e63c16b8d007fb2c0852e5117b97413d8724686a9533597340bc5a4262a8848b2f9ef0bb6298837fe12548464da0fcc06f76a5a599ce65893acec8200b9aec0070682de8da0cdf644a3286cffd207afe82ffda1893589f62c6d0bb2ddf1ba0d72c0e0afac069ea4df0f13196835b4a9deb7240863296c3c89329d79b94df31df9ff3eed02662b236e367c0b7c3d0a51bd7a6d9c6d5d4886fecaf2d0ecfb83c0b96e8eecbbb010de49afd4ebc0354db5e192936a8d9c51ea90c7a2067060a65da1719ba7ee7e7db73d002f4b7f5cd573b426acc4e7eabe00c6bf75ed2820305d0174a48f1007706cf83ad32d13ae4744328316100074b2158ec1a3e9be33048171b3e93c505dafbf93b07c09eeaa244c0d0d6c57a8b519925d01fe6486465a444c304670378ea385abd54883c292f72e91584f40ee814a1bc0e8108971ca0059bfc7be242065f83cca573c0cdc242988316749e844511d32945d1f9d8e790e8680338cd78272eefcbb5445f9bcd9a7add82beb0a6cc462517a91d0966155c2e5db410666500c9b8bbcd9194a13e32c480ad9b46678be7df00955b5d5dbb97b3f3c0ea29b725875b6018a7da907bf6e3dc6315bc9962e04100960dce05883b42b32edb528cc64b5cdd884d15b74c2dc9f3e45fd9d9c07ea17aa83463d6fa8e0529481d459fd6eab233b0fc99d8a03ecd1985510279e4581dffaaaffcee6194479fb2897de2d0af8554604d8e5feb5adf3262a475ea3c9dc7a177b6339f58cf7712da79d8d431e4a74c5c70a05acdb5b5038e3712fbdc8d2ae212a082de8f6aba1b0cdde07a175dbfe4d7e0f5a06300521d35809dc2f9fa0437b1fb6fa9331d2c5115952e608969b512fb8072371b3e2ac67c85f48ee8c1352701a3cfb824b9402796b9e4f6272ea0acadb57fce40a50f48ded9279143040c8bca9d773ec52d9aff8e1624c10218e9c29a55000fae25ce3933dcbc8c329600329e0b1e2ce3c451c6b36d1c2732b982ab5c0bfd08477fcd777bdb3dfc63609401522f46abc2cdea9ec504f0b5cdee20cade32dd0eed0df3e66084731e9a3f5ed53ca8b7abfd7fd0513e9cef3bc16c0ed28a719bfd8a55bd47baa77d4d5ed013148630f58bb1bc204081cc0eff75673795fcaa0b54dbf0bdeec5a2cff98b8a4d120f38445a90d40484bb0a77a8e12d666ab45a4690d5053afb6c25568b8923b3904a5624f3e3cef0de52460ccedf250f0325e31415933f0bb778fa2b6df2b94aa1c951ce1cebe39bc2e9da0d3d9ddc7cc176d878442f26ebd5f349836d834d2941f4a6a1d7febd23ec645f31136c9ca0a2b47f17b444740eff3ed5cc5ae0ebfe8720772d9f316dd6b1117c23c72131ea0e6f5581236fcea6d20529c8586d7aefdf8f989a56f16b71ec299bacf08d9fc62568d1122da42999fa679575913666daa5845a14359874b3dc1d29afccd01ebd963e053b5b00cf5c62d68e28cc38661670f8aadd3a819fea2e857c54a4df6f6414c183a89df1d0e2c28f852959a082dd5442adfecb96c873c3ac838843640e46db9996dd672933fd10eb04b1154e920c08a5ea9c06bf0cdf5371c6fc57fea52c01a36f28f9cc96fff9f09fd4ce981aa4d3be954b284e6987e0a77aacf372a93bb4052874acdc2d4d32faec5f8948fe2edd5937644ab9ab7f099f4ff5098e5750ee50ff6af6c5f6ff99a0ad52d033cffaa4306124842c7534c526a03218fab228aa8b64bf0a6d408aed0657cae475f028c96827e2a3f8579cace6c9eac756869575b541a4ecf26c600b58882b21ba259aaa45f0ce0ba2ad189a7b97a5f9d0295048ad237d342afd599126eb7073fa43f72443bcfb4132bed0f19f17b998109a6fc6c425df351524272e37549d87cbc4fd65f384bf2925eb4302fbad24fc9070beb8b3ae7d2159a33feb09603a26b4f2970ea1c4942dde561a3d0e083ca28fcfd02bcfa581d769f71c200eedb0329289e7114fb97e555081cb84471dc67c89ab002673f5b8931f23c5e78c1d6a3f0e47549df851aca968a811bbffd06c41fb8854a4e21b43ae82bb336a5d2f05513f7dd249199171bbe960b04e2f49ed21871d9e7b1982a24cfde9c7c1e215f7033788d484ba679932519a75e6f25fd960759b51b72e7df3e14c5a7ad83b74a7352ee02f2d38d2d283d31d99674507ad4ad20b21cec99145b403fc254554d69d43ab589bb0d26a6910d70a0bdadb2ed55dcd7049a3099dc42105666e838ec7664d39da8046eff88313447e984de491d9e0b9ec8fd1e3e8c5d36b4066bb66ee6efa3eaea01b6c392a7c5aaa84520dcdddcec650789812a3b9eb42df758c3381b008a49440b6a5f53e6cb14827cf4a9ed97dc9f3861b66813859236780123bcd42ddfbbff2d9f95893951c0f7f750a549120dcf286e048f34a0e2f1745f84b9ce5fe0d8feee9aaf68770ad724547266b042edbde8b580a61060d86051eada8df2938e47ebdeb874290eb989696e827f0da50bacb0d399a393c2fc8b1dd9a41494715b830b9e15425e85046fc7f4204db7b7d6ea5d2c729d97e175e64cfa8073692225a68fc7aff015658d0fa081a9f6a50a1bd245bcdb151f98feea61e32654ec001c1b4c019f2d80b9bab3cbaa3725467ae19a21c618432c35aeb6bd9e160329dbdaca8bd2f497b5c3bdb6b1f2158ae335641dd73f50b09c84ce3406cccbfed9b76b4e233602c39f524cabe28c6ca42693b18dc1533772c5e8b64b775cba647137e3622fcaddf02dab910e1ef9f38f739e5054225f94d7d42413d45bab9406546e52d8d102544219d3c3e7234754604138c0259ff65521dbfef9bff8d2a18dfa1b2c269e1ec2b3518b8e884e68a8e1081e60092c0112a87274d4fe3f71c06371bf20993f4cb48661e6d2d27ef73297520b0e256144870604e45d31736fc60ede414d1a20b0b9fe85c51aef3d6ba865304303cfc8de187637274ef70e7498fb23342b316d28802de9f094a5a98045091219cea11a339c8e772ae2919e4d6594276f31cb29a98ae7ac3b3d7e091b7de25e649482e991ad79562039525ed9d76e58cb7763c91d3977e4c5e419cd709508d828601b583cd84dcbe9e79d18c0dec946ba117dc4e2ff26a120aba4326c881bde344be7c2b7a1fe94d4ff610b1ad32406241ae6b65dc2f3a2519b42379a29aa170f7fad203ecb07b59c45ff0d13c7e88cce62077e0d71ced9ed531c3e9d2522ce1252df376d421bfd034f5d440efc85ed9f1b7842d1f64396093afaf18bf79a4e80dd497ffd2e6ae1bc7831ba6eebf0ecb6a91ab8ded3a34b893e25af79987b2aabc2340239637cd770f6a513a8e87e33253440547384d06f56c90f10b2fe3e8c59fd6bfe44a92ab9ebec4f21f27c347bb87b813cf3068840a1193ab3de913e08ad68d9fc9d60fa9c7b2f395b6817dd2a4f4aaabddaf48c8f9d7b7c6d962cc5a1093280443291f4fd9231c9d3f100f7e7f650abb9bed2aaec4fbd0d5091c6354d54e57f69f95dab3fa34f91cbcc0f6f9a439fe0e0513f170252ebcd6a42f4d67166786ea4b5e833d7d2165a0866074344c83d78a686ebd9c6248b972882432dbc59dfcd4b6b64411995bf036bfb6478a48feba4b22e49f95205d614bd90703de0f630e72e5302d613ae0a5866acfae3b27f6d1fdd40f0b4c371a6f65cd9c341149d366eb924b88f307ee29403af57d76d89b3be26b36ce0f0c92eeeff3aecb1b7e6358933a0ff04220b82e0420b4907a0568e778847d047dc9dcfb58c4d8e6a1c7f37330106432942b69d88a9570a1ca84989092a66fa080de926ddbc927c5bbcb94f120aeeceea2f201025b50b569f8327a7764ebe9032f5f7a2d956efe6dc1d1b26050a28b1601b067fcbc8c7529769e5309b40f66685f70f4ccf48f01c70670e9c8c8f7495e7d70d9b878f0027502928536345ed2c32360468eb3dbf7be8c3eebf3619d9349d3ed3e9aad5abc60cf9598fae94fe2955ef31bf1ca2ec53fe23b7c129bf563d2bec078e0f3c60d75aca528e1321152fd00818b2a6e92122dff486395514123a83b0b76e59cb0c7011774dd232922b447b70df518098287d2c6d7c55773a71463632d0d6619e4b21729315084626c74a3329c05b900577aa81ee12dc91eaf3f8fbbc9b1563b85fae20a587a424fe682c6339aa5ead845c73305465567d663ca117e4d826f56cd67683a3da6fb63d95ce1e15a89c9184daa63185ca6473a355d598cb8a9d9b20e5158fb78cbcfa7446b096aa3065d831c6e471b11762a60e9b3c9aa8453c060ddb9b53d400e300e2de427df7c3a8cfaf9d5946c1c8a021346fd4700bfe70e67bf3977913e15bb30e8f8b3695f11cb327962bd9bd39c212eb7ee0ba4f95db815253723b283e0af40506ce2044c7fc0013431ee32a5d8f9aa6af903d46f622d074b7ea861cd28c3806da6b9fa1fba87dc6bfd4daef2e71dddd440caf99242c4225456a54387da04a88b0566b3450f75091b2f1a35ada79cc058b86cce6715064ab97f4e793ad84f48a5ed8b2311e80e68db4b96e1de3e716b7bc15a4bde558a6a112622d17666c53151ddf60dadb81fbcf9cbaf55c9e24d54e328729d12e28e563a6435666f86545b7c445a275596728af9665c52d41ebf39f22566ccb3e192e15c2e40590c9dc9d28d586b32e6bbaf8b93c117346ed3a2a74bedf238452faa9899a3c0c329f90eb476b7d9ab7d507e886b65f56fcdf2300f17c1e3f7c137a30ce58b748d181b48505bdc6bd26a03f906bf4523971d1a6f21a550a3648a6ba375c0976b8d04884a3fff0c33ced09c3bd27e2136d0ab14f194f86d9bc38a6a31b8e252946166d73160b3d55e05ece398e3f9888801424112330a7895c1a0472483b754ff16aeb2c674317e3c4ff656f50483525f93857ec4439f5d25cd35c4a2e333314e5768933f850ab00ea621c0aaeaa05e370c623fc5232be70ea400357f5cff56b336245ef75bfd7705906e119d3590b76c67b738b80b13d2fe42de00b4a941c732beacdeb30327178ef9b695ced1d1e6f7f23dbfa2d416a5d7d97ec533387cb6182c316a7c8d8a24e4e74abd53f90f50737a5126456bc6f62e4ab2bb6729f00a1fd1b6524f01682a63cc0fdc39e33e3c6386aab92229d46f29a6070f8bf27f710299b072b12901b5bea3dde6f619140ea9bf3d964afb9ce44c2a5e02944eac6f7917fa2da659202e4d36b63578e0db89f9a2a71c30e84bca23248238a9e1c2e812126a1c9cde09c699ff006b1ad9d80a7a5f2a10da019948c785ff59516c12f31eb6d76aaae209fc713d1666c7b3bd3ab829638a28cf2bd88816b8157d6916379d2331c362a837371672e7075250fe6cf780ed4905b8b56ed17ceaa4f5dcfe4bb2fd214c60b9ebbd7860f7188cc7377fffa0fbe967943c56968262e8c646ed243d14f099bcedc273527fff37d912adcc983e74c51f033c4ab539f2580c21ec9966d9916e893e720767ff7f2340befddc04b0e32c0d0a50a53f8c2e3062e78bcd718218ef84ee36fca5798b0019994ee3ab983ca0a60882af52d58719b9313c1efd96cdb00e4a2387571b52447c62ea7f4ade6eef026e89e3e7828b2adf08f868dfb14667b16e26866c9ecc0e3ddf2e4440f678983f63571956a272343369ba180ad2a289ddd7de27949c894f566ab2cba6983","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
