<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"28f21304f2bafcb3442896f11d5f4ddcb2f429e8bdb795aa7950a5970df570b57c94823a7967a10903ab6dd12a8ddbf0f5530f5bbec680dcbcb45fd816ab3cd7f3cf6a388a05bd74ece20d95af2c8b020a9cfd9e716eb2acbb62f236201df2b48f0718e7a718b4301eb624dafd6db0c9c6b8f7de3e783f6b1a0c90bb8b6d45f3a6a722d49baeefb939c89930851166c79eb19af920d87cf350d133a96daa7dff299b249a7df683ba83f468247b8fe465f812ad51f7a67f3dafbb40e716a6cb1525ebfe675d634addaacf69f21e84e66cafdb576696d601c24e57a06d7a576d8656f163997753797bcc0ac8c4f46af62191836300f11b6d0e88f80652f2c6829214f5be94d7d733fb3d63eef85c27b841a6e3ffebac4bce9a7f2fe233d473cd93194c630b7c989a47da90b68b1cb87d4ce721b9d2a0c20125a19ed20499677517b810c9c83b9b9cd35c8165e3afb22d58eb600d9f65b51fb06f56eb364954595d72bf9866e9d949039b76d727580acb639e9e06888559f85663df14c0faebf6304d2567551e5bc5374026fb0ed67e11be00516b907d25e2f87dcf3a125c16588b78815a3a58d92b07ee7422c8cf7913f4bdaa1abd09dbff8bc77ba8cb37a18021f48c511bc4c96f5a221d0f02134bb2642891665f7d572ae87996aed6b7de305d1b549f2fc62896cf1b2c3acf11191e34f3dc0fd778c06567683713527d482fef60ddc86fc1b92f48ceb491aee6c5d54543b59efa75b7d8c9009684c80560753c2f4558e8ddc3bc788850770fe6f5f6c8621ae53a95863aad04a60732b6ebc7c212a7418efcc95b23ad596a9ccacedc8d94fd17e66c7fde7b5b28b7ba7f740874f704a0dd13cc84a99290707eb2eeb67a32d56c206bd56764322395a86f063faa77cbfef899f1435df73df38299a3b38ea4765af93ae9e28886f6e5645d01bc70c5b8a89c248102c819e3acca325eba9e42f30bddac2f7cb4af25a261ed78fc335112b50e7fc6b3ab7dbbed9e8c19f1d2e12b2c8517d506a2c43beb804585b1aed0bab96152581ac0511dff72afc2de60529ffbfa84bc9f1a138b41dbd9edd15d37c3fccfebef2daacb1e7e6a05f3b782fc214f571b44f465373fdee0aad2d806da9253084e87231498ee510763d3b3d472e983bb15bcbd04399789839551f7df9add71cbc9e015b22641311273b7f411a00d383a03d8878add382216091f41a5bb20a8ef375d0c087d4dc1c657c80d01b2f34ea2efc0f7103d6d77318693333341f8616b3a89cb04fe98e4955db0d4481e5134bf4d13cc9949f7da0baa7953a831351d49d9bd82806eac95e53b2875d57e3130a960fd46c9dd17b16e279c55a35a9e20a10b8f2464911744e9b25cb028930191b1ba52645f6614163be93dce53b199d7d4c411ec35a44cabc2b20683db675cd46d472f4338494197189f8041604a7144a04367df9aec079fc72d4b10fb1f77dc9bc0d2b9d071996903703eba7e76e02b60c3578e4d37071b163c94c5893040a1f1133145e1df88362b1a5d4abd1c80ed17b6ca93dcab3040940f090fe40271c2fb6ba48c385c0506d267b7bb9b9b4bcd2f036afc433a48327b68a7b248ee981f9ff13f371fc2f00df3f006c9d6556a0dd82dcf62012d6b5e25c31b780fa2aca97dbc406773dd5c10fb0460c2b8bedeb5232dcca95f3c27c656378b15e0eb903d951f7a0544d14b5c0cb9ce359a44f0042ade6937c90a1794490256e8c38dc3678f003a7af0524714b2a4b790c009d448f888955ee9d17b9d29034d2f20c2390b4c725ddf329916067a4cbe5c7f6d69116314a455670e15455ffba6cbf51171e2fc32f88052f0f4b15e4aed7e9a7a7d20169cb444bea0df3291d0a4425240d0ec91f2b089e7dc0dd6b7946f9e65e8b0baf8f1bcb7017f39fdf32a7ac7dd1fa9ed56f6a6fd1cdc7587d88627ddb87f9550e51e80a65ea90c6c968183f1ded5f5c2023dc8b4f72ca8c41b696d5af1df78cdd5aea337807be99835c70377e6fa8d97dbf8560781babc66fc0765aec472b95d12d005a3c83d88c87b98e2ede1175b5c7015befdd791660b2be05aa59c3082d55cf4b32d346f222784edc67c265b9e02225d49cf949d6200241eed53035c1b0811452202f4743701ed3083708f58a2fbd357fc66417958bd53f40ec39fcb142d23cd9aa955ba1c12857f17c36ccecadc22ac86fdb50dbf568db6a16af501ab77a86ba4baca5b347c5ad3000c0e6a95cb875076f730e1774d1b8b7741765bb70a3799aeb86ac257c525501a48ee88fee590009e3611cf09364c1a56dbadf4b1bfc6e47c7442ab56b35862124344fb434023552ed4c62a0a99a89e8ea590d05589ab1d727f6805bbc67cb67cb8810be40971037f92d248e6ac81fab815d9d66597d414216de665d79446de8180d4b09aece93bb7b8775553e536897918b0d773560ef1cc54d86d76fe6c1165e24464cfd9af7c0207938ed8788b5a5a9685867c592511ec5128e576a7087a20e6ae71fd83b2a96101f166018cb289513dcb7597e71edf0f5ec31d64f37d84580b295efccee3a86784638c8008b893925d0c7badd9ea43972117929ba03fbad8c3087b51643f3459b16a3c61f4d9c8b898f1715890d254eb61ec2940284a4de930a22db01ea29e98de622b481e25fdccecf0104f54713b803914faf80ef40a28a8ffa0410fd9c6ab7859f4e91f3dedfdff37cd02ac573f71bfab7e1f59cc50d86b7ddeb3a463c2bd47e30f8a11981324799fc0d284ca6a4d5636400e97ec327106b78c91f2af26bf1343f4495273c3a62a08c6669944cf5215272d7534f1fccb38798e8c0d891ef3063d52a62f9f04a839699fd99d080d62b5a8b729575aa1b9f78a26bf516c249a7d6788dcd45743e2f6e4a3f1d6aef23317cbf629733eac72f93919ba711b3688e630653d4f0c14e8a4102e1144625c3c76b43dfb22c489ba5f42389fe26db83a2960b1670c95c5267db2844b701cf57c45169f02dccde207904d41c5dcf01b4a7e8533598d7ac141d9bab6ec0c927d0bfab8acb1640172f4a691ad94caa24a6af8eef6cf04239153f906db3dc18bd407b78f15b481e27fb68cf594a47b5411a65fe3f9bbc9afa07dbe42ac3b387b04b6ea942606cee52409dd0870f0200644707d1c14f7405764cca8ddc410c5e1743a8f654b9022ed91363a830ac439827ef71bb98d4d95fca34253ade1be05b76a3a12f2234a4b607538579473c33086aaa6b8871a1414fc97272bf72eb20fbac632f0a77ebf8d98c194f0697b7411a85af964fb835e0b4bc658b7a8f204acc350592b063785f0dbca3e7c64dadf9875bd3176e9943b299cf1c80596e254a185963dfbd1512756adc3c142fa6c51d6085c4dd1ddbf42a2792e9773c9b1384462b2812d0cc693b767d85f01c67bf3e7b74e74ca84dbc83f07a269ebcb18e63b0b1460553e4db0e6b4daa08cd585564c4e3f79d1ce30538da5f5b2ec68332ba4110fc90de6bbf4b5d8e79df64821f3655b4b57a79b935df29cbad807b7965117c5daedfe9a0dd9dc2e705c525362879392a9ac361653f9a2187df8248a22c7242057647942ac9f3e6a1da8597f6b5b8b976792363e1f1a96832e16ab758d1aa829c3fbfe40a1959a9b882b374cad3453681eca3959c1a2861ee0273aeb9925de63b62436fe6b366d666289a228268d68b813ea5d6248bde28ce66d13e02f64f642d0283b8e334bc774046bf818f34bef80058c0713c963c465531168d2f7f6f65417b08a88238336207cf61ee97371c5d83dafbb68e9c0500d6c31df3781de13a54b485de813057d7bc66e212cf1ca5053029c640afd55cb9bcb91ac34ae9df6b74cda239b209c404e31d84078374c5fc72487ad8e298fc2b985467d09222f0324d6f581518daa2a84fdfa1df4af904a0b32ca2bc2091f47be06cc9b9b1b3c299d260c725303b0ce83d838c44f810e96932a3e0fc89af6187fcd58329e9f3c9e1250435bc55f11ab79bd768904d05ba9aeae18a90f77627d5b9d6fd409a34493de04700037d29dd00aa2a63f91af15fd1cb5eec7d7e81676d4b27918d8d0559cf387324e74985283645ff53064927d82600da5bd3320444b12059eb88a5ab93d8dafb0b86dfd90e5fb470345d3aedb9b7abb8b2ad36111ee5f7299e7444f4211ca6226c91a4b2aea907c991543b68e67f17a77643253410c4c79f9d4c979b11e7e8adb8c765bd16d115401eab3d9cfb4c0a384b7167602705b0df681d09ce28b907c93e8e530d7459488302076672c5ee65d505078e03550a17da60ce03b7dca451e20495e502534ba8a00d0ae6e6f30f690e32b439f0eb3669fe3d7d387be35355ad7461c9771598619329fab6a2cd7b6392f04071a244de8af2dcf347080c1c136ccd15df84245303306b2f848eec82d8d3c27debb9da3d1499f002f2b2647c3c467393689d5bde70d3af9f913e56ef450f2d8b9a3bcb6027f3fbc3a9130162b2031406c25e76d73e5065181d554dba8d80e7189cabcab6beb40205e48c5816ed9cdeba9814de99f05285d62d2bc421c325a17717d17c02325ee27307754c90c515181bc097b8b4642a119bed49bbaf4d1800c673be59623788225e7d1a18718df8b74e380647d30f114b36b0b685a4c3d44c2fd5facec08176cfffe05f5c83a1cade348578d487b398f5032a7da9440a08add8affbc136b716dafbf19a49f10a59aac86f8e82b495a29305ba4ba18ab0a172d02e6f11f17901c2d13c406f96faae1d9e7d2f8414d210d8032661b25423652d1121a5ece4b55bd427d43df8e37cffe4a1b8748ce261f712bac628ef2114a1d184e1a0a2526b8a98ae649e4991138a7e3feb0fdb4f62b953e8d490ef4a1725e3b6cf6a009941833431b1cb24e5c15024aea1dff384fabb6ed2dda8908ce936928211422cdf4e3f1d4c7693580884aeb2ed9eff5c873e5eefcb276a52a8a1e7ef767e8137c1c88746ef975065d59cf0d93b4121da73512ad46964decfb654c576932765d29c370100ccfd9dc18c095a574a79cc4e612a24ba9ce3396d383721c9c6327b7c3745de96a5b2a695f1a81ea1b7e42be6b44187b58a1f09ef343112ef5d0831cf658313a943cf30b4054842713bad1f48a73f0488afb1c694c439f0ee1c3ac64536aa30512fbafdf6201b8b1dcc599bd8892c4560f13177d873c9404498faacf83c82e208da08d3bed926e9329442223a7b53ffe4f5899ee269d9f80ed37c07c621f96bab72e89e4b04e0f558510f649b79b1a813a7b8bb8419c867e61dbfd44dd9a5a0958674c53714c3c930c555ab46ca242092e6a6bf37dd992468aa4df011684f64ed765e77990675be8533e6db5ed25c39b7a064ffc7b55cf6b4c5b33e8111dea332579f5bbbd0780462b81213c163f67550598c80fe10d4a11e4bc3ab50b33f3168d2fa6c39c991ca14ae6d3032b079263338a4c4b54be056c95808d65c59a3035aea82ba19fcc705920d1fdd1fcded194954fabbfcbb40958538c602faf473728b193731ec35df53c510b3a057ac08ee4b924035818997e861645f8723df46dce1d670c8d1fc6a1010895237ec7b78223b885f6b30eab61e24ebd47d46e5327f1f9de9dea76dd7c0ce59c7489d8294380ee6caf86f7ef7a3680be57b4c88a9ada59f64606d1effcb217e52919046bcf1b4c062b10a98ee9ecdafa42d91020ab4c8266c0452cb8f07bdbb5442124d52bc37c8d930450f57ba063d64c1b45251fdb53b555c449fb3d03dcac725ec8fc93e9eb70c14e2e81d797510ed61232a8b495859954936ce22f71e3eb39d329205333439ad685a58412a396149c2a7b91caab3d5ddfd0d0ca7e2f0d9dcac50d047008731b91515c7e97e76b1c642aae6eb1b694bc9aeb19a636d60fb14c2550859a923cc9c7bf19cea42620caa87584821baa79fd982e7580629293510922c8d1ae5197f1f67868b178c810e3e6e6b8671179a0c25c7b42fc4392507ae5f5af194a6810f557c26b8d594230d85dcd547f63b9c10cf01532aa9225173925c12adf9536b644e7079ebc7626fcaed64cae480af09df5adcb008317636e30c267f5331f4645852737085f528e78ec6f44f6ac170b38c7853570b34c4dac00f6bb34e169989e61fc1392374236396255d49ceae8241a2f019a52de41ec4587a3f0655ca463464ea854769f15ce1bc73f491b41311a91156399aa4d6a438414a402f5e7ddf6a5322041244eabf01b386ff6398589621bbe096161453f78e10d18d6325e9f07c350c8782305e96574b6450cf96dfb8082a2f50cb65b256066c6b85ae2c16af45495e3addba458060ab28f867a8b458c58216b3c12a33dbf87d05208dd869e3dc1183981fd0952df20bf190046359ea1234e9fd061f1e74981047d4aef31e03d8e5bda677b48b61aa8e32490eecf69b1474360d173f3c7db5596bbd0152282a60921b7b380faec9f7dd70617e7874ba5f4821fad7a42c8e39601843bb294cbf05c05a740886cccd3e6f834281e536d7d9909e4ec1d788a4249339fe4ca3fc9c80f88f45e6e05ad490bf385995c81718615846be16a10748f639edde2092ca602a08d4e4dfac9bba7941ddf9f31ec6d91fd044ef877d4a78a847c5fc6f6dc618b045bea0553bbb1dea98c5fe375a559e6e6ec50960b0c16aa3783c5ecd14451772d55864e46ebacb8422e431b0839e824841d7a014a49a66d057fb7542666a0893ca7ae02e3087dd840258e6575c931b1e64edcc2e4002c1f0f7f30795b659da222c5d77941862d3483d44f690167dd5b6033bea47de4c01955786e74f2f5b698a627d69eb209a7ce9cd1642819aa73224c2606ba563dc92c174e698c6ba1090b4f6447bc3507a6c44e723717cecf1edb95c7263c9bc0323cfbc941d2a68160c0bdf83307d08a5a26a061839b729ec213696dfa2e59252851a86a6fa53f9205e1b4ca3517a282759bee76e87d43004aa842371b55107cbae666102cad03bb3e6e20bb18c3115e7fd91bf19c7318ea62db6e495a0a0905803bbdee908939f746c2f174ac0e755194f211c0659b7daf3dbaf672a21d6264087338927c9d548eadf6cf2f19bb899c8df683b90ae7df4b39aab7d6f22fb7ddf92857ef9bbd5eb83508c4575327a33b2dcbe76ecb2ae6d415a15b252de4d2580f38363b14843f40b6054c1c6c88f501ce511669158be0b1564721b465d56c68a3ba338764d1429be744cbeac1ca50a7debd9441cdf42c08eeffda844e8d7a2524e9d67c5c71e398fff36a392195ed6faa3990d1b9061cfe79f5e3fa014cb71147f9e73b04a0b5d2342f760356c9ade314644307cb3f82bae876992cfd2a44ea30c38e63e3311f7afc00714e0a90768cc59dc06681ae2c054dc3f07230460da868778d82dee91584d2b6673362d319c972d2a4644799638802d1bf879ca6ef9898d6ba781c6f1361b3d8b8253b8c664ba108ef68e52d0e24176e25b84fa3b051da55e148d62026b1875bba728717ec427927de6359126a38f909aa93495d9f24c08687592d994dab6e76f0a4a7224f572f300aef2792e89af8ff1d52a157a60eec973a1b2303e8b5ec5dbbd55296cc4aa40498d6b08319f5002dffb9a8d5b774b2b0ee9f82da78f4d0c9a65121ebf4cc8939fc37d4325026ae82dd9fd6b279e87bcefe6fe6d2d59a9f198d278d3de3c8c66036ae04e4455ad4bb234b1e19ac168a96f9ea68e763d1f3c4b16ff230f893a49d7a252240bfaae3bec0b6d59450a6d76b171728e3159b5ab55f80e67515b27cde4526bdf5b23503c55045442f3c7d06c0d74de603e1fef57551191f8bd7bae0ff4d3010f7fcf432e39f2d43d082a43fa7e2c93e2626d1096c8f4d94b83d2f4cc1bf12098d63db5e5cab48dcf9fe0b38758575fc5c481597e94a74a0fb0ef4d75c26502a1721cbe579bc4e03716bf60ef0b17d7d0facb24a309dcf1f6cf5630d7a765fbf6e990d484993332b1aca64b131c9b3fb19ada34e04a65562c614de34ccb8ecac3ebd4d6f1454f782c629b6d87b8de540c88b4fb2edf7255b83c9e8c2bc81a5ea265cf743d687098cbdb15412a018d7a711f2222c558afc3e17da8caeb66a5107cd0e08949479925136bb176f9dbdc25c1ffa5e988cd4ae2732d4f0ca57d413baa90f0794afb54034c700cf251e67765a53d7bc8c9854557086f5445a907892cd1dfc9b60c8503031a52e16ca7c8b57660b31d2dfda80b0a2988bd471cbf3367e9969a177b05cecf0ef54f71c1ec91529eea72f5a6f871432e1d517ce3167cf7299fbf37922329866b317f15aa34abccee7cd9319cfc1171b8b7051cc216a9c7c09972b5fb0e2b2e57028279ffd5e6bc6cf6c46c7604de8836ef3383029c523b78efe5c3583db60248fd1507733a58ca923546684d9f847e26aa382d4e2271a5a05b282f9ca7bd2ab98f3e7e54cfddc15a5aa5faca32381944961a901954744243bcc50545907604a3ec6df14f4cc3750e75f2bbb3adf468eab2e1d7a688b833c20daa64cc1de58132478e467cbabdbf8403d98987640760dc18ef00fbf056c8ce1135dc6b1304183b6f3da8df2d1d3fc4b46579e1210f67e57183b573c43183d984b3d48a8596e977f9f717057c646a39cc0077f999c5b7f7fa17612e5ff59afafe7e8d7403a6f2f3fee30fc82272ddd3dada3f108fe774c4d28fd31a7bc777c124d5c206288bb8dcdf4618a92552f425e185824f8d84f0e43df08ebbb09b9c13bbf15787941a16c930adc9267b3aa983f00928a7250db2fa7efa585fdd20434b00338106c9057731dfd09a99c5d27352c806b437d25f76e687ef44cc14ce4c0b6b6266d0901940c886699f339bac6b0f61a8e0784d90af064b9f7a3fd23101caa42b45840c3f6d1b28781f93d8b40b2d7c04fcd392f98b3dff2d92d9e2b77f9c85de4d05325fbe108d4838d86a090294fa39c1ffbef05f70fe0a5dd404daadb25d75d64e9e307d4b7e516eac7b9abcaeb8ea16d5debb271d15492681e1ac16966f08481eb2cefe820e5a59f09c869359a703d73f0f0e2933c59551f317ae2b0e91ca27a6cd3591fb40d9c030b1d94e6774f3f9d38f69075fc8edfbe13bf260d1acfb56632599f96a5d95b4e0c2483dfe6e9ee3016f2026011e3424d71489b87619ca6f8cb8f3e07758e7ef5dc9c57117fb17e5949044a334fa4246a17c6c0ea43cde2ef0f30a6888fff2a12637c76482f655882582a41494fb9973cf2835f45add77b1e04bcae4f425a1ab157365fa7699a4aa142c72236ff6ded9bb5aef708d21ef40c8e8ad48f8006a16c227dcc7ce2d8b89e5f44f4b4b3f0bec7fd572bf4a61bb8217c210e3e16a0c27ca568332d7fca09da1a75523adde008e654f7df7edb5a0a5d97e48472474f09897581b0ea231120021d4ba59e5d455d24f9c30f14fc9561fb0cc6288314e4f61df82291aeaa3cf92b8118b9d5e20da8c9b3229f91509aff44e51e8b31840b8fa20db5d464a3960931782c53a3f5c2beb2ea7565c497f463708e2a163f0bb1d1e460d3dc48411b6d828bb46a469351dc1923308fe970884f27d3574c06dbd9a6debaa18bbd85d7be566b3f4c9b41f63b52b421383d6035223f26f838cc2a13415b9c77b948d2d1654132a42dfbef1589065b6d85f05906072597a7ca7e69b373fa69fc896066ee7c02b663755bfdbd3d0f326af035cf183d51c42671b19040495e89af1cc47b2f797b263e545c3cbb2a1dc7d67cf6bf5c546b0a93f1f1dad572753ecc872ea45edf79013fd36278e1be75532c8beeb0be4877c17cada95ec001a8c1f7b9e9bf9814bc69c0efdf4ba9c22343dc8be287814de69896de0a148b81b78a23cf1a7b5ba4565bfdb3a637e95f1ebd9cc81ccc08b5bed22260e3dddbe5acbae4cead4b086fd3da9b8138a7e2bccd58d7a605f0b14bd5bb1ccbf0996808110133079a6c684c0ead74e6f481abf3749cf4fbbd36d2c4d341cacbb7a058a8ab22e1ca8d860b4e3e097d0e2cbe1c64f87cbd3937fab04e24b5f4313eb18ad2accf8cb15ae7a0d0f8a7d9762288ea0f94abce14610d512ae8a393840c36963b9934d01176264ff5d3a530d5c61e60b35c9241a883a8f1b4eabf56dbfcf04b44d7810f4d324ace575914220eb2f9a8cb940ec11213361aa5ba242bb3b4922f4dfead45612da709dc2e63df966656d1b240f63d0cd8a9b81d3dcdf3b8f9e6f33fac09fcc25a3c52a7fe158f5bf53de687fb55e666415741cd548a1c9857ef42e9121b10a2b7b41a60a9f0eaa828700ebae655b728caf1da0197d71369894dd5d8137f16d3a6b19d5a82c289beafd296dac809653b5a8b8dc4818efe968c36044fe54693fcc538bc5a66a6d20af270fb6b34f293259709e432f52dc396244f17d70aafba9f31e4778b57bc2cf8ab6893c38631eac67603822d0cad1d6b9674f6923ef22069591f060b40812c814b21aef30b42d1830f33d43a527239627c20238d1fbbce3ec3951decc9a62b16cad83055fb1040f123ee8dbd5aec1d3fd4758679ed33bd1064f0a76906b3cfe8db13fc98590910a7afb6bc317e24ff2d08b0ca0f1b98ffec0666dff59e5bce74d3fa3fc6e611d0564ddea75e0c75a6967adb183f6449706ab75d8f7f783c9d321ae01ce249af2ccb9afcc5906cfc54aad1e0ef23154b843832123b1a84c5889869ec57d89843175e0cab04ee4c572badc484fda6b6f894ec6b10e5e1e667d8d4f2879d80ff382e91d68c0fb5a84b450f5fef53167d420123f3facf7061662faaba98c915749e9f599c937c23cd66acd3968ff66aec49c518ee084efbc5fd0186805ec75e61e29a3fea5082f76f51f10f90f6fef4d40b68968353f52181d0b46d237c51380162c1f03afc0842156784f49d5873e997a88c188ff579ad0cf27ccbcc7c431064429b2f713f6761e7fca74afc7779d57bb0c696c2c0c817de27ac2d62919efd16393137b89a0106b42b0c74189df8e685a0895c809383fcde2c8211206358dff26576d2904e3eab7f22ff96683d811f0d42bc3b6b5b2589096dbc2aead6fd1fc31df1760dd6a2451aff0dd1e3a0fbd929125aee0fc8378b5aad7eb33bbc6705fe98d2c1255cc5d4f1784460af6787c468626fa7c2b50ab9cbcd4a4cbac5799aa30baf1c11aeea81f9d2885d92ea58b2424dc547672bb7cd9d08d9b5baa68475bcf2f2b54c0da5813559b9aa2047d64d9bc7125ccad99b22a7c72652dac06f194897925520ce48beea548bbc3a734c2203e86c7d81aacf363dc18da34e0653e76fa4569290e67887cb04bacc0494fcca1cc3d2bdb928210e9538cb108a025487f53d7848811212b515d70d7cf94ad0cfef34dc6350dfcc3857d00aaa7ac7b952e1ee6221b8759cb68e98d99660566e8285d66cdbc95a794dd11248b3960431b201061fbd73fc8177c42298e9242ab8f8ebdbc5f8fe117d28be7d208b61ac8d5cdbd3f8c1ea607dc1cbcfe3c235374357af5b9e28005102aa520b76de498494b3e7862f3c0a21aacd18debe91b10c3556ce9f27a9157cc696ff5bf4094ddf2ba23c37f94d0818aa1fd035126132a2ec3f1ac295f05dc2048bebcbb8c8cad15ea4f72a713659ff526e7198f8613ee3682dc874c000ac25abd243be35b907fec63db15cf6dbf04e17fe97c73693a6f959804560bcb4ae3a69c22a22e3b1e59a416ecfbe6ef758042ad16c3e97a09f29451824f2df2b0eaa22797def50aa9d421e025a60715a845d69cf6d2a91beea12658ddddf338592c62853811487fd330759d1a74c2e7a0c1a7f651b1b229137040b48c459a7d37b9dd163069357150725e94de7480be76afcb879f0f986af716140864a726139965991ba22cb8c43d4b2e92e7b3af5ec95ffd5848cffbf488ab421058268c8e42bb1e13a0fae2544403682d8640203fa87668c28ed46ea047db9bcc2cc1a65fad80873f5a3e7061a7314e2ab0b119c91fcc7edab034c61407ba1dabe20abbc2f223a37b04c0ef5aa05c75927ad196083fd53a4285d21cdb3d3a8cadb853d1d8e3092d3ab159f97005e708e0a89c4c39fec02b8fb2b495eee67a6584f7d2fdc4e858c110030bf6b50f233c0ad303a75bf7ad3673c5aa67f2c099d65a0c12a217ff49d16815741b4c5c3cc8b3c7669d8024e0be05961bc98459f7662ecdf7f78555cef23060c0a7d91a167412da81b9a598b68e718386edc3ecc17d2c5d78d43cca16b1f3651e8059bb09187918ca47da3dd015416dc7bd87a1d17369fb14cb7c21b023d1ff35f0c66c29b07c6ee77fd07940a6da662a016d15fb7d8ede9059023e978eca50bd869dbb7544a7a93be3d8f73a204e9056ef9834749457dcd383584b54b531419f57dddd22d87fcc5a3b9a6d9ad085f4e468d23a7a026c37d536b16a2cd2eb07c6fc7fbb56d10352e0ac77c8f116aa527fc0cdac63f21983729e45f0defc398f5571d4dcad8a2e9f713180627efde245b034cb0450a0481133b90b96b66ab8eb6b35ce65062e97e7ccf599ea0e59ddb6b4ec38cad85bc71dd00403b6bec103c6a71aff44ec7b2cd3f25975ad6d9ac0e9ef3e9f2ceb7c8bd0605c4a4f9dba86e0a0b363eede76100a878da1321e09a49deaa6ca26282db6b241037afdbefd274f40b0a2e9572ab2fcc31406daae695ec8c876b9d2ce13d09f1e30fd315c0ecee866767e7cc16ebceeaf0c76caacac82217f9dbde53e20d59d871b324575b767921c16267639198f9443b8687ca71f2760ea39226ef74f58a9ada4699e2914af80e0ea421c4690b5a6f38f0d3de1dd5f0d4b58432953b3a0295d74236b26a4ec9636cac227dd8aa5c133965e60ab9855a6d74feee42b78a0792ebb38df93da26b2e0e6f67e02036a0a65a558a899096f0edf2351098e5a0a78de4a01bfca8b053b4ade95454068c2439280dab27d1134537c3d270522598a28863883eac54ad6b33d24372734c29e82b3a70b9817e5ac8ff4d6ed347e4416937e1f8d93dd3aa2af6c2d9b0077d755c395ecab66b089f152451e37b431e1a40a4588676109312a45957a0ab642c941567d004cdf2f1ce1ffe8f7a0b24ace2d427f1977673ce2e7f82005a83389e8cbc6003098e825f42498a5f5eed9d95f17d31fc2221e50edd99b5ce63e2028d2caa5a5549352b6434a7d98cd8ded78ec9fdb731cf563fc10fa27fc527e69197bcc645fc3bef46b1ade75e9738dafe74db51b76823a89511c284a0d5e518f9b7393f06136d35b7c7a0b7878955add8193b5303357ec016ce0828bc653828efb01b87ea9c2257f2f27a999ca00af6d4c32794cce9451f94bc74ed314cd2e45e0f0301c691cfbb0ad354cae15100e7d1f50985e4280df31736e11233c9c50dbd51c9d93e2e99f278243014b7446076ce719a85a1c83b74d4abff8dc1d59730bd97e72321defc2d2f2c09827d41071ee61dd0940bd7142c62039b82a4ead9047f77bb5fa0a9bcd6d1c9f4b7ec45c4769d4769958967a6f0e1bef811f130ff9c2aa410a5a8405dfae94435e38ff97508733f645553980619a0a1f4b17e3264c73226d3181b782772481308739ca835ce97e593792dd8f1887dd34bffa4822a7f16e348749c3637366e167546a7a1d63309973e8e4c4ed8fc221f5919a4a76257a13ef9991add7df9011e092ff0caabc1ec18294f2756f3166ecdc2bebba8fcc15e9a396acb6dd28d0c98384bf4d1f6c4d25798820955b3cd17666890bc30b1e2386831b7bd7219f48b90a558b92eb6f8735aad5b75939b3fe16f11a3306170eab95a042706bf1788a2de67d5a8ef160233c51b835e7f09f735645c25b8922164d1f5a7db322f93cbc2767ad21b9c238557ba59856b2b99fdfadb2ebacc4129d1ade774e74f507e0a2c482f87b5468930ae1578724e7e1a059d33ad47e8e2c336e952902207d237b894bba069bd151704f8463de76b97bab0c0c0921277d930bce7ccf6212b5ec738c07c701e340a039e267e3f9478b939bfca2e82ac7941f0e723514823267e7bbbb7856ce9ec812daf47f93c04ace676fff1b67eba8ed0f9889bead6c9424a1276173625567e113a001b098e5fdbdd8a66bc768f506ec76b08e25a7eb32f3ed2bc93613a6f3d74efa434dd75d63abaa8e40985566bedd246777cbef608121e01c0c358e4491be9ed1a7d6f4b6c48eecd13a85114e7394dcfb6c0f221f0597709b089eb84a5d4dcc30e8a159df040e1095f18bf0eaa4e337a2a7cdd3a80db84afc40da3fe235741decb10ec3d6b5b44d08af90e5820aecdd4444a78e30e5708a35d73cbf2a424b0bdc92efd86c1c3943d86b3ccf801951dcbc947119749c72d5779fb36ec120f930631ba4712b760533b2899fe1ede39b77c50cba13f74f8f8ba3fbdec8c381c07c28f424a84a828295b04a0dffc6bc3e13343f77272fa3926852805991a8c3ed5842e6923da6db030e194889bd3d872e1ad79c1659a53782a4b56a266eefe25314539345cb2e9c6acfd32c41ca0cf2bc65ad907a3170fbe446844a6811b03aeaa0c0b0b24d61c8f9afbba636d2ed87009e477d33445a7bf91dfcfb72a193d615a5218c4c9439f46e8eea27c6937c19f165c59099e66bef90272a4c5220adfd59406349bb4f755e06dd4c6e02439b7156e99a8b412a478f5c5fe9c8c829166ab76871dcc575c8bc4cbfd40d14dbe450a8c04285659ac0ec4d71bc63881dc6619408ecf8b6ecfdf30c07a73ff026842c2f3f58f2ba646419521776b500000bbe17d9d0398b06d3ed0cee1f0ece838efdd2324cfb673dc81e91b59b8e2ef2e0c8f44a44a4ad108f2d80ea45c5205beb9b0461b7c3bda48d431298788bd8677a51354fc933a0209ea0e91721abe2c896366e1ddfa6078fdebb36d2ea222b3179b03b89a47750909f1aca858b813ffedac73418a37f030aa1bd9ecc2fc89e1678b2a04bded76968f1690b817a0014dec3746f313adc984f5a2d8cbe0c10ebefae46ef97b92b671c77a99bdcba8af6fd9a18c233949fddd7f274804a81f1122a493fd28d75428a0e5ea530c25d20df492a4927c5a231a1b5616cc11d1c3e41fcb8a7f86a5bae2ce79890de2555a1bd02d318fbf09be40fc9e2c4435a7382469d07c93e83801bd427258553d314992ef91f56c9761895d690bc282d66ad5df4f23bd10598dd2e7b2b352248b67b079b753ad4efa88b978283c0a04e57d9b6309563a895c377be314897f6e9cb9e760d9c2dfa39be62b82ce5a2e43fef043af9f54f8c377f30830a1095189896f61b7022cb7f9d10d82e6f93a7a85f47de3443307b94112c016d6834a400b8a8f307f2b617350130b9dc5ab8192be1290f1d763dc609fb2b8ae5c73f391dc08633d7cc0a6a720470330349647a8415f9ba93a6f596de0d4ceffe82b74ea7535920e1b36ecabe24416d3771d1173012b9e5bc4b6b0ac398bf3ff2c87ff2ae75aead23e6c766285ab613a851fc53d38d7702d874b341fd10f99c41e26f4b7f069117ba077279194b8b9964272449f67f8799d5066f9b7f5a46e23b8df71052de6c6adcd327412d859d4e814ea0dbf9762e4d712cfa19437840254c2f82d116acd6953a51e03f9c26ec9778ded7c9055eb20e95207216a7a84c52087d28623c57941a3e1e181d8ba019dce1119e9b9bc423a5314b80e456bdd52e72c2c0fa8ef16973addd14150c0ad07aa4a9d5c75e17c391931286cb05e13e2c08d08637d586ca4002b82be0d5fff1d8a4535d38b4977cacea66d4f95e9ae19dc3468b647fbcae08802e0e9b37a42a2977ab2a52dd85900c0076f988aa09ccc115faf024e29dbf92b83f65d57ecd0c7ea463e06faa27a16f4a497e2ed669ffbf0891bb1d0aaa9cd2f4fbc25cc7ec455f3928b793709c04f52514db9de63285d939b73f39617da71ce95defa5468171f894812f52e26300475765089965611f7b447527e933238a84e8e3ce554a57481569ebf0aeb404cd48cd3373a59557dbd52ebfeae23325d75907927ecd5e3598159669eb951073be4b8f5a992006ddcfadcb8528ce11f7c14ce3ba5eb731fe472d915e167f9d05906763042c1e1e03ee1ac7f8c109279f2ee3250846409c1715846881165aa9f89bf370112e53fe47d417a2ac4f69104a2efcb10ff86210012dabf52da3e77e7697448c919834a7ebbff9005a578a0195728ab6bd7ee4ca771fefcff26553b5901278e45cd520134eb1d2844616f471bab1d0d6f6247a5200569b4b2eba145f9e8c2c350e814929600bd7f5f5ad918cc18861ff2036292c8c5659ab043edf7aa125f591e9cd95779df479be23f48360f3a03fac8834f5ec11f8e43254f6a7e16373693ab340bdfcaee6738d70199b7506572b449f2d9a9917a3453896fe0999ea9599eadf5b33521cdcc052b65c81444bc8830b01b56bc18b1363a67c5faeb85e9a2804dfe0e18362de00b2653d01b5f4fb0993eda15064fdfb4f9a8913f60a4d48fbd194c24be7d0ffe2ce3c8bf0ca9883d39dd3b1ba061ba24d4d9ad145416141ac238aae0bb39f7253c3cd1c2293a74a615ae314724d48ef07ddec82b6c14bb0dd9c989d23c8ce2b997161bb18d4a1e1a9f243bc711b9d481ba7d6f1111b392487a3773a84bc617dba15fa187f9356ec6691b739a1b6eb9807b468cc2f7fad23ce8d4e97a32a0f768e7ae1f74c23b50981c9293dfc0a1370e040ed0bda2a6c119da577fa22d0b111d271f0e3b04ca30517474ac6650a5478d5deb43b05a93afa3b1a1a6ef07708d4d8f81100e61125d089348420f887f1bdd980db46be161897a35440c23f95632b2ac09cdcd7fffb5a121f6249fdb7c528c836cea0330335a8e0b45dc5cfa32358a4ba93609047e3884340dbf726c5433c1f9f1f1587d936b60c62d177776bb167eceb05723897f7b4c6e8e568571a1d0a2c186e53c22726045c52f2e6cf8e68697c4a5b158caf51a2d1613ce70e19bd2dad9cbc322a6e232f4a2477c9f0a2a80822bb2924f18e24d6b7fb35754e8cb8bb8e239005f52ebe75c185356edd401d7ce070bb18519f7ccf684892f38e92600f594621d0378fbef9ffeac5f51535421359c19318364f575c202652afd427b679c8b2cf254898d09257519684861301d37cbc0ed0796f0c5b0d460bf48776e7bfe98d6e33af3c71737f9589a825fe7bc36e7115adc2832a780291fcd6073521d2b97c162316f7ef38c9e141b55abef31518c8a1ee43ab0f5d342d3fdf3f5323ccc0eea305af8cf475b6626684a582388bff5d18aac66991446d0c040604405040ae3cfb70b25808dd7d6768d9c99fa60515d8f799b1c1a9dfb9d48d1cdad286c8ea571d037c6c325a66b378c24b9409c75cfa3217577df2749c10f017529752deb3bf19a527101e4bf0d1d8ba77f433ea092b84414ccb874e058544a6e4e8ba9f0b9220bc31639700caae5e213811546efc1e2c2dbd4972a0c683b9d2bc5243addcd13eeeb2642799349baf127be8b584f387b53162f1041f9b1864cf8898089828dfd43b9c7fd0b8abef665c1cc827963cf5b943674ce0a45ce2770ab70bd2d18925e84fc7635829b39a2af32fa1341bfa77f5356be2236203b9b23e6e3977e20f367ddf723f23dacbf26b8d7bb6dea88537a6ab5ff1f5fd088a046a117d0596b1d8827344ab7f6c537ce641bb5f1e7341802f5defb9b2a636defa664e2aa1c474bd8ce0d77ee41077d018e47116ae903720593a38c415215428107f7623ef426ad03524efa9fd71ccff316e1d282cf0d5174e9fc768dd402dbdfd5a3534444fc8c65ebfcbb9e5c11ce67263dab9ca65adfecc1697cbee832c796548a9788dfacdeb119f2b5620ee00f6692d39c113d495edc5c5876da61b13aeb5e7ac2edb2e51108bf83a6609a3f42b2d6015cba357f08e4608a90811f66f2fddd0958d1ecb25de404feab75c74a39102bc4c696b218e122530f8c62afa8686d90e02d0545f05df7e8e921e3c5ec40b677ab655519fb46bce4df64d9c3b90877a9fcb49bc50a5c5e02d61d98017bd1d6836e0138eb6ecb1c797fb6490a3dfd2798626a694bce7ffd5b1ff6dacf70d0aaa657371853f9ad5a58c10e4a24013ef98f05ccdf875eebd43f6f92df04d115d3d58d4acab306fa36f0fcc7f7d99a68392f51268b808e903926dd651075dfafdc45a4fe9c815e113254a4442c3673d440ec5da2acaa09ba58e664bc6c7cba969abe5a370f92ad525ba86d462fe5a9cea8caeb75cc9d72d5b38df340fe6b1a2327f6a0945fc903957011f50e05065d7452c4ef28b32c1c09aecefa69c94288b48f57517c89366519b329d8c435d05ca3a956c2a5c67e321d0f57e7cb2ad6305d076b01a1a2915ed0586922dbbc61284b7db0a9e75bbbb93721ab108d0bb62d0b2ea97d219c7fb57b40a09391c04c03639657d9fa077117176cb76a656861a496aae0c94a071da054f77d0b7619a7e0844c738e952208cf897f9d9e0f39325540e44957c32cae024e5f2d017fa8830b3a0e2d756bf67ac20e7a86f17fe451e39eabe82dddc1825f2429be14fb7719e730b0f19f0d6849426065bef5df3593fcaba2510c7be443ec3af792b879c453e162918c10b5f3b8f61276d7417a5f909ab8625be28736e9d7bc71bd0ab662003b93465c95a1932b9b2e54c1b2f6dcb9dd8057bf4df3df993a4eb4424ace483416113062aadbc7e22d132f6ee0b72e8e826be920c77bc479b983a502dfd63f187858efde1b6e7394e07a328979d23dcdca6d3080a429845ffc1c65aabbb5f57fe2cc0ae19e4278d905368abb15128209720a895dadf4217643f892bfc2e7cf422700bb53efa03aae4be19ae292cdb928c59219f250ee4eba862065689dd4941e0d2253e68029032bf3c822cdec252c66222b442955bf9024b94bb228a45a6f82511c314f4fcb11cb97d740678cdf4295d0eab43b9344596f4773a34ce5bd127785930786ef04b458d37d7c43dda8faf418b75e1c96d4f8d0b9cceca0ccc7e7a6fcaf4b57064ff84a082af00fd262e30399235dad615d64b964a5ba35f37cc3528110f3eeb9f51c738c948b817f3e13e0ce060dcb54efceea18c7255fc50e68b2439ac6a68f49689df6ddbb8b5a9d72710d35c7f3ed2aecb186bc0dde75cd48fa0d40a26be9362c06ae61ac80e0c5c29f846ce931e72ebbc98866fa95f6dd49fb5f0a5455bdc4f3f2f007a73a1e3462bc0c858ca64d4cbf9ba7cfc7cf866b0347dfad75d62e6bbf648cd550bb1388394df95d6f18161e7cc788f7684297afa00641adfa0909ae5a5db3c07217b7698c049da8a3b597d23734dadd8de87a1f6646908670baa04d68a73bfdb6ce415769f73ffec4ad98ecebe5f4a04b3e1b0fe7249a4089c69bf626a6edbd29f9a4c93936bf2cd40c8d09d41c54689e9aba21467731d30298aa300c815d29fe55fe04296f6fd48a049a79aff4d8e3645f5dec970e9295f56b7dc5e29d64841b62ed58187f0b657a683be4b5f30bffe65bb5429f3d746f9808482f936428cdab323a9ed6e314626c5f84121ae86d7701b878aba23989985aa03a166ffd43feaa69703237092a663b70e4b636e8bd9a8e61677636df1aef9136e9b7fb00a63428f4b9d8eeb594530d6c28711604bda4f175d58927c6dde094a57627ba29540e034b4613a7e40ae2ceda3ec4319852c1cde0b0a00e6202bd1cc4e4a461e34498dbaa7ea76d7a10218d7baefe0c259e5ca0795c76bf2a040372ea0f277dad80193979c1e1b92ab326763e2a7031b91071e2e6aa06bd236a86d3721ba082b39058f8615964e4bf1a9d84041c4787369db3802b3fc898275b6be9617892a53d9aaa28bbff77cb51cd30b99fc0ef27b6b0fb21c6d2fb81f85df36962f43d893b4156237ccb2063502c8a0fcc2b0156aa8d9d1c97a17c16f8662453af77d970ea02dc3331c770b225c9572a6702cbbea444e4cc2a5da3b54eb37fb719b10004910b98e318e1ada2cd1d32c5141956dc5f36d152bcb0a364eebec30fea1174a06c550313006efdbabcb95cb392446e528063e16d4d278ebe1e74b5bbb0031a9dd2229e4ad6cd8fff792c510a849b75a117a38b3bbb24a34b1bba5d406c9dac980a951e6802713da2195941c8f8a3ec80d0a893cd89b6184fd33d69c280e6b1c2a551c01d956effb332a4d98b167ece9f6c161042a66fd5dd987508b4a1bb0173e159ebb5398d1ae87ca7a8b5ad2b14ad617a59a97afa258e796589ac246f04428a467271e3f21f439baa4d95f4337bc38b3219114492366ca7f8839ac36f938e38dd3589a2363af808aa0c1aa091958a6e619d7bc56848b8a98b409a7b75ec07dcee6aa3c30e565a1902d946617dbc9db729a8b0869a6967e33fc5e097a46a998363a48140970674ca919f28961ea000a8a3954c9a7ac29926b3aff46f25ca0dc458568d44e49df74a178006d85e4ad0015478940b7a53d1bddeb77ce41cdf70f4201ba75e1c86daa624afecf426a482ca1482d5d4e45966255935c7d1fd463b75d21e61828f0e2e6ce394bbb0818e5b8aff7099fe09c8491f4cd9780b9c282222406ed92843ddaac096a003294b60e880c9836a4e86cf0ebd4ffa8bdb4352d4c1312d199cccd49cf7b60fc1fb62f0839f867cbcf88fbb4861a7382cfb255f00c5f354ade9de2f39ff6f08c0758a7096dea3be1cbc746f4f93e22e017a5a25fa186179423610cad068ae1dbf1d1c74397df5792f80209b4e01724db9eb40132b80113f50806c0d43f5b4e1a25a038dda8c2d8a4ca2d7028db00b2654ddb3ed6a9b1292465f673c0464694a6d1dac061875ca3a6059bc89a8912100c858e5d9ccf8ed5b70a89d5b74debad3b64d5e84e496cdf4985f18fef2f9757310ddbca161318aceac81163652d0f654d7f41aef5592ed3ae0f1f286af5a2828cdd3c184a6873ed8d85e71248a4bb3b6ada04bcfcadf4e4b6f5c7bf86664fa1da67f37e2c422a48cc7f6440bee8c4de248119459a6540c9e1f891eb24e2b80c73a3fd56979480d328fbea04c5f7d6c13b4731413ba182fdce2d2d2147b7443238864e73f9c89ed433d7dbc24f33703d253feee9a9d4834159b55b08c77b3624ad74b4f6f491e5667b240a4f27a14f6334295684be4ee4854606e77d8f56595e38868a804c7e3e262e7dd198a7c13b5abcf675747d1125c279134838ab9f2168107351d4726dc049b53ee03db6b4f680bbce9ea9fb31c440a6cc55e3e2e12dbd959d189f02ea6e880fb01969f81985b93b35743d395742525f9eedac06b85bae4b6d66671321435fd271e14a88e867f5683e1e8f86c5a4482cd9dd2dcb524b6b2e603cdda852161a67ca9b9da8985d941f6438ed2f3f5e5b02a1987d2af8de561d34084681ba5698937ec60cefb70268d42e66e5c2a0837465f28342a270bdcb588ea31765ad910be570f62fbed7c74d0a6155e69d9640d2c1058dc4684272a34f0ee78bf3504b3b87047cc26b147412d0a6caf2036fbcdf9991f7b47b3a5fd0e83def9c52fd45a2059d231f4c75d14d2be2438313f1139b10cc9a26f5bb1241203fb4e644c54a4a0","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
