<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"457914b7381414632736de4a9cfcb220aa07f23aa3d6b9c8bb035ba0eb53b907744eb933a51f0e0439b763712f4de04227dd9aaf259ace460437f058559188d874a6ffebd09edb39e1e17ab9db4acc95a30568ab123e923df463534a2e9d9b41f87c8128c94d5ffe1aa497e75de1f17b625bdb9071cb0f8abfd8909b7793f85f24c37f7a3272236a7502a6e3edecbd56500dc7f4b8888e13a3a4b536321008d82f370e3c10220034e8ac567f5a1ab9eb22e9969c126b1afb0ab0898892ff19b408d1686b0c98f3f8b106bfbd659996df4b3b3400c14284bef19fe1e123d14e9b03118d4913a37f9707648d7ce4d7dec8defa11e87ef74352c74af1de4a828fb38955bdc9287873f28b7ae90599c7b23ff5177d55bbc758cc96c5f9a2f0edc2ab602f3b0b9716a39957c37a84ec88b7b2deb9cafeb68899bdd9329c2d80e8413dccc3f31318f21386d456f4c73c2af38ce3ea25cee1361106df30ab078e84cd13ba957f2cb3204fb2615a48b0f4a3b95fa64d3ffd8f6048d7eacbbd2d34f4f00dc93f3d5495cc75ecbf63cb74f46ef0205ddf0b79d56fda33ce609c217ae62dc2a1a607ba80d754d433d94899b75831c8ca5313e90082097aed2b42f30ad0fff44eaffb40d9fcaa72ee5e0d953399f18fae161caadfa56dc4f3530db5f543c162f566ebfa5844b9b9ebe1ab72570baf4bcb2e59f09c01d6727eaa19f92571c37ab814bf85a751dc0a09e2be677fe889da7ff49beac010ad7e8491dc2fd5a0883a1c93b3d6b9ff8199def13ba85df86b1fe90fde12b00b2e0251517177a2a1779623dfdcd7b305aa99d98b2ca62c0dc92a9f02cbf9e8310039a62395a776072696bdb9b344eeaa050087e8f92a6288e97b1c54b01383b6e29d1cf5741671ad4860e3d197788c326132c3c2b3545194f6d5b28f59b0da2d3e5033e71be0d82059912110acd68880ff59262ae1add0b2ab8cbd084d9b9b9dd551d40da068ae83230b4c721c6969c96f7410c51b0bb00fa19711b6a394dbbf5b33e565bc7966892907a1e871e861ce4d5e3d6268e463db8eb4e274cf1a803707db9294ab1c9abbc08a851df399665b48482b6c7a823fc3f8fb0a05c22f9029e1b1cdd3fbe746915eb43682a73fcdce75949258be52f1c8d9ecb109091557a9d74309275dabe704de7dba89b87d1bb6a02c13edc033fba7021d0eb486fc8d23a307e545b7a03992bd03631797b22a1b8a229ba3981e3e7586aab062ff17987b6ba103c4f0c18be782673f0ec47294b25ac04e1923b12e54fc46864f6e977b5e9b52145f079529b1277bbcf71fb4f6cedebfc6592c49f62f2eb1a3401c766bf16328a2984319e651d20481a61300651c9e6d0f0cedfc42c33955c9da48f2b03014976768b928221f4c22ba4aa8b9db1cc668850655769bb6a8acc40a4c30806c55a4c30d3281521ea0a9eb5acda2aae8a18a283183f7de817613c3454216835e5b2180d348cd62f8344968b3af285fb795fd978b9f3aab04f3655b9b07ffce0df565a4bc99691bb4399d73f469c385ff29a5ce64bb5c18bcd5e3b0598951743eaaf3d58498cfd1d0a5b19bdf5a2f088135e89846af8ae36920af929a29840683c796282b0eb71adcf9b0494ce6ce5eac304ab15c01b1f7260a14c44f9c2fc9186412b9dc46d83bbc8fdb31cc6a75d4672b214fb8cb16294f9c4e3633f7386f451dcc828a2b3e2328e954035b0f826ed9db7f5a1e24b6a4558849652f269374c301d0e898c8c8a34b83e59911feccc7be6d9451131887a4cad192630a1c3bba8635626439947e8e1c89ec7a75f690701900c428ac9acefd5faf358db587ed0d70af3165be4ae215533129dda5c0617905fe834db17aa6b544a5d36b7242d723bf1c5147f328487d0d0fe1b81f394937f436686ab3543dae90a19d813909b9deb3ecb03a0a414e4517bb26eece57ff8c4c529b6e57d54ecc2a0bdda21d5ff877e51bf647a29a51227c66c3a2ed316a1b44182c1706995682212bd21648837c736ba90f67768579589e2687d2128056f1e1e52e69355ae541466a551ba088c4504a65fbf70dbefe7e584346075af600e91921a653254b26436c607f81889566c2bfebc1d473b940b8f630eda7c37aca1f9a481780e2a8dc89371f04707cf460cc94c635dc96ff9665ffba224bde9b42420fc681966fe78d66dfdd2059aec1f7294c434817f4fc19f9f89abc513996315586d5d8a645e9ea09df140d2a4a0ab2ba9d02f7d44f4408945c1ba0b2233ad8c1822dafe2e228132a2264a4460d9677a1c9c836e99f1cfe54e041a7b73ef87a3802dc14dd9ceb870ce29872c5a196e8f81e74233114ddfbdae0bd660598179bd9163073eb16610cc5fe061d0410c3dd4f78e86c0a01eb6044151a45357025bf6ad9d4b7aaa9ff1d5a028922be20a95e99ed918be017231c068babcfaa6d1c34e0b822aa49b94ee1f17c4e92b00d172db8e734ab5c43d55eabbbd962132dc71d186e9bebea2cff84f8ec4d0aff03515ef1f7a58b570e754f8e6c8a9ae95497b0b2a12122d0f03e3381e49cc091742b25826f5326720ff0e57a0d96a74a070e0fe2f7ea68afabe07ac6c39f087da2ed5d7e4d1ff93ce46f5929fd0149a83bb13493b5296ae72dc3340ef4c989c61476d8febef87ea6f6316950ef49d146341dd35c85db11f58a43ce50a7390ccb8cf64485260e7d01cc5d6656bd146eaf9628edb76b917712a4c4322797d12dd56e3547d10dfe43a64f9bce6804d3c2460985fc6c417aea06c783fcaa068ccad2dc8d9fe8a46c8707f9f3a09a5899abbe8caa5b6bf70be3ffe50e52ada490713d29f8adbbc4f18a04db4166e4b07741ba14019d7b1df0e4c8278e17c4627773305ecf4eb5a6f0766fc9c5e2d9325dcbdcc958f32f6ea80c88991cf1324243fde6519635bfcc302175abb6ab89d857da20edef300532898355fb5f060fa598559cb9965c0ba2d3c2a1301c08451753242cdc295ebee0f5f28aa59f041c6a99fbfd885f45cf9f8f158f35eaf26f32c52df4a908501db4f8338bcb6c3eeb7b3cfebaf2a52754e6192726b1128e95b536728cac7fc9a9bee7c305078f7757beb343b269f73f1001927ae73e7478be2eb9a979d65f951635ee80626962d73ce05949dc3068b59fc8b97f802d718703d018114c8f998199360494c0e4e6cb19ecbe84ee3c8f851161217c1d233c3d7708d3779d3a5459dda603aa75174bc686c1c35a9e330605cfcac608ab276f1332f16d4fb142ac126c4fc152b1158499098f92578cb58ca3995f83e015c11294f7d43abf81121b886ed925d400054565b421ae52f1f96d56bb73b40a211b62a48577805dbbcc59570b2728cfd9d6c8af220e54c0bff211435e628800a94689c10c98e1587b057db7681b63ed89c00243b4f39a395c2d1df908b7c17e3f2f4488facb2e64a46e0ea6d2b75a2825c29604b76bdf12a8d58d80f88511511e1553a987cdc4bac5ca0497866c92e7980296ad568ffca1926799fc39554e58223ceec2f46c5599d9c17be176571c00bef7573790bebb6d75bb7039a6aedca279ac6778a6ef30107b18f6a5dda66c4bfcd207277626f3c6fce926cb14742c0e9441a893a4a3316a9a9177009edb486e011e83d6dc05b9d38512ec23712b914682babc75d49c42f09c546e5205cf1b7b781a0e8b37aa1c9401f3bcb291ae8a0457a93d3f41a38084de6acec68ad0f0512f0bd749c5e09c96ca13bc4284207974c2fe128f8d105d86fb14031f94998fc3fc31f1d2e2e01d46a9a4b2369c09404d9eaf430596c4b4b75042f134059862cf79de9637b2f0385f47e80a2f5e53a2074afc2c5cd29ce666c098acf4254c25a1a06b907935e5db0b1cc5e4db31e4f01653a68174ef1be2485024887e951ccf03b8294009480e73445b3ab6efda74484475927aff2cc00562f486cf6c468bc5d99ac00b2baa9a0a27f509d88e6ab4eb24b837d6be8246b527b144fce59cbc32a8d9bf28b11e271126fe87ef35a10832cfacd7157f5d1a4913f0c1714e7ad05cbc54682c4988acb453379933efecbc9e8f7180f661a1b091c53eb779f60c4c00df4142afe209bde747a6d6da0b2dbf312104db732a2b0cc2d5b1be82c916ec76fab969d1686c024e1551d0b189bd095db7b883b4d16193a685d500ab2a8c5e6b8d283ce77d9f97c5ff7fa51c16379e95e7df3df3ccd6d987fa5cda0dd5e928346e9f6b6866c8eb58bee30454ce4e31807cca736960cea220479ae45d8f85c795cb7f35572770e56d2df269df06bc8603e325d773cc75d06a0ce45d703c82c93aaab924b77178feed5c4dfa5e90721e7e2d3b75aebd5f1ddb8761b7535d296e54884014d32babbe02bf41b2f019b87099e9d173970b86086b0e6a207939902fe90752d0f3996e20226b26432a0a2c6afba65088292954dccdc223d9b28578882adf4d6df3d9022dc06f6fdc27a538d4fa67d0ff29d2fd4e1806aa94ef552d57c5c6b2f869ec1a9c2d2fee0305523bcb79b3a6872b51ed71107d986a442005c754f7c3db6c9c8c9d4221b529effb9f68299572dace9de5602c485d93ab9b713f5cdca2827eb0dfb05f743a272e9073908c6c1a6f8c651c99eb526cfde51fa9e72752ac36d021c69c3ad3bfe37022fcee37647185aa4fcf390e0a17772c78f84fdc52b00c354ae0b75e8e266a00ba6328e3df6a38d8ab47625d5360144df5bbe290e0bc4fba5b3e8cab74c23c2f62c5e1e0185624d587666eb6e1f9deeb77d7e423c1340f8d207d4f159053ad403d110e34f32a64ca982e2b2502784bc508ee490e782e9ac45ef248e3f3dca0a31a6b3ff24e281d95312dee0c66162289e82fe87a5192cff8a0816614c499825d6a4f7c751abd4a65f2b1f343ebe24bffe71fc0729d6ca2a7977b43582c942b03f6c9a7e0cd9ab4af934f7b1c4d239fba4922deb73e290e461846877ec56d2a878cdbbb60f8833ff92325bafb882d39d26fadd2b80dd2910f3d67e71c8265dd3cc6033924adf9fa69eec824376acff349cca77d7102c21ec79f387188bca7a1ec0e4e73fa5d9914ddbe89372a84e84d13b859254003d591cd6498e53377e2176ad5b18aca36ace686d628e3978a832f54fd27ec388cccb924cd4111828973e8fe57daeeb11dd4ee3b583933ee2357478bdaca39e8e9b6a029b9fa43b9b50f6705a15bb46beb47e8fefe098a30f4f71804f9adba31a6d31c1fa3c26b3c69f18f74b17bdb8d0315d4c93ffd11a42576c5a8e42e957b630379c467bf432db1cb301072ff262e9bef95fb2102aa6ff87b71d363b8bb1beb3f820e9538ba151823340e575f6c8e9c0b919da211ca2ea009bb98dbfa34aaa57ea6b8bdac6ccc7b6916bf3a4f7d57ab09ad8df3358ca24cd22b620ec793a8b49b6d2b92aa9b644b4054b1c90a0fcb797176e0c4b34cd71e89039525e87e185d5f8f8493f1a86b0518c54e7fc68d2b1c00523c0018bffd04d512c69d3244f2be94f42436643daf28c21d1f6ead56d1bcfc5d95fcf6d00c997772d676b7115a1399a4d279d2bf3602a58fb54cfcb3072b865d3007ffd0f3ad96a0aa874bba5cb818045c472734dac6d3b565450e22d6d79d7711debe2dbbef1cb903bc93247704f0d019f0790d3df49aeb06d53854be6fd080e8d830a54a64bd3f28e68abc9f49c0363a8921eb21ca49398eb33fa393853de19208ed8c1f4d20524622520d8f7a0e12b8ffd0109b945a69466106189ba85ff8ae13e327446774c839b74621391073421cc74363899ef029733760abab92c5b789177a6beefbc31d3c1f4b65df7391f3273fb30da23b785ccfb9aa4f039f648475ea56897441e86876963e375f4ed1a1fdf52865b75a99aa33b45787fc14bf299a760a9ab3c975037f80fa490e7154417c68268fc843baaf3d9c88c6274e510e7843f53ec856e9eb5f6d234e58f448508095a585196afb4f6017d7dddd967f1f2d9801ec421093149524f1b34ca6a290eabc2aaf8cb4dcf4fbf16c49ff9d4415ea1cac1d13913a6295e9d6f7e980f337611d33b928af621b23f7d0751ec1d60cb6ee7745972cc7bfeae0273de5ee124f4ac0c6374ae5131a93b530162a8aa04a1de1fecdf69a64f7cf389d43945d5e9bc9df44bc77fa7385a71e6de070a12b6ab816cc14363248e89e4620512dc607e0bb334c305780b8fefd98ba4ae5f4d592d82b73c91bffdbc94a024571f7df5e34c20a25b076fe88e49a3c5225736989fd308433f3c2a75cfc1a1d47dd727fe707be324a9b9659ca68b009009172bc4f8b64927e3a2618decf0c88ccd3feb85109c14f22f00d5dfd7a193d5e101b664de13a9e6f95b20439debf697435a6969b04d51b00d7b160e2aa251e1620b616c4288700ec314561d75624896b1d0625c90e3ec7e7de21fa4b89fa26a9579c888007d212fb4711815a3e9dd7107304e102c006c1da42c5ae5d99a01791558f5159bbab0d6831b604e0c6785d036dd45889b76e0c6622cbbbb58b03ce376992d0f4d79d9f6347b7f702afbf021eb339352e2b4fe2dbbae30fb6d8b5707a8410af2c0e2c9415fe7870af238278e6942d7ec3245e1b0c9411cd43cd80262c05f448d03544e5c37379cb7698b23a7c1401cc5ac6926d2ab2344f334feada836f62fd50dd98849e456b616231036cd4d8afe5c1e0f52cd5ec67fa2bcd8d7f485120d09bdf57e3fda16317cbd96657ec737b64e14caeaf06bd7496413310389728bf10aa8b60cbaf41710d998295b0e1ace57553097f4bd2a627a4fe034b247e2bdcd404c16c385ed4669931d3bd9728d3423d0291b8989c0bf781d1f8caa36720b6139f0706f894aa08fbdb1a300e12d18463fef5614b3f81626e291bf82e59a6f1c9b2f88f70c45171528cdada2c4e842e623d6411e1f7249ff5edd3ddab037a8b2e0ccec533ad3244ae623362285ea7984e005559f5fda0c01d4f228d32b629d2391c2dd7dd1a0682cb7512aea799aefc27cf5532ca605abde76a841b4727bd5fd59c517ed42ca9ae1ab83624adca17bcde67d8acffa8e95a39842ef8eb79623f7b4efb422bbbbcadce265027c512bdd22d568a22b0b112d52ea9605f66e6d00c5b06af6e32d4c2347f900b09125e2815cae6328fc055e7068c0a65732fa58c2bf100dda853a1163d598220d6b5b1038e228999a5ddf53246fecfbdeb61d26e60884a7758c61dd572c77367154d73bb5509fd58352c76800b2849b3ca088b46681afc547c164f5429db88a4662c54339c21bd112077dca9849919926cf2f3a77a7868c65b298732e3b762a35445d1f94a4ef9065c894ecb6a8500d8c5f773e3b1548b894fbf4136368aa6ba817c112beb3549f24f5596edcde89804825528571faa71ed609f22b14efb3ae661b421a62531468848cbcd4a162e9b09a31b1b22846f556c2858eed1a6a7256cea6ba1f0bc72ddb61b2423fae6ae3cf08dec52c50fc0818355e7be9ad377a39e00133b73c2be5766890dc4392adbbc9547885887ffb1ecf1179d1f5f8e2ad4f5f93c762609393271c5f5de63d00c6ffe890cdc647d6ccc8a2f23104b6031e2979a8714b594715f86e75fa86bf9a5ad4ea079539dbc585c4d62ed194bdb0b962adea3d874f393f6ffa23aefbf5b72c66fb186731134b92fed44f41d99fa881769141280cb65d093fbf2b3e90e0836c79ac3d5cc074fef95ec2e77b86a51761d0e9a3ffe84195c122f517c6a117bb187a64ba089d05dd75ba60705ebc36e3f3f11876d27a612a612d0774abe53e3d05dc8b5d97e31ea9feaa73fa6ae303b01757a71d10fec932e8c3451769a8510204272ce7a0c5c7db8b2e0d04db26335bc2d6b04dfcdd8507529bcaee274e2f77734e1cda538ab17de629d4395934c61266206f7b0562da907f555d2086bccf3d7b7b2dc088f5efc2e3deaf549cb9f7fc166e9c4acba702496fca54b709556333c50d8b7fc85b2ac694f98fcb9e1c321bd11ea424f1188620fcbf6deb870591f276792781aa8859a5615df128d516376d044f53e8a7169615d38fc9daf414a2a4f4630414d97f1c9649dbce17736afd817de9e4c1e5bc668daaec5bb559fcdbf8a541d579aea3ba6ce51437376e7ac926afaa4efc5d742c7b066abf29f215fe72ffee540ad39330d28f428ba53c5471f22087d3b2e12f252199f9f85b0c2ea622e6bba5b758042d16c6081462856f6369f55097b0d16b89deda0fe2f91780d49b61532d6c0fdc7334ad0ccf412d898026156db41fe81a12b583a44865ebd8d35aaa40ec0d177e1d06cf04fb72eadab9b552c4a81916e35b1105a3bc7d092e40d401efe33fa4c3b6f23242b2c989bd8f3af90788b9f7b3fc37c210a7b0f2bde6159d87a37efce6916451ad23c176d601f998e844da92224c13925d05103a9d9e7f421a8b4d7543dfebecd06fa200927f9195303efdcf8c3f1c837b3988cc85b6f7a92a57a0f8e563d4169f0ccde93e97e334f4d969231ef4271d89416116ae857bd38b08b1f375a712dc6b62bdf97a7d84a0f629147af85b00189b0be89bd7d346dc9821d10b0a948023008b6d381e3723bf1623b2d1e57357cbdab01442664b4131cdefce3659b6bb063747dfc580dc494f4027abd7f52d3a281ab58686d748dda924a0b96618a38ed01b1e575c32172901ff33f4333d1e6b8856b2172ef4bbc71093a1f4169a92e5af70c7d3f4a29b5605fa4af2c4d1b1ea9841f9ea10dce9241e0726e3850cd930116ff029a97deba1d100be6fa51b43c06eab1f270b4cdd68c6c079b604899e6a3419d7cd37ca03ffd77f0b85aa63492ad3cbc40e3c6415e84583b37368c8d4517a5aa73e07ab46346b51292f8cd3f370a5f783696e4a99787b60d591eed0816e1b71d3a2ec6f0e25b68484549569ab38eae3f2b6d1faefbe2aade090becac97961343f4b0b253fe8d836bcccd522c1ab09d71a4efac9b47b12be86a3c2574daec6d898b0f74cc1162ba0d5493975d4498432564ebf60936d991e8a85a7a5ea269d32cb1845421f630ba0abc6e32ce86b3b23c0db3fca5826fb7bd2575d8c37521d5cc296fb520f93b15ef0613f8c46482c1748a6727aefec23b9ee4e4d53c2f4c48cd6c616baeaba47074cd72b94fbd2dc2851cb660644920969c608eb33901f971b3f05d861cd95fb53d2835d9b7261f8c21674eeb5c72dd6e52c5c8535a10da2aab7440b34961c34f105542c3dbff79b2b3b89dd8cb0f67e9030f58b224e4a127700322ae11157bae08b90679dc0213625eaa3c43b8d297bc90d250a7133ca19be036b908d607429cd7592334ed46c1ec1b063ee53a803df85a959dd3438be50cfe54e84402593b2cd2f3d4f0d78d857f733fdd36acb874c77fc738061c652a8d6c1d97fe6f78a1c244eb0979438e8b12c2bca00318de5157696ae430608cb2b4dd85c2cc0feeef7bf8db3b482e57a0c7a7e5c039f4ad8e224f45d623805ac5bb1f29730167bf0c2ac4da1845b667f4ea7d12b5f54cebd5722353f8750bce5f259da58a3afb9a55d1401497d58718f7f518259d12c67c3cf33bbed67ba59006181a92fa7c63216127c5d686b2c6f677d7c77a142c5e9007c2f4747055a7a5f02057263feb0b18507998fa10f727c7f85bcf8bd1b3b8ff3fc9cebe2a3a117a54e43e85e9e80177dbdc6f10c3398ed214e6c4b6f418e5995c70c1bda24e3ebd32a643af76988785fa778d9afb4a1c414d190bf3211f02150fc429174f9c86919ff1eb56bb128cbe6c2d76ff9e531c7e8ae6f9315c01d923f94f03bcd11975f99d955773f00e1672c3243bb94e0bde46a47eaada3dd6782366bab18af32dd9aac0612f4c729de8620c7745c3165cb7d8d47e867c7cacb1643877436f07d1074a74a839bf13155812f08559ebd3793b322c065c6007e9a1eb6fd5e064416b3fad8bbb65fd94edb51670ee8fae438f9c7be016641402150ca00dfb78ec6b40dc9c0964d4bc1b752cee852967e2df2363ace8a723542baf910cd8406f9e8ac08e3f80c23e7fdf558895994c639e42f07eff4fdd64eaf4fdf8485c7e3932d55504c973345fe941e80ae4bb7f598d0cd8e0001272611b42eb566c0a4a68ff6f498c2c10c05994524bdabd91d7ffab2d5f3051a91276a7de26321650df4ed92b69a5bb8f2b1b830be55526b448535d641db172621c9de83421ac77a970313966c0b0c9bb5c654381b0896336c621f3a12af979566f3c1ce905ab54fe8ea7b3a36d0dfbbc3d8524ac64fe7a2b3a2eb0d6aaba71ffa94c1121a759218ea23990064242fe6c12e509cdce48a2d447b3e57ab764a0f9a6c0a7d31b1f8b96de3559eb9689bc0f1533eb4828629d98d07a0479a91bb3de6b5e06c28d895e31f79af055f0e1fa1fa87552cfae4da3b2f322e0e66d7763f633f3339764a0712dc4c031e0d0bfaa59f268931f884fac94e8e878cfb477176508e4488eec5852bb922d06c907f8441c25057d0a44c451da105047867117d7ad807a490975f7dd68bb22fbba203284f2a6125913ad44886dd3b543b72ad9ee83ca266a49f80b613518983ecfd60d45fbfd5661def970baa69f1d7fa30b6fb146cd22f173bacd38d01506034c62fee3173d9caef057274ec970e6bd7cebcd2cd494059405c2b418c27f7fa809cb665f7c6bb84a7ff981d364e28ac3d64ca95938fc40011fb730338de33f599cc49f30997d812c2527f9d9514128a5440a8f49deb00a68612c5a13772bd1786e00d8bf9220822e3721d639fd58bbd3c6cc8c33d7632cccc153cc73670010472cf93425b6e14c169139931a4c8aa565868280b72f4e6f49c8e90fc7c70c9c66ee4b10153ed8d71ff7503d3af7b3ca502a9485b9f3433ed9a3be486a12358fe458328ce1447a67b43f6b8a4ac0243422db41c8addd409c68be22df7b58269506567a16949f21b097474d541a390c3615b608955da93069bfcfa1c1dcf94757c0c87200b5941172bc1fd726054999c403801979ee307e325d744b1ca5e6ba697f1db7d8c0e6a16ffe2586cafa8026a8067e38263f5bc5743f3ddbe1543a9f9dcfea567b3225b5a5a86eb8ac999e0f1ef15cbae60d5388fb9ee2e8d2b83fd88454fccc201eb768ac544e928a4fc45d0b17a228e78a4b1c8c02fd9294a81486e31843cde8be4e7125fc1a27434c5919a2500e60ae7c02843fae1cb72461a124185008b980dc7fdc4b5c93583d6166a7f15447819d7c8b59f3bf56ff478803c864be8598dc2074a48c03f0c1c3d5a07f555f711d1ddbc3cde95a4557a275879048246e5c1d3dbcc9f5dc1a71d8a36776f1113539fc37b99c2fa4b9aa3b74e710d94e578ee1c748da871cf37769a8d4596fc849f3a179e59f909a2215949dbcb5ea9aaf92ad9954ebd6e74fd20487fa31c6d79eb3d407b10f42ff25c6c52d140d03c1e4965c9342a3bab94ead897490da7933aafa9e3bcc9790016d2928658b7c94f163be8c72cb63aa09359864c79311063fefe1a93277b521c386a5c3dd028e06d9c1b49f70344ec29e6baeb7aa15e88bcfbbe5fe41a3700d178638b864db2fe309d937124f6b38506a9765e373ed412bf5c57229242b54f494fb4bd87632ce1c653862fd4bbf4bb8caab04eccc2c768577b7b0f803731ce0689717dbd429bad96da736f52acddf4ab55e648ce66a0b570e343fab8a66abad110d369247854778bc1f2b76a988839ab00a96ff09372cc25af054c8d8343a96faf9c1278a62cda07a528126a4ca43db6235e296c112db0f0bef5a6da9ebfa450c8b79b30931a171a334532512c4683e71cc398cc66a1fcb70edc5dc1dda07203b2d49b227f14be260a704e435e18d67bc07155e5ab459501275ff5f76f5e6decf354952b2d7088cc673b3566e4cbcd7f03250aeeba17487b5c31df24e5351e8d7609df9f5da581c119ff5724c49b73849a07db700c5d0db3961913ba7a20858f6ce493745389a20775bac10bc0a0aab39d6d5662d6809237e0a819f3609f24136b2ce7a813c4190d1884c99ea3bcce7278b875d3101defce53fb44a189746c1bebaf265cf9bacf8de4db842670c05cddb0162ab9a1122ca4dd1e201557b2031e059be2011a54311720c66ee3429c43810b9b1b9bb6f9361deb2c5e2eca75bd17941a3192e9eafbd8cd6fe8c1eb26dc91baf37c4cfca2f0871620d464deea3c0967dbfea40aaa54cedd534ff7e3702e77ebf7cad174fb9947f4dfb7ef592a3852569a9ac4c6ed4e0635e699b2d903c7a6f306883237fe459fe3feaa0303be0e2c0777292ac64102d47ee96d7b2824c324260a0f939a407fb932c19f60ab6ddb18983b9a1d2d7a6806f2e6678b013e94ca48707b943b3302796c06599b96371809c14275d6c6c3ddb43f21ba4236e12e0a99b3f7fea186d11eb1043e279a1d7c0dd3c1f6cce768dbcd574124882f6e4e040c905a2314762a4dce571031a1e9fdc8e47d9605ea0bfe7cefad066b67c7bcb6e7a4e8cac44c05472ba93537e54ab268372a1c22e1c9db2ea0bc5aedfb9b25908997210ee7d5fd831629516f94e44a9ca2260e676606a3596e671070194cdb815a29963ca3f481e9e6514796f5cb63a748097d77d7af6194897f42f2efe7ade24d0f315a9c999b5e6fffde99d591acacdf57a4e5d48a0c3464309f471c5cd59d933314c1e84d1e8d63e124607d1aa6917f6c0c824f256e3f77db55c662fd0e1792be5b3d4f06b6545411ae3d25809a9828bf2e645bce7d883f35cac053805d094ecf9a70475daff4d1a355c904ab5eb44651c140b11f1627666e8dcd1c35d90170c3969b456b2259668752486e0b124b496c4ff8addf199b0c33008f1e873b9b62af1c9ebaef5fa0be52c4d12be5899e20e7bff9d11b17099c42f8d016b80d166cb324225bc02ac3eb67b200b6d49f5671016a6740db9798848eb9a7918d89ae6381af2715d6c7669ec039f2bd1be7dbda4adb2c4592bcb004da6495d6243eace483cf53694bec45b505fdab9cda2629ee6b0fbf7913489226f7f6da420bbcee8e53aaba51b483be4f861e4e1b54b1e9198762b56b2586dd424aee4f6d0ec83a7958af2e6665d4d75749b1701c1aebff60ae64ca4f8969624fbeb5e5cc906fdffb23c4e1cfd808e9bf3882ac07373b75ea824707d0833b5a9e63f07aeeceeacebc28a94ccb971e2e1ab56db5abff8005186d1f432dff3c7cfe80ed6e546136c9d850495e5b3441aaf91ea6ea18e8ce9d28aed5ca5302299ca36f2ece817744667ed94505af02bdb69b48d1981398d23b5b3b7319dffadfd6ddf5f870ad1a581dd93541f9bc85399233f1d719c7a841204a8ba1e58be7f2a33ec1a12fecae7147e8968588a31daf96ad797a147c5e86c213309bdd2920fab7ed7529d8df179a9d220d56d84c2aec84563af7d17c0c788682bc8d275b72cf2c4ccc3169cd2eabfd95f57d6f341ebc366041fd99362c1a2d6dcc72e79868f7abc7d3f45222c5d3c5ffcf11479499f5a5d90ec7040189908310fbbd9f0d0fb067179724f2aa7091d1b233a16e3316d45ee7ac7b666adc95a2e7a9b3de9b3b7efdc62ab846c31d40a547b16629b41b585b5d8daa8ee5267930298bdb10ddd2eb011e4b5854ccb43d1a94c28bf91ddd969323c5b1f8617bcab5a262f9db8bb8423bb08d08c3ad8a9f7510a258a8f80db39ac2bc7ba763573f1c773ef89be0a2237bfa68f0e1352d1aab2ceb970c93ad4857578ca53fc820bc8be4c60007c12fe42bea13b34e367f1471af2a430292016008fee75ab8c3e0073032ec64b446cb665a126eaed8e82ff27be4eaded905b22ab5c3d2f6f1440aa57c8caab0042546297f1d8809ae2fb602d551f7779a1d586d5beaabaa517bd06a437ee285f19800f3f7ecb9eba198fac4898cfff96b592fa22c80ca937ec31946024d499bed39cf6cbd71f66c0f7beaf08ec40e59b05cc8b4f6d1211d0185e2762a27f595cc8f8ecc839e3248bbbeb2820d66ac748aca751619d10b5ec009fcdc7ae1a442f5182a298faa7c9b9ea4d7bc4f328eb3b5c5214e68c93ae8a06e3956378635f88f1bb73fe9d188adaec7fc8f682c98b230e8538370f24f129e87bf62005b9e1b5af8fc51fe8e1047a5f237cad9a4e02a338a144c1bb3057887b814b6d2a24f1eeb1edeff9052fb9706b73930a1c5bfed84b84c508f9712426cfb0715453af3b3d87c2dabc9ae6d086d67a97da6062fddb572540b95fa5b2ea509fe319b778e8cd91cfb54a32592c2a286ad14ff8da053c970caa8436f8e3b7a1c0b607fff19ba041c9a9269e46431d4707ae6ef4de452d992be0cd2cf0ae25ce458e5f0175c13998f277ac30358d3d326dd356144f3f7a8b6ea5dbfb0bf5cb1f9c57b335a564a3593cafd69b560d30a0f775e7734eefcabdfeb92f21ac4cbb462342a8b979c45b44e8659ea8d400296bbe7d6a2f1b20570e4c74ba72426eff53e0a0b26832c08ec5e3cf75739d687ef9da72f118cbba3e967d840f3167a644e33a14e838cc2b6415ac0ce0db55c1ef706d4bf4838a9f1b05d6920316e351a09fe9fb40002afea74d1e3ef4f568ea3f530bf4cb660ee849583fbc9a415c6e470d3a6702fc51d52357a9e0ca66909b3a1b141f624c2a5d98c632ca2b2c94d6f0e079fc4d67f51507a39a208572eee989f77b213c8c922672ab46a76709ba16fc43297d6ca7f8df0cbe2cbed70aa4f5ec161a699b5a267c916b44f832fcfcdeea5846af1e9614b97170f710e06b91769be6db4a74165eb207478ca58c9e00a59a2572cfd1e4728657ac0c2d9e2f404bc3e7f0ed9d6b4fe339efc57814e46d85ccf6bf307456fb6240f564d816c03af2014c02bd26d28e685fb4d1ef71aecb8e4d33349653cfa76c8ebd9017648dc991894baf1e08af304b91a31f221a0a557303094f584bb674d2310d182f66389667b2c4d853a807823caced1ce99a29a798a8c724b238cc72f6587b8e638caebaff92e735d9e51464981bdab2871495c2e65bff1f8318d6668577edb2effd2ec436e8678e381e809ab0a1adf7982023b640215eea5daf67ad46da1aaa1c04ce9e308ca4a81303da0948ac54da61c638444531ec41e5d617ee51a5ae1f31f115f82d376ff242e6b21d0e09c6e0475ab67e926d792ddc41de55598b638409778778deccab08a2c118315b9e017a49b4765cf5bf1481cb46843e0993c5383370d6ecfc317475f2bb361e735dd9caa6b00385f8bac6730d11dd9faa8b5bfcd1b8f50abffa9f80df83d03912322d638f138290959bb88c2c7f977ff5e0a488fb63dbf8c1acffb3e7e131c351aa4fc6cf4653fe2ce318c3e2e22a477e72437893767783fbeb22bbef088146b3160e4eaa7f3d49b02e5d0a1838cb808e479d5d8218e04b889793d2b7bcd2a17903245b7bca69b1d04f2edcdc63826ac3f795e4a2272615266b5db1abe5f3f4d5a5558975e36e2d6039e3c63a43e3fdfcba4acd702bf63eab4984ad80fbd7f162efd723af859f9fc4de2bc7d023022686a846eb38f8d2242083e331c3af338f1bfee63547cb18ac72c36ed606f5b29e50859cff8f4fc57076a34be488db1ae61c38c9e81c722452e56e5a0633472414a8bbfe55478003faee1a2ed4e1effff2fafb8a95ffb5ebdc23f2472765de7a18649fc9beb7d234266e592517a02fdfb9de04cb68c8b33cac91e37766c8ed1a6a41d4ba4c5d9bc8d38dd964adcdb7014e84bfb6b7487cb534a3f944ee20179d44f1e5a69de63f628a81c3020f92267d5d67a02f73bf2ad2c8e5785fe897639760c442ea36214cb2cda92c8f54fac877f80cc78a2aff9c32f6a1f8a26d1046149c16744b3fb287df37a97a3cff3013435938b890ce47bb788fd75104b6be380866b0bf73951f582835a77c2ac89187f342fe2a1b6fd493750208dca07e7d274334bb87ac6cb18cf7bde81abca01c39c4f7d34b7e7b09e21e209aed5cedfd2bcbc65d66817da5979466d0df7d01429545e0965bfb223d1f2d6ebc60401a1bbd8a2b059a1bd07ba46b29f5502c8c1e6fbd348874cdceaefda922d05ad84a2b3596ea93b6e0d54e1b2efa0844be4999190c9710ca2b953568865c452dc363638cf404d625ded1e0fc5d11f4a9f4d30b786ff20244a52996576ddac211e0933e98b8bfdbc30a9b07ac58bb56fc541960300b4b062bf27d317013da82a18bfc9e2e4c7bf1ff86f02877da4d8c56f85a8707e2df277c721fd533f21fad252ec0d52ee7c1e8b4b49b051944a40b5a675cf354e21b722745ff9e1df17406a258d9447a58278b9c6f18c75d5563bcbce3454e48bb60b0d788c1f895ece87874c7e22bd740c67d01ae95fd2d099abc2f53a4088678a5804351d73edda512d7d08de6cd97f0599338f8de75010e6fe5a4d8838273cad0c7653ff165bc9c55606918c964ea8a78ff3c7b7b3a3dd5ff8f7d537d3559503f63bdd42b835981f920227ac806a8ad47f4c147c5653caa113345d35dfa2abc02bfe7882f96273014e779dddb1c1abd091d19ab61cf556b495a5d3afc513b903bb524798ce9b3609a3231c33086ebd8d0e5bf76c27f79cf4fc5ccd97b0f38f421b9e7ff85382c256eaf3f98be79001247ae0aef348a281b678240012fea77cd850241ad6e9ab36c9b032661afd1a38761a5f2bfe32f3732e63d27ae9ea90abf98984ed22d8a7fde9cda59593ec346089c3a2cf43767e577f52fbdd1ba5efb7f2af67a4bd9f6639886c28c100340bcda76564001b5233e029e78c94be4c69ace321f32f024a0e6f8eb91d8a81e9164a797cac6a1f6db97f5cbb3efa2a0abbcccdb7e023d8e4659032735d7a9409cd4e728737282f19599138bc0c17b28f9ea8e8ee9af2c0c79a84e1b6ca388b20faefc53b64a1b38a58c4dc845d5530707d10d415e7e19733e7acc180317e8f41db51292a31f86e40e2e7a2ab7a0ca5010618fc6b57aeac3da116c6a3d5a55fe03dbe6283aaee3ab65907d1d6f9c9d5547a38390f9e0d64b18a917f5d68198785c4b0bc4aeb414785dddc449eaa20669217f9c9159afcfed1aba418a85d834673b6ac76286c677c8d60c51e3d25075160f14378502f77f8f0e2fcc490541ff8a1808a2495f297eb3f8bd3f0061d5aed4c8c6e697babb31f370db947bd1dc9a636c2610b1b8ab0e18bbf8b5e7d3f82bebbef556604657e279780958ed8429aaf59d6d50e29e830f29763d61b3dfa8759655e780e913600861b2318efd8810880fcfd3ccc5e1a5087c59b715b459acab0c57a4efc4db2c202273c58a5cdccabbf416f42234dd0049d7d3cd7e428e4f480687d21db3956121af397a744b6d1e5176f0596b614a4a0bc509816ff91f66648343ad8a47b6e594298dfaae544b54ada5eb8935d43790ba1988a018b58fce77155935f5479f84bdcd30afbe9bc40d8965d4e4fe1170471bc9d29233591a3bfc8ccc6db3a1b9bb20941a2f62f17bc9a69fdeb72c6156c8e3205435c8bebbe04c116017bf902c8bc79e9ef40c6a25e4ba3ffba865b8431a5af5d9bf88fe2f9d4f222028f2e0c10f56e46747910eea54f7d9ef84f74a9b918c835d9b048fd6e8e865ecd81c5209b6cc115cd5436dbb33544b4c7a53a109cba1d45a841b2b22cda4a2e0edba134b5072d80d554a9753723fca166805bf01aa9adef7efbf25e3ae07889623526444f7f371885c75c77dc4ba009771780e8af7325e2df34f24f42ab1e992847d0b949130ea7a225cb9aa5d1552c8246c7acf18dac0da4bf254f6f822bd5db0fac4f493c5e95769a9d0fb47030e5b3de1effd010ae0b4eb7949e4f52be2f84f0bd73d39355bdab1fb3c65047b74743329e504ba623e15a245ba2999817d766a975af5b92eff8d63be42fb54f5547c346d83c96f7ea6fb3c1491c6915b034e4018fd5b995e03929d035cde04d431d965de565f8fc6b5c90a10eb44c117b65313cd9e3493fdda09af70199e2af98dd5d0ee30b610413c0cf5e30771519e55a5a1026fd9c9b96da3351cf4c63d5ad10ae9b0f2596cc396f8796c64ab6835a14df152052c126dc5b70a7936ed6f272867434c6b68ca07aaaadf9f74d29a6ffa0e050669d865dad48ffec3db0f1921fc60937ff34297794fc8806a1509b6c5e515f6b0b610793fa64e770203fe745e167d2f78882a3697acd6660ce129750583a6db81b8aadf7959974f91e3a550e49231a5f2723ae92d0e7da8fe7ef389fa97c679755753dbdc5c7089ba88c2e3a04f8805223b53165cf800561c2ef63bae5bd93a32508adf2bc9d381f45fa7da3aa1978abd7abbe445af1e953d2c3fbfe813a6889c9314eb810915fbfbf2a8ef4be4d534ae573752512fbeef45f9e739ce86f97a369d53ef8f55942639cf5b59903765cff06971dfc9a8d3c4bd7b60d232305938aa2381ac541ea3dcb44e787dc87c38e5589dc4c708bdbb183999a7dd5a7bff8d5752ab5796f8542053b4b1defe2337b2025e4b8184085534c7cfed47fd89e6c0b906b0cd610114c1fedefc7e7e7aabb7946d5d92a698e336124683af7e45b1cea7e0367d512e0d861fbeaa62c541c9559d5bdb6243be962853c958aa19b953a945a156d3e17362a5ff81434fb29e6230c1664c444d1b7c926bfa60e9f1ed21915b07ad37d51683dd39a06c55102a2a0b63347139ce89c629d45313cd09ad5e56eb1d57810ad695d96b151c6c2c2aa5b97ad7af2b98b05697d9166348ccabf943f8f6ef485e7be163762bab38f7c7a65ed36a533c2406807fe740005f68f1bf1f22a8037e4b0f9b01b8f28aa40c0b3e2c637064ea3ec881c6e670bd35f02fc11ab480c471d8a862d39f74dea8a3da85649953e2d9cee2d32809aedf8897f0462d8b3c98640acfb2ddf9674fb41fee096e34092f2d0858abdac5c2f4d4e9e476c2d3278f739591b0bf2c934d1700b9f8b4af7c649a1310c10ccf57e15a443b712cadfb6807b075d89834167f8d6a2a6fe7e3ff12acd597b9c553baaba72852ccb214c8ba73768e41b54107b27180d0ed643f235d15c0c859402af36e186ca990fec8fac61274e99e8bb093d8128ba850d0e228e6f34cf8efc789a327b68ee8b4cbdedff909a20007d626f28a1bc1b1ff39ddd0a9f28f38943944774a0ea0ce22cec750873e675dfec3a0dc7185f097a0f80170871aa01d3fee397fbae92ca81071be3d5e6186c5942f3a9c0dda5b5dbcce3bcfc629137f84cd6555c8154e965f7eca4392c3a6fec2024ca2b9e63eff5a0f3d25f6f92864adae767e2601b70e3a70222488b9ae7f5249cf0ed005b3121833d633a294fb0fa73ff58dbd3310a533be4aefb868d3e896f3f552ce8c086805e5d69066619fd785476b68041fd9d28543185287f3f3b894e69dfc0cceb733739d5bc51a11239749021548d44db364f007cdb655cda3f030190ae5b6422fce3c40515366deca08a0d8d1e53aaab49ea28339040fa13188ac54deadda6270a95bbdb611a0160497a8f417aa3406018f7b1ad60c9aa6e3fa42ebb267509d9a39c2a22aca57f7e390b5661173b28b2cfe7032fd512fbed1c2358d005f5b9115bd5e9711bc0ba93f11bb56dda9198664c69b27759f73366c584a39515e66797f9ccd2df9b83987405a3683ae1f98c736df31c195afa9862b4a358600ac929bf4aec440cfad75be1c62feb91420fa8e910d4bd0d6442478d7b54c8feb19cbf5fbce4a39862f9a545e70ba1ceaf81660a95c5d88ffb4df83fcab074f1a96b53888e6b6a9d7c68242474cf8c6fea8269f301b8dac458ac17f40ad35b471a66b055d12fbd6f5d05f10bb92ab890388b05fc85c808fd601675308d0c7066283a35e257d6bab7ce07a1067a6f79a81054dd0781cc684453b2310b2b4f84cf43b1da299fa078b6843922e8af81368528c60d5c1a804ddfe374cc9e294259ec0efdced156cb2a34bdeddc7ae2a3ef6491e65ad4331ef7f03cea8d2f6bb8e93780e48634cccd550b37ae04e0f83675b444f122887af0f74cca9cac23f7b517562e82d9f096aaa4fbb6c1ab27b49b31ee1a37b62945791ce9d267419967eeb4874650919060e161a8cb4ec301474a6b3e8b1234899010ddeae22b53771adf7902026211435f1d94ba6e6784cd9f46db7c4390617db07457dd305025ea4a4fc1a0d262f4c1bc9e828a2488d7d9767107b8ad0f7d9235612de593300af448a8947e4d12254251324dd41fdd48854cbadf7195976b1ef424bfdd4bef32d3cbb8488a4152be70a8db363f014f71d565b97d1d34df04c1e6901d0817a41ba5a35f240b51c1e96a6baf442d10be99a0d464ce6919ef61ff7a67ce2486cde4845aae7203937a2b762ef06f3f40f8a9dc61adca782a598e15f4da7513ded504925d6681304599100e22205a3f171d910e91507f4a8e5bece178648a7f2928311244ce603ce669f48b2fc3c48c42a687d4bac204256f15bed405757d76015ee486690eb45a57fe2b36ae9e7e3938dcd18a75c001c4a02b81556a1d1c3394689899aff025015c2fa3e4d4c6cb7f2166ed85de5b6ed937553300b089761a67fceda067e9aa4c74c328a4b574b054a6b98df492bb2425c81b76915af630ab3fa0c66da475f491cf8710ff307f4ec1f1d3eef73990c7bba40353d83127046c1301141fcd52794ca9dbbe562a1080a6af092b32cd10b52ffd3d509cd669fff3b38065eece33874184f4e10e3d8012ffe036c8290212100ae741926282b1c78a01cb64ae352244627ac5b4335010a0683807a552a37302b65023f11ce7640cdb3cdd6d9cf15c4bd055eb6dad18483cf05642ddd810d5d34698decd6396a16b7cfb6595d79ece0379c7939c41cf32c3fededa0022d0acd246f6d4c02eaf218ea7f5506a34b0a557cb619cb0273eeb6048f1d4556e6a5e287d080470e75e6256c57ece6fc91b660d1ed4eae8b804bd8a3c243204398bd65c27818802507dbab735e379c97d49e57e7f9dc1f8ad3070acd5fda02be31cc15a13ab061ec158b544585863359d88f7df92e37b9534b650ecb66e1727c9a9af2ff9ea6bdd8c1a6f7a78be98502e329b83117691ae8ba415209178c115a25aaea971fc87bc54d7823a89cb216bc490498fca9fcac4b398ddda6f6688d9356e94225ba297becf2a18f796f14cdb6181df0ccd4c6c78b5800b132d033ae95ca10cfab470d4d0a172fc20bf7eda2af356a81fceab050ab2e8ae06e957b40ee42837857cc39a74200e9cb272a17597457615c0666f4d6fa274eceaba62de0225319113053e02133de03601771c3a41b6ad9c0e1e09ce86a8b9252e4679b3862ff8287105823ac8923634fdb1ad974b2f8195292e24440c569726f9240da907a40d346ef62ef9ed5a44f083400c0bea03f73581f28341027785d8780bbe5079da828d7755961f9365f7c5fb354ba2b896767fac1d55b66f5b5aa4163bc7ff12edb6b208a735eb79acc1270d7e61dac038dba47afd1ff797b1d979b37575d653a9c3ab25fbf9875322a90f98a612ded514b0949719284da84388eb6c03b9d61f4127fb97798b7ddba240aed18782581473faf3ae72cd672cab765e15bc01965961c42","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
