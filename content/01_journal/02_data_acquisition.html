<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"b63acbb96c04da3e3c8ee9d89ab342df20c8b11b968b8ec1daa977236f3c13ab4bbabdabcc94d8b08cc075e1243c851a2338a4ba39020d03ff808400ffef9cf249978651997b075f44412ac3500d3bfc5478243d2a38b59c00eab1fe7956de029f33bbce1cc09604477613735d129068a8d16d66b95a65b635284ee23bd598668edbe47eeb03c2cb189dfd5088ba398947201c514526938d41cf18a53d324ba1824a477fa45ebae1ffba21c6407a9befbf8006d918120b4b581d50caf03e979b9283156492b1868a44c2a46b0e516e0394c64a260d04cf1b98a6d4cdc81f669308bd99572ba06f7d9479518bc4ae51260a13b10d4b022c6580f89124ae6624784363904922fc0642acd9f79d95ec106dfd7b48d5b11df983b8a542d5edf195df2342491fe3e431c13fe7ab70e8d2cf3d057661b8910704826a8be8d8801eeabe3375693284ffc0efbe7d3467362930db009a6fd556c2e1d095a914e8b95ca5f47e09c529bd0360790b1cb623dec889968518805d5e405598af2820eca8f315bcb77132499482dc1ce05748c8f9bc25db353edc1a105256fe560ac308c9f34016d3b81e2389914d3f5674bf78ef9b9a3dbd15c0901c5183e74eeb78c5f98723b5210287ec9f54b55e2ed278b8db5c17eee0d78bf75fc960faba3c2f35cb1ec22502e009347446ee1d658655e99e338e048680545a86452258a720ce1f5fc219d359487ad1c9517eb029eda2825e23763411b1077beeaa741883fd88955ada1c94fd1d6e105a1de4b11e09f77e5b6eb196248a7e12a7fc40f39c47d71fb306fc51bd65066a1828b8791eb5b1818b6b96545ff19c0261929793638ef301e576d76230e8cb879b26dafa5b2d957f14fc98f226055fdada3b102198135677d1db77aebde82bc25650c55c61e3799f1f612f46785da40345777558e4b224e0b619cbc18b87821035dcb63f878507b30a544033e76bf06fac743ceafb7d35046a5e852add54a9e975c358b039b05793f65f1b52be35853084aa4ced2650431478f590a123ea4c99416aa352571c77e8ca0d58ae759d10d037dff8a149a96b3e7a1ae457b9ab8f30f02e8a9381f96335a01ec2efc057548cb11fd44a275178a7189d9f4975071c8c373c59ac88d58811e0a7a8929790fc50a9ea02f7857d7c236e53682d05ca8f4f9150352077dd29f894e8e0dec39399e16dd3c4077e6bf31d91016c2155d6df188117a2097dc9158304a04bfee33c31ac1b78948e0794329f152ed8254854373d31823c714563dbb8fd604bca2cc22bd8b746ffc6e95877f276cbb2814206d709260672d5dccbf2bcec0f70be32a5aee273fb66b06224bc7e47bd5fb5e7bc4331507925f0920bc4b91d8deb8fc793ed0c4b90dff07292cc77b786830aba439b4f623268e541ae51c701867e0d96afde3260d9a0a27f2eba49cda315c8e6d401d174503d075a4362c890de287b8e7cbb06d0309b9f4b510e38561c5f83806e46b8d99055a18d5666b2a61e68e711be37e3a167a7bfc5b8037dae2d9034272bdda605cbfbd6eaae7498ef248b11ad536e281929fe015cf5046b67316533c643d7d0755b1fba4a5d3cec0976c02a57a267bc6f2f760225e59dcf2cbbee7d573947172f12be4d5aff6b513314f12dd9761cf1d2e6ce72b71641680c384936b009b0c8735578f42679eb692b744b62ca5733974116ea5b054fca471d11fbe250ed22b5bcb5b7a0f7fa220ddcdf98a6fa25e700eab60faabfd38b3fafcc092e231e598902396d95ab3971fdbd6f6a22bd8314deea9c7f3848545987304eb77e56c9a591acca35fa325edc082c8f8f37c6399b60251505bec0caccca57aa4ffacc27cccb5053d92ca7a15368783aaef4d70d274940d9484c4b67618cb5822854f53829dbdbb52b69d230d0dd1ccfa92e59db247f008ab1a5213d9416aaab031080ec3842c09b5c94ca1d8206a64ac13d0d9df9bae5aa6502e76fd10ea9b099ac6f8952ce0c066b5a4a0731b9b74382ec4207d6c6d8b378d7627d0ddb45b4b8661e50918f2e2aa255c7693f3e531f0ec8788b83f108d038134da3177a9f0a0f00117c9bfc745cb91340a31b35c84b2efd09343930ff054e16f511daddf9451f5f441d91ca261f285f926af6d6856764ae664b6ecc855680fc5b20da000f7c354e1388f7e72596d48aa7d95e265e860d436c55af8383ec0d37de8f0edb0e9fa82272ce525e69330980766c10dc6978df61d6fa9b3b8ac731d55c9338e11e10c0773bcbb1689ebb65cc27c0a630efb8c6ea8c24c52acad6de5d9309ff8f605a61c2630fa3bbfeefe7bbbba6f629dc3fe2871769888fb2803fc8fce7a1b471dabaf193378d543434532640e55c016737f3a32abc5f6e85a8021425a53b7644ecf6579d9a338a8ffa0787cae76477118710dd896cdf611e7524fec4bfadd868669d0214b9ee98a60f07be74083e4bbbed5b909f2043e02f8358d3e4f0d889365b916585ae9e14a0669f0e2399392d5308e990bfa2a6b9aa60cdaa64e1bdf1d72abf1f72934349a24dd0933ca56a2757301bafd378ea97fcf4db6d305ea1eaf0010d3fa1d591aff73247fc3ac5dcb854bd20c50f9a1466a3fc7d0462a8192c213d520754368d2da4e664db44cb4ab8dfde8c4a67a05b00c1db0ce6247ae9f349743663d77ee9eadf1de1c71434a7dd938a84d9e120d02c3cedac4ec33bdb64aec4035461eb6266a8d8d828cc779e5d9641ee9db173c8b4b23e1c64d8322af5b5c953a089beef3db7ceeec38393288f224949d79758c298d30d9d46646a2b07231bb6076bfa30da986bfe5215de87c2f07b259b3cea38f40481043bbd9e01e68e15f2202d083db64fe6fc73182425f307650ebaf72980a6deb1f16974e43da853a9ca4ec6ccf03dda1907cd9fb938234db1ee900ed43aaa57d53043a202dd97593f740cb472c4e13516645a12258fcf25d5b1bae13e228b8409f972440d010fa71499fe09bf74bbfaa30b06b1e58e327b9066a5552874cba9fd7963c41b550778235e512e26b64011903f50971a4e13c8e791d6a932cefb13afe7e2e04ac6a460d2b9ecf1d4bd154fd25e56c97abc1c162bfd6ca6f89de20a763322251abbbd76f34c982b82e1952f43a08fc255fa3843281ef31643a4ea37f1fd577267ed09580d4573107e6629dd4ac925dc404318b421147b0927e10de25efc3e99e80d903c3742b22ac9a56b1f6a6fe7d1fdf1fd0d83263113502bc3a63c6b1103b70c641cb1b48fb3694dc2859d8aaedfbc0d1993e55e17754130b336054454d45f0e09adcec8fb12f18626d67c00bed3711a85a8f48dd530ab08795401748d62cd46ad4287fb9473647dc34e75dc3f153b7ef275bd6b610590498b3279e9e7439fd3475188d64e6d74986fce62d0e8df85fbc096e7dbd13c3021a77364e650352c2ba9803cf818d223f887f20f92d230af7929c6aa3d490dc91a9d527ed3743053d20716266a7bfed05adafda97eed3d82de77a8de6ab6e9728955cd4c01ea3c4f311c53fa73e3a8046dc346c420f3a4f9f71b598ecb76d9e0727ad5c1a03b1a6af0fbbff6d77be008940dd0252c4f06e0a4e2ea5404719635230008d7077688733aa1925c14cbeda24be8fc18e8183e3eb695c22e0984a88a09a7adcb705a6e041babd2bddc5e302ff02d6c99245777e4446838f2e3919e16af778749fcf1a9ce848e402709a21e5482bcf72efb63bcb5695a172e57998cf6ab93053ec2a9273f1945cb9ab829caafc807a0a61c5e8971e7623419a01387ad8eac0a3d997ce34cc7ba1207865b631229f0917895acd9fc2f8b932be346551d76a8db84a01e253ed464bf56b425936b18f58ef8975e3284c45bc70ae541734b66e5a1c5d05aec274b545e0f085f6b16fd9457d6ea5903c41b97142147618ebff33056729475f0ef6e650d584593bdadf3457980ab2490efb5b56721a13344fd5291f74a3d921ffa7bd73d2bb6b02622f37cd6a62b37d0a49cca00e6792eeb7b131350d24d7f65c5f7b849ca6e63139f70ab5853dd4b5b8ae7c2fe0a256dac235e96f3da5912cd10a3d32c2f73ee401301376921e3c3f66a4dd4d135d61c7248c72ddd9f3a06ec7ad5ad09c065947794451064fe54de04277a0070bf807b685d222f2cb205949b6e1ae0525c2bf8ca15581dae407196204b6df5b9d2314bf6b98d3786a11129ac3b3984f1c051d5833f89bccd42620b92030f981ca220a6a50c3ec2c535db70fc16044bd1de2c0e525b2478a9e0210777dae879664a4d2ad410a5e9bb3a4d8f17572e9b34f4552b8b3a71681071cab0763109e44cebf6d1d21b3c40ff23fd65bfb2aa7680a92525e491f325226081bd9b5170c17dadba655ad3412c6dd5ddc9a07be36379be40a40086d28edcfb32880d935f9c7fcf37878c23e89d310d4dd2178a62cb406a9569b93407a3c67321931f4901c8c1108a6c8408a474e5fd209b59f94ccbe8c8c8211f1316480f2be8eb2905931d79a4b24754427237570b8884e52f6d0b0a21f09676a12362dce9845b32c5e8eebf7c66606bc12a8c305415d821073f9e3f48f6695334f5f8cc4101a39797d3e24716d9f4a29d069d37196a8ca700016c8174df0fdf79237c78a78b98976c3427153782b74b64b6d116442644017114266e2baa087a0484777120412b43ac57c9c598f8d9bc8e251f993b24db817fd4e2d803dea077c346954455efac8a743a10e0ff57a1e8459e0a4b794d57108e53f4d1442f8d08f76925a538d8049ad9a4efd8e504dab7ce6ed9c0ed92be98b2e9b8f13513cbdd5879c0c84a599bfbec8a7637014f13c6cbde3856e053fa089bec02896dd756652c7fc012a2bea6230386bf934c945c5fb2eb9ae796c6c80003e3720c72d50e5f76c7a7698bfaf9cdea7dcf4e946c51b9816bf4cc1903d55b50b5ca2de7d89aec005cda4c4f97a7d269e71d924c6908cc347b4abe51aa00e2f5e12e799659540fd4278f5a9b3044573f72b26d1c1efd85da5e0164545950b1962461e0db74ac944e8a0e27acc391162a68079a9f712af448a5d6710ed08cc628e98c81e27918262b68f9cb26aa192107f8511a60cf1fd8027d3dccdcbfa1710a5ccffec398ed1d56cefac704a9d60c775cd5d368bd8f87ab8efd8f6cf00a7347602cfe5d64c6921c92fe5ff62ed7b1dcf62dbf2b668fc43b15e12fe79f3ae6a880b1b30c982ef64dada895ebd4634c227aa8efdd7b4286f7a024e1f8dbd8448197e0816728593d7ab9ab5590e3427fe569a50413e519a2191f2c58e7f510bc2b92ee355c7baf1f3a0b869bbdb8e6e2015b8d8767d83b347056365c12d6202c156b1a2f69d969ffde46474ac74809606cfa0007ebb61c74e45c2ba8c7c5c618770a6925ff892602a2439025e6c4e615dab2cf0a95a058668d9feb81549318f9267386579edb3c785344931ac7b81693226748d48f4be1883a42f6cb5f9ca1174b5edd6ebe7e92c0dac9e053cb0d90a5a1c18f59d499117b3d16174894f9936ecace437387cf442f37cc53d0e122e66fb34de3ad69183c4c574939ec44bc43177eab067d63164ee701c71d7d8ce330818dcd7aa0b6b47291a2d05bfd499e4f0bbfd091ef7ce896f9a09d2cc571a78345f5c44a557fed17ab93a4bacdb6d04cc35c8bb3c5b43b4f55dd87fd2af02b2d4940cc6c13265e51aea2ed1175987106ceb891555cfb221b1a58c3653f17b2cddd682b0495e499e397b94b1a09fa9548cf1f7bb751746640b7047895bc21b243c88f97966fa767f2ff9d6befc3e11dcc1513f3d6b372656894860afcc5ac927e2200c3cd0b839cbe95067cbb30d0419959a058fa9a4c756eedf6f63307d6e1bad0244497f2562233fbf152d9045808f01866a01852496acbb7710b0a7094ed0c8fff7baaf4243e34bbcdef9b69375cd567ed211e7d7f0dbe12b60ad49d1a2640a70a630c86a1bfaf2e1be87627def63fec17893aa9f26295e9a349ffb619c9797d2edf4bf70375a18afbb340edcd011cf33202b6922ebde1d55a92266b9cb610cacdbd3f5492b127de9c51befc96e6b2dec8b60ee90f2c8ef35133382c63676217e834ed9c6541574bc4fe7d4ec6a526fa6e2f410645d87b6733ae63a633a62ae908e691f9a9df10d66766004e6f2bacf7df93cfcfde404c7b52830f695546c94fb1cc649ac428333f407aa7555d515d85ba5cbef4e394190f998da0eb3d2ec035c6728b7ea3f37bce2e79213c671a8ec4b8c50b1a69e490d4685a4738ddf7a4accdf108cb4cd995594fd404ea614ee2342f0bd57a29e17405ca89b9b53c304bd169cb293d77ce097dab8768e103eae2a0a2bae06d2483afd90a25a374d4b7e8aa377e29274e5f151b65ebf6b8d4bc25736d52efc61f8267c8d22de59e2de7e99258d0e5dd3fab768551d5fff62d4408906e47bc70f43362518367231c2016ca6f48c0c82c65b8e8d7137ac6ecbb160d02c5e9178c56adb42b0e1829935edf5b0d1a023afc943583bed39ef87d57efe308141de4c76d86c2471dfc9eb69b2d18cc1fc2855be34fdec69e5a0ef00b0cca3956c3c5351de29cacb9aad09c052d7a8f3755a435d7bc6b58eb5f44f249848072cc7765dfb61a2fca4df5f4363e4e9f6df9accdabaf064c0205ed34202b4dde48b732805211eea29fc2d1b9735338e4110193647d5a32b5b87d22a9a925e439706b2a4cd72bfa9e05463b08cc47184978e2b53752d5936b522700e337f7a3ed127ad819a7b70e64a4e2d711a91a38b49d7f95c65bc4519666e4644af478e6bee2233c72bdfd9bf86ac9213ad4a05e7e8909d41f6033fb9b50e636b0ba374d715d221122b773a9bf50eadc286936840da9c7cbf40b9df5aef39d5c74cbef3dc2509893485a5f991995251fd492ac5536cc18c2363657b27acb8479af25b9b084cce729c66c94035273132966251863a53669ac00a6dea569d013d43a8efa5af565663f728dd9904c02e780a3c527301a08cddcd2daf19df1edf6c698782add95c582c420cb46b2a153f473dbcb8ccc87a9f22fd1daa560530e37a6b937610b7b2197dc783bb11b19acd82af7874a1085a28c707ec6f5e152bdbe9b50757d5758f2082c1329e920a82c910901c62a88e26aea4e41ccb26d88b4660b7c378859f3a9463ab55522862d58c1248bd3a3856c65082ee28a32f62b8e83ce4d88be0eb5c7be5b58b75d06af0b0a095fe7a4bbba076dc8fc18f507d2ed0d658bd9c65bc0675dd2e5985d6fecf0cb4b91df98622b480a70743153735c7132ab310438a7855e8ca00327dbec1caf8843d66b4788e65a078a80f1e257c7d42318b30bea067db72c933454cf83b8d6a6d54eef3aada8be7b9911fc0f366adbe7bace40b0988ccd4a93a55642338d90f1789211251426a237c52a510b135e7eb7e613e1f4bfad0d22dddd7b2f6809eb8dd37a3ccdb8f10107cdd96018a03a1018fd6e15eaff1e0c1a73424dbbd916e348f53a7a416308a1360c87c4061037ca3a042e04500b10454cb00f24b9a5eafa83f653d078499c97e1b5dcf40f7c10bab8c07ce1b5fca639228ca95418bbcad92168f1fd5abffe1e3b95488abe40eabad1cbd79d458be3634fc030c800e3e2a0b69c62bfd524ef49ed029bf5b48682cdff818da4cc1f74900b6124da66619d7ffe4b5e2d2eadbd0832f8591768b228311abf41cafa0def19c8adf336ef5ae33c0ea899eaa29e444cb3179672c2f451690893537b3e57d8e756870e4bf619f9d0691df440ea1c31d84209651088108b0ef84c4175cdfdea20e0a1660300660eb6186f999af500a845cde33b529a0c515ea9854ff258be0a0f0da1317d12285fdc927abcb9b2916db012958b4d6e6344af77d8bd96e58b9b03de4d1c0222189db58c053b0804718f4551c21602b1c00fd5080effdf9b43e998ebfc0a39432c4c8ad84d26b977e80e76a53c3a1fc2b8b68c9a6965ad314e61f149a7baec5b0dd39aaf6d0b14ad626a67b0f94e9cafe0951695a883bfb811db80d1d14ea68b7e47576d9be6e5c9b76ef097cf25cfd905fc6bd129cc38977a83ceefc80b4ad5f48168070d98f326b1b6df9af8cbbd92028284ef3dfe9f6dfc613d42c28d1dabcdd7e6c0bf84240243daddb88ff220041b472ece80922c6e1b0cdbcf8291c88bfb1fcf06dac41e71187a5f93f0ae4fd4602d49f3ac37db122fd96be5be830383176dca7bfb24f07e8b096756dff6fbf5ebc9e808abce6be4a32283d305c96b35f632294b5fe4576a0a4de8e2090f8ad62edf43e13531b43c43fb16c0febc02a179244c0d90246d587a78215d9c90882b8c4c12d196e4378a60b8e5517d6d8ad832173e1736b2d8419d2ec55347a22739c928429fd0328b75e7f82e5460e6fc6876ebca71aeec25924ec8c736c2751922bde8b99db3a7fcb015c9441ac0eae2820cfae7e67770baa9ce7374b4bfe0e6ababa9643f3605b787d45b409664b0c5bf49d19d20e388dc9ee4807188affbb620ec6266fb9362f97bd530d3e2246cade0c4a140af953b797007058a626a286eba3b620d5757780dde00770b9da239736826a8c8fe2eb3ef5e7d12e93d2f25470b0a33937c92b779ec9a9edc5b3704283d2e2dc70d678027f6e9ddd4ca46b9211a43b0504733eead5a5fc360f139ce144266defc6f87a1873b3c628b2ae1e4c3489bff5d90a1eae3fb6fac31aafd9e20cdff76f732c10da7f551963848b157e9e01403adf88a4600a8b5b6f309707157e5a5e01bdf1c25c099ee2b454635f261bbb08f3a10ea90b19b1712a5ee5783b2f95072e5ccdb3bfd0c006c867c7b15e4bfcba0eec92499b507e80b85023227d4d813b23fc6ab47e00c9df87536b9ad2182cff46ca1c0696be45124ffe18c927194e6e02b8deeb4024ef5da6ae12094ad32389cd666660a362dd354983fc9b16a976006cc8e74e872339a2d95716f9b596f621cbecb70ea8e88633cd555e7bfe881213d13f8ad3e99b5c376a9d77bc1569c555556b4f920aa9a7db2d5cb1cb0559515dea841d110fb34d14bba527333d50603f9b6505fce8714fef1915eb3080081c9649b76b9120170125c37b2c691f570c804c7e0cc503e4aa6310c8afd925d501e5a8f92627ef9b9f66bc98d29c0f2407d25f7580d26a5af5fdffa684c4e725386e2981c638a7974e0067193544e549544acbd94fb3fb6ba2fb3b324bb79dcf04bc9f194038f4ca6523144d19388e1b843ecfad073af2de3ac46fb1e086c5e404ad06355ed1e9a11677f6851142221e52c187153fd5548894be2f122c593b11f8704add7b12b0ee96cb61d348965074ffe523260c3a6adc46637e9ffc28c12d516b7ae902595e60e9b4a6e1515a261c2a1e26ca3f7d2968a95e4ae8f5379fd1912ed8ebf2407f2e624ad0a17cf6e0e7800c58982e072489a8df62fd6713ecd8d6597a1f93347cfe66e365a7ee62b43c37f7bc4b4c599c925e533f95876175d4d963ded86daf66b88f2e8e336df1a3d476b29e9e48f21583e8fa9888b774ebb0490ef0f970e0c7a85110ed1a986fc7e35e94e9a7611fff5791299a25ed9bd3d5762c5c297f03551f693b620e0acab9067cde7e081a64b7942761b3d9bff9f2200c2a43117517f1bad7d09cc0f12da86438f59c2f635daa6075447f537fc04127a92a7f6747a788b49561c2f6e30a1e14e519f8d647fe5fb2497622991bb0a23363ea9a7157320744646edcefc14df61d3a3ab6909464cd924830de33c508565300219f97378a07b59fec4d950091324402bc3d3683b5cae838692b933bd80431526df8a505205e7e715b978796e49231d1a715c5cdf5c797c93321bf4000209065dbef8cfb8124f09d4e955a988490428770ea61247b9d9b9357d06243038ef5a1f621d27e9801b3818ccf3357e7a0b13205f0899c5928914ab90188b09889d38d9c9f6546caf3031e5318689eb4b4370ef1eeeff4af7c0818a08e31d116c1128c13063b0521b9ca493c3538b58f41937e8c8da5b06d8d2ebea7959b276ec000b6ea08fad0cb24cced71d4883a98e3ecf5b3221363185ff2c9537682e438c11f643009dfaca79e9a21cb424e0295aa5821f1e8785ad8b86f646f69b821dde1e5a6b29ea47e420cc11f2bc44489f9637015706bfb70b946f94a961b8d001d79ad84e7ebe751e417ad9ef57ae2a455731ccdbf5fdf23358d170dbe9f7a969cda41cb27c09e7b5eeb1b7336459772010eee4f00417ac49f30f3fe897fb75e0261c347ca515e24f290389b8c19f8509a71a8c87c568f229985191e3050a0ce9f0430089badb659679cee369d62563d2c7c375d822ed15a4835569aadc0d98f35b2bc18afd44f949813205be56b6916b804420e8ead1db7a7aedeaf9390148991eadc3e0e32e392ea89fea3fc38d870db90d57f036f216c57922bc8062b76c8e2d4e5672a7b19918c5afcb0696ca7a86fc27754508ef61eb8fc46b6bfff4ce8be0f5a267fb77c95fb42b975645de482cedcce62f085ad450283e7f77f560833677ce16ef9dec10bd4ee169408f8660b185b3238c084f3ee81175c5d81055562d0c96842aee5b39f66c0883c51cea7177b9766bc34277b6d24cb7d708ec27ea726f286af832903eec1227cca930bd93d03bec4f67eef650961fc7a9c8f4b21be93bfd006bfd49af363815112adfc718bd031dcabe003f7981682769e41c04d6261a99a6f3719b8b25b68417889198d61d030ce35d36549ef12d70fb146dde2550b336df3026767eedda6e55348ac5037efc44c7806fbd895c4df07b05e96e2b887a84502edd882437b0889e8f9dc3768b9365b6f73b2aaa44aa611acba995f4b6c256fcb68aba574658582829ceece918e35a49f5a1a547432afc1b522cb062c95de299349cc08ddc71329559a432114213fe6fea28abaa60485447eb863b751aa71ca121823175cb6e903955b9a9695a6f124372202d3c791c6469c17247c8a4ccf8af6f60b309054121eb03436453df29839690a95e9cb57b0707bcf8ee14a7fc1fa0a3a9aa82e4d4d3caa2be2c4418c6cbe153f61fcf500e98ffe5233f3409bff0718cd3e282a7b0195eefa002837516b24d31ae5d7d99631015e1cc481716bb26c8bf2dcecdd755a4f9e988dd812f62e55ffa69a8c1dbe18c527a9277674bd448777d6ad81ead0f4877206d81c1864c196e88dc33c20db5429a88dcc0048fd16cee285195fe7392cabbeb971c571f6c903becb317a461e86b7353b35ebf6f05a654a4398eb328cedd92d3ad720ff201835bf98c875b2edfd7642a3ad42b9023867d1a594451da33d9b5594a49193662c39b21cdf48f0f892c6f7da1d2fc46bdc4b49c425d9c5c1c251a94913a013151aa60dfc569de3eae5fb2de3512397f26c9c5183453c3c520d695571dae4a9443e2667f0f947d984178989a7277c2dcbd1297d674e5da341c2daf7401eb596d40494064418cc14a382bcd92a251921c236d3e59e7af30d56fe5fa560ab3089eb6bc98b767aafa9c9c466ff2fa15fb99db8f6339a49986b4cb2479801f959f896a8d69bf8eb27b38f95524d4d179bf44cf283d328ba1a4485edfb8f01cb4aa22c056c8d3137d0d3f293f050b8853c89495b4af0d48af705d6658d62a816f9831a8fd6caa10266cde02768092a194c249d301508213e79c9cfda744ba6d7ed5939539507270fc35e57a4aa8f9aac70083dba10c269b410ab702c6c99a3b185fda1ba87c682ed4cd8b1eb96162aa1f40ac2510a76e35998ed9797fe6f505c4bcfdd9c43e5f9311df1edd7c42b328b8e02856351ca607361aa3b18d9c07e08f24c095b92d6fc4c8c7cb3f1840897208712ab215d76cee09d93e768dfa13b225e93293c7520974cc1b28a739a13d7210cbcd2132a78d4eb195ee1c608d0bf8d30b81147072ff7308624dcc11f0d648c49e9c1783c4ce35c39a3f00c1f0c991318e9150c57b4a9df15b77a3913b87dcd087aede8319937312f103bf2f6c94d5a4666a14788455bf0b4d3b17a840dc947d29c4242bbfe75bc7703580677890c35f71555874017ef7c95caffe5bb7205124d6715e897afc53225c2293d4d9ca83720a4251a7c756a3b632eeeffbb248384509472556e8c58bdfa913bc33e12232aaf73c52a3e86f1227744c148beae3d549933caa0aff0adfc5a49ebffdf7dcc74acc0d26dd206e5b8cc2ac1058bc5011f9fa391300b7a97f2f34ca52f3e01546ad8d4607295523a20c74e0a607186c26555343e821925a6adc2419a69c167fa30d3efc6639a5e5bf4b515c55fca60b76a34ff3c0d94af80e0804bac48ea0899b38e4399b91845c55a3f26ed15d30d649fc3bc8305e3d28c2f302ee6b9b48da1160203ffbdc95b7384a777658b44e1fe49a1cfbb518a3dc82c23e7d30b31340c37c0a3aa6f0d91c2c221c8538e30cd5d3c451a2a51dd0ffd1e2493d1f6c8343c57aa171924a31196912412e563c4c20261459b4bcbe13a5f1db0004fbf98673b7bb3969ec592932678d6a07e8f6ad6c77218d56955396f7c5a16fb9aa87d032a1e35d7529fe54f88fa9d89bc71e2cddf7e880829e6476e45ed80ef2369869f443ac6ed87ad88c4da3446a5ab4ab00415e9d25e727ffc6ec7e3e678c4b907bd65f0b06251de22639f277cea67b79a9034c8caa1570f1e69bce403db70a693b0f8e1937b3c1ac555c7156e62fee58fce0a74434dc2f3543dba28610325ecf9c42b9dac0714a9ebc8dd72331e7225297b9df9aed5ae27f36391c953f803673f278697ab448b7a689c54c4332f172290872e8767abf957f1bd392ebfbcd4b1419803aea0b37cbff87f4d04c7b96f3c40cfa4b3083d4670df0a6fcb66b5cd5711567c7806e40d4fc571c5b77f54da1d3835bc24d8dab0ee8c75c3f61bcadc59ab001ecfc643f834e85ef4c16c08e69b21b075e9916d67e25a9399d9678ba3eaada2345a682e0ca4921ca1d64e2a1bd965d868c2f3bdc8800c85239ff5bec8162d6fa44b831e4728179992d12425c677798f3ea4f21cd36bc66f5c93fb1f249715f8bcc9e661bf1afe31369abde1af3cb0db96eef2ddf8ec2c97771005e54ca1666f25049e21ba5fd843980dbc812653d075120419730a65d9aff70ad5056d8cf543645a917731bd2293b09aaa1bd872f647321c5c7f2b7f38f4b57041c46abfe2c19ed8601790d742890ec499d0b0389178ad0e74c553050e6d4951b6f2f74eb11caadf4dc6646ed7bebb51626f4e6cf33621ccdc961f05118d9e564914f3ee453373e2fe001d73d45631098bcfe5e3b1ed911f4a74bb60702e2f4b8c7694bc953b57babb3e8a51d94d4cd557df8e8463c20c7e1b06cc0091f296e8716aefbb78c67ee86b9d4bedf5fc74b308ee929b4f3f2577b6e4b4c5cf95e7ed5cbab643b1238497b2f7300c214345aafec958bce364ea42473556ba3973840c2faddd74d4c064d3eaf2ffcf11c9c055c578cdacacfd53ac84a1b2d34f2a616f3d4ae51c3a0208d46c2acac8b88fff257f2fd5603f53496f936f8d8c8a384ec7ce1789f3e09f875df69a74dc2cd69e655f92f7d533d77e373dbca88e8a4c623638d61af0c2a8311ad5df51b8a02de03a4e61e59766dc20e897e6d3f621e2b7e6b7b92d6cf91906742555f39510fedf3dbaa98b51e900010aed655660fd8a1201a99152cdb38213a9f706f4b2dd9faadba3a350b53b6f353b2911dd68726977efa7304dbf024e0bb36403f1409488f453a5dd05035c16114f4b37f9cdd4e02949a30a66d98c253d3730c28edd8624eaed00b9d21ba71a95fedbf52717904bf2261ed518dc543f00ff04a21564830b0dad52f5c8c662a1e7bd88d1c1f80eee5edec1c3ba23be829056f2de618d6ab1ce958f9f93a0fe5a6d4323a2a5e7c78b43d23e5612d422063718b4944fb0d9099ea4e4e2cb156b52c41151e36288ce694e6a059ba6faa80de14dca9fdb1e0b0b2430ed51f2f229f161fb0cc13da64fbe9fcb75de8f25cf14cd4599aa591fe89d49d53cc14a558483a1405e992838eedb467f20f755c0af6e96f38d3e952a9849a609feec23a94c99716ffdbfe1ec305839d41ece7eec69617114cb9c2f72b249e3f1488510b30468f768f23020a820ac0434042cfdbe45db957869a8b813b2ffb75f892ffa546f5908d3efe946b018b5e57b57621d898772f90dae98bb39168389e5ad4e069965c1cadfc4d2f19dfcadab959f9f7b867fb3f67d1d842f12c709f42cc6850f06e8263951808915402278edada015a7582ce08cdab44b5295f2b1b266144bc069d34c892165ba49da663e3cf0149c142055608df0cdde3bd81e6e669541d6c5b996943ea58a7b6ed5b082ff71837918fe7810538227b22643f486ced71212532323f5ca805a258df4815814c2aec7f97bbf4eaa7e907d022a45a7ffaed09c078da2dd23e04c7d72d3c924d9bf4737d4416d2e5014075b6b9e884a0bf071fdb1267ffb9c0470b6ad01c6af4cc8b70e99806e2a4ee85271b0236bd529438b0741d12827dfc024c3b6b618b4aada4b2c6ec3d263839cb44cf186b5a2a2d055351475d580c18e3f35ed6def1916b896fa8be6b63075d69ce79a843503262483b393ebb39dd447c2d8ea7710f163af5ca01dec7dc187c3a9dbcbee6039babb957155cc45daf890de0d80d82e0e8c008e9dbf96013a317ff4b7f21ee9b9219dc0a8ba31452dd5066415dc611a07e7d1f96774d46ada6a822775ca4741741a02e8bfd90fc9cca55c66a4caa9019c0f1eec16efc6b55c24edfbed972d6a8f463b7be00991de39454013fdb01984cd33c8bb25327e1681ab8d4011a7c649d957dae41ad72fe36d7c81051fcb40d4caa252f1b11c8d2da390e36fe96a4c0f2cb7bf5d080b083b3f70e66e8b3aa120a377499e876b594f056bb790dba88a3d2b5e7be2408755766da62acc082b5b2b6d817305d4f05c15514eabef07b202c78a11468e8b7cbcc549966bcc28afa9bc102e884a7569401b5637bb84009786011f375c9434a56e0e238241b033964f0b4b823be9c00229efef35ea11bd48c383517a0c3ff732544b537626eb0de8dc86eb85d2551419593029fb03033177628c1b26df87fe48f159c2ea2d4991b89a517bb50fac783a3ebcff13a0f4f9c97027d7c5113a05f4e23a8f262318a56ca3fbaf9282e52e5ffcf763722fb019ae74cad090bd1326d87a3b89d5ee489c6d63681fb9f2084bb26d9b90d9929a053874c6a880f3d338dc3ffe9b087ea06702e63cf4d2b0b6a71cd3397dd9bf3f2a19eeea36c6bf03e03b39df32628c23a3f62fb5a4d78a264658865b2cdeef939bc4d6e27582a85e9ef05f8bae2ec6ed16a5ac0b108aad326973b39e7efb896f6bed211974ba56f209adcc9a4b8895aecb9a6f61794c19e712fe56036e9c49408ab897fde926f2e2f895d1470e1a391631b5586643d985912b6120563d1eff6c7a49ee2740da10ca889834e09fa64031f39e2225672a9e7cabc9838338033620890fc8f72b64a683e8d611639b72dab42ce891382ef524503e3312366bbbdaf0cc2521fc487d0971ddb1a2d9313ad5de72ef94d555b514af038d23e90a4b7cac3499398562dcf0079b66729888cc240b995fab90f78e14de6db3e9e3efff3d0f8dccc863990231c81c5327703e5305140847467daf112c57c6846a4d8360dc2adec44e2fca5db05fa1af3fc39ae5c459f9a27621d6e35e4e94076c38bae694db44580f6ee5c0abc3c7f3a8517d245498be7c69dc96face43eb4d0f1af5f4128d151f500cea1a1b7590d8e724be0e1adc1a1a44e17a82578b381d6a2e56573e697858100aaba0d28cddafaf825b78e4766c825efbd77cd5c077fd34853da57e5f5a0fca3481b080b6e0401204c075ea1ce5f6920b37c1d4dd9bc033472b90eadb27fd3ef9fdda949507c0ab1e99afdb8d6f34abac0f0a72be2e91b0cbb35f304450b025aa4a9a4458e152d7ee8d16947f4f7d40ae9b5f98bafc86fb4e27bd74e7cffbff13dcefc72e61613a9180d211ff34e8e0e3dc330a9be422a6b780dc80db4d906ec8c72d24289f04471dff3b24ce5d228f6b3a2f990c346e3c06314feb967caf62c80c316d636ced4889972dce59b0100206b162a48da81f41a31bf4449590e074d01ee7c09604cb9814ff02d698e9ad5df9a3ba3dabca1c3618932673280d2e2a4b6f328f9328762c0336170f6f147729929f130d1eff0b406e9d21ed85b935294983fc06f2b5b80b0a4ccff67bba0764635d8304c8f5bb317540b98c38e5dfa421ecaa17c87178c1b43ffa09272ecbb2545f6fb21b3c0c5d3efa2f77e20cf5e24bcc9ad138d55ff869223ee2642b4609ed8df7478b282d72971fc972ad761fd6f6eb5797eeb9284f074fb30e27f3aec3970ab7fc2d8190bade98399d12ff1da7b2e2f55dce20c394b8fc3df07e74fcfb4efb3fbe3421c09bbfda7ede3be1ce3ab03477df715d411d97e4d99ff9950d441aa73300144f67790ca73ad75ba784590d666b2a978045e7feefe67c18ca6c5e88bf9dce6b691f049fa198bf6460b540bfbc4a6ebedf277dc516e2e75aa246b044b82be09fdecfcb2d3788fd3c3a27803e7b3bb8ba31615d7de756fbcc36dbd77bb00b9217b4375a79cb98009673be102419ab9cb5492b91fe0a10d244fece4c864fc67d61c7eb21e944485299abe740d1637e2bf7dad4bec6debc8a135d8fd44c90fa98fcb5db3512f514b49f9f0f879a3327f87f045488ec88210fd09a6818c6d34fe45ed0ec5157620cfd43929e02b1c1005e65362c3afc4a4ee8c55d8e67f509d521c80a689bfd593a2dbe693965c656c4769ab5d3ebca9edd8b59db2f799cc0d53b0dfa4f78ca69e0af87ff3bad27d2724a68122074a026461c911d1b6232a1a827b403f2716bc5882b4fc21230587734151de2e08dce9be19fff032addd92efc3c183e1887ebe1d6f060218a7b6aae98207c79831323cc1640d0e59d7e0bd35e6ed1ebf1132853c309d73c5bcd5432615f5fc25fa5a5dc589ef978110707e1949d7f11e4a61c6eda97f47a540a600d912253a074679a296d51cb5b65e4702ebc74d02fa15ba28dc3fbdf609da60476804f8ba6cb8d81b85e49aea58d76459a48d7a3ca8d181b32826b77f5eace432dfea7da936b4f3c9e902592de141a561aa00c6a6a0c1b5244a3522a984ab3d8216e77af47d34d286e404102ecc35fe44193011b5c30446e6b7e498ca435bc4a8df4ff4ead61865a93d054e0a115b3b0740d0ca29f07bce88e4a263ec1c19231481338b876c172d77e44044412829160a7fa159c135d339c46c7a8ec2b7131d85645600629144df62b49a7781709db1d5f57ec0416523b2816ddb203e6bee0cc54e2b3150bde92535793d48f98de4d6fbf4e3ae310da91b1cec596657f87c3761737ddce3371a144c6f34b1534f76c0852e4c0df9c039ad8b2d04729ddb90d2b49781b1e40a2c55b9e639f802af492de49aa32a861c66dec8a6029580893ae831fba11a34611d5d67b0755e8f128c89f4b567251367db8ab7ba16f65432210350d6e322508d804d6d8f4d0e11581883dad7719377c69c5b0781313e4b8b87ffb544356ec71918740517d50af57dd3c4e4fa5a8fccf167ac503f80e48764347412f9bda64965c573602eab15f47d7dd41984a1b259e98cd51a05a5bb324242155faf7fa68379d08daf4dd85f7b165bbeb7570c0c1904f238d1176ffd760d985336c4ec4259e3996456ef5d96d465241cb1a33b4e142b0cafc440a57027a25c3d348f6dd82a506d959cbbe944540400c30cc575daaf4ecbf7f5a8c5112985c1e0c1a18fd2aa07ad14099c6f3be50ace20a47add250a94cb82fd9f1369c205afc577d3f10a0163671dce186552545af9c0c59b57a9ed4a52eb2ad9b8582263b0009e8d224cb59790730a0ad19120fc282d807a79727fe3141a37de7a43ed76e08ab8970aea424fbc2514f8b0e99d1496ad6419072763ef08b3494eea9b40e8e36e1ec120f2c1094140f420c8f3a38c5baaeba775b3f8a3939c9a95d4af3e54eba4ab9a4052fe5660469e451a446718994401c9a70cd936a2250bd1b38f4d97010aa6a086c33c0f9b5e7855aa3e16500e9aa44c54a3ce7e6da3e373054c706b3d92386270ffda52f5425ce93b2d87fb720c094de953c55d7d1c4e8a13ccd52dc1c32e862092603ac9ffb2ba1d72c05dc41cfad218c56160d1d81e97662ee0c3abcaa3a31f9e75490a622fe602b8c7571cba5ff407e98a9d9e34f8ec702df8412b0bae4900d0c1203c24f538870a11602b242122fa10ed8044b194077b681d54102d92d9bdb33fca346ddbdcb7eb017bb20e8b95a28d1cbf789fd7d1b549419486d9f01ded5ae6a4134d5109bad70bd71b0026a14597015e2748d33aa0837bbb585475454eb02e3199de109a3f71829c1806f4ff0ef211a4dbef7ca669fa00cab3cedea7ebd4b3fc551c1627e5ca09cc3e001b4c95ea8a0231d82507c06202d48708825d8233b04c7b0e775572c13a29d4305e06384426ea97a5767053985d1c16b19fc33666e9c6ed5e3fa1eaa66af9723bdc7f440bbc293fab828a20ab132ed2661cedd528e003034fea24718eced38b292ed45aa3843d08897974d4f7c5c2c8878e1d12d0e9aae3ee3d019ac4d7f0dc0f37079f9dbe6e136fea9e6539d1b78163bf0b9badb14024ee497f16ab31e5bfc502d6723f2e12903a1aec12cecfbc32efb4622434bc20638c9a482461f63e01805d231e11b4194415620b4a99ab684dee7047c6e923653d7bf321dd1ee03418c20dbe7839b033cc85c08445418951ba8dd5e191758806055b8f5c195272b8057d45760d399e01ef7e7abc3bde5ce59bc08193aaf10707860f56f29d6846c04121b9e66c3638d3946788a88f1038c91a863511521367045327018fd5ae3f01f04dd1b4b481aa87956b4af85f5101e5aee775a622915bd7e2e76061762e8c5332f07131f95a903de8f923baf4088d56eb4c2b3e3afd1ce73172936f5822d6323517bec662cd88e7f3783a8d4c074d09906d1ea818f34c44cd8d75f6339303d611b09d27cbc096e835510e1d3caf476aba41672477406456d144661c21423b6cefe3bc36a391df6b6820988b7064334a676b050a2d2e044a12d5535bc7d77575bbf539858935826177a906fff75ccb964d92f447032957458ea0aab4745213b00c7e725c561a2f076de867099165419d7e52e006c2c39c3f3de0fb7ac13781a393e5692ae1214f8e51276b4d2b1f5e76aec3c7d8646849389ca5867893f3be5f4ec1625ae0036e7402be512c87a4e4b0d1ab6e40ac9b5045dc0890f41429737bd010922350724ba8d98c61eb23de8ce3010288e51c138e7022c2a73a5f6c095b131fa718e6945e95d776dd339e1c1bea6968212695250f4c10ca3d90508a777fbe7a4a1f31208196d74b9f2ce78d9464e6ea74e5bf6f3da354ba35a57e4e8607049a71b66d77c9f192db3b9fdcbcd3d4873af2bbeb503432fa69d803e7784e644391403d408642757f4c6322ad702f00e5e5d3c930481af8a0245278bb57a52e9f4fd264337278ecdd70df24a8e9d627fcfb2ca8a697e9dd9130ce72fbe6e8e2ac6e0b8584a5efed84e39dd488a2e2cfd9f94731db063c3a5189efa25ddf2b51a26c44dbbfd634d99298eab14f3d1ac6bfa85d72a396232508dc4574828352e15e046e4f7c3e9dea0cf8386bfb6130f2614cfdbe0fdc5b35cdc55d43cebd4e7e243e90cc430d9db35cf799b9c797c95d419bc4088b110f81c9692a10892f5caef6f8f7c0829ac624c6306d4f7eb64eb0d076ea9b8c4e656490fd7e94fa435b65e6c3dfe57666bf56884f521279da405e05f0b57cfba94366e6c8e6a9569acfc23b1eba53d2fecf75c71dff07ab474faddce3a529df2a3f906902df6f9f924025d48edd0fbdb2c20f3fb37a44c1c6a6b9206ce10ae4eb376ae168fee75ab9651a62f32915e678c245b6b38edf36adbea65a85e8ffd867601d5e7fb6411823a968f626f92731bffbfd03bc86bbd6dbccbd8879eaed32f371d4994b52e22b2c5814b50ba87383d1940dad415ee669d1da761766fdc62c6e59159bbd09de0d1081144197a0c6e630fd92cf2eba92ce81b09bd4d0f82e6c9155375996094f3ce0ebf27144b09bc1d4868689b3d19732c200330f73405f761974dca9b62560795b6a04ed9d9711d3ee65889db6a704d882444580abb46db52f9285852189716ef612ad32e99e6f877b3a5512f6acee53a2cec7ce4773521277f5cc2f79b18dc768d265d16308dee12b4411a50842cf1bd2028fe7e6527764b11beca1617cfaa33487a686860e6f57ba82fd3c6fe0bcfdaf8ef4282ed9d9135cc311f1383114f161adfd3a380e6e1272dc91da901daf75bdb9f49f0901e535eaba5e34354d51808738862b8c382e859f43a6fc62fac5688d9377622e75e5866b51a03e7598b08f21dc7e9f6f4191873c9510084079acf87454758aa8192025d6b1f9f73ec45119866dfb04d4173bc04b9dfb8fedeb66a0f74285c7ed2dbfb3e8c16ed0f3bc1f95786f12ad1e84b12ecefcd6ffe26f486ae6334d8add5f3827acde3c4c236c0466d4f9aaff0a673871d485e9b8551a3628a600c4e62bad1970bbbeb4e840d77c5e6994230ffa1788db92418e89d02fc74acf3bd63f98ab550cb006bca842be1f677b60ec3832e43975a88ab7325f5c4e5b772c876af9c940f5aa85a978ded4896d6f82bbf492635ef3c7d84c0e712bed72e477f6eda3014614f66cf8567666aa22dc9c049882c6496d88bd394683153de8a970c8a4635916a497686cd94a9c8389052065bf0a1cc1d1cc0b04dc629cb68a664d9111919b3617b20b15f0745389a2a4ff49386e5388d47c84830046385a13455fc79f7b1bf23ab0731c1fcc489ea0defd28e5b5fdd4e8e1723487859eb390c9c5c48f51579687c902872a7e8e0a7c45705020f46ed8affd7de4af6651e81973ee487edfeeaaed466bb47aca811de6f057c26d584b6c984bc90bbf9b4a540404752fa1b5118c4301a197a033f5038cf87e53cce04a07b03feda03be95081d0c6c29bb345ce43124a117ffcd603b084088760c28e6e6c64125b6a2c2bc9eb264e7e06977396c1c3ac7c0275a08a6c1cc5342e191a556997e016172c55a975917e228e41adf2718c99b33d1d9be47507653c43f66cd789690410e913be644e8e4c96ccb0944cf70c60ca7aef23be48333cd84e1adabf67f2fcfea0b66f7e663a11586f44eab8b050dc602aeedf40c45b770163d47af8ab0ee82f1480ddb1f6b389b9c3c0fe322d3bf1eaa76d5b98aa97b27ec2ade34246423ceb0aad07af15667382747f9003f699c1364fe41fb928aff02ca8a95fc684ebe2f9067d7d4cc664a07f2e2458a71641e3c54143ad65f8d1a3b28b27fcf1494722a6f103ff77a2b8d8dbcce017e51ae74c16d14e2156b05270ccfb55e95fdfd7ad727eb6d3e423d78acbd8f99a914cf43712852fead41d18993d62483c622729f80f285512822d681be5ffc7d594a036","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
