<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"9243aa35b8620725b06484b2055f36482cae95594a2212bd6d8d1a9e91e6309cf7a629d22cbe9c959d6d1a11e31fc652d0cd3b0e7b4ebda7e873b9e0b5ea8ce80705b5ed03e769355b2c97bd88ec59eee1d632de68ffa5d2041496c915b136e9238a2df02369a8c6e0aaaaa3d9f397810e3e44ec3b297da04686dde9801f370f9ae55393d704e88adad26746a158c8dd15ac3d3ea80fa60e6eb29a534ee597f5af9a44292f687aa27edbcac3409e072022ba7514ac11272ea4c2cafc5c6220b9fc0883e66c5d7610c5f26dc7dec1d98aaef51727a7b3ed1ceac6f451e9e764baf5b4aca1092e01c17ab89480d1e13b38b41ad1ad1ca77c406d33dc8c828585b2d12ddb243e5c4da8382eb5ae08e7b69ac3c3f1a83943aad972ae6a30b0ac2d2aa40f44839158159ba4a778d506feb9893a81d9900e40820dbef04418a0609050f1774e8523cd881f6b3ab27d64e9dd9908f8f8d28a491cbeb78cccc5d85625350cd69dba475dcfc75f8bb1e24a3b9e89cc25213634d25167e54776d09efb91ca8966c241c8e7e0fcc21793765fe0dabed5ceddc9580e655b4f9598f69defb82c511e3c530383705c8a88c831f6d198032a294c9483cea91565000986404c1b89011cabaf4f11fe36f1062acff96447463d124f5968c935657e4f08f844b636371c55b2b3752a8450d54292e154f9beca881d9187aa59dbc2e82c9ea7418dfb8e4d04faa6ddbe3b8c9c44de059d32744c1cf27221e8b22c545eae0adf7904bcc8263ead2c6dee45ab62c7fa221ec608faa34a74b251476369b8e0e2a85e519bda34538080587b5e9b29d8b144b619d2d3dcefb2f028e308a581b6a5a97046f975fa077e7aef95faf4ed836655fe9832d29c99a9f3adadd6c23a5012f88b0e4867cfe035fe1bb4c779631380d402ed8d416ebbf48c07bbc3a288c5d2a649581c72b8781425e70c7423bed80e68586f204f32b9ba5a319e761ca8be8da0b411431070288a1774da4d2a1e383b6c8a22db3548bc87060999fbc1b84230ece02705101a0cabd2e6ffde6e2fb79959e0b686f4976f99409ce40299a9b37bdd2784ffd71fb70a8d2b1cdbcb2333b96f8834e0a425b04452ab8999ba5251844d192188694307b09d4eb60239b502d2639046f0146f3fd695dd7a39ee3dc1393f635289bd3893218c4bfcf4a8fcb58d03dd3fbbc8a9bc3d60d2b4f5ee9e3d943c1d66c47eefa8ee1500fff488c8677f4f1b469ba95150716855fcc38891f1ef3526744981a07fa8177afe4cab1f5b5ea7970a737b7ac579b933bd2bcd5d5803d7d5e2baa115c7795c1f744cd0aa94f25556e0cea5d951b753c5273c5108e0fb11b56a4193cdfc1b540115294075f3205197e9fa01ddd5c59076f7f75337c45f79b60870b0c891dcc24d6aba4f2f0293cf0e640f604f174f008e468d223708720c9e32fcbfe79310b9e2661253102529d432017ee71628291c8e80d8e43636bbf654d2ab45247a4fbbaa1f7f91936d56ca798e3004a92198b25b5680e95ce549e114a64ab3c95f324ce530136c266d948dd1d6b0c17c90ab56f4091da3911d06bd6329361937b78af82c7d5b3f11050e1d68d39428bbb85393efc82ea3103f0206236f479a9a95be469c79745cbd88c80d65996d8406a0d95fa4332c15b4b6eda4914bd72dcdcb190b92aadbbc3c5783a852311a291630b5c84614baa40de7ba10f5ace2bf1d37867c954bbbfa22ead8f7db5efb021633b33cd9ad36d38afc4db40e03d5409d910f6c29274033ab806ce6ce25ee3d7f3d909b5dd8849f63be417c7b98df4bb0f125a26ab270b817aa2833b83f8d48e008a19288e6a52eaba9879bc7b252f66afdb4c6ddd24563b2e637dfc20ea57e94671c0f6e44566cee324388f5137f460a044cc2e2523518d7f96ae666da553791108f3135a1b43a2beb2baab7590ef03773fb5e20efb4a768e2dea78aa7a3219bb7d82d7f07231e2e6461a8042105ea2651c9e753f22e678465d29da3c9115bfec775e8a3769dbebc437dd8fd24a28039096e2e93dda830d3a14fe1c1a31ac0667ef5fd08c6a0a8499fdc4dccedc2dca0f84c7dd756103bf56b3325e0db0e0fcfa462f1b5b2d693031a442849d321745289389f5f54a9b58c65f97deff1ac3fbef303a59fedc3c40cd32126d771f6eebc28e43ec6e37a3b7f7d9b0fb39fb750db5dd15f92d5c5a2b91387b2ceaf964b7c80be7d6fe6750580da1e414bc0d0833db66a3ea7bc0ae63e98034bab0d82f7f6799c97baebc15297fc7e99e2706f7d830a41ab1c697261cd6da5d45748fc185b554a25e04c37a60eff978c2c6eaee5e55fdbbf8b977431d39ac493f148bf94a92da1e1f448731dd41293c5d0deacf6a770b28bf5d2bc3d525f52ee670ec2198195766e9b4d303e1204a86858ff0dfc7d2398a2a4799a43bc2a5ba50a57d57d85437d33d3b4291e6f1b5b1f928acbe7eec628bbd7da8cc19ef7d4a5e0ee9b30f4518bdd10e087738c4dcdf96eeef239a2c2887c2906c5353323b520dcf9db9e36dd699fcdd2ce0a2b6bb21040fc3b504fa330b35b04f9b556bd20205e2c56ed0595bc1319674668fb00d07d7549f2e33121c81bca7d9a0cb12dddcf86fb0277fc330368cea294edcc9de8a7f3acd8e9ff633080299499ad2d9c54ce72b3011df649e2b6de05419b287af4afeffa7fb6826988b54f931e9d37d511fe417a3297f8657a3efe5ac1ee26896910678e1120df799fa521aa7d10a8ecd5f458e42ba3a7648c2b261f7f22930cb5ac0d1caeb4f0debf95a343943d1d3656400d1f828b9a5f02d6430a5f0069a2f42ce0a522a42906731a556315c24e3f45af16b839bd8cb8761e470c85307cf8188036465f7934fd33b41ca4797f4aebb5742628b059d18af4e494cc72574307ea01ad1a3ffcf176d11b506a5e2dbd16f76eec6aa92fcb40daa08422a5857a6bb5d4b9f13e645da5c0450e79d003761ee4e3ce1e51b07e91e6baace3cde5efb895161b2bd950221dda4e7beb2d4a8fa9db1f587fe8dce9756196f75fb610eadfbadf5fce89b63bb4fb347b030385d46b2f9bd5c968f7994304610e45dbe81a8da605a2a3b8bfc3415be483fb1ba2ea9b087d047490b1dda4c6713348d37af6a0fb8aa7869eba9dd8869e5aa9d3bd7e28f57b97fccc36560ee527a050a4dbbff73642dfa275c9ceb4793ab27eb8c053c18e86e91fa1cad2a36c0210259e4c2dfbc18f6472a032e5a57dbd7d9299028f3365a947f44ec6b86d7cc5630437bcfa68de8f094ef784755430eabf20f359ac93a1960ab1647abb84afef42aee6ab9b5438e04f2f426c9025e1771fa7c7caf699d225729fdea74f1d11d85771a7700235dde246c4f7ca4055bc63c1ae9f40833386c43a37f4378fbfa0a1f8db7f2b08a0ae7b7217a8263cef6a2cfe6eb9f265282b61ec5a4438cd8c53a5cb31dc089937338f286eaa4977a4e18407bf22fcfcb5b971551cca157d66280c533bcf3b09d658f6a3bc71f91fd0eb92a9251908a177f2c01f6fcff211d3dd8782336b15408e1e8ffd4c245ca472c9b664be77489a3a0c0cda48476dc12dac6a58226fdee662944cf6e24f21c7ca5e1142c5393f9ce63f199e4ba8154fc14ae16ed9ffaad8ea5007f0d71e1c30e830f21f94ad1938deb002755b841a6e8a1e12a1de828189ad05a5ad0551d816a96d406c8e832691dcb2dc9fefc24384375913a0c3f773256d349533f99b3abce3d9229d2b027f798460391a53ced02e516316805d1598ceae54e8d3d1e04a178ca72bec4229fe169cd1df7678e36ab387f7b1b9dbe57aeafe55b22f275a39b8c29be96302d82e94591ff2971673614ee015cb97eb1afcead2ebf9f89c58c41881b7d9117cde35ad232472e2e9af6fa1c7bdeba3041bc0522f2fa3ffa8f87371466a02fb608033e00087f33f5fb7f48ca9a866d74d2b38307008efa54a6f4308babb2ec90af2fe625f45ce78dfbfdf62088cdbd11641baa6a5acb7ccdc70f38ce17661ed50e33b99569a00fd71631303b79021c24ff78de99c7a4192cbccb8fed2037046b626caa386197d561428dc60642f6f4c5a9b705693f212fb0b593f77a68f89bac4c35d5c1e9a9e7c30f623eacb453ac8f38f250da9ec5b1a659638349742d00e7caadf048946a6f37ff4ed29e3dba42c5a9a7b96e5c390e40e76e95362ff1ff8ba6e965bf67c9bc9e31a451474468e485fa2748d9a6775b849c0ba92d3ab5bf4ccee6c98490faf27d3d3a535f3a91198df92dc88cdfd8ce4b0014d7db860c3ada556e6dcbc954ba7bb57300b06be3c0a755bb02b01443dc4606bdf88bb12e7edce1f1ef39ceeea6f75bfdb6d7edaf41f008b3e47fa6c62c7be954f5fb57c5086276f4a39aad6177bc7cd229f545f6b6543041f5ac8e7dbd26eb70919b37676d40ad09bea8253c5d9a661800122be6cb22b86a7c983c00d28b458cc1d1f52eb624715cdfe4b2c4721c7dcd15d2da8b4c777b6e048372b929b64684835ea055615f782b8db16d866baac23c7eaabbdc2500e002f749e26dc4e57ffd54ce600b5dc314770d5fcd41c30049fa1afe02e37bf462ff7dabae45da0e77b4aaf9960a5f5fa3bfdee371ee9ca8a238886ba79fa5ee6ef480af0ba3da1adf1eec139cfc77ba067159a4debf5ad502adf778d2ec2a037e92a0808038041d4b5add8467904f3c20d5761181bee4463031cf926e1232b3902d92bfb56afc1eb8f4fbb51e2a52a5d90fb76d1a379cbf318e668fbeeffff64b935261e0e3cd51994af1d54ec6a89b123380998ffd7155e60aab1322c5e71ea7851727a6e07b68432c5245ad43363bccabcf38013d4e0f75b18009a347df2b5b39c4fad09efa2f068cc6e08816513ac8fb449bf696f105721b816f52083239f8abe3836f747f74ea0109810e08b70be1dc1923eaea0cdec9e00ae8928c6bf6bc05d4c25f5d56b2294958f7cb0086a06fbe16e14e07fc00958a0cbef6266e7a5b2242b959bf51a95881a1f1459e4a6e3447c79194a6d95eebbbc12fe9fbe3d7482f0faa5d6b982490197c62b5c7d12631de4de7950231293db924ca001ac47ba11e86f3d57b85c792e0bf888e99dd83a7ed421481ff89a675fab7834324cbab10c8438c9d044e8d4530933b7d02fc07f3e649025efd8346532c7a5f4a1d844ce5b35a3e5ec73c5d94228f59247057c92749facaa04b30bd8b8b41a4735934105f2287898f753c04821157805544f675f92d585e1dddcd2d51e25353a3925a28aab2d122ce96e752d861295e0233ebda3712d39ae50cb97061fe4daeb47585bdf172f1fdf0847ec111bd1d61e3d5aee66d98c692bb6cc44381e12bf7e64de5f40a05d4bc73cdc3529be4943b2a09cf8676b64488b891bbd0cb5aef5014e40397a86a51b9a5d70e08d82d562b0d71c6d00944f181b2a4440033511c0e5a1074397549f1fb1ca8a35de183f386da0ba67c0537c318f43f9586dec93b78fc06122d8383e878b01870e43c0e14b316a32b71c2835e0c1401537a333a6345b816d763a0139b684c6964f73fa761965bf4389cd124e81d711dc76926187cf9b1cc33f9810ace65c76c7af4dd072d2eec1831ed8b72280d02276b12df17fefd2c2f99253342876b4f33d113dea08b1282dd1cc733563122c5ccc64725488a3fd7cb6981d1f1fc42de38589fdbead520a5118689a0afa55a6b1117412e9360a4f637a1ae0bef2ba928dbbc78cde4e6fc30008c826fb065a5da539efb346659028dd1f45fe150a1bbb2c24385ce343bc6a05931395d7826ce668329de5d73e84e69202eec0d0490c1c2501e98c99623c7ce00f1de026361d4ae7f4ffc008f304c273a1d6955b05f4aa64312b32a2a41d3862fe0f28ee1b4aee4badfdc055df982a3f5a5cc0faab402a3e38d086944d4ccdcf26eae0a4ec5adb81472aee3e7abd8d887c405590c86b56a64fdf8d38fcb2e53e08501daf1673eab316a8b1e8a07cc41a723c3116ce1f1a93235a37aa1ce78e5843bd21d1d463abd9c1fe66e1200253d0a8802a55e5e1d3d27b689677a84ea3bae39490448a93fe6364546e144f0fd54fcb8a37f0c6b3132395e1a67f0b8eda2a139c1caeacfcda1477bff4fb520e3e89a5d0e8c6bd546e276a2ca90e77d224fe984ec03843beeae5dd465f0843e445a575f7e76018b98abdaa1877634156f3d734f844d724a50ce53c5ec0cf94a6c9bf41bf6c4b5f5abdc9e4e377d16505fb7c6ee06f7064d690e6aedf87b0d477fa6eb7901b7ab03ad6f88553efe1f42ec4c3470ff054437a163bc6388eb189c06ef1f9697f481d2e010a0d6561d1cc5586f0aaed29712afdbc8a894f8ca0d0733e648606498747274f0abd9f4c08ad8ada8d34665817db2a9f5b870027de4f399fe8da1760372097a5e9ea7581d699968f8328a98b1dda0ae236c791373cdf135fb1b5803c466a82d12d5fb2f4884be96e5fc33ad7b009d6f3baeac2a06467d4ed6737a46ad38e4dbf810e37b9945a6d6a3afc0519adf9b6445d909d73684cdb31811bbb3fa88a4b980b7f11758b891a5e1ac0de42705586e789eb174c7cff6889ae173f646bab54b764ba3925ecb55a6bfb064dfa4bb2b19ba337dc6a4c08fbab980eb2098fd10b13c64c2e1c668ae6b0943d4434a229457150f5373cda1dae79bf73f4be8a36a920aef10e570c589c18522daedc248fc9d45f30d370a7de447953d7268c16f8d20308abc0e0531f159fe39081373ef486440436f5971b2661e49d4f731e2588e12ce68ba299e12adead5c4137af0e6979b6467d0b9e57d0e13819967978a28efff38c6b43dcda52e967f454d6679e6f64bfe31b9e03215d964948a1a924ffd098cf05d65b51b028d296109685655530dce91f1e3a8c30754ebbd1c226ba2d524c5d26cc3c03541fdef08cef208fb91a91546309085e1426ab4ef4968e6d42c793cd773fdb037fe16412d0974e2095a489f706a2ab79cdf8d1769229f5e95a173a18dbed3765709e9d8d6767083bd0b19705e26987f51f36e9d0a5a854462d85fbb4d812579a12dfe128946b1ce42e7c6fd44800ddf0b7a5976fa75b79a69efc570ed5f3a30651247a87edbecc26afbcbdc10a68fbc64c6701ce7e0eb8a8a9d6fdb655a8508253bcfb8c6bd3251735ac2e175ccf4e9862ee830e6c9e8224a80a863416ba08da156a5d87374db76da03f257370087345d22338f8a9935a3f3bc7be2ab006ee7b693713b9971f8bf1300d9e4c67f15e8943d83a4328e8e39d721658daa54a3236407a6f5b918099d240dfde440ec1cc1ad83df5716e56c95e498b7c43b3897d16c41f0b0f27dee13e59241daed71a88664540f9459f3bfc72efc29dcc7ae6c872653a448806e9aada4fcf601ac6d7bc0e50323db057ed6aa56bde8b72706db6f827999dd4b49fa95fe02ef12c8cbe01c8aa8894ac66cc47fc78428a06e5c98d71e800f41d7a83abb6a81e4b94da114c516bf5997a09a3bcf456eb13130f9a66d3cdf3b2744745ce0948f40e000382e64fbe8683021116e97ec7ed1ca1b2442b93122b6fde7056c1f0ae4b0a821b92dfb4b3da18691ea1121edfe29a151e4128af658c77dc7b52b21e09006f34490d5dd8552e0ad894e827375d89d646a89593415ebc2a4713f430545452e88c6f8d0746875578572ab2ea808c0665708d5e8c77322f9b2effdde2b933e823f4624dc6f417fd9b239ff56c9229d4288f589441e139818784d6be25d5b2885dcfecd10d85dc33368c3b695a75f440e1414245b5dff20829d70259891ad6be040ee6d29fbb5624cb46da9c701f4d95fa9cb67aae7606cf01b3686cb3f9c3b5ecf5d444d2df9a56965cf9d8c37885c2cca5859297c965a0273e6bc86e4f47f100998f0248d4c97b8f60914b82c7b276534c8aa8c666a33dc00506a3a25f4c44152d3712fae1b041b5c52d33d81b89cc6b72d318fb63c40cef58690035880f25f12de7f5d13db78868cd9a871bd9cca700c87e9d5a29cb9f3a11a32c0f5ba0bec9834fb141cf786f58b6fca76e391ccd0d26f8387c2ef3daf8ec2bbd84019112a0546b97c02a6943218efd997b313b15333495fd87806e3fa752d4fa134fa01b24158b4ff5e93e32e41ec4699a7d389f04d5f1e4adeae637a3389e44d9dc1016815b675d6332e0247c4fea8954da189e39ca8d3482156871c0a042a266e33bd8cecf47c746b4815664e23ab939384175d24f8fc637b22feb5c10c8450d7e9c605776be3f725ad64a567be1d83d007755da05c1de3168a2451b562f643efb040ec3273fba7ba26122456190464484d35d84af55a1df6e2a9bae802a2fb4c2afd8a0056d0952c26a5b9da95118f7d5e33dad263f311c45c3929835c0b2a53278692577619ab903cdf6fcea7c0e674ef1b47617f5cdc04d4ec2adabd696c5658ef31101329e95ccf43d9e71e85bf6c2221495d62fda8db9872f8957e755f410abec4c5bc15f706b046ce370aaec001e6053c749392f66bdf375d74923e41c3febef76f8ee0283992210b75e0f1bb70bd4dcded79af888ba1a0d8a2f3eeba5fdd4d236a003b47beb0898575be44161459af4dbf380ee41afcf2b4643612c3e9b969fc62170ab39a11e7ea397d2d50bb9609f4e0422d2069d8cf74392925cc453695b40163aaaf97a462d036c652678e60f5e2cf4a8c1a5cfe9e62e17287054737ab0ea9a40d6fc2bcd1c6631856cd1b06f932cc92fdd33a85feadb105881f3ea6ae8e5aaaf5661e31500cc1901febe2a7a093cb7a7efdb4a2416558cf1413e23ef90f9e0eacca9aad5e8898f7e04c06f023f4796cfa693530a483ac3e6b01e18fb72474c393e39f36da6f09d588d517d41cddd894bd664b1bf9904251423347e8f336a7ae772af3755745ae229c8560d36ade7e31e203b7e944659fb21d264a2f9919f12d433ac097a0e2348d650d849c2ab9ab2aef1ab30a70fa8c61fab04717ebb4a24f10bb2d5dbe1f1c37cf1cdf0ed04d730cf02a8a3e57349fb37d6786cba26cc6c3bfc9b1f20c20599bce53b8ea61dcc14635daab7f56405e00f7c7eb44faed64be5d88497c86f117356f4422e5c8a88869a823583c4022d6a82206df3d00a5b7e380dbd9699ccec5de25b06e08fc169a23bc1c321b0536614df849bd0323b613dabf9b6984999b9c9fb2a2e897e98199de00d1dd39c29c54d6958fd9ba036c50f00d2556efab225a9c62f20819ff942925e93a0d6a35935273b528cabbfd03e3dcde61c5c3edd388152d5c4ff1714657afe88b62471bd15d061fbd0f0c005cc2a383cee704d4788a096ae691b1dc2dce96b62679bacbe48d29be4c6c8ed48b464ec9c40968cae49fdd2ce0127b67bc8cde1edda2a33d531d4a816893b19d4653ee54d31bf5719f13ee4f1fdd35bad6719d1d1d23fe73242c25ed44a17dcfaeea01ef6295d32f2f4e4525f6719a4d2354ff413ce741e1dbcee6c1124c6c578bf5f68b2f39365dfe2887ec8108447f22176b4156d79fda6b74cd5f52936190250b076ec78007a11357adb8f5bc22588c083b1ccb5e63fabf380894e2652b72c4f852be82469fe1664d0198b475f096b0281dd7d5c0965c00725b01c5a6cee65bebef6be09265bb87ebe91f9d04e43bed1c85987f26af1e9028e0cc1af823a595b9f30c98fbb90548dc10503acf86ec6a6d7978a50228654b324d7bc7e56443af4df594a788728a7e0e9b6f75c0f2b16b34366c90d08c68eec9b7188d6562e6e2d36bc6303c27161807f29a53b5338b20aff38c0ca50ce945b438a4b0996efbb2706b8427679ea69c2370301f4d1228b694db1cb0c3f97c7dcfe043d675d7dcd3ebeec8c40c0f89d1014693a9dfebd472754230686b4a43552917db32c9b7e57a387db31e738b01e3a33d52d4f2f3094cb2d82edeae96f5e522b8f9d33c6f5ece495fa9becb4646c235cbc37e04a8e84f74e25d543c5f73ead9f3f6f087ac6421634c757eb77924ab36097d3906b4073167d6d963a1e64e722e586cf8b5eb094989dcc8631f01c8233ccac60e5e2ae518a6d472615d9fdb24b4d2eaf87b4c280bcb329743f08be51862ac9f0e648d002150b9a63bbda3514f97dfdfd6b2522035bc5077d03e29128c1901028ab0758efa5f65c89c2c4de9414f00fe8cc7feb54ebc9f6ab3538af0c5207894963d3890901e1a1fcea0de3e1c9170b6f15bdf581752c90bfd6092a1036ac096a1adc3632a8a7b5ef31ce896c8d965c9fc89389055c898248669b8c1b0cc493935a8da4f52eee26d2d996df9a7328c7c06d622cbfae37a1e7991443a200caf4e124807487de679d250a390275a0b4aa069fcf0608dcc34cd40d634912adca8eea7083df0b37538f88eabccb9884b1bf34bc1ee6846429de2bc771202719d36be626621417469d6c8a62cda0e5f41692dea1d19a32b843a7e96ed87850b5278f10e6237f9006b3643ed187b4478f7cb080a4f697460c6be6628c80b116521880adb981229dcbb92feecd27606d47469cdca1515aeb6b8741cf14fa2d31823571bab7f7c86b90a030c6c46eb71247b5b18b81f07f1cd971416b1daa9fbb3ef356ed37af6c55d746ee18f946ceebc4a287aa9b83b87bbdb22e26d7a60dc2e1bb067f14beae87257a759e57795b943eab149fb02d339e54c7710a70e9fb2b8b25c7e886a9c20cb44eb87991a19201c9b2b091cc129cfe6195383dab9124cfdf887f0860ae5d53f1aaa926eaf56e558bf1ff58069fde4ac82512deb9e4cdb937eccfb09fde871f32c0d522d283186d1ede3ea2e7a9e66145716fbd24d7512244d3337d5bec9a7abc8b7dc96ef136568e02138c67e733e9803c222760596f1a493fe29d55e70a9df1e83342b76d51a7da62a62a9cab5d701e4036d2792ad36834bd5f44e6773dd3124f494bff02aaf387bb5102abfc25e09b8425024c82276a9c4f9c0345fc80616a2d1ad58c2c33cbc27ea666dc753d1778e125acaf5b582146f3969b5d231e5a0c65cec034980fbafb75645afeb84b73fc42941aac7260163ed788cbcc9909ecb1ee861666ec51afe0bdc5de404daabadf07bb32e7ec4d28097dda489d06cf852192f7ecfcd3c58a0586f5bc9093ebc8108fa96c8f0174af2473461c839b7fbd2fed55ad828d6b67112a3ae3c621662080a6e3137e5332d7a1d13a8915e2a55a102f812dc364e21f43c8a975448453ead5f0cf8a9a069a3fd2222010528a5321a600241634df8e15a45c2f8bfd31b057ff51c2c8497060fb36acf0b18ce6527a18a014e17b499d88d3d85889665adcf50aa3b62f0961a15ed48b0b5e0a907ecc299855ff07831c856f2555689cf8ca61bb8100b75f836f4c7fcff7a617eda8f16976afcbc31bc721d15fe81d1d490beb878bf8c259a78f783ef6765d3c666384ef183e51968bb4a2de784ddfb8b2cad56324d49a75def0574c2f68c487cbd70c7863dd9ceac03c7bd4dc871899b73a58b14f7e1a04fbe637cc2d2779d7ef4f2a9bbef67dd3135e1673f6939983bb56949274452f6ee02db62dc29d9f763abbd2f99351831a30a5ed7dac7d8ffde84f8c751cc2ca5b5ffaef9c11992a8030c5df2a19f5a5a0d5b7afb20f61953f3bc2bdf5d4857f2c6e2a193687673c849226cfb29f6853005c38d2bdd7871e44eb73e5219381ccda6a8f2b8ca241d0c49a89f16ba61176798105f63f833b69b7ab10d0e28249a774261c41efdd9787ffc6f138d33b8d2183578842d09631223c45e6206959ac0378d98980076355caa3284565d9102d9f02048951c1a68abbddbe1afedb974ab2626d85296757f337969b08cf7f35933a2410c0bbbce01c2554f9f21d43ec53c4b3820de718b0e5e5823ed1a031015cecd6400e46cdf34e5f6bdfb5671c9caa5b235456b396a4e7a7ed2adf701e6992d4affb1ad736931628e8923b9a3ef6a0cf663924de336cd6efb54e320e410767dd0ce24cfe42a6ed4ee367ee6ede37ee2338619156d1d7826abd4def019c31cac5424eca48ce9307372fe7cadb7081a29aa5cc3ec8983ecc0f28b8169d181eea13d2419b5e7fa6e70e15a958e6f857067a67733490e36f516c43fc385db8a084dc4fe98df5227fed43ece2478405db92cd74c856c5ca69f609512a2ca9adde98398c03c8360521bb34ce358bce6e1fd40bae34706164fb68d3d6737635c6c3289c940ff1f939d989ecd2d6c2aa3b57a0b768444abc87d5f24ad2388c4279ee77d2d977534f01cdc4f66a090c740cc33dcc6a4cb48b852e4a5b4142af53f8311cc30193fe04f038f5dcfadd89b76678d91b18bacfee9b8d53fb5de5ad89b82cac7a0d4d460d2ed65f844899570c394c77bb19dcd9bccdd62885f55ec510465a13a67532976ee2d0f1572ca1ec7be6cdd10d7684a4ad3538354c26a355d66edd697449e5dc069a36be1b5f2786858ea8aa0372d6096c28bf79c66bf33b3d5aa79e179bfb043fb24d1de92e69c1b392c9e08376ced540637391498912f1d53248cda1655cd8592c9bbc8a7c90b6e70dc8b715438b212a3972169e2e062b8bae4ea1da31b6289244dee9e31c7ed487de9619f9b156174efffffbb0507c4eee40a8d3b563c31557ee705cc83a13c88b34fbc6a4dab621a93a1c97d7765de8d9447b35bd88ba1a300747c42d567e2eff48afae5b664a13a3708e4d811733982039d4c308de7df77c1d79b9bc783bd0fef852eaf664dca7254de05e40614041e6c53f2976dd9d09aeba5f92911b94fd487786df814d3dcc7df2a655ba5296bfc08b4d7b60af70cd0b2c093ff7906f547b600812a2579cc836e8458ff7d6d781acfaddbaeb029b521c624bba733adde5faea87932c0a5f1a3791e3fc422ad906963b316270a1f1e2c5497d2005ded47112a142196e19b3be7a0f165ac0a233da7010ab2fb9d43420f4dbbcd2a7d3476d7bdf405d7f943b23d9ac92ab517bfd05576a6b597ecf36536a0778a236f789ef057e34086144454b5b1c0f48464189614cb5884afd40274fbfdf70c7a44609a62e84c7d6a865fa3aa2934f15c9a4358ef2e120a15c08a94b6d57de93e1d82fdbeafa53cc6863616086672649ee3327bbdb2980c7680e0365ce210d597333dc1a8184f0dfc3a105b1626fcfa010b9361920f28dd0c224db40aa37a3ae990f45615e1df04f3baab56a466d251543a9ad091fa57bb1ade4decfceb7642de25a5241041e8b19ded2ff37426525d71bd4d6a2d0806f283110335bb972d363196223b01f7a58323c8964e25b6958ae39197ef4496fe1e8bd446bc294d70adc11f676ec8c823cbc5734cc14522fb94c9a28f26d7ac5c4d00e7bb2f973b7c77de0886fb93fd98747937da06f7165cd5cf4a8167b1d2fdbe636d4801b52564808b90ff053b3835e71cb040979b83964f1821a47cf7cbb445e97d70431d8eb91d324c667e13d9b5ffcfaed6305a77f951cb9b69ab622ebd64765c4937f41ed8bad8d069b10a643d0b902157b4e083d7d891a4ed99136d235d5e0f573baaf63567b488e0ac85bac4007171ca712396bbd9340d534595b0bd0daaee398b396565e846192bd167f68cffa3bc6a0ccbbaeb65af9c533271e8ddd7bbad9a43d8cc942053d3d58df5ab8ffc3c0f41fd7517e1bb27a9e8d58d030974105ab75e7e8cc8a426a3a23671d96d031cdfea94173a8b58c3af64b8628fd8f50aff28c6f4974889428d1b1a65f8ea646900caa15a77ec4de51c531515ca2670d595da8c0ea65b9fa0ed44d9d9111aeeb3fa9d4a0bf9c2a8c9450ad398c7ea3015e1377b36ad738739a357cedd58cdeb4005a647a48e7127be404d1fe148c2d9072614b0bbb31af69a256cad582e776b9c7337267218a018b1e9fcd3750bc8d80f5139b58567c2418ef90dbfc2d07a49860705a960a2e655f17f5847d0017aefad2c1738b9fa7bdd10b577257da0fc4b577a912a168f33df24cd0d393b09298b82012412e8c4d82ee9969a9555a52a3b788f8c3649a7fe454f6a65072dcc938401494fdf9a2dccd68f01e37a7262ce6b9f9ef6df6d37cdd401fb32ab831010e08ce1f1906cd6340efbf117b75220612a4949fa80fe658c793dad792c2824ff99acfa5430fcf96f2a6c76800ad9e13d044061e0f1785af201f395689eaeca15cbed3322852a63898945919da09b00b700f6701ba33d88b4b95e198f3f871aed3e1e4cc8e8b99e9c8d1c400dabc95525eccf3c6e7b21e7ac5af3c940ffd78bbf8bc62949d47eb9af90d58deeb071c30367da692c93ca0d497543e6403dbd397edaa25e996565f811beca5d4e79810f2edc9e8f541bd45e9fbc94dfd28237a021918ea77e449b26460d9485299ad1a03500d961b4390e4b0c47eaa89fe0ff1c11e79e3dc2ee8d16bf9b3399e733b6d1afd7f558dacbecf03b6b1675a66a4309b3506423460a1397ccfb74ff94ff193e05e2c1e64cc59044c3e50880db1e6a5a7154a2f6af1201fd85ae674ef6ab0fa1dba44758278483b5e50e6d302469b191a11bf9ffe39b8dd95156489a53aeea0b3f1663bab8ef0b1fa346f352765d110b79f0944e4b4e9cb235c9978cedd18ee24f694448f78e5c5450bc2904a42ce72266cad345bd3182b3935fc3265f20da185187dc85fa3c13865f379728a86e6898657747c84e960c93c175efe40228e59a60ba8e1c7673b9061de6fb8bb73c88e9d2f1d4f0d5c819e98679a61c1bf14ec905a89547de982d8f5de393df82145594287cf4309f0e7c399ffe3889e7794e8b932914ac77a5c1e0926c1edd97102caa24443f0c0c7c4e893f61fd095969f38272f52fdfe0c94e438cf02727da56e640e64d3898963d746c1d9f7303538645124ef26723f165484a7d247a89124b7b8e68166b127335ea26c259b8b9a3cf242b1bb5717820eb9fdf49dcd030a9d7e14cd925ffc92a1d116b77edfe660335091213df1e13a13c9e99e29a7ad9da214fa757c367cb7629dbcb4510c687564825735d7654534168a20ae50457c3cc628429abaa07135df90acf7ebf2b1a64bc09dbb4552ff9635cf658647e3ba6823a1c39a5962916cfddb5f78efb548b655dff6f2d62d76633f6a8a276f8a918b6e15d32087b5f589b42144f900858abcc91e803cc9a41342cdace6910ad2f070eb4682201129ed788151e2d2cb40c706f8dfe73e2acd0f912880a2da4ced22715e5ad44b5c96b151209a0e31dabeb5904245f024c4b65fffdb83591db899477cd858c9e8d5d7ac56acf0f9c4bf3ad19d57336bc8373b78fc8fb43095180d7eea7e11164e98bde1a08212a2da8bb83ed0fa60fd7775adef80a44bd7cc962e54da6b264689131f0f611cae1deb9c9ba1d166b66701be3b2e8ff590dcb101c7129ecbcb37bcac554387210de39bada60226f5bb34e07156f7135ec9321df8c099a82aeae2dca1eb55f297cd57bbd336b1e797533ea046f4808a0657a2625725a2f6bc9785ae0e4474c2e6f997b7a0488bf31089682dd5d3f459870c73964ea63791d961b7b8dfd4237cf244436914c360583b5c011eabc50eed8dad3fea4573a521ed0a7c76dee78ba0234fc60fa2298b0ce43ccff0f9565c502bf8757fcb4a0ce0a3bb38a3cb96fa857611dc055e6bb12174bc88ed3d5e13ab1feaae86041123d3bffc70b8bb5a1cc49da90aa6e3049a7f02eeebf4b2faf05c1fb06ebf857ef6ee0440478b17f7a69893a22ee9a6d27d4390048ad75510110472d07026abcb460cfd5f7ab979846ef6fd160933eab7712fdf772f6eac604ef0762d193b4d0cd23b4d5c23f1f4426e24206967640a272932f3c8cfbe6f16fe612c4d87fd86dc79dc5c9b82c3e8d499a6fe116002cd0a3319b986db7d95683bad6e2e98eb7d1fe673eeabc7656df20ca5bea298a138c2bc769715d54225e355edd454a7d8ea9dc433bfc879cd3dab02f7eeb71139b3bba957cf2c3e1b316f59350d21589894f3d18a03a038a8120c9fbe9af865e913d59a145ecbe403ab5ae48ac3740f00f6f94b14a6c6e3b4197273d40d5039c4269ec31a3e307d0d638e190b01380eb8c0e24f32000c17a8bb8ddfb5b0ed487dda3485117a972328d858facdecf97d5922f095e388dc054333dc138292e8ac034823d8b4e2f4e591b5d08005e1a2217f28c0b53b3e17896c2866fe9e79bd93cd68ddec33eb8ffe732a7699913a7a78eba96cd0d530c1e8333812df674d258d8941d503acf0a8846efa9a83a1d4f1ec07649a7ef7b83acf23142dfed9e5e9599a2d4b06f175cb075012b6c58c06a907e912d6fbc1710ef0c2c003260581d1972971875f19219040414fbfead850165fcc1aa338b81030a9793a0c3332079f6dcd0e4566b2e86da59ee231a17b6a7d570d3ec7a1221aaa6a02ce706a66a45d3ba87c4a7c54a2fb9e942fdc6732f4106d84c0b5f55bbf9cc5df8b1ed00b082e6aa7645200f393463b64bc2d71d9f2bd47c64aef395348053a7bfe927e7793cd58be644f914f2da470b31a62a7826d8422e88adca9836b4e59342b5025b440d654659c3f6ccd612dc473c448cd4fbd9b27f130a0a98bebea3cbbd1d9b5a8eaeac44fd0b17ed981ef02cc2ed73fd95ba49ecbbcee8669290a11cb55be32da138e4c0e4ceceb5e4f7c8dacd8b687e84cc31f65e604d6f4766d7a8292770f151879bf9c7ef2c2998830cb664d7c7c6d09c43475591d412aab802acee9e718523b8f1f37d0631602e1854c482d7cce412cadbb6f7ef10197e84fd2fb7b81d343cf121ff2447ad364efa6f4226c854bbb14972294a60591890ad4e5d3f016e3dcdad895f9945c501e5ee6101f8436f401f389cb10c5d7b7622a98ce8b40da8554e9b15f678ac018c344c5986531bccda31aef036ef4abc54377650043661648cd9f7b7315615df78be381af3c3b5280939fd9bead481278598a262962e1a66188c566accb462aa6aeee3a17f2ddd792aa706b228e9a585140646262290e21cace364368b54230f397ab4810b8753744b0cb471f99db56a365f5454f874ef77c07ab5705e6914fa14ebd7ad11366f5863a2ba30e9092237008288dce787233432cb062d7263cdcafdbdde6fd7c20b072ae048fed987af763a00c2f841a9a80efc50325abaa9e086a535a17b9d20eca28517c2adea8818aefe88587c639ef893383b7ca0c400467bb929365b04003b26498d1010e4f8870d45efe2091bac57cdef744b01ad8cfac88e21e956846bf1fbe9827df4b03f4d5ad003d8e59d4c1107de3b898e80898de557371b391997239064101ad291c968fd468dbc702818a24ea419b23cb83aabd7e08fcef18b9e2d22efc06a20f07e22e7d773ebc0682e9a1e4a509795feba60f9a412840330f19ba517f0bbfd8fb7f111383849a71059ee211f90cd05e37cb5e8f5179ec90bb5f6355c71dcd04221b386d05758a824b29e21c5f8449094c5c5293c88d0044105b51dde834d03c4a095022ad117a33b0a8bb7df76398746e6078ae74cc830fa8fed07ee2145eefe851b5857899731317b59d37ededc02df5d044bfc23a785fa5d5878b8f0395eba87ad31ede74c948a2c39a6311a0a7b70d601cc3ef0fff252b40577351f1ac3ba8d5591c69eeb75716d1d595022d6537fea80d93f9ebb0893679b89743d23fda6b647587eb54c7f7f49f944bc0a3c92f5163b8e551c9ed0e1f0d5f3bc5f530a783dc85339da1a3f356cd08424f5f53d31cc9f3b942c685971c4fb9ae4b67b5b213d2422a722590b6f0957306b6e0236de1c2879d9e7e19b07a047ffbfed31c231f5434e0bbdedd8c85d6c93bffdc81e50aa69db7469e4f1b0a9bb369ee481e840beec5efe82fcaae60e22c488d9eb6ecfbf835374f1a4fc9a67cbca351e93e176d1ce213181600bdb20fa45894f35f0333306d4af1bbec9fe52a5db5f94bfb7e347d0bc6cc5b72651071f9563b2502441d500822766a899755f0db64321261ba54eff3edcfc677969a5e9af6799cdb34b3f3219c7a8e18b7a8a40c0b465605c5b3bb7afa60501b1929a156b300c7118f3c9889fe0b3fe9cd956011b5dbe74d83388e798a3d9ce10781314d7a64950408ab0faeba4b0a3f5fcc6a1ad01b081356c796a01c803cbf025d9727997f12be6359d6482466ddf392a073c25eb587c81040588bdaab80e59d1035a5d4a2388dc8084e2bc523c05c68c5717104348cd82197367f81b3ad0c4a965c815fcc8e13c6b8adcfda8412cd6a9dc8fdbcc509c31f2ffe70a1656b4338db7e8a283adda3e824df8d0516f2eedb43c56a5b417240690c011111dec78cea2ff729700ee673a7207b4ac4ff3cd1f2f09dd9f3ba195d157738762edca1926500ad7252f4556d1c014b6c9a68bae4d0474c182f8a94b0f78e99c1e11075147235ff67ab91940c64fa4c3d1f7efc524fa8b8a7a3c6b3fd7480b71a9e5a33632d73826a8b3700e5a1d703de9469989eefabbb20b1aa8a7d0fe74bc8ca629ec3779037fbfaab0e606a831e68271863065b479af863b0a1ff76f29ffbf5a24290014a5324ed28708ad7e66ce0d39c590ad5c8a863b6aa1765049edc8addfaf1a9f00e017eacf62841ee8c7c4baeceb107362f3612d8ee99fae3b500739fabd5765d049dce515be444c069a7b3107b9dbf88485013f5140dc9f08d875b4db5188cd3c6bac49dff3753eceb4da65452b12b4e0446bbe90352ba1b245e19c256a1666f26d86bb31b211d6dcae3a54ff9afba19c1d1235be21e9c4e9014bff3895757087d52895e94e09ea72de39821d74222ff1268ffab00ebef30fe53a2e80448c9f6127c4f9d51f37dd90e39356031d6f66a1b44a220f2ee1e603abf1c92d0b377ab670e6b91ae0224d031d8f3780209df38e96b8537f006b2692279f9c2993eac73f0f7548fe88ab783a99faea0f37158a86ca646011a3a1a15dc2c7edee716d8df3c3c992f0ec298ce9942c7d6c9a83bab2e86b81841276b9688a6524a1576a19ec70c2fa25824124da4b2a48dc4159f3a7079e60ec1946b48dd9c1ec1050e453dc11f3fc3cdfb3e4ab00dda3141b66849236fed6e28276e7087eecdad9409e8980d4b5de16901c0b0f4503eb88f8dac8725aeb7c31d64ac5fae71df9253aeb52e19ba052a316c4035ebb1282fd6ad6b790a79158f229d51b5b1e16b136fee6716f892afab9b903ae528309715e41ccf9aedddb27d406904b5204dac439881bcb50f58390e206bf0c0274d486be0be17b1c71a2435d736cb9ef87822254f19a4ffe711c615328ed6227e224dc18309874cfdad4c967c03c3d20244a8f91bcfe3f473b1f15b9cd5c10eb4de2e47aedba9201636ba44912d9aeb3abbf1e8a56ebda9e0bed16d1d0ee0348eaea0ddf57dea8661ff1b220fdbe85a8ac27325d151b213f584bdfda5d4470b8abd767408b2211076c0f8a6ba681c43b566f5768d68d45df21caada40c238f300c700bc1ba1e6a7c4732516af20ad8a4f901ace8884ead8845e5bdb4bfec59bc44e40552f46812af4e49756e9012b2e4c7b30cda04a9422ece013159dfc652f4289849e77ff0b6b1f41639e098c5ee905ae60c2d7d6348f338a02df2f5027094927ca702bdced01debd4c3d4e9919afa7d753c2022a31b89ec9fa3603c83252891502c6275939e767dea66143521fa36d222c1a7d19ece8fca171df04e25799a321a1eed3f7edb2272e7eafb8562f1a6c4654bda444e9b4b8220aa74944d830b3714452f8b4ed361550612b29a4610ed007f696766222e8e73ba1e99c23faa505496eab6f691b74b24b4bb75f354aed82271ab18cb123a44d284f4c388325fd5eb60262e98c32cc87c6a607da43b9bf1b4d8d85360ebfd9f4233611898ca98182197e3ba441ce24ce6f9e2fe6a3f7a0cb8c5838627e25d0a9046c2224530070ea2009e2b871cf4c1c0be37ad1430a8a5f00b107774d7d9b18d0eaac27b8bf4051246f797410b792d4a9ad88e541ca2ffce6d0d7c1a4fa22eb05cc0956953d704396f8f2344ef0605b7f6e04b3eeae5f9406ddf1a7081b8bcd358577c3f0d354e38f3837129a93d88a233428e162bf03605600840a3a15db65fd363d855e4c4b7458b776c4ea2c9f794ae29848176ad6fe62a38a7b6e847d9842b78a0221506953831449c08fb64e36501e95288e82317dd0567fde652d54e3dd3365bfb2344cfb30850c7ec47951dc36841afe0e9319708eadf0f0465deb37b6555166b0f1ce52b053a182a3b93d8e847cc754df270572c10dad9dd07e0286662e1c98674514918e32cb222e7fa1a11797d16847dddba906027b5fdb3da012041bdc03b6b2840f4eebfcd7cece5e084dad460557ed1c48ff7259fc6455c6411f3feb79f7b8706758b7745492421e786200f27a2c35ffaaa9285d13709ba4f33141c24a23ad42796dd409b07ce8f9df8e3b53ab24b90ecf62bbf624cc936202b744490ae349965c8c89cad71dba2b02156446ed123a0d1bf3608397545dcd65b8d89f4bfdca459b83784a5685ad38bdbd1b1b98679f9a8985fae086a4666f0e47d5762b3922da454f882724faaf21c107f845db030d96b8e89c5882000b875f8f9c4dd226f5ddd75e5fc1685857a0a1e1f0ae8b14eb88cee849366885ada0d9c9b9846dbb2fada0888eec56ae00c2c6b891e5cf90d6a3c56e066513ae45d756aae2a1449c0d9cff1367690c3dcdc158f48741056da6e4603757ee3059f52fdf2b80bbdd1b4aa32ea24741518baa1301adf94f2b62e5bca7b4afec515a8f82736dd6a0b36fd78b36f1a534e667463cb8a0ce6aa0452621426d9872d2670e1cab12c10d94b0168bf6f52582bb4c00f0151dc71ae99afd81fb32ed2950f40003d4996bf7c2546aed8afb448ccc891c33b5f6f1907beef8f6b679009abe3f1033c180fc1998a34a2c532bdea0c0023b1501f41bb6859574d83a87db4272257d3577af604d027bc582144a27b61db837bf983d9db038c05618cbafc956f6dc2295a181fdccd3d0e511e84ddeebf9a1339b07feccffede5533ecc10026ab80375cb37743c812ef4e585ec0ef134d2353848249227c36fd10d905d1027e785e8facf1d36dcf8e4e1a425b3402259339740b7c1261c2fc7760d0b8cce8fb6fa15f2ae6d67c554ed9555c549782471ee5deca47fc556f104ce298603108822e948fac0338fb52de3ddcb78c795fb1cd7f08445e6ac2a49589cb40b4221dbb7bb5f563f600945740e62ad27b87242440de22ca21793c86a3ae34ce6bc0e17242a94fea4199aff72afdaec860f3b2f2ac0550200423e68a9d773c997846cced01f995eb65c6053bffa85982fd12f54f83951ace5743afed587883bf9fc60fb020cbbd52f779a1449e9f000d525042e1ad96a25ae38817dc04efe36c073804cbcfc44ba0f510de3ae89a2f5740ba74eec9b5635c87fca036ee25999df347764ba76b757f65d48382faa5ebdaf09357fd575fff2f3fa97c85900f7c4375c6e931f536adc3ac4fc0a6b191e826a320e47b252aa0775b4c962eb894fc35c035e32d3ccb5ba8a2ff0c04b3690abce416944fb2763edf6d587e272ad92c597d30c336c7672782683c6c4de569386b4","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
