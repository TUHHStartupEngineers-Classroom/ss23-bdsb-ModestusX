<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"f9b7f2bcc76cd08f8b47376f5f1a2c2cb245ea3b1f35d154883b11ae56e0953212c1428e0187ee14ca2903f6c65d340d3ec9a3461d361eb52cc75846bdc1262661bb004f8b1b58849acfae46100e78a08ac2efcae0013247e5e38a29dfd7435aa4a34ab5e0a229b962ff40e87e238f9984722a7a71f68a21deea5d0d35f5e5a386e05ad985a0ae81fdf6efaf01ff8c1df76312a16e09b7f8e170f1c650d8c09368b26e57881481c0b7017475f7be481f87de3a758f3bfbfe1ca76ad178a158f89e85531bc01c2c51f25acb83cef023356e6de9106ce73aabe6b57665c47d377c1d6b720fb03c7df73a97bd466058dd426df403785db0b1b9e1ac00abd09bfbc95d3597ab8fe94e4e6d011112403db2d0d108f8887bf4d88505a6cb1236eb2621c4245272e53e55b64928865f74e41f77841814af6ee7584e5088f7bc92b35271c8107ac10deffc131aebb33170b5f4e106128b55c4b046faed25d5083a3078ff54fc7f00d7ca50dbca1d13d651c96623f935a87f37e9148eacb41074bde37904f29998fc04f8192fe6b29c61a5f9e406afc13e04fa252e50b3e8595e5f4285abefc09d90a6476c0b6dffe8dc6f1a5d5d951bb9346437de3a5bf43ae2a46acc6458ac1eaf75d544e9d366a9a96c5b281b799a1ed7ec3595e6cf5ccd16515e85b4d7d10f57c0c0b94e89d93313c775574a8a9b55fb7a755aa1443c26debc2db45e33d387f5f46d203d97bc5b554ddc2110d5c8a0e35284b6206e7b377c99844d07bade1de5a09fcd8d9db9f3e3bbe438c5391e5aca3740255e8df9e69a20fa7487a88043ce1a660a5e5895bcc5b8c134a4cc3ea8ce4e9445958b3c5ba4873635c7c9c9ba4dac159214313f3bc3a8734abe1aeb9ff40dd5e0c9257548ea25e956238458ad4e618c9460bea932e4326c447e2b15645309b81f50615508d04e2dcfdf43ee6ebffab06c33aaa23d10ae7849fa8bbd6eac15fc7bfc85686f393903224ac86dd9c880ddcbd70e1ca1c88bf680ae37f62816106112504adc312c0f0470c6f1653d2c295894efd3c0a45bcae5706e60a1cbbef9d97241dc37e3b8f75f882b1c8e99b5bb65bf4b034da3119d9381d1d452a0b825e16d608aa6966139310f74226a4fa7c00f84dfc6a1cfecf7162c9abecd962d289debcce801f5e4bff072b58ab89ae5a1bd4232312de3ac5bf45ce172cdd6b464222270e2a1441daa842be8d9b486a2368e2bd8a543dbe2450eb14cd4bedf7fc2ece10c4c84216b228a1cb43814fb3a3a6bf27d57bde894dd9afbe49d6ce3d58b67d651a0487fd48523c4e9f3e2df2980040abeff9288c63e522bc5a8f92e8325186c0226ccbb3fc57503d8110a36190d1f14b37f79e2683235112d56f0332c6d0f2ca7a23cfb563e819777b67bfac34975e5ebb816181582b0a5966dabf7c8778a00764b4eb699c34740eb18b7f0b2b5b0ae2ddbe5dba41a99d265d30cbddd0644fedf445c127af470cb3f504891ddd41bc86839a6efdf05191d48da895e8144e675efc9f2410978ee9efc6bc03c6d21e7c46b8eab15cd0cfc9ac5d5fe46ac4b0661f49ac6bbc8200d07f31074d5df4a799678cdc015af13fd9b228ecaf9730a324b3f0517c7a91c82a513b784befd9692cfa3ff9b1f0c84779fb114da8c639c5a16da705cf0e906085a951c1b4d976e32dbbabdc98d6972f6e0df7f64ae81b8b7293e33cafdafe6779af1be2b7fbdfefbbaf7c50b278329a0f86095e0aad45591bc56c6b1d066b988ed300420668963b1f4cca46704e179bb0c88eda656f999efb8b49748d36132436bc00b66e4bb19f4e65dd9d117295d53546898d65915eabd45e1f92e2f3eace3bb1141a35390bfaeaff951a4ee940c1ecf0b110dc23ee56ec3acb020ced99bc60b2e69b9e1de119460a47881080d6ac99d85681bd48fbc146f1f8741103a33904d99b972b162b8cec23cf55bd3e7e0292f06769ada0e4899f4ab4949c875ca73da2a5b65e6905f5ab3657030086630f9f0791c5e1e68658b28f8c943b18097e58277bc195c467a5660dd1566d360f450202f38ea39b63f2122a6541cf7ed9d921512dcf76aff07aa273d54f8c51dd529d4c8388b36f7b98da9d06fb3c7fd020fa0eb6a8c24e5914df7fd0a01679238f5d78fd2632dde83faf859d6d3721768a02df913b326004bd097b4723e25cab1c20623a97aa1780eff3bd934dfb4ac0e951788ff7b06c77a6c05fe97cb7cccada65c6304add39d1cdc7dee158bb12b530f643bd1888c89c5bcb069589710e9240bc05b67a0f23da768f696002dd82066d6b06dbe5393710f7c512e46ebd811e91bd2e8bf1fec2e45cea8ceee32fa06828899070e250853a950d9207dd3335333b3009c0caeb673cf11a465084bcd7b688b7273a26a23d66a39b8afe388a6eba330e3d896d553b43001b9511dff57066b8a8f71494ff9109f789d9e6ef7b3c547ffa28e1fd13192259447d6a0b50c33c9e9f84dcad0bb3cf91cbf153043fe65642d5c4bee4ab4cdaf50c141ee405205b82a2216f795fa77617287af722ffa90608a50efc47167a4bea50ff61535046bb6fba4780fdb604f11c15220c492d16d21dce0bd683293ecac4a595914b07b7b858263e0068591732afe8a2115f63b29acb92e266deffbdbdcac1e7b6cc66ccfb31459eab3e39b7eaa33549bd7d91713a807ec20608f4d3ac75abfb8f4854769a950008268995beb763dc82b3d94bc1cc8f2821b24464b11adf6dbcae635a36dbbc586c8936455723b7c1e9507bb43a674b79c940b96ec0598070c2da18899af6d2b20c14e4bde341f85c855fc63d0c2f5d0f81e28e849958ed5cbc4df06da7c3657d878a279d8ea2a78fd4549f721114cf5be48e0adfb82b440bb15eb2ecb15394d60dca754748437fd62023103085ff8a23698b9e8171e153707fd672d7638c05c130ffd4a76ab5c81d3315b11bd2ff609bfba1e3ee1ab2f1714294f60350e5a38af15e89beb9dab8f931bb25a18ff96da63244f4b47a998ea70f1b2e0c88410e60db700d79f9d7653b27300c8dd160e2d6ad9ab909e7c9891d6b9495b4a207c43115f960e17d033a5ebb592e9c8c802211b5a8903a4aad9f1bf5105a8ff00df74715a11b2e55dd5dde9736e62d330daaa8a8c00e420837fbfaeebaccff8c70743670761d7a385ed3ab5fe3df020c9add222eba50031d5872a0da2443981efc3c1f11afe9ff039396db93c05bb3345b59f9976a620e33cdddf27965d2a9c8917336b896a6cc55843f88b31589d9831a0f9e045fed180dba741fbcbd81412ecef13c3a6fd2af7227257d697d09394eb68d59851b398b39cd8eb26469e1d3ef1b01c99aef5d152df246548b18f6c1adcee368a13ed710700bb715883e7d25f3e09f551109da3aee2e528e566e36c425916619089a79d9ddf2a50efa2a7efc1d9aa64b8852e1ecf3530bab56069bd4b90161d25a39d8749520e0a380b31c1a5921c944c837ebb66e42f7972947c8efd1ff55ae30242359372b50ab5752b196861fb26f0d9afe70a1927e4e41c6533b8b6aaecae135dda0db39b6c550f98075912319b517cb84d43dab51a7326077be78d9e17ca2e3d62d600c937aa839bc7ec6e7903c479e6fd549aab537ecd0a05a6aa7b2b1b7655d6927379182400de70d07634ef67b85792e1638dbe27f8f4fd3b36553e376aec3ff74aa2333f82af5e54837fff11facea6a5161bff6a11a5b3623de75035849c3c170178ffb90894968c95223e1a7d122c79bbebdfdd65006b4c18fa2ef4daaaff4f2b225010e0ae1640db9f73e8d1036e400f3cff428c109e3f2b9ae6874ddadbb1cef59fa968a5b6bca03439e5ac51320fda3ccac07219871859510f612d280672c1c170dfc8c363ea6f0485d1352a1432ff63ac5d7501ed7c056afcb81c46a3916c13a80e53f539885b0ca1538187592ce1e95f4fcb1b6d39759f019b44ae73c405ef82c29f940bd1a1e31ebe89da96300be645e0064dc5f264c2bfc4cea7e66782c732d6de2ae04f85617141a59709c2ea86761bb3a596a495147b2ca2eb4ccf6391e768eb80650808db57f8f5abac02ad976370251b038be5c50cb21292a656bee46c2edcb7bafb777d75a15a71dd0b5c11134979ff2124a58a6bc96de82ee586f36243cc3f5945eec55ce8a764687d82d22d3abbcf8db2b757e67a352ce2c9e4a6f218f116202cd360b35a1d0d583baefe8536a1b4cbe21daf874cbd94739f46e8830cd441287d82ece6af5b189f65f1f4d3cad81d581769bb544c5a0e89c7f9576ba2bafc55032929384cacbb133b4c90621c85c02a12ef333778c1cdc997a5dadec003c4acc2a3a2c345f93f0bcc4bebb85dfb3b5ed456748b0d69fb1108717bd1b63ac8b0cdc09c32574b22f830a567e8d648a4f9700db7526f88430a252a6917d047c7559177d9ba975d7cb0fdec273378e5ce1001ab834cf95affc640357f719d368c1dcc250876d4a2bbb4c7d5b328165802a3cbff12c076c4a9bb98a05cd2a7a7792629bbaf40aeacefa9a3a9857dff11971934bb18fa89cf1c573f5a3e0994b5825991572d44aa2a20776248b899ded0987792003949d2dda643ed88770c135f48c0d9a292679bd85007c5965d9bc7dbdee88c327a1b1eda33897e0d1428717023f9d2330b4c60745b0f86e476a1923076213a4d69f29900ff7162361a15051f9d9141a2e12575e31448c7128ad63d36bfc075459bee6c260cc29d00c9cff9717c3a8984224dbb7904e1973b0d0223e5a35b68b6df88b5ac55842ef7acf9db6823c453705e103a2723d1c3d5739f36125095465c5135921ef5838d9af74ec23eb6e04729478324b656b1e22ceac8f7d6027381338e9b5ae47b107e98291f647a73887a42ca49aee3c8571bd4eda4b549cbc5614222cb8b9ed1f1f2cf3814fe95a7853c379e3fc2dfaa120f66cbb82087381622e5f78f0e6a3aa72abdfc8ed31009ba15da77bf43efa716ef4557f842a3097930f7c926ec7995bfa4ed5da01b32aa9d31b49eee2685cc0975a040cbcd8f5e03fa54a3b39befaf10f99477e8604bedb634b7ef6d9e3b9b6939810ebfbdf33db701dac10b519d07cf6abd8aea0adcbe3924520b5c416ceaa6230ea0c3fc79ef6918774f3bdd948e3c1fbff5bce1eff7be927510700f9b3b3d89d8c70220a9b034580d455eab4eb3f0bc0a12837d4b679b45694629623b644bcc9cc7e5889fc7d9f4c473aff671baac58abd3f0f6a423fd723b2a64e1cab5b543c5f602c2f2d929cda41aad52ba5d9117464b5a863017544d1ac4dd3cc61c647128219109f84872853d1510db9457c2bb090ba8a39c4d7001b8bde45a5fd814ec1efa8f1afad1e6a570ec026a23dac1c60e44aee6a3ee8e8026fb29ed480ebf1e432d2b3db8e3c0e9e22d93a154c8a3b4e4bef1acfadc649734e46c2876c21db0ac7bb5a462ff215a45f6004787cc90684ad37f15269df000c7255e45fcab60911c1f1a35b83066d47076419b88ccbda8cb14313f2a73f13b9c4879b672bcf01f1b792bbfa054e160e23e18a4638282846eeec45936aa9196a676f7386e780b3869844883346e171017ebeae256d2aa555b1d7356cfbcccc54435e9e3f5baa34812eeb78b7056dd202359a2919f78ddf652a55d38c65d5af6e0447d063e9c4417d91977afe0747b5a614729658e598acc71061e1bbead450d6060c454b79ee6c3f7fb5e83de0c34fc47927cb9c5c82050ad4436b10b9acbff1fa2666d753432eb10f005d9fe32206c7f6f403053b0d80e52231e273e2b8853c849a00d5d365fc0e2877fd2e240b68b64d3e649abb2f76c56197cacd6e0dbfac897891fbbe7fca897bf65844a1422c9792b75d3b317654be874f80519b9e2b277e2d7213bfc2b7db3dee414472ceabf9aa9d0686b1ef220a140790ebc5df5e4c8e1507473d90ec147d6e46a631e468fe68b26f103a927a26679153a33a61d2b72eed74dd1a62cfa401405f53b9430f586508e5163580d95cc43f00e2a28fe13c6e94f4140d76c4cc04c24eb1781903a55091dca56b9009ec1b43a316b1f9891ee0139f6442cb343c676f2107f8450eee08e5f1db6a1058ec4731c24b86f20bdf288268b4af987e9ce87371a88ca9820735285cf2216bb46034a60bf40eef61342fddeca8590945dc38f57326a96ea220aa23e15ed4958aacdabe13f26f51eed66496b966fd6a1a3081032ebaa29a4493c89a25a221ef88f57f64188f1a8b33244dd0ce5eccaf857b73bf7d462e2cb0d77da46695500d73eca94844dba1dafc1129c598ab6579479c66f83e61294e85c11d47aa490c367db60a7158f1e79f82d05d7cad72cd4400b1480487046ad5b4aa7b192c870fe65997b8f8efafa2bec90600996369184991d921587cbda2adc849fb636bf80da21bbbd6c6541363b0e79cef7dcd689939b9b0d7cf9e52bcb82fa011903d11f0328e5700c6b556624deeb1b945117104029a545c2f4dcabc17f6bfa5a507a7e1a526ad913df1fd4a6c1beb6a1849c67541e48443a8ec4d88d60eac44902e72beb6acc977af6e8518f43cfbfff548435ecc805258b392a629dd74b456155d3eff34e3c9965b729412c973773f5a03429e14472c99a8a154f99f20905a7ed34294c2562c34637bb3c4de1ed38f64421f03416ea883632e8213d2d1bba11e32a28f7f6109a5f6dfeb1d3ea4d5860ae3cfbfe1b42de4d86df32a49451cf7d04f73b1b66064305d78656e73f0fedbd3d22daa2c95731d12f0b6e6d88089d72af50b1f6557dd00f3c3012e2f06a655e21f4c0c623da5f90e642b5ca20cf3357ecb404ebe8da24ea4cd26262fa50378ed674300b1a68a191a5dfe2d55fdd84f3c99b485fb0f4c2c1bf705229a027eb614af050b30d23b74ca70f08c95fce00385f503d2adc9a665660719221ea313f6aec7c2a3899384786cd53e3d9ea80536fc7577d0f116a1ddd71f5fb64a67c33f579d8592e8d5f9299c51eeb26c5a8a5ba79fe314cdf815d9990574c42b92ec14bc2b85e9056d6dcdf4cc8547b7469552d46b52c9be68c314fb282c847b3d65e3b9850400fd71d632f50b835bb764574142555f1289795fc07fe4b4297da951d92e1ab7c79ad589b946a357d502f569ae88be2e4ca56a9c7632187ecb0a7f210441dc2eac40fc593c75466a92660493f3e2492fe73d88312d133ddd2954c9e18f1d5881e288cb7ffc1c36c5d7b80cd91d79c937117a0675049d656efae0a17097790e990ce36dfb953964dcbe9f3d997ced6b75727cf42d71a779f0fa135c9abf4331b85cdc8957f61e470b1ca573797f2beb311b1b3e9921d4c915f7337d2453ab614e36dd295b4b0c47c1fdb7b843331e3e71e5932331d43700490e9f4b95f823e04f8e52ddde29cdb6eaeb06e66b13bc2d2a5179d3c571a319108ff981b1704c53e1b007f4440b63ead7bb991d53c32477420d4a0a019f156e48f7fe9ae1b36d21ca7204285fb8076ee464b553053722dc3330e4c87922ddab1a6b8a479711a6ff085fc2aa0ff125d0a8b02ff4a359c0ea93adab2bb528e2a2195537778abc4f1c9a7ece59aeb1b69790c244b4d2a8c6edf1843d656ec63980e457b0c128180f971d429fdc27036645f91a90ac9f8eef6c6d64a7e67a070c440e1997a344aebe03adcb49b8552fda041ee68bb978f44eefa80b586477bbc99562337aaff8fd4a41a6c9ace3a54f5bf2e89b6b0809f5e7e4cab1c747939ec3ce2055ab0ef6e8012011ed1bdad1ba5ecfb92dc76b84d1591797130fec57c087edc1714a33f04494c2aa2dc92894836867b82656014d7857e1b64dd2eb779f55ec2e6e1aee19661c39ba6f619ea7d7810ed8a3107c528a5c753494b437fe26ddca2f06afbb084651c01ea236ab59d8d9cc2fbff139b5a77635ddbb1b8d6184b1a153d936586f7d3a850a8ccbee7b0979e84feab54ab6220510be429c91b6b08acf61c49d8ebb1066e0318f9bfe65d78d909c2197809c05a4ad4f8a90554bc62ae55d919de433a6133076c34396f4ae60eed2b477f1a03269d4fda2aac0c65267801174864dbde0cfd400f20b7abc93530a86a2333d0ab3915c78822ac9bf0ea52de9fd2b1bc7bedfd9fcdb788d9f65de8b56613cb3bfc7a751e80055270c1964ca3c678af8ce392476e51aafdee1e3d6be03bc58b6acbcbcfbd170cd38804ca3dc8a493641fd50bf74051d89f210ab0c988b35eff542ecb603bc84f833c1f69bf6c5a2ecfbf8cc0bf3a3100c04e5d2015e17e36985760c8593406954c58e8695eaaa8384ff64d1f2d64bb333e30e6e05419be682069acb453c515cdf5d9d4e43c07f9b76c6cfc4d262a0948da24b2b5ffaaf7ad968760ab95d3904dd6572948b6b12b01e376123aecf9b115b56e2cd5446af33ed38d1e79f94a3a822ecad542cc3e201d57debc2efbe0e9d9150a02dc0e3fde8fd32de4cc6eacba4cbe839c21c26152e16e494c70bab933fa387d3268859ab479e14d12db369f9fb5be321c6ee2fd6bba9be6d62a650438bf3766ba7c68b17f07cd06fe436ff5721bd8321c50e9bcf7199ce909524afc34e5549a2f0c74ee1c1351fdd65f3e6d9ccd817adc3a981dd4ee3f26c44d06a22bd7a3f374eede05737f029c165d2339e83f5106c8a8794fe2d9c2ff66826248fc2a9e979b345b35a7d0d9ad11860bca621f6f81899ebe37d1cc3020b187897070897468aa6277f6ffd64791b132e69aad14b22abfc4a1f9f35a6c4826e2ee35029a3051698dd3f602ba04340ba4446e3a1aefe56503ba13645cc2715563dbe641606942301d80bc07191cdb3246517d36f6b254b3822c5deaf4fb19b52ff0e41c313da55cca69f050d737e35cd91017c81cd8e664cad041d549f80e80e19769062e2dbfd7ac173be537a4030f1171f28040561d6ef32dc76d7cd4ca9bd0d276d3e8ca629b6670bd453386ac8589f12c8d1ccf44a5ec54513584a3b5adff3e3b63b91cffbe44fa893b71cdcf0fedc9dc47e34bd4f6d045a6e95eef4d4c746c2a606670e21d675df0ca4e84c862a1d642d656bd61b171b809d2001ee12b06da59ef0483b906b7e738784b6c47e79ee1434c648c2909e47c7732992d2c5d00b778742b4b0cae8edfff29de1d2c194cc8948876ef51ad94345a114adfa389adac0ebffe2668319c43de8e2c4fd1e472bf1dad0b6f3c36ba7d1e4c287ca96d3c3546cb27d0820312b7851bba4acb14342d424efc1dd762cbe38e39461174028a9f19f51b26e9e2dea7c3987b60cc49d5eb63276b6be805a6bd2a6330e7b53026e5f3f436f022dd1efcc4800c54764c74af599dd7d94d7c4963f6ecd677126dfa749c5a929f680f1becb9b18f282e244ffdc3eb6a9216f11f3344b4754f051ed1b022eb27cf7719406407c83ced76d02ca06b12cbd5420488048bc179337e4c4d507e5671bad8a3bde1ac82f5cd4ff670b71106c2f69909b984dba2df49ffa4b624b4f930817e3079bde5a596a15b082692f7db748a34322b864e160e50c31212c78236351168dfabcbaa3723e2c8dd9cd05f7879fef1e79c2f3d2fa192af410fe74fc9ab6e9a76fe8d725232e967a8be4ae173c276d29667fd2fc72d80ab838a9fc8cd32f82b8c4d582740ede8b130b59aa746416f466ce199ce3b3ec1388cc11e4df83b74afab2e1f58cef46c84a438a95ce620fcf5fd752e2eb6f871348d51bb6ddb314b9cfa7e39234e9f6e20e35221e3b7301c423535bca9fbcb0c0681fbb4732e68c2b36426bb5f1253758f91df062fc97a266cfa949f4a96ee94c3fff2f24cb7f333e9169b7caf1bd3f4e761cd8f6fe2ace61191ddec82b3de1575733ad941b0747cc963eaadb0f95e956fb28bc3b35980d1f0238ad35674e1b2765de7c7023244fea9c380cc7700dfa3b27e3fe7679166619fde67e1daad33bc9e4be0489fa1b08ca7568e3c2e5d1f8589af9b239d0c280418b98abdced0a7e442e86e9d0ac8828d7491e7c614bec7d325cf884e4b4a78cd2ef48c6c429d74685a7ee3c2b71e2437bfb01536345fada3a41c3b781504ff15f9fe4abf7668948b31791c397230196134f56ea75d61859ff249a923f574bc176988fd8b45564e429d3db15e81435f68186f6a27832e955e2a8c88aaf5af367ecd966b8cef263b2144cdedc5461e33ecc2d3868d0cfeb67d0304220ed009eb82ba186e493b570170cd66119f957ffd1e2ee3eae982248b61f8017ff59d0bcde6734a7a4d424ab351c15b1e869f5b8c8a88495ab6d7b23571f0dd4888430b9352ba872057c64ff718a5a4f91bba2ad5ad8e7439c8cba7d21bd7d457008f53be6ac74d620388b9cf56f6e4a7f36566ab53f876bfc55a639d8effc81273152da5a3e2368c508e8679d22915878ac66b914c0c707ee42509f76d1cf484efaf1ce62e7b9c74bb119e05bb9497505c6247aaa3232df8550ad0400dfba75994f1e058889a73c99c6dee452cb08b51c064de9fb35ad8f6c5c3a57bf8d8bed3e99e44643baf998e3bbdc5a5d5066b69d6b42d627490469cfc489a9944d4f97b03eeec68f5357f3a375c8e3b34cfc0da4a13bb27c8c1b88ff384535d86530dfde02db8da7c96c47170972941a0ff48bd34c372f29dcc03859813cde71aeb12eb12448cc6ecceef4d287ef73cd4183d835808596f6837637eea3ffe81eba8c16c8a913733ec4fee50da682578a67d83328008e4ad96d43709bd18499f4a55cac7e84c9d525fd6c6b809c33152209b8d8554b039b25fc9e0e1368ae68584d8dc743afc1eeba1b186ca5d6065feeaeb8d884b3cffec023d172a45e1599b94a54fbd44e1f1b19c323723857ebb134d21a07cacb59dd84b6d0e7a0786c1744888891dfbc009102c8fc5cffbc95dd9a8ad2d4e9d02858a430282db34f493e5dab75985cecb0a90e6563d1995a9f31d057466aab69242a29bc00ce7f3e77089c6042063bf1b0441f2cb205b1663a1339e60eaa7697f553df70ce580b4fa82ee97ce5d7d28b66cc75983dbdf2a64b1bd8686412d2444214590bbcb64c12f0e7c37ae7572f9faa01e300e8de7890e1fe7f46bf1abd5290ea88baa3fe9ddc5d2ff22394f5a7d17e73cd362976282eeca021b298409da1903d627d67bbf5a545b90d5dc8ad49d27520d9ccefc485c90a12d2e8ba6568e59188b19fc7a01a04d2cf16db65607ec36e63af996a8a5dab64d2285c6ba9c1c07e66466631f6c4197ccadb06fdbb2eeb9d25a06c5d65d3bf59106a8ac0da84707a863a0b6c4cf3b01797ab5330d325bbdb4d798a930189eeefa2e7443bef0f7367ed1130c24cf41e4d324a145d91ed9aa21a6b596c413d7e32a3d632a7d7ae2c2c06667df557bb787811bc7e3df7700edab9ee0a0d37695ec31c86f7e47000fd010ca6deb194f3acad344955bce3eb2b0db88b7f9fea655bdd664917c4763731e68dc363574f01724005cff218d12c5bc6e426fa990dddeb154681028354fed0872761f068b8dec5b4d39a9a1a64b9b3d9ed9268e38a98b3513f210b256f51361fd2907b0008de317fd9a1b0944c984262217a64675ea032c1219c78b91396433482a3cd44e7afd6c79d00b2877e9e8bdc535ae7ad5b80594956f0951cf5c765aa6a5070e220f48dc0da4714585c32f6923827308da428d7ce1434d54868e6acb29858fb1f722e0edd9f6b5ce51df4b139b3b55a889c375d48eeb339e06944b88bc763cea2a0cf93945115e4eed8af6bd7d459832e7704d9d44d46938607f4829908a0dd180d9c06355d2f300465153fb388dd0470f29f8eb060f5ab681f21f8e3a975315283bb8f09e2b6ac3febfd14cfd7ad6816b64568acf29177aa54465550dca9d03cc31bcb0da180d30b47e3521b2f7ad85620499161290d24967744bd19dbf91e7a6d1082fa12a454112136b37adc9b9403fb31d402bbd1ba451236058e4978fc1ecb5c5abf699ff8de6177ef78356744c4084af238300517d603dec6c7a403e5f160a1bd46798dfbdd7437be71d4168524ac38e7bcdb3400547c79e751e9174f58a59e737fa0f3cfc4c4147f3ea19aa1f4454c3dc500d4f896b8ac01d8ff09f4c6cc60e6b28b94cdc92e2afd1eff4c7d2cc3b796a242107ae195e98efb9ae24e4f2e1cb7d0fca8fc52621a4676c22b4088afdffbc3d75b7adf32619948a6710b310e2f7231e25fdeb48f2bf91ced571a0961fc5ce6bbd0183d5e5bb87a2102ea7ed33278ade9620387f0fbe999663c46853804e2a7a1b5ba356a96e59940db1ee90371953c61d43eb1cee09d0934d896fb5e1e9566e27d16952d93d44205c0acaf079012270e366cb1328d1727ecd78162ded0e82b491bb54768f3a7f96acd8692e0eb84912c0cf0a7a2470cdb0dbc2135ce360cffdae07b3400b7f92b716d3616f6aaa682628e494cbd5f9d0f9a4f2f98a2528d06412dd0e73dd04391aa75fd54b24262f9ded13c1a6afffb8eaaef69cbde00dae96acffd6e4f7ef3e35fcbf04b6c7fdb58c37b875805c9da44db8715cab0e1265e3624ff16b0db2b693a9db3740e43d562048f54425ca05a1a883e91bce67590834bd672f1f22b166cd152507e22fbccb8a428bbc7404b4c6da1369775ada1ccd36db2781b31c898a8b68b04b871e13d3cbbadaa828a1f9be28a0de4648b9855f37a80c238952b7112c01c2b32de22a409f5865dba8d1e56975af833f1bdc622394b7cd7eaaa0a437cee392402edb9f576206014959695856d0c4e0e4892816ec0ae07a66f2cfc3875067d3dd615a2b90717a4ba9791b4af0e1d2f52a2d8c3bcc2fd1d62467f02b5aec660a4bc86a2bec78505362ed5a1515fc5193a874abf2964f742b2f57ec3d051178cbe1624444f6f6bca7d3323143470359cc4df91df0f5aa8cafe1a1967edd121abfa86f301053c455420eea088f892b347df3eef4e1c36160a8d5d0f0cc43e0cce4d380fb97bb42e506f051ce0ef4f53686b1c686490a23f99dae4663d9686c3e9791626676fe19225dd49f490bc36f0db3fc5dff736bd08bb4a3494f4d45246cff9e1427236799437c7dca5a22ef8eb7271c1e959b95fb7490f5d259d2541ba81b924c6618b2ebdda4b13b41fd603aa292a8130562312d0733af7756a144ca1a1f393e1112bac336136d38998790d89c9f2fcd73686b2d8454ac90ef3dbd5b16b167e8f64060326ab25b6e432cce24a6ea6c71cfbd852e0add57cd7f3fd0c04be4e89a046903e9458e42a411f73c5638ddba039f13ac57e23ec3d7b33e82f00e23be248d8fd0aa4b1ebb60fd087ca7e10f21bb570be0b5494f7e08fa24b2cc71e3a74c401bd39dc4ac4dce018e8b633c68fa7ebeb4083a0103c560e2e5d8351afc127bcd8d0f2629a301d2622e1993875d76ebb5210bbeb5044528879179aa2808c11f81cbf6446d410c64aa0ec9ff19695400aaa8073207cf6bdcbd08fd805e30dc996ff5842ed7dcd04d2fa908ff561dbd2947be21632e5449f7fae6d3fb084ca3370930e1ae44e5c4393021075a67441037fc9f16e8561c88de4e14f5b7138a54a5f8fadb7f922340504d83690a3149bc713a6b20505ee93b3f910c64b7a5d338ef0a8d9eb25ebf37b4c30d297d3e068016b6b3d2f06c810070a743e9534d5bc7ac5d098a1d6e4a7dc9ec54a702088f7b66413fbb8be2072cacd1eaec923e331353a18315a09c60c07e7a02965be2e7d87a8e711d5582c13d4a2fed2449aa5ef0e1d67cb144e658d5d03156af7bb4180ea2208b992c43e13b288ea6ce662602b0bf5737f8ed9ecdd4258af221b5951cdceb9c22c7a33c52bddfc72011f05f52f6692a9a30067c5c0645225b123971f29526ad3f265e7b2bb7e0fcd7a243ed61866593b711f6c247b4d642784c3d01026c1369e90cbdf24ce3872b3a21a842ce0a1564644b5c870e69708d55fe6da849d0c994fdf42f50e4be32fd3ad0fb0f08d00e2da0fe0252e26a159b94e7e4b21f36ddc8dd2fce6ed46a2945931d2a7cc5e86e3c3bfba35bd250b84a337a8488fad7ac2aad4a7692f2926de5ab92ca0ccbd040c76b4e4fc4d86597848238712624d9a988b523b38053a15741c6c386a4d32d54c7a7065d430873e4596b2d2165d040cfe5af5500fed980779627a0d883a72916fc00fcc3040c96429112ec0585c6ee5fe1629b046062d120edd8a3e08980a2f55fe46ed7403cdced685d27818276c8cf3b4b982136e07915fc69d2f96582849c85981b3632a34d734c438f88d963b4858972864eba0047d09c3e287814f7355b803550813e5199901f1507955c07d8bdc10e0e0a6654f2db7241dc0d59b29755358eec05b558a631e8af9c5c223fcc4c8e75c689af4256c32222eea76e280fdd8b3058abe0649c529c60596447a49fa0b7088cb73a0b72eaf226727c77013108f2138f555b70c23e27784cb5572a7944fbc206ebd928b7b294c09b4ea390a8f4d6d4da7d733fad0e7a3ddecb9c05aa153ed8b46f4d4c9ccc55034799a911477b586e7ac2a44ee89f2e8a448bbea67f3625e913bb9bf0275169c9a77edac412df675360a280dc260999915ac3b30b680e7abcd21190d4f80a412a0dacae63f335c983f0b07bfdb9c273f77baf03c408c4640a1d2b168e11694ab3cfd98f16c9c66e8355c8148f23a4a9d6e2bbc70a597d0947cfc8f16604e377e997e004be24c00c1108b5e9f849e2ab1e2c7176a4d8bacbc707ca7322d022734f4de4bae6b24176c0e7ae5f6c2e2e5285415af666408adf625e26c7f92f2769f74d69b1bbe649e73203a71555cddda39aa6020c5d1fa793b68d3536ac2c5a31a2fc397effaf5203052fb124a5bf8d6f6921166b60dd0160aa9fbe3acfda4c9dc24e71e66aa158ab2c4abe199a4795a34551e1d01e409b349fffb2cb300c48a4b10a569739d9c2bbc358b4c79ccc0d41463ee84db9eb1aaf15ee61b957e8f3cbd13ec65b62e7a532629239260c5318ebf77f3667eea58a69439d8f337229ab13efc721744dc5fcdf1fddaae2835bd6ac50e24236bba672ccc1943f144a5450cbcdc533b40bf96a4a01f388edcd474d282636f5fb77f5f7ed41dc89d5eb2ff52763bf754d9fbd51d7ab0752b1c5faeaaf01139a668e5a1d294d266985cad3672ea68b71edaf5ac3ba4c268f4aacc177032041483a19e6fdcce3c09d473c2ed42864e2e3848d75e8863c2899563259d3542b9e7d9c7e22423fa627413037bf9027cac615e606c0eb9fe91c0b18612409edd616c66a001d38f9fe00a6bec0fd39287d01e9a4aca6afd9573b8f37f58e7a097316242db6ff8988c3a8020ead030511f3ad0b35efa51e85ea8462c60f93fb2d7c8dd954341732507e7286fcafe02e0dbea96d8cadc9c1b8e547490221faef375fb5cc6e99d5ece618b0d6ad045b5a320964057e4c00847d656f7ba05c4c6d8d4b83ca0c15e9c48492520ea40ee8aaa49a942a1c198bd53574fd84113a003908a22271be48bb78b02ed3ce987449d64787ab8aa3b1452841c058064ed32c824e4ede7101fea7a0e9f51955ba54e68176608ce998967e645bb8d40b8f013b7ec9e5f543392ffa1a9ab38d700948d3293b6639fa30085dff313ce005cfa077d12f1e91f03502a8de87425df58b1ff0bbdfbd2b5a458e0c4f32e000a4a03f68b937d39ea0008f813d15149516610df506c88c952ae9f498f9b6a314911c4328a6046398c6962aabe8cc885c1b59667b45520bdd0642f9492eb167a6ecb45f71023f92ea5e0b1ba78f3512d986a76a2922f7452ef8e4c781af1e6a8dddfdd6bbcc33a0d8157437f755ccba195f2671727259be9b40bd2c4c90881afa89033a4fb8f57654a7c84e40c6ac95379c1057fa646c2f394d3044d1de6d834aa26ec51ca710bb586f73de65dcda7bd649074662a736c04a64866ae80eec14df15a5a2544fa8284d475c19cc4d23f7df99c1138754087dfbe00b944613c6be2ca607806eaf5b28bc5cc79252f21e97a29c85a1eb00eb7808eeb3bda880236b690c33437c85fc087dad0c417d71a0a30ee3fe8bd15b45366ce148197371dcd46c4151703ee80b3da09793f1eacfa9827f5c16d640625da1db997a55396d0ffdadeb0f23ee82aebf63b669cc10df563a963dbf55226f82ff8006e561bd5cd428adebc08ecc10869ce070609160fada742b3d47bdab0ac39ade85e3201a2bd50efa953c82b034097baeebc5ed2229d9edc727dead665e3a3560cfdae154c647c3b983ba9625847fd05e05ae809a2a097cca767aae3c2e32b4d0170b9a0c6b46ee093743f71a430ecdc7bd7f577523103c0fc44f6e05bea9e89cbc63793682ee78c192a7daa5413ed803724b3d73cefe551c46c5f15959dce9a07c70e12c848258e1e51461a175acb8d2be351ecf1cc147d50ea1a1ae9c0c3dcd21d5ff7d75e28a59c1d08436602dcfb36ac22caf5b26f12adb5c24ca4165fd6f773b53477dea8796d952a006d866005eadee1b87963279e221ef03b950e1f390dc9e8c3565f55cf81bd0605b864faa55e36c9ceade5c653ec840c6cea54bc92265ffec087f4d3153269dacbab7f36c6eb1995ea14bd3a3535c91817ddd8f41986febc6af474ee3403eff5c23c88ac7e0c41ac6cc8008c7e1ef70d4d5d4cf69bcfbe54a09e645deb878dd042bc0ba523b1bbfd972a1545e77a09b969024ebb1056179d4d0fa59b132b315f91ae7850af983c316878d078137d34f4f5698eff72b90cd5c13b906835204f34be132bceb527bc662b324c4d42ec27e2832693b838d168362d6349dc3a6942f436a227a604f6daab761cef85b838ec2635b487308cebcc4a876b21bf69c3ffae15faf1ee01d2d4a97cd1b796f255971445cf20bc5a8483be746cb24c5a2deeff7d5aa7bf8a6e558e4cda70bc8f6faf971e37452f976bb9921b7188c6f83431b889c54610c5f35f2223ebd6810a2909e6b296b8ab6a9270cc397af6242a94c2aed1970dd566576e76cdae4e8837d99a65693f906c11f3550bc4aad6e1d4ea331cf98d1d4d7bdd9039c7a0ade6374bcdbb2140248a83a85c425a6634ffcfaae4ede895b6d73f52bbef507659de1f6805b12905e470a0dc103fbd09ba769b46d1a568107f4f3f7552d44e4108e245fb8cfa272f3c4840937671c50538655abe493a77445289e85de1368bbd517d89f89c1d6a593ea36446eff20b7a5970006a8e1e4addcaa93f9c4247c6b1914331b591e7ad416128993b22197a6e44cd89986b0320da3242e29a3124b6fa9f459eee20e1ec69969d555aab24c2132aef8655d9d46acb0e2523299740364ffd8e03138be4eaf6573dc55ba83701075cf859909b6e9fdcfcd78905b1634ad4c31f321e8d0d85489614c41f11db21da3d86afcc9e7c7d3830b66995c3554d094aba4ef94f5191300a9319a358c6190d39b0765b9b7c8893a484ebc2b2e4b4b40b6415f9b9a3e2a880bedd805cf4df2dab49a4fd78c951cb287635fa0b84f794719e8c5188401f56676b477cc0324646110c0fdadb3fc5e4b2d80b93771ecf32ea73226c989c8a953925e62c2dfa940da5a9cc5f430a4e4f8edca3d8f7309c4c4e5fb9eb147498411918fb0dd722b4391342697769c75eeb738f877354e1185b9ccf155f043c7e81226a2ae6bf905bfb853149f810ee9b08e415550bf7e767f7c4f0c0c21c414b55efc8a699e43c682a758034a921f7fae9fcfa9c1f472940488e99e6657ff988eca7d7882a4a4946835096c89e5b8d056197f870d5cc08022ab25b4bb02a8b5bc97bf0ee72683c5b2634a25a82d5423a8d39781526f39968b2ddefd3483ab224af11a45e849e30781b7edf807a8091d59afde1d0a69d903f93c6dade6ebff7cf143b536666d9723ab60760d83d720285f4e57dd0a3c1b7cdf71c5fe80412ecb0158713d79ee052151688ece679249aa2434c1263bfcd3fb22b838af44bf9828dca915ef49ae984099010841c114becaee4a7efd1bc3e9eae14bdfe77a7d1e16d0e6245fca300007dba91c34d7ac5cbb49729a37b2c6a50bb9ffbeaeb2037d7d878ac03b42b12069826fa08a13111055dc75594e84cc97f4a473f535b4e56e69e40ebe142f67c67b135c756e0efd7e909efb5902570753e656bf1a35da37a2c561359d5061a136df85baa12d033c5367e728c099c0f3b505476f8d190ff08ad305ff60028440115f1d71afd554db3c6055c6c2a745d1d24e484fd03e3c72a07f1901f5bfb65653ce4b37ba231c4659138c5dfa9925438102b2a97bce48cb79010c507e9ce3bb36295a632c0e93cce703c5b7f819920ad6032816ddf4b8847e6e219f85a71eeb9ccd03c0381940f496c4e4a598156ded44327926f357ad6cc4d04677a4b37d50ea615218f280bea707bac5c1de25396e2945a2e352fee6f79d71b5973925a7f9542137c2b5e7cf274ed1842e675888195d5bfed876ecf85a73da5e2884ee6414f0a538c9bc085a6846bd3d4d327dfc86bd654d897452dc1be82c3ae7ac0908c4170b8369ae13bae3656887eb5d899c8e0775ae0fa8cb777e9e3c6dabd2bfceb0b151c414c08fc4cd1b079e0d311d2019ea88b976baf62cb33d3a5392c5abe09b0b8984d5522c5b95b23c1cda1f58e25b3a6d0ddd66830001aa791043630391cb8d7ac03d8d2360de192243f8d7abf776a4fbd9d07e2ba1c05457819ae41f672489789aa9debe25582c921fc6d70b088848fd22f360449073acdbbee6999c9db74e9cd13e36553255d506d330414d176d7d96b59426252b63437b6833e52fb72f9fab3ddaab8fdf8f5d91e10099ffc775769ec5a2e284e4ba0cafbb0e01ac8176d60ba48e230e4b37944e9810ba0bee260211267f4012328853c05e6c9dbe9c3b7963adb146eb4a46ffded150fa77483d481b74738117f3810ed486fec5fe03bed0fc2d48c9aa4ffd99f69ee03f292690a5fb5c65c959229986d009b5d7787a37668eadf41738877fe1e0b4c3f751aaf54ff73ced716ef5a05de95c105cdfacb55dceebfd30f21406f22fb3d41adde28bcc69cce483a8109cce768463b8227790f8f98cc96c96b25f63bbbad7b542d7c7356b9f9cfd12c9c3b191e1ab41c866bb2ce3b7a61c19344a567768db4bcd7b07d4487203b58454e0cf12b00ab6749845f39bbcd909715fb90fdbdbd92bfe32ebecd00a8351004e5665fd08101dac8ee0e5ffa83ef8ce7d7bd1ad60a30a038c1829a02c87675ddb3b91fd6b97d922335f6b150ee468e66dacd792fd074116fa17b824e203962957603501e3515451989cb067f50f568bab21a796117786dca4222e7233ea9e1da2d065ba4e3ce84f231d92c9099db490f238cab7c50945287d78833ce76183f02b04040c5259ac93a9e2fe3515aa62afed6d1012ccb4792750731f29a0ef6be1944f7cae6be25768c2cde488e8427ac44d26254662156c03bb4cd5cd33b2e0201dcbd740c2ede3aaf3cd1a05f6290b217d0ec3537455d94ec44ee570c575e339b3dfacda26d830f519a1190f45640099ac71b29335d0af0a2c2ad01d1dc0bed6ea82a0ad148cbe212a041f3af92e7dbdc5ad8a21735f0bbc735c5f5b8d229d7c8619c166df862b6e2229ac7895cb17866afe2850f532eae10fb7591a01a84bbfd1f291f38bac62fdde4e645d066b72498161cf6ebe7c58ab27ff5c0b82ad624d0cc8f323b0874b0672bde3e7fc44d4761a6922d4e7a9dc15e7ff41ef141658f2082b4836166b4beef4a27ff5cd17c4ab8a31516d88aaa00fb73577ece2ead93cf10ca774cae2fa7ecff71fa6bc498a28adda2f488a9b9c0fb4f85207f0cdce96f100b4c69870881a2a2ca92d88c22ab5984bc999bfc387b2aea3a8ad4f9a5f75163aa654490e13e1103afc7fee62eaf8723a049b3cb8cf71678270e9747d4b8d30a75adb6b41205ec090aee6eec19951f9a1e7d654eda6b3569ec6f0958fa538979cbc02a938b7f2107f7ca6404782239a29d5b4852de7c3189c5f9b269070cbb6805ddb7f9885e73e3072f6f811c2401f04c01d2edb0e8929141c0a9afdfee76cb2a71137bf52569559227140c9b06cd6307293bd6e4707a6140117c236ee2258e085ea64c28b09401388951680a321245d92e4fa3845fa3dab1e89d4dba5fbbb84db282fc2c9f425a02a882901f1f1258a1b936d617ae2b9e446c3900d0146e2368c9556956fa6ec776f976c31eb10776a5546d74d5aabc9071d376a137b7534abfe30006abd671b6538285bf41fa5fc0f927c59b54bc8853ec02525710b89ceac65c744512e6886668fa0eb0ce866e8ee822837151bc38774ccdc7469f56cf78c297453ba076dc900655292a99764b2a33fbe771baa6fefbdbbb8c31d217c653b27a6fdb4da8b684f4b61334d02a267035722398ab498f57190cb8b1d00f6fa61cd94917633aecb5d82c363b5eca7a49a07eefff5d45707872672e7fa6a31517e21109e3e5e72c882e3f1e9409db805ab7cc6f47cf4d578034291a389dfc781ffc0eff1b8cefff8bd685e24d86bab1c458b0530c25c8630623b8ac075d253bda4b13e34e7cc71e551a4309e0328d5a32f835f6641b0af95f1cd6b13a8b6af1bcea0bb095d93b8d338f6d0d5892bf81824cbb25ad530fc4d58f66160748c82b2d0933067d098fc15564a39e4ad22f1757795e71bbdbfa2f01e0f41fba909085a276ef1005b0639ff08c23447b2c3c90f301a4d38fe78362972ca118f405f248f9c3be5e365b40ffb41c619509c0b2de86e0de928fc1fbe2d2b4f82159157929eeaa543e7c8fb6abf166020926f6a349baa75539140c966a8ddc4dafcc4b006a6e4cc82bcba4f5909f4ed4cc635453e8f62388d777633941a5a5421e384c77101eab8926624af47af3cc6fd9df554ad13f2297010b2c0f7c781cdc2f3a101840bb844bc3e63000d633205d9b65fe4383a9fbb732be792d3105b9b2f7d600002f3b0a80927f4b62f78ef4f777298f5fe4af02cc50fc774d968282c0561456a5955523884923fa80b8c9ea6121997ffef9c0666a5c8bd367ce182359e930c9e81687721e32c2711caa47e2e36dca60ff208fe1353a7b94d34fd82660e5920c5c334a8c479374af7c1bf4139e747d8f67e56e000658bb264876a720064606da80faf1a456d80143746907d01958914fabc2686987560f5149ca2e595f04ac4bca55f43bc4de3dba27e2014ccdfa42fe895a804a4253ff9e1075cd099a71b8dadfc94d6625318d2a71568f26507acfc330ed932e489b13746998d1d022d9119ce8102ed1c7e27345dcc8a3fcf1d2ebe3dc22847f8ed328413ffa8727958187f8c12813d60cc84959d5cd7285b9cf5b836a2d5d13cd341ba41af9fb953ec9a340b1eacacba672f40d4935b114ba3c44ead45976e78520daab7be815ad9f42728d205ba006ec28e696da0be2fa662184fe7c79ad052056fe2efe6628073618956d8cef6cf3f3b84c010b7ca9b1da3e1dfa1d96da56a62bcbb1d7ef30ce2d9bc3a3851bc34e00675e5431cde4f671c35f1246d4e77e44691424e81e28cf7806bb4a2d5ddb7dc02283e7a6492b7b762965b9734ceef52fc77e0a42e93d2","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
