<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"9247b8d27d30c943e5c816779c7c1bffbc5accca68d9e89db6badd22c18e97554aa8a1d8efc3e5782eae9b2105e2d0f35512147abc0e81155de6beecd9b339bdb0e12703c377f7e05eedad6bbf6c3c74998df1184005174deff67f417a90395ce26f31aa5d763ab6337a8745ee1c973363ddb0104c4991b15066f09c960acdd0bbcb66a80b3a17f4d2ed5c86aca5140f22a2b8f6c63e8c0c0b259ef11c82ab86c9098c36f3b24d182640b8958b1cd925f9a7213ad7c03767b6039d702443a96e103d880320f3784c21cadc38cdf66dbfb732b7eb2011b0251f8c812fd7439d4b78b98c0b6e11fd49a92ba084830ea77372d09906e5446e276d747e4a6de568512b5981f3855d9e29402c1e4cc626dfe1c1692c2a89c776cb2134060069ac068a281d180bccaa15fdd9fee2dd1722389410abeabbee6bb5dea13ac5caec8c10a6444bf3ac0aa4ee3393bc0f8c90c1ce2a1ee9efa1f5c6738c4308d7a37c96bdbf110ff5b22d29510b29b6380f7244ca170770a6ece42fe5882487822b610e4da31fdadaae7bdea618381ed9998960df5200b669aa3630a6d76397479c5655bddfe94cd12d290794d143dc568d8cf95c0ccbeb87dcdc3832c96dadf1cb573b53f752d9e133dcba236b54700c2316a6166a16e1f590479c78553211a5570cbfa4d418a03ec803420d834b70fff6da248ccdc1dc63414f2586d33928ca5ff3b5d5ae38fe212a775b8e82a57481e52786c19fc8ef225032cb7a338877829ad0e8e232d052be72058a296c0885a72f4d6987c3aec0bade0d41988674c625aae6aa86e5feebb656b9918498216aa18b4697db7c68126b0853d9b5339e337ed1fe5a5b026bf65e6863977df23eddce7ebf5d3a9f10e1a013197bb1fe23105131da9ceecb7a09dbf5461b6fda183bdac33b671f0943620eb5734957b97c6fbcc550a32c5b9612160384e1e648eec4443aac8ae1e01bc932674c580f19626eaaaaa73747df3026e3dbfbcd188fc5c708d0bbb13a49cee182edc2b3efebd761bdc42f2dfae76da43380cf6b1533ca99fa4ef17a0466a3a5068127e35b49dadf1d82ea52ddb14e9775a95277ee9fff5c3c37aa17a6fcff700937ff7dfde85604173b174e2902fe527234e17eeb1db2a3af14bb5ee39e5cdac4115a28db9ddbac1280b2b2597e1dc9b00765afee87cfb3878c2303874db6f522a4033f38b11206addb7719eed9d08c2ce46e986b32746b44791ba8910c6ec17351cb0d97115a71350bd78d98529b1d30ea9ef2381c876cd07097d68e8a92318db2baaa2447607c9316a2b4639554a3824f2f5bd5d63e0641d6abcfd1c57bc853a0edb1c7ca5a2bca64838fd1b544eebeef206c00845229619becbd4079aca16bbbe18a50efffd3d5cf79eac261683b32698bec1eadbdc0f5b1c80f1fea9c16ec3434d6575ffa79ea195757461dd8170b449e89b4b3d9371992a4468c843f124c1833a904b6412099561113cf8233bc1abff9aba25d88846e65915212497916813cb2132f7fbe2c77e97e670dded4f458174b668b0e9fa5daf0ddedaf76083900422d729433b19e20f2197bbbb7a0926992a4813a067a8e64849b5fd8b82d0d4aa25d87c061195a294572735ff4ec1dea3bdc88d75b972b80a7392b82f320cd63551e893114d43a6cc412a1bd17521d3c7a1da0983e9de3d968f17be3edb2eaec502c71be734eee63eddaa5f54fc3f8b94a5d14a69dd9c3785b6886818a52fd14ca2249039bd3ee4c812d0eaf1b57cc6f679e79929c382ebe214fd96ab0d8e45ffcf10cf3ff2cb7a00659e25c3d91fdce50dd52f1285975cd6a26248850b2a8621fcfaa19de169602838831a765e7b1a440ff3ed2a95dd965bcc917bdda1d98fab6a7b07e0e1dc1ab795422cf76fb8cdcc7724223ce360c5f8f53cd077a60e06a51ecd52a622054644faa66c4f1f7138decbb73359e69a74b4ac6bea5114ce2bb0d09a25c6dd719755bbf10d5542da5adc2db7c9b4a0db058c766e395b327720a76b4fedd46f3bd4693cdab2a4bd5d54293a6134636fbeaa1c6960c56e87633e1733993ade3faf8d6c23a006b6f0c31436834c867663b09c1532e43a4a14acd82971812a6a82e2ee7d658b4c20552f097358dd661201bddfba9f698de2560668950a43e1cf21fe42b55acfd9c81731b8c4084873565cdd9a2c5e3092c06f9c7b2145d4be88f820dc258ce3bf3f784774a5ac266a834378bc35d89800e27e69a9719fb0fc1a47689ac945939fb82949ba96184408c0cd5fe898298f901531d062f490e2deb6e8835fcb476553f9f0e2a98795d336a86344701e7fe9c76b8997f43b9effb291a8ae0ee2186bfeaf9ed2927d8c9191e127b6440c8bc7272b1710170c4919ae8c87d2629685221bf7c9a8bd69d3e0fe1c35dfa0f04e71038d6df70358827866468cec8a6098245feaf2f8d8bee50ab553b21e1d163bd6599c8ca5bded0603582e22192bb3faff7b41eb0dd0bc466f97cd89b3a0ccef839b40c563168d9c48a0bda523e7962a2b2996cc748683a14274130b536b8bec20980ef9b9892d101b7e7623574d5e98deb176c26143a0005330d23fcddd7e663474b16fefd732778ebcaf8d850e30a63caac823da90e67a771c846a174281e7228cdd4f9560dee436cdfa3fd996a9d88555679b3c9ca93c35bf546dc7abba5226ea5f4ba44918d103e88aff11cf32ac65da2c5baaf46cb10ccb1c47c847b01493dd5c69fad9ace9219975d12bbb649c373749e38239cf376c094e778a808fe9e59da2402edd5722d1e5a99340bdeadeafd6d1968507f4ffd77c5390519002308afc9f1d58cf3dc5b8974c2cd6b4c3e0ffe817fd79ead45436c41c6fb034e15c1e2e01f022a94ab834b4f139a505e6de6daef2927f15759454eec4edeef707e53a64eed8275473e4119da3580ce565c3a17748121566782c8ae1190304f4a7c3381edaafa34d70c4e0f773754b8df47fdd19c7b69d79735840be44eab3b789b54182b120c6c15405a3134afd2d5690592af5ab0e40df6603e95279cd44cbb807e5d7696b3e16bb74419df6af29da44983cdafc456085c27aa27f14a6c0e2bdb5611dc2f6a205d4528b36afa54ea246f1a2426d8c6e6ebdff44601ef2782c6ad6786d862860002372049ffda580e12caf29cc770642a2f2d5ea89bb39df80d253e56a3624a0cf73dbcad3434e6feabb63c4f9daa662575cec4d1220547e94264fa2b11c3261f7f7cd62446909c9846d41bf8269a7ec9846f388ce0cecc8b2eabe3a70b4ecd305d5efc44d1f2ed87dae4b66a0cf00fcfbdbc8a7e3d60a2a4972925e40c5a143da88954bcf25e8e74dff979afb919c804d26b17105ff25999dd6ddb025d3beb2b09c5a30b0445d3d52823efae9b38f5e231bbe510f6473d4679963334009d4eb00da39bef1df262685ec620f4d338aa009c0c5217a291389e65ae463940b1ddbd67fe3da03eeeb29264bffc7ff3815be0bd5be362a039273c3c07f341ef9e8367b1ac8a66a71b40ac0288af0e39356813409679846946440e125089e9e66e99dac352dd3f3f54f3209d5404a0ea9485903c5378db52562a372ea9aaade78cfd12835a989de7174e0da0ef2ff41812227408cf99d561583810d94a068631d6f8e40f3c0d02ddca3a09cede662eae0ddb02b25078bb56e80baec1a46bc4bb190405d9a7e449a75bce876d859f1361c770c5d598c73d8520dd7e98bb6b4ba73e7c334934f93893ae6a7e02612305ad9377b1cce3a05abd2c3b4f3e99a6723854e85512e5cc066ea2e9d57aee0b9e41575fe1a66ff961415cd7d74a08e622014dfb01da1835cdd69bcee5985afbe1161174805c8895a67178afe55debba28aaa8bbc3a7dc47c1d5bc260e8863781328395dcf06a916fd35c0b4998ce95bd0743fc6f66e15e67775269b17878acf649f4af6d7dbd4a3c4ef569438abdfb3bc8bf6aebbf3b7d4f8d469fccb6bd8699283e31e1c62dbc59319c0cfeae3036ea92bcb95782a3ae9eead85bf7f7103b2655b2b3f086f9039c12e5a48e098ba48c207e961d697a15d95fd38db932f3e9dfe8c3b0f5e517e78e44c4109d389aabc02a32c627e9057a15701faefab7cf34f4c8cc726ab996568f5584cd35fcd0f14ab78c363c5a84ba8932e6577354b719db90176800942f7d723a37214df817c500a0bbf510c6cd918e8b9586c99134d6cf8fb1f47eba9a520a8dcee2e9ead6d433c4f231dd42822594a2b3426cdd364d38df6ee546e7e0dfb74ed889f9e9067f3c3ea1faa0469861dc8ee084f9bf2774acf3be348777182d4aea83da02bbcfef0da3019564964090fcc37a8c8cb9d848515c7bdc44fb56cb9183190d0124d7a7a5bbabba9bc37711861c4afff6a1ea278d20790a1478959ac1eff2fca5afa2b8ba4080c93f1776d75e58d95d9fbe5d44fad12f6c7d8690c6489066f1900214bcdbd4ab148bdbb0aacbc30e91dfac4314f741b8d715d2c2feb4c65aed6b0defa6e591dd6837953099cc22bf6a03e55e03d283a6dfbec63c6fa6b3797c1e9ab69ee43240b5f4e62984043cce828da435aaa4d8fe68dfb5801efcb5b9c156fcee46df9f8aad4731c76f835dbbe75cac6a199d84da9c5432a0ae0dc7181575bd4bb8f2a02525562c22949567cb284773021ace2782f39725bff84bd2aade15075ad9e244774008084fc4714486e86d4728cc3e8968593721a18e96cf6637befed0e5097653d9e0f8ed3caee92bc95770268887c158d9628932c290db9fa8d25911751ff8390644d5f44a528e33d73c30809395ba84e0d89f9ab0ec81cd8e1dc38d9dd2d21c708ed783d44e2bd678e8e05a98e4818be5b288dcdf4d03bbea290e22476a8a3fdfbfa85fdb9e870ea349402bff7a2673b5ceac2f014875b5ff7ecddc1f1d261e3e473f1e7514b204b2562d442f8a66a9ea8edb012501e8a050d1d5c72bfb9285c9fffeabefa723ca4399ea6aa85f2565e140b54aa44b297b4ad13910504b9d39f24f09670f7b48c241f662e9b0fa601e1e404413402202d85bc453c30fa2aa030f1a3c0b74c27eac89bdf525719cd6e927a252141994dfd0daba8ae59626018ed8f0d283d519990f8071b6385a3d2c933c4fb28bd0c04ee3ec57034bc9ce50d9183ac90d8e2cdbbb03722718349c13f121243984beb551de823f860240e22a64c5cbb0fcb15de05b017c8401931977b537653b7deb9696a42922b7ef9b64b639cf48715a13f4b49544c8534ebdb1d4ab96a80d6d900a77e01555abfed63ec534035d33d9edbcd83d4f3ec5a5b458407817b2cdbae6cf17347c924e03bafbae9cedbd659d56e152c6a146b155bd7b18432fad42d052b49274e774a53d2f9b06d24410e95564b6985b29a54e6382489a72d9aad47f817f2b85d94d11cffbf5d48fb7b24fd0336840239fff61a7cc8d631ba8d552bd76a8532ecab0840703d24641cd15d8076ed5b9c468f1867c2b706ce080f6b953512d0fb56f465a367c6cc8c6cf13b74ed3cdc2c4530aa2ed0467fb6cdf87db3ce727d9ce0bd39734731fa7a06bab92285447008ae3d92cb486f377e7195c8139bbaa61c4a45a08d5538a5f2c95b92a9365ca5e87c42ca64bed120e71c1426722fbccf32b6f42458955e90ef752f062164e51dbec1fa51bf5ff925adbd91088e03dd6fc7805f21198859f124a3f64196a33be1b8b2f68c7212f1cfc32fa749f297ad2373a64d3281d34a47b4bc866714bbfff60ebe41caf0e428d41797c4d0e51de5904c4c1588d38367feca3051fcbf6225a6e65f531a28df47ab564042f6d80a644796823968949b818b6795b9ff047722ec71ada58d3c235c299a95e34fe53a19beed1236e6b516b8388c16b06f15b1190057d178f02af132ff7657d42f220b211a4bd945dac05a3a6fa59079f272f61c2bc5f33c4b2eed2b03d920122752f2ed41241fb2ba941f9c3a6765f5f4d63c870c0cae0ca90645593dd9bfcac6155d689f9db524e9cf4f6acc2818f02c166edcdf18d51ee7ae7bd1f90bde8ebddd4a4cfe6337d43d851d3b256bd07306443f9f4a0794b90f4ccd0823cf44f339a5ebc73413b726f9871a0a2162e41319ead8a9a7382572385a01c807e6fe20bed1031136a4c1e23783e4adefb274ddeeb762d1f66949376bd155140edc156127eefc4f703f9cbc00a78197589d9ffca277ac027318e4817da89521cef35dc6128864dfb3da8f6f0e93f1faec9d278eb2692ced9bb8c0e062a42fe5f5ce082d7f087cac7558282cb97cd337ed2283270d40a676e3eedc4871ff7dfb07194928a9fd11e473d7269b700912c1611af93df6fe9e100d9eb9ac733b28eaa650d697c525cd75f9954c4ce63eec010b7b44b7aae96ada4d435053fd1c160190308f96d8eec1a104808e13c7742eb6808ff9dddcc7961a2dc70451bda0883d16b63e3dbf8bd5913bb36099aedfb81d612af3fb129bbcde4aafce7ade311fd3795fcf23db440e08d92f6992dca735f20c58fde89ea91d90b17ea8aed64b4b479f4d1cce66fdc54ca7adc7e318f32d14877a7d3dc405022da1802197615bd88f63e7fb9950ab1aefe213cfa41df5edc2939c6fd2cbe9b6cf75cc0974661173428e60789278cbee27ffe623c5dd695259b1317778068c217d06bed610c11d6e60670802e5e9574a681714d55e64e474ef8ffd3d5566c7e8d561bc09265adb922c16e59fba0aa5159da98dec6baf7bd0d631e251700aacdbd4750104bfabda2313071819c3bcf3d6c7e53fdf90b1378cafd4cb2c29a5810ddd4595667a24b39d0fcfb09124144b5c918430a06e7058a3062b375fbde28328eb74c5e73d0b6bcbbef453a08221b2f6352ca5b9086a35bfc14c7a80c438270e2cc93d29ed1b0dc8b7978323eeecceb7004e280d6d2e38e4812d19d49e23e6552ab4e0788bc10b0be26de6ac984303ba62f0be101b7a44115673c7a0efec891fa8df3648f1478d8b49be68b73c5b7b89c041ba031f267f0476e668f283514b6d28eda169c3772a10417990d6c3419bc952ca766a9aaa280602955caeb22b2419a14c71bf0da47201326fa45707a9023477b669d38576e47b548b4dbd42e635f3269c07aafdf066f41ac5d70b02cb57a2fef4b51d3eb04a6285ea23293e8c543142583ad9900e0836bcad4f1d980d99b0f28a4de2214658020dc46315079ea1ccd1a003946a7d9ee98a7eb8bdff6987e736ad67d66cd3b6b25453510aca7df13a25e6418685b998fc0d8ca7b6e97deff46e59e531147258ef8c83c8da5b9f05975471adaff13e60007652c56bdfed3fd53adc54ddc382b861fc935dda03dc3ba7d592f07993dcdc23951f0c512474d3b22a1ac62aff5bff108c4d81c8a3a77e87717b13abe2cce9b14aa7c98147503aae0d88a15b2f0dd56e87eddb66f6a49577f88a8cff0ab6b303a66d02775fc3c25c0c7d236d9c80c860ba899e75297e7d188abc4654d367ac690a4d2857c783b407b34f1e90bb0a4cf1e4a6188485f22c449310730c6259e0e9e053baa26ed8ab33ecb3174cf037b1743809a7b01856f3626e1161a9ec606aeb2c225eafe902d12aa6f4904f57cca0b99c1010ac4bde09b0b6078ed7501e6f353fcde41cdbb56a25ca5e62072cf99a9badcc02e168f20bd44d85a9a68a8a39acb4aa70701c556f7a6c3bd1145a45376020004d8102a4ff16f7b057673f873f50238af5cdea21c89b1d3b326ae46365926289db3378b34381a7cce585f51533a3236ec9bf822dc70cb10a64757211f4e9c20909411dfe9e69b6c4a0acf6c9c3d870ba1e9a52c18f2948341fd20043f03c8b51c5f47a9c86576427ea182a2c8878ea3f59518de4ba313e7f03f49329edddecb5c830e3fdda3f79cff0fadcdc64fc43660c7f9499237276119c57d93750a2df17a67ec587bde265457e5ead832918bae35ed6b30d188ee03b1b32ba503c4dfa18011ec75fee223ff5ec28f2b624a3c8f6488c5bd8299815a3fe36cf78a1b25f8adefa390c9201c22f4bc6d5d010a7e751b130607e6922e21e6da1a8cd22b432cebfd8681138b045a380f89d539e35990f30447dabbd15f6a024e21cee4275d652683feebf8db971c8530c3e9be3d01f2e3f8f26a6cf2b13be41c11008cfd40439744444d29eb3122536af63a5daba7e0440d7a9789af99aeb225a9f31e1d9e04ae9a29e805249829c5760764a557d6aef1100719beae52870d1a2ee076e539469229babe893abc516059a7be8056e5fbf9ea08e708f3f32b7763482ad464d1986197d7ae9e3e574c18cf6157f8ea952abe6ea1e7b37da711ba9704b26794338b14da1edcb0e64a76ce8df0cae1fd8e71c474fa0d48bd190dd547eed0392c8bae5cf221a4e850d634082dd87f4709e925b2e6560e13a45d6b58d799aafbe736becaee94ffa57a34a752a1a1b6eaaf63a839297d789d6d57f4daac42a6ac63b8d9ff95ffb89db5687c0d907979a44387b55c8527445cc064c13b7b629d349067f2ec9227d45a8b22ae5c53c2b1a41c0724e693fe39343e2ffb647afe662736ba30b4e944eedd921f1be4abbe60afc3618b3f8225fe40606aeb54017d6d36e96cb44455ffec15fb474065f7037b1ba77961d1f7993260661d09ba5b23639443ac902a85695d6de1b7cfa2e3668cae30439f56588cd215a86019fd98cfc3bc560279ec585c816a9cc6663a90c452b591df306fba3774a8feed89c5e43c5472ee2fd6974828ed2f3051652148ccbde59d0dab6efcff589e179f5f87472f5bc8c046f2b316d93714a4eb55ddd39750e65364a4ccf050ef3c195f2957856cd73dbc2ae4ce712a1eda5aa558ae6b1ac255515c81b31286d90530841c7f845e6291a719dbbeabed705c5c02e189c5444eb21be24358d4ebf53902c2d301917ddda0a4d82774aac899faa9f4f3a83e46f0cb44c3c820fe5fd1dfc118e30c74d454082550c301a92a72fa3189f76f8e26e98803be135ee5614843e11ec9a75b90b1e9252e85d5bdbddcb911f0d79a9e6caa2068c3e2409949f0496e1c40f63d8038cd225357d916cc04e69b28f907e507a0a08dba8abcd59cfd33888c575139824c76be20b9a3fc963a55043fc4f02bdbb1aecc221ab5a7bb566a58258d5deb83a9da4fc22e76207abd6d34331478a33bc331d4ad4f1cf357257cb14507e05d2451e3c7c14c69f5aafe0914d3c9ee929d6046f2741ba81086a0423da18fae2ed946472af96a3a673a04b84c6b19f79e9ee8f39394f93462ed265ca09f7e00239bd4ace01a05a34eb60dc666b87a09a3886b2eb1a308bf5d71c2800ad72cab2b6dd0243e8b4d6151abd8c53dc52276c76c80f1155e1f2e78d830e76c598f3146a8c9da9b657089ddeaf842bbe9711ac57b77506816afebd5acfbe14aab885afcd988afd58318204f3ec58e5ec137874d81080777a357ca2893e3d29cddf737667b5e8a224a32c6dfeb667dd8667d8ad0cff1d86c249bb1977358ad7d4d7b77bd52c920aa08c7fca74fff82eb1b1f6bd227bb6f9ff275df56dbfd2aa7e3ad240aae42aa9ae27a47d8930ae8b6c1fa776ad981bc167db7ebff61db7b3dd1447b71a21f955b9109a6e5824ba74aa819c89628dce8d0f437f2385e006df3645cd2c04b8b826cdcaf80616e870463e3c41d51f195ee4f407ca6b822547fba6e40735075cb86f42cfbf825759868cb95e737e961a1e4fd85f688e1fd853399e70a6b42a6f5877fd7ecbc482082f380cf1a38c22f6aa142033d0f3db5f2410bbf48b846a7c46957e1f67498ef98fad7fcdaf6242e176119c94c3cbc24d1894e1c9fa8a27868daa9485982d3879f1423572590b07627a5a080e839025df0a81a91f0394eb96026213d1594dc51f35afe384375c71fc2aa8776af7b3e027fe80d4f51bc283337e76a535dac713ae777cfd17f07becda56b1c9f63cf6db07ff695a6b754d8d1d5d6963df9dadb5d90cb81331332e0b37587d63e48cfb945d09c34b702cdcb57ae595cb0750033bfc9b068141f34d3f985b4f182da4b0b66733e00ba9911fcf9d7ed55f5b675880d8127f6a97968504d5c13b4eb8d3f3988ea268683b8841491ffb14de03c55a8a723a1b4eb302c60b73e1fd6aa6667d3083b8bdad05b730c3a2eea73274948600b75a9d0b5f197539775e2b6eb47427e7080c96ebcee2062519b0f63be9bb9e3b5dcb859cc285566fbf0eab36a53343d6966838d3c6bbec92fa14a8b6b2ac336988b9915ebe2ba1d4d30fc1f085d337c4995add78bc23ce7c8f9f36e5f9047f10b142ed38703bb867f36d2944313c4a6e0b4ea4cafab9fb6026b74d83520bd15029cde9048e8ce25b9dafd43e8630a79df73ca6ed941f125c8fe30376b4da34a5a6f89e020752956b3181b343b3c4f18af889a72dbde327021b08e99a8db350305b5fc34b757c6a77a2e23160b1219eba272c1b5c0a49628491ef89cb76b435aa946384a756c13f981409641e03e6fcd0926f525a8f5a9571d1b71c192b021371f86dd1c11914533edc21a3ed7de308e67b15f4d8785719d823b8ea4712216ff1c6aa22b26a43a5c6f87cbcb85e61cce6c761546aea4bb99a5d608bd6f9a0cacc2e044cc79cb10322a124c9f44c600c37e6ca81df5f9e8ef422f9fa9c4145173c6401509309bc217d5632f9c5970d60e2de4331e4ed5e4ae4b3e4b43c44d6b585db275e78e01167583d35551b1de6ff5d84dac088306cc9ea0c5087fc4e5ee3c04c939e96f271c0a2c4e8c6b85a8576b50f6d1bf954c0d2b5d34f6b0a0833d4f18715081df7472fc31aa4c233213e85474788bb80044881338939565c0149109b60a646c6f76d930443812ead1050663305b1a8f14ce61a28d94ee49edc08dff29368142445f382190c648222b172a0a7048416a5b4d35faa996217400571a10d222f887f355360f341e86bceb5bb1c5945ee7a6b1e244eaa0b69b1aaefdf9270c832c6bf76f91f67faedcacdc6813c31c4dc45e5408d59c90767296e3bb6ca9a5bb92ff2498957bccd413ce8fe8d92a4cbc55c78ece147e15a0fe444be47adab2c8831e2dec69db33b92080691aa3a25fba45d2aa6bb4c866b67164ea68fc538b8a0a486371a191114d3084ab6041deaf8b2f646a384a2d86df34e1f0cd754b74611e8b2b44db897bc72deefbe8fa4928059b46e39ea80bea38dd8fc99b5c7ab1a10e2d00cb44ce05a7be4d9d962ff1befe103951e30c02b07fc1ff49e9f40c89e0991b21bb2ff381119ca132912a1dee4adcf2b61e2c4148d778546f03ef600a108033348aa8136cb627c1708caa7e9375ac249a6a87c50e6d0290417d9e0ef1f4c241185bca4a2af837fb7eaad0c9e3232059762b1f86cb9246bd50f972bb046822352eadc8892db158bc8b1314e18cfc217eec6cae059b6a8c535db594ab890a50201ade445550b2ddd63b01fe8814321273fb3aae23e4e2e0e19f304229cab973e6384913ee8e5d5ef2ffbc7a5d419a36ca42ca652d61e4a91c65493023db277d17aef0907f2ca4d17bc2e72bd4c4d940a4e014de47e4efd5356b573f69fba53b8acdad098163894d820275626a57b83544cec964b5251db7f1e97c379e499b1abe84f8e00c9c7ec4164534e57dd9d5c6229f2a29d96468439bc8865bb63054f61e2333d63d6000fb64f9b39bde6e3d6f0b4c7ce2e1f342d4f4b6509a4c7d236df3d0d7ae7e05bad7a619b734dc73064106d076c847eeb5712061787550f41c0e5ac143d3eb6b339ca15833565cf739fd22cc19e22d63b0e31df4ad73415156017ffad3b4835d57f8f599c338dd0f6ebaaf023663b1a1f794a52c9c923ed197a9aed6f339ccf5903f7f4a48171236d02461ff531a9b36ddba15790a698600661a330f3916205c2caa4e73475faf54a4091684b848acac6684773fadc033ada7af77fc561fd652766eede782cd0f962435ae7c075c9815d43768f28a4bf016755a2f57bb09369030ce5248816e1e4f74dcdc5abd410dab501dcc8ab0f27f0cfabfd70e0fb76044a4a39fb386ce6570d5322b199470a029f3fd366a9bad7529e660f9e4554cf7987bf4011dd5405dcfb83b47c1723a89d3b93a28480c2af8b77a403195e860aba8e7a570ea3b978a82896d896a13342fd9bb99d4ab1ae02af10dbdbece45ca3f60670801443de72211364a89770dca4d633a7002362aa266654699ca512eba3c306a077d0bae2a44775c4deba29e56dcd843c301bf8bd1b38c26c799122325b40e6f88b278c67a7ca4afbeda87ea094641b870d01baabc89e00ed4c9d74d63908c5bcd7e22ddbed346a59c4ad90aa7b22ce37dd29ac0ea0f45c36cd0a2fa3523b782812da25f29b84e9adec7f2cda2d6450af1f483af55b48c88ad5dc299728633d08dab9e990dc8823f94cc1d8e22a13b16b87eea9deafddc26195e7447b1f3283e7f5a0bbec6dfa66bedab177f932df21a1afd606cc098e274e9cdef9721126c322ad0add80e8a28fe71b6740b70ebb4593f5a4be5c6589a92cb87d4745325afd162cd791c826e515ab1b4aec0bf1449bc856027090f1cfe3a44b5b172019ac8fe41cf43eb90cc8f490d0e6d746d14a7d3398570c2b4b755c6237bb77c49925556c3fba74f644db53da05b969e7ad1c322cec1b134c37ccf4429a302fe330e74bce62f841a06844e605198f9b8d8af9f79568021d3873ae7bd36857b47f3ff98a361e8ac8b75d7f824a7d738b0745b86886330ea336cba738974430cf65ae92a90751db0e4e077f38030d377abbe96414f0fec8df34c4825fd568cdd97d2430ad8e18d2cc40571d8ba7441ae7b9bc1a4aa85de85498c65d7f7ad613bb00211cfc68114b7ab8b6268d543205d4361f3d3e36e050f6db6729cca1a425a0d0c00c794686554492b4c1f11a4570e42dc78a9a33e82ce9294a022b9c6ffb6aaf29c3d4c404ee33c0fdca01abb444a9e6cce9ab693f22a86dd1957183b7ffa8151932f26f6050812a83dd482c162b5709ca92e6a3f71af3f20dfa5273374f7cb74783593b1d5cad6a357abb5b8acb0895a223fbb51b913d1018065f40b0709d93103e7226bf44c6e76095b1ca7764b2a2506b62c482dd9957afaf54bee4b2dee6a102dcb5848a03062859bbb38788060d866be4304c6e4177376c36e889bc9bcd79109dac1b80e8e7423f88e1ab7e0bf53d1f3dfaf723cb938e882f9280b4cabf8421143e0a9424d9ae18bc977beb8fa6b3eb7db310a3bcf1d2092020df3ea5438e958d0f1350ced906ba91484d890811ba0293b04dd3bc80a07b1d74919fe01b9e378aca3a1a83b9c04d0162a946f307c233c48aad95688b4b922a00de62608db6f8e83a281973c22eb885d72b83608154011e944f37787301aa4ec57a048f8cf420c3ad806f1f727bf8660e5a56d01f501e50921fad5a114f7ff495fcea090a3e1a56496b9cb6688baa8194de265a78f3bb452217c4d7a3ce83a0b45415941a63a2281b7eaa7f2b04567e166dbf12f54a8d286872dc6f80435cb3a7c62118d2d92c008e81d15f3189ef45613678951fb2a8ebe1b0e968ac1f0c9f8bddc6bede4a125f860ca517e7b915c7ad9b4e919756047ff60dec0a887f1ee513d21ecf0ae486d302121f79dabf33b86b74deb4e849a3468d77d8f192246932489a27fa321185ec02f1b6fddf8e642103f38711d13e9843dd43da496ed258157c2fd76f3b80b2fe6c706bf5cca492d67644bd96cf3e203ce1947c6ddd8753ff66dbcad72561e5f35c5f4b9c91568bb2fdb737f11b8f41c04975e866e83404e406bbc72025d140a6e8133289da42db4b81de03a09fdcea2c0593617529e108b3327ca1021b76ceeb5568bef7b94f33ce393d182fc85fcd79dbc5606b2668c3f9cb9d67be02a792710ad851994590935f9cd12f59191f3d1eed01dbdc1df6e3222d9e600d5b528f315dc7b0e96f2ba9070ec9f101c4c3d2d3b468e2557e85f7f9367ce95fb4fe861a065fc8034c39323deebb9ce5bfeca5b4339f8348d8360c76aea6d0f59fe2bdbdfccc96214a690edf816827f35ab4313179e5bd236d70ef031d76fadb8216d5048a9dbfa1a37bff999b00b62888699dc943c96365d061264e8634ee8561c0e2e1b15867201df72c23558d1c901da7149a034a3a015cb6603ab3493444e9810cb5c5cb82221e9bbc70130963cee8a4ab3e9f073581ba8274cb07272eb101a3ed55af7b9587be4c17267b510bc05cf13a5baa44ef304aa10e7d797bbc7d4dcba3abd371d5731d36eaf683cd875553c48159f13301d622dff2f70c1e5822d8b0a1e267d36bedab568ed14157643a93cdd50d05f888569dd04383fba32f5edad6d6cae37cada8d6d572a209eaf86dcb8528f7bc226aeec44a3206b655055ee1e11fea88bb32cded0ab19fb317c5ff70dfb816b836cd122667e6a34eb3c0c385bfcb729b4fe98dce0ad4a964639716aa54a29713691084da3f903661dd933e279d49ae4bcadb3fd34270333b4cc6d81d1314314a48d2f71eb71c2bb854f0a86e8275b1501b53930c2f0e3b8b74f6381805ce5cdee086b0c629bc5fe85cf7574835af4452c5e6cd081c07758214a14172e2196f66151f5dcd0083d32f1883e49a3f164876952fe90bdd87fcce6a6fa8828c961d0e39061097c8e2748b4331af36f1648136db3dcd9c0cd928fafeb740200649639a48608a87b2d0c5c18742134e1f83399df4e5376e32aef9a1de837ef93fff76a09feb38c1994c96ccd7fca4a200a86620c83a9584371269cc192cb6369e694a7cedfb46a095cfc0127de82e3d4c3bb9ee79e1a5386a7d34a244a96f587f709cd31c958dcc0de566e47b63c6dc4a0de7580e5ff260ce4e0a15e150f84e3c908626def0a1ee73655a929e65152b664c95c3f21fb37917f0201c9cf7a4e63aba06e16fa3b2ce2a65251984a7b7808200b6112cb0e2430d74a59deffa5949736a7e69944720971cb5089555ed07fe3256168d727fdfbc1be0e171b1e228601ad6768839ffdabfb25adc16d13b82ec0f6530106cf65667da73d43da6f1275cc1a65c17dff982e73779d77cd557c8357216d571574f0b2cd0764775dbf2f4a35c1d6b36d57330c03b57d493fed87a16c26385cf6d617a8596306dc964b9851ee0e52b0e122f5df35b0f3403c841c4f57a5288c7a1003eca2459392a9d7097b9869881130dc3845a8f56bab732bea186b8ed37eebb108f2c013da2c8436ee6180c73bb1d95d5a0b751ec943e1d4d04f27d12ec18842dd8971982b2cef2220d4ac61ecc67b166e9245d2ee7e9ca1abd9162db39b229842db987440194c5de7b01546fa13ebd05eabc547f26ab66c5926808c416c34ed3d30980bc43dc2d5cc985f0c6465f9c7a12a924b7e5f9c81a140eaf1c8b0ec39939d429a11ac5e882dd29928e596fc871eeb4222c861b14b2bf7d9c6b4f9a296b90d0de23a8549d5044a9829f648e1d35d4330f3ac40399c5d64a0ae99631b66a069247f7024516fc105d4600d6d9c3f952c07eefcf86d47368cf02a04cbaa921ae7823d60902f0906e0c5fb78e886d3addf473d5a0d1ef592750ea83e4b0de5ac1cf76aa3496420ae31d7b619d0b1004809959a82c5cc0eeeb0ff9f9956916102bfad1a639d1749d4fd1bfc093d1f7c77fc5ed8bf52664d617d91c0edd31ea6e75b7e33e53b1f328f2ab072faf2a01774979e5365af3fa3980e14deb46fdca9dd0424b28df4ad41c7d4ffda3e4423ddc0d8fc3b963af16646cafbfc5876839a0c167cf0b4a10e2e211106af62f288a221e689d644f371799cf95f8d408e9f36c9771da2306039a9564c5ce9bdf211125a2b86af1cb6708d857e01bba04493a93f4faac9d196bea0654fd9caae1e64b49ed4845b2f311c35afde9f1da1dd982d995c5fd4bf789fd63d5c10e4fafb8ed9cb7f3be4279091f930901877deac9d9568a02fb17ca9e2e5e6ab2d8fbcd4c34ea3b3dffee5142551987757fab73beab4da2d1c90035d1ec6c964d4dcb74c7f95e09828c3b1783719e921dc5b52b118d14c360eb48b6d45a67258f1b62a594a5d837ff3f3bddfb32f83b2d4fcf2117a261b3962d9ed7cecca81742b7c0eb45b96f1a60226300a9edc0f6e01a7572060ded621355d875be6c4e87facf8c91ccb8a59bb2edab2356a1cb11b94aa2746455ddf832b78ac56c5fa0e23e265ea64fe390208e6462b5cf2fe8a436504c1c351f57ed4d47be3dcca12110a50eaa0be31530c534f2286eaa318b9fa513ed8d5c93b93ef7ea46eeb98842e5349f71236a531ce1ec87dc25ca2a25641800552922dd081b0da5d903a9ea9a083bf6f9f85046493bc6a2d2c82cd2e8c6e563e5c22be07c8415678789fb4d0f4f505a4994a71117f0a4b88c59dc72ef17888cea456ed12bfe3cc557bc2b46b8e1348e2f8487e4f323e11dbc3a49a455533104fdf51df742675f30b4824cecfc3879962b6d10f76d69b05f701e27cb3c176b695633ddf1185a0ee1765c32975d985f4f990e3bad6a3d319e11bc5ae0afa9ee6d8bfc99bdae0acc0730569f27e44848d69ecdff31460d08a231c734a68dc6193bddc4163c7731660232101b1cc13ec1a6a8a472884b5e13ba17262f50b5c9875a94b6ddc21a97025d152d5acf08dc458fdf33c2651fdfe0b599c81e0327e640cdca666fd27552820c1c0cead72078640ee23c3cf29c019e175a63bf499ca6b2f567f0c6344574800e9517f0e51c12801176875462de19de56adb3b9823eb2be8d99c7b8889da80ad8970141b382e6f841eca7cd67b295ff8ac8c8b2dd8a7847f841e92bd2776ba58f9e7b30da01fb8ad2266077ca135bc8ed89b3ab5537cd6827b3c71765056ee3cc78e90b16d5a30ea7fd2eaf786b891de382f554e7db6bfb7268efb3bdb5268380e2416697e7da07e56c0c47a89f5dba37f05729889587c30f7691b627fdd2e4a46c13197f6d7aa3ac5ba11586440f315f45e8e0677c1d89f28a2a2cd783b755f37e6357ecbaf8394551cf34d54002a6b29c2bf4b19bad04c5e0f84fadf5c68b7a6532c065e1c21ce9313b6062b4656c01986f524dab99a455a333d6e33c3c337aab375fe2705f8470f0a376f0932e554a7cc19e94061840189a632444484cad144f2980f96767ae087298a07f7e6fe4875d8f17951a3133b1e1d8f4a6d1bd7fbae27c791add1de32c927c6fe98c2f1e175fb456c7f904f0770b313dc4af566aad86fd832e8472b57fc6f0360cbe967284c695527b5a167f120050afa3ea146135caf5367f9f648b576e2c2517b2a053c31e06bf0c6584436121fae5f2d75a746c235a04be04b8ba1e8a251dafb8efa5f73070dd03cc354d1ca7253743da3b0c8347b1e8915cef702e5e8d016afbcdb1a44d1fd0d366dfe6a02b876b2ee863d02ee625a8c8fcbbb6f305650141c0607723ff25c72b569f70898877dff4847bcce74fae5024fad6b3073675fb8d15b5de460d4504a4199827628d034d5b9058568a529366f982ba988a9759d2f32ca5836d57fc91fc775bcd7613e7dc3e64ea42eb062f924961a68f0bbae3b590c2b756926618fe63f64ae18bfb36a8d247547c5e3c922706ad330e9e4e61c207fb5c8b35037c62abb0ac2592ffe7009f9c4e44f7f721d347c7f341e4bab667be93864a77518c25f57966e4b528a8fae8af16b7cc34d4ebc14f7134b398946998d15f3992f0f78adf68acc976103d2efd4d4f8d2c0cc9849daccd287bdcb7ab4a016f012d275e4fd651d7ca74027a395b27a23fac6d47466d1ebffccaaa554879b696d2eeae860c5345b9c58f7943f92f6f6e710d311c2859d659bb3d6d5c877d53dcc6831d3e06f9548170e0cbebca6aaf32a8f6eb94be2fd6961b76493ee50f83c00eeae35261d9978a99593985371fda83e8e422cff6844dc6bc5cad8db9e35653f4d0985a02e4017d6d947cbf424336c85c2ae076076b1f175b26aabc6e5a3ff8ffe44fd4fa417c167086bd1cb4e31a72bcd8dc2866c312b94eda25a7ff44bc30bf7905a33ea2e5159448510e53e096909b83569adb883d0f95edf58ca0270d67432c50d875061c49130bcaae5b82f330c89f6ba0d5ef11765c0c5b411e7ee15dc16701c1d930dd849165e6fb26118835f4ab18b14e289e68baf0f90b8fc06209c126027a9b46a5980d5ac30497821b5b5a3eadf280e9f8285e3dcf9930407befcb30c386433bbc5f22f92a047d984fde19bb15e08583b00dd70350737b7e12708018492ce67f62a37b52eb5db73db112f4cac8b429b9254e74184c47bbebf4091c3f77aa3c9fdca47eb5bddc72f4cce33870b61954e94683612585e021bae47ddd77a5cc09f4c42c362bcdd681da3a3cbeec86306a02a6233c23e7c1622fb32fd2c1d9c545462ade521448a4662a9eb5a64ebd8f0b2129fb0d852da622d6f0cad6a1468c6359b9d67a4269828961aa10002f64b60f6fc9c370639f4c056067d2a2231869ed468bf2ab23b23792008ac33fe0232715ed31be548926d6bae225fc3c4e918a1226b9d8cd5dd11f2b594949d074c680e333202a79af616bbf5a54ba16b1ecd97f51ac4ac405bd799c23ebcce1cfe5fbb6947e630aa1f0b69234ba1f5a1feb6a2132549a63e2183e8db17df9de485cd9987215dbff62e30db280566490354689f7af83711f6bdd0b3bb1de14721a7120812c02c27fe826e61529087e9afcacfb745967095cf7c546c088bc8b5ae7e9d0756229ed3b60524f20ecbcd60133e5d053f34c7438db15c8242990aec0177016fe1d8f6e676d07cbdd856ab69c34df51c992e47e0722288167bed614dfabf24465b613eaff8811456a80e51477a7dabfa004e71d82eab32e7effe445e260940d25acb9012306a71d45ca38d77677d1125043cf620a98aa92b435df8dbd133b26978feae05381cedfdfa772b55d65b86e6ff1e852bf5a0daa7b582bf0113f270f888dc44491e44587dd73459a2abc2c8a67ac6f360157db48e51b714ed0497397882cdf3cfd1143767c790ccdaea490b281119bb54830f573234e23b997c719f516a02516fff8e29a3ab29c76eacc48b474a0a0aedae946bb35a56fdc804d415026114a23d94cfb295b3f6a9d17baf081c9c8b0135b27ed731362dd74fc8cef7c25d1b38c2e43845fdea0f885c5de90ea36a55c6af82600b13dfbe990bd06ce2794275b3dc3862546ad3837f689c36b06bf8788a40ab08f1340289c51165d53b177b254c317c5a3e2c096f4212eb334382587e5f2fb3e50dfec8b0fef1ceefa52fccde3149c9772042f34a795d13788396dd146bea9aa428a9a7098358dee703d791984d26455f78274d113404d5aaca41accc5221114edc5b7b47134925acc411b018cebab100b153b987c33a9c51aa7ae5172a37d50c7194b922c920a2ee9132e9e4bf72f0774ed922a3774fbceb9898682df28d66e8a6584438d1645d600dcd470eed67ac7af1f13332721a9c45a55d18861430dbed46406f35ae9d1e79c14160ab5a1d3d823b0016166fec9c2049f191c87a3b68bca3a2e56f0bee29474811b215b25d2733fdcb1bbb1f170f0515c3baa8d2e03e31d541476c349b3e85b2c0ea43e199be5d9f541c0fd93c3772abcfdab3021b8ae887161abe0f91367ef97a0a71152c2b0c3b3c76a5b771be82733d27be49a6807a42cf20dd446f3982ca71d19685a53c35517235c64ea64e291760af97bebfbdf63cfe31be237a31984031c43df632e7beac5fa690ec646ec7cbb580802a471b55c49c2b00e7ea00d122e263229393999e4220e7deef23bc3a8f681028bf55c80f083c305c477e7fb43ef85ee5bebc0af010e5b0b0a7bb7deae96bdb8152e4d79a16250c146f6e2920a3600a1befbe0b1b628cc890301ee18155969fe32e24a26b0849538099c79ed95443030231824c9220fc65f677fffffc88bb0a184091881f414b8b721a20dbe96895a0ff6f25b40565038bb133b0dd74ded43965aea305ebfc83756cd599b7bd7dffa3d71e704c27f51440837ab9af8996a220e14444c718e6dc3bb2bc5215c8a9eeaacefd2ee8db43c16996f2bbbe57e5b1b73662e85cfb23c31acc9d42ffdb285cc89253bdc506fba84996ef8712a4b90fde022683d3fbf550a2c51430e42636d8ff07238b690d0591c89aa70166e8ede31499b072ad5f84a36fe48d7ebc6edd6740b96ce910331054f25e6601a7241a3dec0c2739191d8b1c7c06ffff56f6dd35247ebe1762420872bd8781f02be742eecc0b44b50457626a9c68e1fbf9b302a2250ed2c453e22b087e57ac6679fe199291fcf33c1179b07968827bd09b43771a3920e9c8b5517b15b07fdec43d3bf7ceeabdb08021db71c102afea629d8251aa5850ffb6e4fd1773136a3f852bb7767582e5062b97cbf84d7efcb569b2320c6e1eaef1f79e8e32d803b83d4a5a4346260f6d8f7eb90f72af11daa74bc66d7b705c604940470b136fb3d36dc04d53e26c06d771163cf0872c61537fc3ea4cf2c042194ac1d8b5d5b9fec160da55a7655cedef573a3b07230c531a0e003509a911c9097eb424c33d87164693bfde0e1214af6ad59f2a851f8b8cd9b6aee9395889c78af5c377c106724e164697678b80ffe49f09c37a5c8cac14ee831edf3d0aa11ef23fbe6ef1e58a5eacbbc05ef85c413cd67e846471c3d90be67c1674474590977820d39b91645f7919fef4471e378621739621eeca54cb0073ae19f4bc7d93affd92b362045f0a59243a6b7886877fe563e35430aebd955488804b1a9be65d542d4c62274e2031ea29632ce763b60221cbdeef12718c8efc51570664270977ca6686772dc0d0303e705d9063bd3af688d1573145483ffdced1ea68e226119f940904e151e887fe72f971e817d049a9f96610e9072b33b2c36c64ee05f198392de97c663e6c20c5e6bdf7b44ccda78ab67897f175a10da30f1c841f300675859595fb0ed10e617a08e1c1ed7950a0a186be55cb5dea07f0d375c853f08550b28092fb5086c0743d3a38ecb50469d2ac316292b110eeda507928385f496f28be5e999a5dbef2cacbe3c49110bc69e83c121555aa1f80979c02e34b3aad3ce0fd1d74c504cf49f92e8c759d261dfaa600293e939458a88bc185125cb08d8bdd1617c1796c94a1a86e12cfb1e1be0cb1648ca6af1b9930988b7e5d704fc54c089c8f809f40888fb7cb85e1d3e8b56118fb22df84ee3c444a366dc4e337bc977ecb9717139829df1fbbd60176fd0dd191c65debd095f8450bd38ccf6318c50c1a943aef3a4ac082c3adf9ba5e3ba13499e5b648337777e1e60a89fa76fdedda6be5761b44168eea1ef26ee46d14d9e44eba790f87a0c8a4959c6fca93225da59658921da59e09e9627a4f3298441d2b9b79f609f23d941349dd904bb4a664dbb7c1e785dfde28b855594e54e45eaa909a5d7c5419ffb2c32f6dde71ddff0b796b2f5890fe2b48ace5531ff0c330fb019b2f89d5d4adbdeec27466017c05a5f405cb9f2f1ce60837b3256f6991427ac22e6fe75881971d5b7486aec43deca994a95a8311e6dd7ec79b3ec57685c38f213","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
