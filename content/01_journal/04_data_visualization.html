<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"324faf3bfd05c7818027f6cf23e694407fe5181aca474af72208d4c618d9f91d9fa73ed5077ed3e6ff16aef50cfd9e6987ebcedd641ca87de287c0a712408780a059d74e9a1b9687905228f867bac395b3f19598960974a38c762b509c99fc9d768f13276f58637c28e272124b49683b046f320b486eb173945fb215b6da82b47d10a618b5066dd622f834c6fc93f020d2030817ae83db2f5e1bf358a0a4c431c28ced4016f8f475dde39fe73506979e712bb6f1df480bafbe6454963afbd66ee6a475a2080a1d58f455b4240acb5baa109fe077801e05393d6b28fb88ee436e50fb0fe0a30edbcd8d50257598c7cfde333e4bccb1718ceb02f735b18fc389792d1295453b2beb284afcb4aee1b10439c95e0f6fd6a92a7166cf94b4aceeb122bef0bc70c895b38690860bdf3080d72949931bba2e515aa9b775a29de48faae5ba275e2a851251e5d065e24f4c9ceb023b80e32029f7d9b6692d95a555b1fee65a153575bc198f7370a3181dfddc289c28ebca59f612451defddb386dbcb290ecbfcc70e61cb29cfb615ee3a809d463eaaa503aef45d6318fc8be10fa21fcc3694e83ae3696744678cf1a4d018426c242dd4ea0955f1a6ac7ba8aa5e2e1fac74ebfbda56771162e06ff70e573ad107a2447aa66b33e581d610a2c012ea1c791ae40e5e553476953f1821f49cb0b08b96d7b27d5bb64542bef8ff1c96e5660c5e7fae01ec63f7ca2349b9f3cb24568f2655788cb1d5a1dbeea97c432f886e03c71b97690e1818da701f539a304a442b116890bf24351533ef92454379125e62e0c073c07e44b4e5902f3f6dab9d325d844fb799499b6bc6ac1548c3c05aa2c3ed2fc854873ebe9973377fda6a7cb9c3a5144cbc7974022c56d483ae3e1b7f8b89946bb14594597cf2cb9ac0a6bb8444a7168972a29044e1968ca7b536fc6e875deb1e365f33cf4e8a1c6b14842c12cc89814afb7c11b2761d50730808798528806924c156766709a57f0e40d493b1ab38c9dd238a1b83844ebb5d77cadaf4947d7f043ad6cbd065059fa1d2b6ad0506a9fe119f0025eab31a314b17e165e5d51dc3fcfcbae1d2fb4b9c0da55f9a4051781e21fe3da118b28c46afc71a301fff4104380521897ecb1afcdf140b8eab4137d81d09cb81cc82a696af7f0884a973919d215d4bc5d3605b6c9e42845b26cf4bd9aead8644fa52eacca7d1a5e0ee70d5ac830619c84a6ef336c4dbcfe6d0f8a592fdc45443983228f6e7358977454c12ebbed623d563ecb4e2b3bfc3ee6b7432136520ed8c1583846d81c1fabeef0fdcd79f865642b0efec2ac3d00af424ae531dc4271f2ebcab5aef2c8d930392446f8aa388816ade0ee678483fffb03192f76ab918b8f81feb8837592f180edf6098b4d3f468e9c840da9f16dd5c91ff07879e2db1044d3ea57c7ed7bf49ba1c274a34884133fd3b127ffa1e546af12a9a58130649af45ce4ef1fd54fe6eff010de0a314c2293cdf1cb60cf2b1669193c6859e0e8f7a029248357c5d0ce9ef9292410c982c06933e95c228ffe8141e939cbaa57386e640d1078d620ada8937ac6467788463c706284eca84d6e6f0447a3b75b1e604e33008c46cebd2869c241916863c400ce00d671d83abfbdf103fea02fb3ffee2f5215c909493782cd1a1ea302870c640d2c78476a7ff1b76de39d54f2d33ea3254dc0b8effd80a786df0bf9d0ee2bc3986f5b965adc27a74fc46e3ef43386be2ae00a848d37aaacec5f190f6ee2a5889d10ee26ca4109187eb4ec3515746b4b2096cbc41934902257b98fbc9897881babb21a32d55c994592a8c6e8fa1caa1fc2f743572152310da5289cc9fedc956b53bc666143663e880b82451d40cd3048123d342c6b4baf5d194d1cdeead708ea59f7104473ac56a773f76d62910459e46781f0396e09a2300a99ae6b417c4001b42eb35f06008c0b8eeb1c4e4c5825fae0212f409d50c6b1fb8cb15204773d2c4e5b4b5f418ffc4a79486b942e96134166e36cdba9dcc6cf9a2949ab54879e4e52a270a548e6d5ec68f51962110aba901f7194ca1247112937ffa94ad6dd5a4685d8157845d3516f02fefab84a559f9549c74f8008019ab9b16f43279dfcf7168bf77c0cb7a0ff74347fc7be884c396debd4f95956be6c5fcfccd823b3543fa35b76e6db5b2e44c736eb2cbdbe367fbc85a45cbc20b4931271a2f504bb7bc9d4a96283dc8378d8c67edeae313089bc6a8d765ffeafb57ff5899343a78087669482e7023582efa3633268b63612898ad3411a73f575ad05edf9e13bc8315a9d528ab76e9b1c9ee34a071665f9bea6c685aec674d1175e179ea5f1d04c098da3f7d9612603d07f56fc023d2ca8803a597ee02e254b8e98d3dfd25f353ea4710b1cadcbf756ed4b953f81e4024099be6da4e295966749f21bbd533c42f75c443db819159784d7d1022afdc419dd81bd0906bda4ce58f6d1ec2dc6d4fd092a18dee73006a0bf5dceb856eb962b0635176462099848da1503eb3e56291f40d0ef2053c22e8917ccfe1c4999008eac643c3bfa8fe40a2016104d4f1eadbdcfaa8cde036dd8e5a3b4ac9ddca519ce55d37af8e81b6069bcf935c5876cc26e61e25ccf9015da88c2de1fbf8ce032e5e483436faf6650560480834df4167f19616580a27a16c7cde8e3c004053a432af1db20620a7f4e107e932ff44668d1d252de5ed3736532f5b987ce465761f1741f29ef57b168eaa01f8f83a54cdb590026369494967c3c9d2de6257fa948274cabb7f0efa040a9a060454756cddca8579bb85054d486f07f1a8677fbb1fc57c76982e21296addd3fca271dae813575aeb3b7d3979a5165df96aed9605f8249833b164b2514ce9cdac85e7ca06052953bbe8a60827665c144bc083680031e2166d57340f660d760484c3adb7f24d9424d041e3b50344c98b503041e9e282de382007c36eacd417425353a699b25a6464baa1e734b67e17a09bb8541ed257faf6ea4fade5aaf329862e191e081fc6922a7d259ef8af0b38f57ddfed091997f8d12ca813c36fd3b2f3f0305e472d06a8120b46061c304cc50e82fd371eec5717bd3e54f1a55c17c88dcf513816197ef496adfd939fc3e2a28fd25bde4da02d2966badfe584bebbbd8223e61055a983fe3157a1586629a11bc9bc83cd58f0e578c4245837945944acee22e378c2b7bfd60d9628fa595baba7ea1e6c0a07c45d4858682d017d1054e57a4072e0e0455b0312516c5f0474756cf6d548aadb2b5d9507cf5075d7ffb6d46fa0ed07a9bae4896927ddfaeb13142426f9aded08b698ebff5bdb6367fa1be0df8b74ed8387b2a30c4f60230e44834acb199ae4d286ee2634e42dd3863f27c16790cb2bbe603d4ebbde17ba24b2c2b64bc378761d46e3a6b8349853756ac06c50c168fd2113dff8d5b505cfb23658bf3ed678a56747edc7765e00981a1a3d5b60f396b22c7b6f346952076abdc324cfec27902a8ae0df7788d6015d668e3898f4bfb288d130fe506df5ceb25ef711425153fbab970e648a7391a972147f67b0584f499e3a6efffd206e61e157e9ed15819c72320fe28885bac652d1bdeccf3e69549a88c000c68f71aa53c7b57f44cd8996e6adad2aa930e99d677d375e809389395836e67b82f13500cd67b3481b430058723ccc42c6aa49045fb934c7b87c41044ac912981786aff8c3224897ce61ae530f734f5b3924d19f53e1b1d5dfdf0471bd4b8b84fd0455fe098812871c5ea9ad64b85104c051ca52c28bb54ab4898cba2b3b88c3107d406d1a2974f158d601a45ad9d88312f9ad360e0f9e402609e029c6dcecd56f6bd195e3f6f51007893bdad1f9b1f50497cc1ca9b52cacf1d4c71eb5f33da4c067a37bfb4eabae7000e39ba3718f5b8f89154dbcf7c8f1f10179687683c28a59b7176430782f8bca3c38961448685f82f9eaa1e29df0abcabf3b73403be705fd8556c608ca173b513879ed6de047c4fa2797578416cb1717d241910dedf4429abf8e9fc4aee154e140073404255a634b14b64e52a56589e7b0fea9670c9f36bfbf4220bef8086c6c88526ed9f2e7e0af4899124b2db947f91f1caaac4dd46e5d8faa03d96c00e6824b0a7380a2126943410c1e6402b0dfe984b0226d7208100028edcf4ba9e608fc08450fffce5c08ae4bd307f004285529bab387d2593c7cc244e64011ead1e61e63fd3a236a31e4e587151bcbee82b090ff286300f65b6e32f85b4902cc5b7eb79cd8fc72790e1d403bdad48ec5bf00ecd9d366f64be63064a98f58fe16247cacae42a066a363cb0f3ca67c2527dba8a33f8c9ba110f8f5f69be22a8b44baa0994615d6c17108807aecc01642311febeb599be281994aa40c4abd25611cffc5631a9bc1a8e8985d06900b0e534f3f6da98f353fb3ee399245f2c0bcbb0b9da5a374870fc4193805904d1a7bdff42670ab008b5e0e1e3699bb573c13b16adc87a31d8fef14c04ff72261b6213f6cbb0353cb72ab089bcae8295022cd80d36f5ecda3ada801a3dbc32630a5593fda146bcfff3aab0496b2a6f6d86931912b3e393c4ec5e272722e4387ade11b42d96761f3d44301a1e3fea0f167c076c6e764cdeca4b84d1453ff6cbc018e726402ebd7d9324c196b4f501ccab377d352bbd6daf10e0aeb831612532fc605b8907dcb420a4ddcb8850ea111a25e48ecd1b617bfcbec78f4ccaa4e8bd890a145f9217ebb877d1dccc4520fb952c8490d5732e4ea1a5a8bd87cea69cb88e53faa3256cd50950a004922fb3c9d0d51ab59b8717da25940b50b5c98e6f8573b81cb5214b78c88a3489ded3b44624209a92aa48dcd32489a1635be2518ab6387f5510d44d0091aba77225f313195fe5aa2e089e8b2cbd84265c9f110af73f38664ad94fd4505a6fecf552661c9cfd17f0f98b4b68c73fb43577ddc020ebf6776b3de3cf20ed79020fc9c7afd0205cdfef2e703259816b119c885d6f746938525dec19bee17dbf153d24eb8d7fc5ea5960a4f363d3687dbceb398b3d83a3fe5cf42970b5b63a8cd6b874a5686824ecfb0ce55a274dccb701bb544b56de749f7878e89e85acc4d6021c8a188651da7f574543d5ed76ae73d775fce49640c5632f17eab4dffb6b46d3d2a0ec5d600311247f869e1b87d02fbf284eda923c7cc70b4c9f0dbb0d2fc0c387ef39e2049c93663df953378e7dcf3b57f38d74574134b66928bf88d9e43d1c75609beb9cbc385e7f7f1ca4ea91a72515be12a892da52c4fca369bda70b46967b9889f4815e08421ec0b3a110edc5da4e36a7b7c267a3db9dbb616fc84d323e13bfbf281b094856a3183418c5ef7226df2bb012ba06a58a0daf7fdf84c6cf871d58488cb2b729904825d6da5628013ed0d838d393a197046822a7ffc8698cf7c927a4b69fcf2a3d53694f4a4b33385d013fbe025d9757d2439b154a2a26def7ad93fc94f72e7c3a78805deded155ccec87ccbb0f229752d975c8343e4d6db9e4a5088134c917fd5c22411089e70fa0fecd91515e33b7923a5deeba841ac23fd95df294fb39fc4a7eac50ff70f4edef13820b198b9b11993d015a9bd2751f3b0b5e5894ccf6d345ca3fcb60cc75e003f958d31319244a6ff8bb702cb1b86f9124d4d6b021b5be3a9a4d0498db8220c597f7a9de4b36a45388394122d886818a08a9c892328246d7db23c5f215837ff4dc952cad8fd13b1f5520a2321fc4265012d95b9895674870e3cd0687527a749a34f13d102bd8e3e3c2a629a0e7774b4125907423364b6770b3f258ff09dfaa40793e938c108b0271584b7f110365ac1b0173f86684056f937956b5e01c0a5ae82760e2080d787b55400cfe23faf4e4be3267b3b5d0376e39aa829e3abbe272be03007c06e41d46ec5c1293de18276fcead4a4a9df7fe33e661e041a76b695430cb084fe48eee285c3ee0b287ca6db0fcfd60ad5be43755daef0db99af9b31307a53843e3493415b2a0333048077ee94930bef13ed28b20c430eeae38bf734cf1a549bbd44b3bd33959a57e4e9ef094d04d05e57f57443e1c3f1074a0afceb26d6ef3b2d732300ccb9550a72aac87ae883d9aa43291f44f89f0288fb2af9b05ab3fb518a6605feb029f2f4328405c2e0926a7181fefc15d794e0ee88bb36e5fdc80391e9b93937cc6792a337ecb08673bcb2adb8ea36710fec4fa92164cfbe844546911f6c2069bc3bcb4d36f3ef16ad88a56b940818a45026ed3b8a21570af348a7a9eca14074ccb9c46db98af64e4158921805d032ca027c359652973e43e50553638fda9d38607d1e8f2bcbe69aed04975f65d6a477b7e561bd1b1ae60bb68b1e7d46d40888765cb6c6470114bcdd8419c5b925850bc85ae646b1606058fb2e730bb24c252046a35ef1852fa0b335466d3d934636798f5ad3a41fceedd097f4f0a43765c6a2d7e764dc1d51a8de79b25d2962193932bac21de75b32c495107fa5bf3e634b976846d5196e7b159ae3c55e98132d9e00eabd685aae6b7cf9093a4b1bee97db664b36aa4ebd3b584c6399ccb0066bc81678fdce515a4b470a1f5c412d975dcbbe330d3c51aec503400f6be7de7174156b248470d192cc995eb0e30bda5a102c5f6249e33503dcb788f261f66a9865b26ec37b3d60a27a0bb39edba7004afc00e0120541c82f2cc98004341facb7664f85a155f0cee1d070c345f9b9b88eb1c164b976277e38453be3fb8c10754ae1a28f6ab7ccfc74b5e78d3c6a3c4e28048b9978f1495525c57952ed7fb51f345300494ab513dc3dc6ec34200f1ce04c7a9f2ac1dd489404427e72e1f2204ab5efa066912b0216ff48b1a3644bf8899aebde65f7e266571b4266af61fdaf8f91446ff9abcc9a6db63d2d881a01667814b9b8d0602989d54bf4db86fc2514ac3357bb16ce7554f4156549ccc606fb1cf458eaee79dc9ad15e68ca133a2cfe38ea26db48420fbf419db78eda8e898153cc7fae9e767b77d4f9fe9c4854b7466b0bf9f6c52626cffe3b9e348dafe78f24ce1bd6f9d0a158321442f73e26c9f935de085598bda0a9b2d86aaa811816ce0e2892b5d7653229981d0b7b64a91e28516c76dbc4146e7c13ef0d8a2526408ea1f7651fb3d692d287d25f88f66d50d4fdb9e12a1fe06c46576174cd790c15a49f1181d5110ecb38fe6b3ea000640154e57ed3271ead5dd97e95a091071cd631fae69cd729c62c5399de16a9be3301580c6773a36c84427ef383880de65706fc1ca7bb59ea420202ac6a673cff12fa38f49e5a7772e0e389802cd16a6b5b12eca20150f6e0927c018a80ecca6cd9bbbbf53d12fb4ea5d7c87ab80d28f823cd70d2fc396059660d8e3638f3a208d5a3a793fd05b017dbb4d99d087294e56254e46cbb22e80b0eecb060d40f958595ea8b81016d6307114224254788959ce7f5e3ca7ee5416eae48db7ed0d13929c0d4bb418a604343526f65f43fc2846c76faa48e1a9a8e188fbc3c3a3a6ee5e7ee264998cf0d281e4429edb3b5312d302c82388ddd81a45a6aee7ce10402bd00daebdec91ff4726323c567b837e5c03c989cba9e4ee3c6a10aeffd044537a7c05c90eb49bf593833922d61f894a18c4a4d67180875e4f7edb8bb623ed6a051391d93d9b2a84dd9d4b1249c39c8bfadd8b07ebe2e08a264d08fcca0fe4808967d1421db09f6d05a8f3b2656e6938911d3896dd7afba4b3bed3c14d400a435fc76d03446395c27fbef62e9e09049b32a5cbcfe8a04e325e7f859668846aaa684acf1ecdd2326724e0f0d809ab746a4eb67965c02835c6480788905a2d301a56aee7c5c7cf80812e68be05b0ff5dde0ac58be78d6f28ac3a842128ef6d70bee08c2fc59c676372d7b38286f11c7eac332c3dba6a08761a355a6249c286e4e57959039cc5956cb19c20207d51ce7fb666a2f9b2fb4a47d276cb5774fc68d93219df723653f99331db6799f2eebf0ff19d7bd38eb1fb375bddd0a8b8978749c36513c3d055cc60f27cad17692ebd42803927d2aacbb89c5ca47019673ce092ce96e8066ce37d446343e80841f60856aa2e3ab765aa0a0ced413746c0f66abc0def66cb67e689dc8f8ed5cdc599a11d537b13eec6c4a7b90da5c89260669c89393461b5696569b7f5ea0f01db667faaaf86ece8779b5b1bd4f98e018310c7bcf3dabf9f4289f6df9f58fd8a7afe5b4e8ede25cc0aecf68c395caae804648caac1be6dbae962ae5a980d82ed77e7a05f55a556cdf00a39f894fde51e7b05d6a8b3adb509c2246f708ece43a56e0ca9c9f16ec7b9c8c1d4934267a03d40f1c9bf66a093c6d62431418638379cccb73adf006cb0b3c8677f560456f473e5463400e38e81863637e7a6beddc6f0c4490ab9c3447103991107502524cf9b29a182f46b566dcff3e2ebdbc579f9e5c4a3419b66dce3789d353ac282265d5a62a15a0d23eda0def760d16b49038e9210d3a0b3ba9fa46088d2d5803aa6c87103cc63280a858399e794445a4dfec54d2504bd1500d3d31df2599edf6f939e2bcedbd325de1104a841da5b62c367ed537ccbfcd50267db865f2eb5338b90a9f9c771d9fa44c5cd89b5956274f8f22f0c99cb799f9f6b2339fb260dbd07eed0b9c500b8c960a7379d5422519fd735bfc3fc61e16eba76ebac080a9f3aa2bff161814a03b086335787b6fd1d2f9e1e68a0a338c9d037f43f83819d165e1f5f10073fbba76f6ac5489935a0300cd26ad55ed3d7f76853e255a8bd6581a8499eaaeee7b7291d35e3872a9d85370290f66c2cf0a971b8dcc333a31526bef2914ebc8f26fdd46f864e58f838839984808daa095adf8bf3d2ea1f1b7700e6447179a1c670987814fdaa2f0a1ba4462a85149dff5cdaba761b50153caa0d74c1ce41d04da57518fdba1996efadd8ecefa6ac3e0dc2df1f47775882a305e49fab17dce2e6e9ca1e749dd4cf37dab9fb48fa80600b0d16c8bfb58e7a33f47f6e64636ea9df04513ff0274d71c94a381eb1034a8d890bfdcc9810721645e7043e8ec575107fe9043e4535c92ce1c93fcc6ea82459296fc1b760d04a69ec3bfa14d4450c276a0140b8076a4709395e2ba0b31b441eaba9b0013ada03f0bfbbac48bf9fcdebd07061a425320bbbe6b9049edb4d83791fb3af1eb629d572789764176371df065fa6eb8ac19d8569a019fb77b8bd5e4837570e0abb437e6183ad4b58e59453238b4880b9e3be87e09f72b5d76531506d312de5c9152262c54d4becd5e2df7641e659670b8a1398635ee7284fb6bb58a05ccbe1345300970ac35163485bc7837107c9337b87ba216af625ddf8e7fb5d1377b2c1b006532ea040073d089be3b95a87726897d02e73f507a3a59b4b6fe7781953f43f4a7e2eeb534e3d2e557c4d717a97c46686758acda396c30b4718fff64eb948ebe9b177c837639ff006c65aaad95fe5527ecd4dbfb32d4b906e36918b09443ef7464ee29869869a6a0d07a98fa83385ada6d4c03e9379af0c07f5cdcfe4f0aa58ac72905c1f5c74250b26d801acd5b8a1085dd24a3bda006fe0371ec339233ae3abc7410cd253c55d13ba343cbec2576c830a9c29de5d19fc906f211914083909a73167764da022b2f9ea1bda0fe8670603867d2a9005582124aeb688c7b24bec8b0a0505ceb561dcb006cc858bb38be671dc599379d03f493028264f3f70048ebb9dd5309b6185b081d85e4ce686a8f5a2bf5f4ef1f803eb552a589e358e609d231231dd8be5684f1792941ce8ac21c91af761d2a54c795bd5f39eb0bf8c9418f00b9d6dd494ce65a00a2c5066465eeacf7ef980c14d9f7794ff745e3f444ca93e4b77ecc2aa403d0446cb595b48cbf59723dc8e4d32d247c392a91de99570ded4240b13863b3ddbe2d1b33856ac62253c38ba9efaf84dc49189de5742af733e34be4a59b3359747951d96154b7193dbc6585e232b63ab9d9f1f04bcf297a37e7f7b8aa00c864a50aaf02304e780fdaa2c95a0b325e84f690b0c4be985775e37cef197503f85232ae49757dc412fdb11c5706de57317b318b7bccd5089a0d91fd3b1b59291f0266f89580055d5b164cc529120f337e0149a330c865eafb64b9f26eb2c7213bacce2ab0af563226d22ad67088ae0cf465dbf32d7eb0ca69612f5ce1c28754d38ab0775a00bcb406afa2b90eb36e22be9a43c749fcb288f198de29c0615337db93811dfd45d91c0a1722bf9d90203f088e63b4f413342044da8e87fe66bf86be6abcd4a3f3b35f1783a01ad64f8283857f74fed1b333eae4ad334e0e9e39de5f5a12a5838300b1a31ef1daf411582662e9ab7a1772cfaa5eec34f387796e63f714cbc1321480fe945c0c7d69febbeeb71229f92c8e8d4b14d7eed4fcc07c06f5570ea97a9d8e0a4d720d93f52f71693398744dbce4ae2819cc1be07662e194549a22194992dee1ebce1e0a76c6ed607b1497344595ed0a334543a7e14e1ff4987bc2544050649ba963314c60af08451db748a0a1032a0cfb17ca5b2d5e7035715c1fb0f73d3438d1b658c319c2c2dc9ac64a40b8fb6a9412fbc23edc119dff720a80d26eab936374d31799893bda2866f7e4872a38b983b6f4b77574cdd21f270de5a0283288729751f406c26a93beaeb70a8a822c98f456669ffd50bb20afa91a83d30a874268e03953df7707289c58ab86a8c9cea610f0be1c91322ffbadededf9ebdac9d1d039f0a5567841da3183c675230496b6ea94926123c24a128b997f7b91635c488d71025f97f00772e636e79dea6861bdfb9aaf9c297c88df1bf601102ca44fa32f3ee6db7479cce6624e8a1bc636bdea9f2584295065f23b7f5feaab4c63d3eb4cda8d444882168cdd42c668b5b935a7ad28e08907b5e1574c21cc5cce7a23c85f169a9c7412c7612e6b1ccd07dbf34d2a9b8e48c18c53e93b8b2ce1ff0d9a5542b949bd4091c5d35e7e636359656bba291acf401b4d0fe9ea24bb67a3c3fa29f71bcb69141db2d258978d4ece80b4297ec45bfe396aa063e06244f109f8ca0a87877bf35cde4090cabdb9c5956e432b3a417e3b523f59603bc9798fa0a500cd0143c1e098a40d92033926721384f5d66a3c1b17c1cd44c6523ad6c91e1417bfb93dfe65061744238fc5704c8b29f9cd97b66d3f46fbc03b541993698ac5efdf63a6e10757c2ede851af95e2b1df966fdd914e83db86ee46769eb06f9609fab423e068316f7c4d47e9b44f25bb1e479490dfaf6efccb41e998377c1d159f96db888ee3c7f0e03fc1c16e6d5f8c28fca40b7a6749de5cb3d7e0deefc621d413c9494a3d940ad09d0413716184665e4e05cd9390952e890a3a67ca3f15a103d07da86e9d41f7590f5ea38f21a39752e4fde4957f85d523cd35a606834cceea6c50b179f87159319a12fa75c4511f076f7d40544fe6cb65717fbcfe49b59616a24f810c66ee3e3219f930b90f9ebead84427983b0a65bb39dca915f8700500285d2886d7041cfdfe0488c505b4ea2e5d369dbafcdfccdc2b9c48077b4b4649295c5c7a8a2a961d77cd1c9970e2c966286598484dca49a4d8e4ce0067047fbe336424789b0b6fc5708496adc9b316745a7ca598730c9ccc8e07bec92648eb376ee0f2e0364b7206198e683a5ce0cd01eaf8b67ef425cd44bb748ccb3708db26fd4e318814607c234619d59980e2fa56ad6558f29ab9c373e1ff6b6b59f87b2509361c5248db6efd05b668b70f290fd2dc1c83db779ba7adcc41eb92852618b1942d4624c0401de7cfdf5a534bde1ddaf53b07bc9ca491d6ce95f4acb7e09fc7197ab116b884c5f63391337f7d0280a28ad41d13dd2d207ade41f0dc11ca91ccc8257fa4a484ddd4e41463e299ccf606e47b645510e9f9dcb602bacb2d956f7ae2ff37ded2c00af03bf112e11f4bbf99aed3044751a9b2c4e0902968980406026ab5e7939f77aef310212b7a852984b065c13338b4f054119bb75cf79d027e9abec69d264ad3d645c13ae39729a3ca0981fed76381a47fd3be8e71f157068f1380f9a938cddd604ee6e6c9c04ea8965ea6ce6c569aaec92b74d28d5a98d6ce03d00b925f37bb4a8ba3a62821a7a2cbd9c15bebdda05e300e1767bdd13233c775fd9678e2571b2778cabdb223ebabc409e18964553c8e75ef027a26911b805b9ab7ea9b9dc9d3d03595ffb715f84a38f67e62ec94480f756fb33fef4aab5b1538acdc26f959fe7a0fa71dfd12d62302d99cfaf2e5074c9af2b6d351fd253b6b72ea82d31839be29a390c3208bfdb3e546874c3251324835e272a5394acbb13f6a369ec13fd7ba9b4c40cb350a8af403985af2224867288ffc27d8f1e29a1b88506ab62b2b2d0ff2f87a04b348980d0cca6863d1c097f4fc3122a8793a1c23f183ce93a34e6db7d5041f7248129fc0627306af8eacce9011d0f7eb1fab82f105319c1bf057e28cc22a1851429158094f7d937cfa716b46044832d88610160d74189314d59b5523870613174f7380fb02a9411b72db82a7dcf1879f4a5e7ff40a045f6d093310e389c0830f2ae334e0d46c92c07554a0c97743165c85d5e4ee5f1a64c562ae7218d8c3fb42f8cec94ce382e00f19a86a27708ae2e018ed1dc88a6e195d4a8bdb9bdd83498ef441f7a914e63ea1848b507cc0f2263cb69fd7d87ab95cffa0c49477f313fcb8acbf8ae78d215e2db924441aff32578c6568081f62090e389c9112cab001fa6c0ea417699db0b0e1ccf573db3fd962e9f27446b815312bdc11a2560d95e3a3fca7cb6f6d59b1c1da7dfebb897c28265c7e3804585e7e21a21892b7f5d1f37a34a729feab86fc0e44700b76bda817b338b05105e09dd193bf3e72094a45fb062bdd90e64fb5af9309bf7ae259e58135e8a629ead2f576020264c7d7822161ebe995d1771917e1a972bf17f2116f0fffaadec6c50b00c69fa99022f16f8afc804ea8ea3b2c9ac215eaa868c7f4d3bb8d46b315ce0f41920c8345bb01f50398a8142f5fa77b39d04c76f727baded5f4c0d6118e47e9d204a1ebc45595f50d577ac8ae727b89ff5250bb50a1eceab32271efe9873944aed96603e6b5b95216144304abfe332cdd1bfcab633488eb6d8fabc9b16d8ccd9eeede0c2ecdded2885391cc6d69735f34dd5a08abe87242d9cd8cf32ccb0fa1e49e6aecfc1700f01fd2263ccbeb53474e1a0e80c714fd08a91f099a059c98896d2bc8eee065462bae1e5147712a2218a6646e6ad31a82cc9a0f7570938c58e4457e089bf6a0f7deb0b51cedf9f281b13507c0a0036fd52d46c1bff5e0e24c80a76b8446ebff4278d0472fc71637f10599801d57c42471dc6feb8601cbd4c11e0a4aa28e27e467afec3d407c9e78e3e0896526848d11b70c8a3381b64078cbc08134c396aa13caf0b21e229222bc8c66b044c7b868d9c51fc30fabee29942b11782172a62e714437da72caa1360adb0440726b9fc1c6902c562b37ac4a993b90e00b107dd60b8f2c4ce61932301d1da2656db8c31fe4b5f42d70d938e547e3fce94afc3594af4f9e8792baa96aacc5fa405fa2b43d537064a946ec5c6ea52965a0811d8b1db4922cb396712bed5d8b163ca16d7275c1d26e2e13c3c9f63f88799e5d60dc803e69abfa8b3cad5e62ee69769213e251251d114496e6dfe51e220c8a4f55bb44c6fab4c33f783e790344063f5d656e85bb546adac7e77bc13290d4a5336e35f82731c190082eb3251d35e512a7220a5923fd4e3b4ede7ca1f7297f1472c0d92e43a9e9507da0e8d0777c0f4755e74c475d07721e704d4a1a446ed564f567c21d8e769663d6b4776cf82c528e88f23582fd9f6600a61d6934deb72488d929215e22722d8be747bffe95c7e4305a6ab50910bdad744861ea53f001fb57e02176b9629711a6ac6d01a4243a979098ed1b846576e65db2871db966a06d5c17cac9eb4b97657fb39447c36566d8675ca2d6a90b94e4969f6f4d0c04ff1fcc89250741cb1cc198737627184e38eb37e734d23e7e90e93b664cd36b6e455cc53926aa43b2cd0f96ad1729ac62041c63069becc7e7efade2603b8e613cb511e9a16c1c55ee99151f16ebfa2963fa146962b242311ff666410e6f0ed558126d7ad868b0a56e798c032e1e196fd8f5c104d8006419cb9b1efa79437f76c18eac90b4def03ea9228f0c758c265b22e622c964b9dbc7a521ae6a882810293c01f1b319e4858b3b656903bc17c5e3c00549e4e147b01b6af640e3c67571550100d01084d3a84d9bab3e7d9119cf519e00999ed1ddc792b392f1009d3939197332b43f41f31a6fa7e200db5150738371f75dec3073acae9fa4fe363ba9040aee3e8a5e251864383314a2cb3798e486cdb4a5cdb59d63c18530b169669919359f50c1caf6c468fddfc186184958d58b6953eedeae440e2c33cf946b9240443f4e710609507785816d9ccb34b47441e02466203e2dbcb2281508e12485113103038f258feefed4002c248e56cc9fb1864353aba27030f8b3454576bb17a2a52b10c3d19e0c1e3486cbb48c8d2ec460177bf62527d785b8ed987db06da9faf962ef639358343d5eb31b53dcc0836ef170c8738a81739e2ce34684d7646896d1496c1fb390f2cd20e57719943cad20f1bdd6f850e4e7bc52721d64ddf337579bd1724d942928f5fddd883ca1be30f917324b958889022f9b205412f3a0dd108cfa0fa6d5c6eb405c97d5d62c2e6867cf5046709cb43a88c8994bc9cc70da3d1cb48573933e79a8ac27c46cc7b5b20c1fa64681bf181b571b727f456f9cfc11a1656e6a1cf55807d106392441a51ed057b64ecf02fa0f66126d55f0de4189f34f64e0c30c2346dfcf705ae6147439846b4e2308f2569ee5fc8d1df80c1316a62897977205ec712f08a0ad389abd7b189dced49ab325fe788552d7f4abaf827424b48ef48508a424df218ac72ce887180b15ea493e948869517bb5997cacb18de5a060162166e1ee3a272750f0deaab13bdea98b23d47d34b9d435d0e04d1127d3e6c886a09a21a5f5004e3de2ed62337e9a46faa4e167e3bf400646e4a52ccb4db0e2d6591d313f1c5b82bb06dd3e5e163dad2d6c99f28f1131ff0de1015069722d2806f8dcd75dd052a83499c23e42ab81961eca98a37158b70c413cf3288d3f78d3d7b53cf361872ffa57c4abc8c655c438b3217e1c08f925f41a66612799906245558976fcdbe58b9bf68d867acdf77dc0b86519f53408f805f3552dae2472edfd149270cda8f6baf82415fae2d8b5a2c75d1d6fe8e6daefdd2250b7e193165b622de58b9746e966d88eaaff88c607faac6de72e7a0d5254040504d1eeab2e8b4ffafdefc72178631e3c432af1ecce72f6eebce99a05c4a5b9dab9faf2e8204cf6de2c0443f670078658cf45402c1560d3e7f92162f8f6842bafa5cb51a900dd91d550f205bf51581e2a397d0f5857175715c78b66c9dcf53fcbea44c3d9fe35f003a828f72d62af94a99e96b1f64ef31699f904be2c6d5f06a9eb7ca0e3a7359c27ab26181441b709d8e143ac96692b973cb6aef347b2fe0919c507dcc2835efb61cb6a754c075401f406c0b6e1e22777dd41518cf2dbbed8584a5de4d98d948e4dc238b1634eea1a94daa7a98a7d1f9a7a1038617e5365b2474248f37c88b1f99518ef45e532fd915ce2840d1d87112bf4944cae5a2bd92d9364d250369801857a2875f0c49c1fee0b61abb4a1c3401b9b4aa126c0568d618435315faf7dd130d89621fc29fed6ff817b4e8c7a04fe422fca8364931e9c1d98136c14c13625f5fa9a3fa0b333cd9f29f22f9d3e9c2e6874e3e0710f6434cbcacf34f2a6aca5d6bc26139512a53821ead97d3bf303618e505be7613dea8923eda4b4ce027637bec66ebec2df707f5d97431ee5c4bc4ce6d967a6a1c903769add2e95356a5c9156bbfceff10387b928368f8f24548434bc5a4e7cd4e8339d961a59ee04140d77b18c5579e64e75903d44f99c0d2f6273a13dfcc4d0b90b9934d087dc1cb631703b125737825bf63e8e277e74f0e78fe60c8e680b190cf759454f87e768dd07d7c9a728888d7ea3540b96a26ac516e2e8518c8db05fcd6d6f622194d8e6ec8631cea4ea9e372f463e612c7dcf123a55ba3ce078bede66a7b842df674c7d154f3a2a7ed07991ef44b2cd00c71a346a7616dbbd89bc8509072a812dee092eaa3c3ce01b4363767656c9d735a6b38aa22021d695eaebb351cee0e102b3d780104720dece3499b2ba900b39fc48332e6522880f0ef6b51363bd6194a5b1fa994bf37b6c4fb24847000cfb631fe6c1b834f3b926ab6ee466cfdac7775075397cb59404d0752a1580741c010aff6518478f002ba5b0690e15b85ceb985cc786422745d9620585931b76a837231f06abd280669b8ead35b7f3c618c08a588800d85bc349ddb332b5739b1a079a883f54fd134e5f6c8c30ca2528a930c34fa2d57b85d17ff4558120271eb9589592c9548a7522706a502c658a54f78bda6f543799d15143926294f6125f8ab7c337f0cd8bdf9304d57b4b53d337db98ff37254b5d517441dccc7cd60225b784f7b2acf7dd6e6fcb6d409d997c04b2354ce6dfc849c14254cfed787d7d3c30215d546d0d85af3f72dce0e1f872be823465d038b1445d0c06746c6bd68ea91832a5c5c9d8de9be088703466db884a9f74c2b3a8a1c0750389b728f8bf9cdb6055adb7234d9b4770dd1742e75db83256f17b55a225495e361c17a0ea0c690ed9e1cb85ca7e5b836c2796da0d943a9f943edb5b19dcdded6d971e526f97ebf2ce43997552e9a873671ae6df4f4948be1fc96f10f341206a706d8872b6ed505cbe569d20dd15b7b62703a28ffe3243a09e355ec1ef3abc5ccff0dc157267f0c2d51926d304ee4fec7e2909268fe73eb2acb99ecd7520f58ca863bc2cb74b884f38d23578de31936e13720f021f31bd56e6fc8054572a9d4f24b6a65758599fa79bd64cca133368a346a9c563846845dc34f85b205dfe0d5376cd6197637124666026c1b8ac73da167ecbcf2f5410b61aece1ec5e7b7776f9c473f0f89219c45d767343450bd3a429f5b03ab4cb49cbaaa670d4ea79aa9d78f0c9b9e14ef46cdb234cd178068e0abfa59d7373db9b06a49f0798b9267ce0ee11baf49a73f2f0ca8d64a732401eda8bae92da48ac16cd5cad73e92cd7107cf85fb64f28b3b4ca3a2d10f6d1d628ec003a166dd61fcb55281b5e9a21236d146fd82bd668e75366f1828a07e9c0a6827cbdadf2d05a92073c0a7d980d3cc7de113383302000ef10524b4ab953cb0c733dbc38bdba475257e2cc2f4167a3b9801f95fbaeaa1b5dbb2467f77b4c69707a24b8ccbbfbc17b223d6ed72a26840430f2be689dd663362d4e3e553aba4df4f126a4402bde80a3aa3dbc353a18b81b076fe7b7381293eaafb6eaeb16a7c6e6e5ae8f80f987e42ec86930fef8768fe4d9942904ed0edc8f5f81d14a046ebf2ac31b5c0b9d96daad87ef79b789c37137574673857c7dc6362d89282ea125e09961ea9e1438969436024067232954b36b290acf00a30b95610a38fcd752fad05e2f1a412ac3b672f387a1022d02cac8e889e14f89e455d11be4c237f2c8fe123718eb4d0849f3f293a6e4761b98052549017e1d0add7228f48e9f0f4a2abd64d3beee1493c5e7d509cd60ac3e8cbc4fa58e3a48bcd1fab433bfbb641a19ff68642c1e52c88dc5305c47f85582e42739a60972ad6bca831cf7a5bb28b4f152b5ea5954be947abdd357d6b0208a6524d5f994131bd6103d3cca8eb67a7218c2078dcb2b4aabc318135b184014ac1d6837cefca5083bfe7ab7b08f8495df0779beb9cc351514a9210c1ce69411e06f988f4d3ae0607a757efb5445e394d26bbaf850cb3eaa9040a73b18c4cd469abaa0323dbc7eeb2163df310ef51ba79cccadb2712b644460ddecd458bb688ad1f99e58186da0f71eb66b059c17603de894dd2eea6f565600987813643818b80963028cc95594ac3e2f5fe2777cb84a7f534ab9cc576000b2c9e77e90aed12156323cb3aefe63324056dd150379385137064bd9919bdbf61cb6f6d262c20d150a6489adfd5dab983771ef280a241f00e9dc2a643ef6d4bc7f35db5c6d925e30132183a4f7dc417f2dd9d95606af7ab7a661a5b5b0ad0b94573be7340bf63cf4d65af4c8e97bb8dd91b5eeccc34e5fed9d1a64ad8d6a79ea9be0554bc95abc6b3c21af1e0f67f5242bd7bed84b56c907a6d5481a64b4862c6f57a8f1d5b8b9db2e7e5e09768793ecf181eb73ef7a8f0d603e091053b7b95a36a8da9c9f2ac74f5dac008799da49673916e4fcffbd317800691c205576e608e56c267c28ec16c6ea9256cda52a7081439bb75c128d42fc36dceeeb40de85cc0d72f9f660f6cc361cc2b48882a225f4f0535edfbea083e91d13822df2be1d5d9fa3c6f1377dcfc8f00de4013429cd2792a9253a34bad5af9e5556254c4c4e7bb0f8cd248e748e78841d4cd43a7d6daa37513ae8459d679483e93feadf40991b53c61a87a08b2edd2fd1e3aec24560b407d4ef9778b3cc83262528fe3d15dcd296e79c912db862241da291d775edcdded1b4eb1b336fe8daed900400cabb6f7d3b2b679ec0cc590a20546eab7063735f2679e56e9fd57ac4b5cc806fdad1f04d97167a8ce9befaf532e390a5f79071778a7aea6598adeda0e2b3c306edcc29f242fbd7af028d82c36a6f4eae70a34abaf0f8dc9ccf4d16211e35501521bf065cf3c58d84dc27037a0e9b0d86417fc0ec5c6704f1cdc7c9f230f6d8c0ff615c3f055e5bb493089b1a5c0584e5ed68a8851e923c9ac042ad39b2f8defa11c71db4467d100bce7f52acf70ca71f609fe7f365d57730036e5971373a10b718763bde0ce3af340409e6b6d3e9f9d87dea995d118446ce3aeb1fb08de945f4e7a6d5b491b01df51fd53e21a21e0f55839da0ce1e093fbb55ad21c8a64e439e15b45a32e34f999e50894816d06854f24a771383ffcfd8c3860f563cc9a93f234dffc648c5f050a78707d2b34eea1d863775b5b98a4a33f66e56d21e92e9c8dc06da5326a39630b729cc99248d2ba84ff2d951163fd6d5b7f2e541b0c9959c2d7b8564890dfdb177f60d2fc24e71e58bfe8c8e09ede6f54cdc74483695afd993b921819498b1dd6f5c2815ee93185c3fe8606cf01b8168b79381e12c1965067fc982e2348646b5cb02a68252e472c6a018b9a6deb2a59828245aa2b3f8c530c93d821bac3b814635c4ef07a860c2a9e264347287d8407155ee2d2b43e17c37fc8b665ec82fdd738f469d856df53082a3fa159431d3f404f4c73c1497ffe4ea2125b5550d295c941ccbec9531630af12673e6ee7435c4707ee229c4ef4c3680825041ede80a1c130fd78d94813fabc016c487d7a7f772c69ce07034f0fc5d6c6c6e98477bb8be6c5cae9f697122246ad013e04f0ba49b652cc3a219f7f3c7992bbcb1f95c44cd784d86f435e25315e6dc33db33e5a04c0a37f219bf72a14225afe08e3e27ccefb6d8b98ca58c3463213af743136c6291f7afa8a28713325c402c395bc657618b2e0f1a3e8779504b6faa1fd35e71937960d2bb4955f18c16bbbdcfd61886e669e346413aaf0da4a7a86c1d198183dbc5e957b645bdb45a053a2c6593a66abf128896459efb5600dbfe63d2a25d551e74cd8e7855d3e899e2dac3cf4f9903349a7204c59a376d045d251e525b6ce62cf915b8f8348c3b245d011724e8d9a67fefb9aa2a7a9e0679ea67561d21d74c5c38c4fe9d1a8eed245a6c1c2fe49c8c422860fbb1c335cf550ef8793ac25caf8674956fa42b85c024eefcdab9b4d6ffef07258258ebc47c3a6b744b5e8f7d48a0285cb91ef76bbc7effb2eb0c85875d720acb45d149e5eebba275ddf42729aeea40b4fc97197350dc3bd9fd00edab0445244f0724ef9d998abd02227510121d32e54191c550c7e4ecd44975dab757b681e6467981c322166239062b4ba993caa04ffdc3b30f073cb5c8140c9b69858dbf38796794ceed03c017b1c6239a703faa06567265cce9f866aefae786f90465be67d754139733f5936d46583faa0f75b02957e337d808f5e32ed5c138ef0143075d13213cfe48d1db7a112f3cac5ad6dd5c7679275baa7be8f3718f1a75496c43e26b5b8d2e6992fa2104e7fee106edb12b65800e9a144434cb328996d93045d8ed63570453f59b4e497a70f2626ffedd8c34f5a1aba4cc152c10bcdc7e6b21b56fbd57f491d285b4bd1e36fa09627e9693100e0fc354ed892165adbc331de3ba099d3337d54ea16fb461bef7767f97f4f9836aeff1d9d7740d49a18aad8405824d56a595eb5a745c14b9c12572df2150a7a97b10047882a4031ecd75d75953949b737f7d72f926e6198b25184ba2196517bc4fef200b1097e0b37cb25e6e25e85be16ba2b629d8f9255db570a7eff705ff2fc9239e868da7f63a8578a9e62686775682338593f4e280788038a7048e64f7e4b132e2167d396056deae4d2622152def73b89723f7bf37dced563476ef0ea2e35457ac342eae53bc788f5cb21e047c5d024f0dce724d94cf7d5355cd6545928cc48ab8c5c35d00d07a7cb5e3a75c74a1516bda9c7b654ca65e750508f7040cea5d26398fe4504616fa30f32c63bb6b0d5c4394071f6fec69e00cd84d99080fe99ab420b29d6c290099e60281a3032abe75c161665223995a46c986c7709d68ca9c614ef750598e4b27e3dc10fae72e8cd4094430300f74a3be0fa9a14875f663d64609a71593912a672d86ea066ff99cb80cf3fbc9732c9078f12c48b55a595524971cd93f301fb1b56c75b7a1c1ea08beb9f5d62714a0d6b613e43b2707654dc77dc24b9c7c51220dcd083e7aefa6695e0e1ea98c69f6476f76c0acd7260be845a1ad0b48981c49265baed9915baab223b3ad092b98fb59c850b2abde029f609bbe259e3e9519cba281922300336797e92f5ea86b2811c5c98709b6f3eb641a8e8b1f4af3a4202dcb8682a558c39e67cabdc9d2341454ddd4b0be85f7bb4d56f25f3c13c7afc43905cf6b1b50b6a327c00d72edc3449d0a09fe9e8bb52fc07509ff6cca03cc3c98fbeb9236dc9a0719cbc9b7d7df8714e270b96ad0afffe2a5bd82030e449ac6dae3a353645c9342df6daa0920bfa6c5fbefd4d9391f53450e07f45d9e54d0bfcf9bc73eef3fb44a88efc7a16725261d5b0310bdaaec9817a5891d6287191ebab2775488a7f541ec38875a3ac28e0aeb905471c9ec0d86d057328bfc7cf2d38cbbaaeb28c1124dfdeb9265e9b7a97e0e4f3065e6b73c1fd0a294e434cfb17fdec151ad99ed959dc104d65b8680dc4a0c0f56ffafc3e202f4055fe95dc39b6b91423ad4335cb49ee5b7dedaf837604172302c92f4be7c8722b4897ce544222645cbddc09c18f007f8924ab3712bfe7a3de6ff94a8d28722dfd10ceeb314573890355882aeeb6d9e34982d5e01052e43540e8c20bf30054eea5057a0497dadbc877c72bfa9f7db","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
