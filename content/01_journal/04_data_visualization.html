<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"bb577d37a2d8603a83232c6b43202a72e9d06130ab4bb839ec1dfc1d0060929210fce49bee1b07fea5be9fc73a4ad5f21e5c3853c2a091d6705d468abda259ce8183c3bd451ecf61325ecfca2b140c1752c316a0e160001f51b79ffa2bb81511dacb626533f578bc275dba025ddb94d4ca87afe36a8a07c05856155c99e9d12cfeb5cdf5e487cd2b50356b652ad4cef242e3479d85a719491982d205dd4d3d21232d720e3e13232efffd8221f0107f8e0f84ca0506bd0cfc4ecab2a8ef50c1739a0c7516196feff4ddde6b2e21a96f4473930f7491cd3bffcbd04eaf6dd186007799feba2da94c9c0d450ccd7c8eda4ac9e8ff7014ad7c9734297616f3487db33140f0a30d5988f1804be342f555ebd0c2b891955cbd144391663536f3f66b54560ea49b07509f5e606a5545dc515969240c6051917b69de20f90d95fc382094bc62a3b2a6df3e86e2ac89cb3beee6262a196f56fa3788a19e54bf1ca0bae8628eef6c0dedf133ad1f33d3eff3fbb441af54c0e42810e45357183fefc6a784b5fcdad2c931041172b33bc7d048fb46a15baa9c1d792fcf4f6f1e9cfcda5a343adedf36b69be67e7bce6ce0f0a6d56b7771663df18155987e33ca5fad2faa259e7876d0bc4916b727f5d4f83da07c1b12f92518fbc2f43fb8e31ee556eec25b42170d432542436352773eae0f2e5c332413488d213556184bbf555dfa3e423ebbba792a0ef945812594f1315f7c0301cb4857d8821f5f96ff7391c7c5d7dd99d808cbb84b8890f09251db6057f0fa095c9c8d4ca8fb7b348c221e2d794cab7b3424ef84a8c7521b6811ad695b4e1dc6a138a5c17d9a253b8221885c3e671de16822856791e9135e7fdc778d1cc5b731f478724e471d61aaf790fa898cb935cf8524185ce383ecddb3fad0c880f259a69413f459fc341fddc1560f152eac7edc5ce19c08177c4315fd68892779a7534c202fac05ad6ec6862b2c3372be7d8f9d5b54f704b4e0da58223f392e217d0549383ef1b64b3de10a80b1feaf831c5fd73bbb365bcde0c38632368a928f2c379a973cecae085ebc45754d99f855c46011b5481d6b04a4d4b8cfa45a738d6d561c981fb86694f90c76d828621dc7759b92635e1a2f0d731fb5b75b2e4f7c52eb1b76911d57b8d4b66730e67b5a34e3d911a78ee6bbfe0ebb6a8102e441d688f5683bec1c0c3f164630c9fa590ea5d7cf6dd295dee99b026e1e867837ebcb8f45a4c7d8880959e147652984eefea3840348217dd3e53c00d0b6bda9a40e1e5f3e3b7fde7de064a5fc8a4478a32ce1d41ac05f0661332979459486bc123c491e39aad3cd9bdf9d56adc0323bf9e0c77b035698854209c4dc36313e411b5fb350cd4546a0a1af573f5a718c6bf15a1c376450ba0e29616e398c9f957737d358ea22ef8ab7d07f605223764b4e3be4ddc225e49ff7276fdb3503a8aa9c4efe37097e9ed6428da5a7a10a2ca1270360894aeb7aa96a75126a54fb74b82c86de06ad0afe5ccbcafd92f22f463b8147fe1ee426f66122058869328ed9b260809b6afeef9537d5711e8faa93024886f087684c7ce0f15aa747125a23c2698bc510524bb503747ec0d363f4879c02de59ccd55c3082177040a3157eb3ca39f915172a3cbbd983f7a8da16e901c82b01ca0af9bf4bf7e01cba030dd833f7d391bce27fdcc29ae2bd15321192b5e7dd18508956aaec93ba5846418138e5bba4a1b3ca53f4804799946827ccb748b212d229fed4f5a21a5c5e799440d8c6d7e4ac4d4d680e148cd770f981502a8a1bebb90e28e45cf67ac241119c90aea2e4d96925504eaeaee4189dd9c33ae88ffe37434a87b206a8c3b0bb07fe1dab48b54b561948028efea6b986b0866eef48f5429344079cf746de4c83606c45d343ece58a98d549d83818fc1b2b579650d8340c23dea1f4496e412b5d9d4b35ad5eee4f243fb7b62e4da5a6bcf163901299710caa4f279b5819ddbc33ba6389ebbef50d69242de135432b4d4b7c8d4c2faa4a4a86ac50957b07bb772f567845171e557c5d4920c754f6a3c6dbf6118532c02c9e4deb31e935cf094dee655a4ffbc8758e30e82336343c0a073eec98ee1c880de14149544d3f31601d85fc5543df6ef24150bd329e75a205e05cb2b0f277e69d8da509db7ddbc6368dd254d441809738942ce7aedd595a0df381faa79378c8db6ac963ee7f422cd5db392ba8be7fea69e867dd7676e133001f20cf000f9e3de1ceb9bd6f25506a4cf8341cd4e5a081eaeb5ba5eaaa0bca521eb2d04fd16625dbf73f309c509af1e05c780e4fc514c57d2c10db22af15abf956fdce5bf88f2915e922e3b3edc61dae960c83a06e1645dd9e4f0ac044132dc093f3e1de811a3c68da61ec8ec268d94c5f9004b4ee2922b18ebc649959daa6fe9841c575fdef11a30f2e888c0e6868c3de20d37a6f3dc374b36fe9a3c74410e2a091ce45c29f6dc22ec557df4ed97bd45277f4a4ab540ea19e1020dc3809f9e5186977cdc7347f51460c35a44fc5f0dbaba0cbaec3e8111507246506bafc985766ed5a8e22cdf0114046936a2221a082435dd112b9bf19e1a5252a3fd702b46186a98a673d4ddc306b94c8343713abb3cf7420ef1e02d036475a0a8d9f85986ca0e6d2d03dcc01b0f31cc5dde7a52c53661cbf36e5fe7769a394890feab8cf8ba09f5f4fecb88c37575247ba0c3b249fbfe4ef847a6614dd0bd2985466ea9c581b12062789ff3fd5a1c26f740498de6e436c192497c46b51d36cdb8b4bfc1ca88827638808c8a39873e2c338dd23952396b67acd93d54dee98614073a539ad363b8745f8b80b4a7abf4980238efb1a58127ce77ba2ed61df6efa4ca451d640eaa1dc8f119a528f437fdbb7791cea75ebfdef13ca74a9594688e7cd7ff22f7a0c2fbfa520bf29a62c6ad736db82f684ab9b8f14784aa81dbde9b15487e24e1a89d621c83148fd19e0e5e15de542e5b03facfa493e78bd6597cf300e693fa8faad311daca46e6992b6cc3197429513d0d01a997b0547d6ab5b686d6d17a37e112a3d536b1b679215d3cf95cc10118643e3fd1f683634a72f0796e129b4d27a1c9b94a8e6575450045c0b9dd36b6e6e74ad9d85f755ad173797001fd9508382a5bd1dafee18ecbe928a74fbdacba06dca61aacfe50057c7ef4a07f9952e538e7b244fd9f9115dd6a33a083e7bc19dea10a3edf74e374ab423929408dcfcc698ae7be3b6ed21f0a53c09756f959ebdf7d03fe4dfce655ef1272573d750ce8b349bc46734de2cf92862e6a9f1c28fac68d8a0be359f894bf4be50405e08741d72e73b3547c456236abd750c0378b440bdd76581c8dc6ea42deb89083a7c79f84ad2f8e1d5fe1bc71f01110f7e3acf49aac2af93baba275700c9f4a05142ba9bb5cab04be37729708479b06b9f26cc38a50758297f28ec5102b1821b140672a0255e69ce5efd6168bb32cb1507edc48b2ef3c77314e1d2fc77347e511493cf773db31603c4ad82784a0c2098cc08f1735e37a59b49b28b25b857878758112d7e8e01c3064d80bde3abc62da9895ad18fbfb0c61549d5999643851883bc30ddd0a5870418346356dd72178f4c523100569fff831c6d30b1d2e152418de59ef87bfb33d77a6275da13bad91c21107fea7c20957477effed7cb06a7382bc2f289bdb54065721222b9fe1583d881f14bcd9d87eb91afe928e2ebcfa16a60dd6fbff0712911b7e762343fe79f0c0146e24a942b8905a524ff81e87bd6009def8c96a6fa3c243f04933ad48ce5ce4429c44168c069331dc5e60c95d9c2a4f77bdfadcf7c3e1c7bad7df5c723b965f72fa9573eaa5d3051c043841d48f75bb32a085007f60f3d2877ca146636ea8c8eebde77ee546f24536e913ea6d82b0241462493059de4a6aabde23e6f5694c169553b8825de967ed4e8c9d6edcd15f8d6781bd253052cffc8b252020249bc96450663977ff230ba1322d5e2d696d80028885fc5699bca5fe1f7eef70ebff3819631fa6e66ac12e284f471e4877c1221bc0e66f35937f73b872fe16ed62e4c702aacef5f446ead368a2706be2957bf0f6533c32b06d44fd84081b7b50e5bdd440d3e7603e189c731504bb9279a3de788170c0d6ecda4d8bfcec43fd5f067ee47c4b35c975a3d3c485226d409cf8b85ad1164da30af11a40a357c998e7c42198604aa1f80c01128ca0bb9871901b1e7176129a554a0c510983b1db940181619673ab7173dacd0ec2fa0772ceb0f3d18fb292a7efde84a8dd442aef623c45cefbf7a44bbc7251dda3767e7ebd838b412c2381e7da77bab526a414fa3535bbd96a7b7078da4cf6d642700895e0311ae4fd3ba53b3cc192b4575095c0aebb437f846696bc13e7f4bc0374b9df20b40f55ca02c2057b9c205f6e61067746db115060af4bea76f3e26d6fea7d0eb6fbc44c5407bd502cec104e51b7c0a66a4dc690110178db1035e3823e9e2b3ab06f6b59e052a4a021ef5b34aa65471f6316bf2b6c96c5305c865aefc6ac4680d0e87585ef7ebb81ab83dee92dbf33237c3ad43d106cc2bc1b1eb3fd319bbc960d351acd533a52b148e5d9df350f5d74e23d2a2d44693d458afcbf64d9b5efd45c1b3f4cc01535886efc99c7e6cec3f9edbb58bbc127555341593f44d66ec72d8b5b0a47ff6cae9bcdb3f4b4e65ce4aa9cc8a9f0c69f45104b084531fb06456b2e1a0f1e68677492f92a2d483a2a0be3f7579eb35c2daf748f71b610ea6a1dfdf778ae992c21af02d0cb5e416e5fa4587f1d4531db304d2db7fde7ab6a16dd452ab4057fe191343b66166eb114d6908bb6d148e14a5ce2987edddd098f978ab419a0f2a19a73616505d33ee449eacb7e70d3aa67f393d38d52e75e43735573256267025cbe703cc6bb59bcc7f9927b3f14c26ac5c9f9ad19861799d752ecf8f4d6b6278b9b8917023b5efa7bce15a1db00c03ff0e05173d1c0cece57abd14c905a3f3e89e808896a42f0e1d8425829381a742598bd117d5d88a46b1debcfb137dbb858080780bec1fe6943f8912aa1cd671c11daa975963f0cc6c47f1671a58570edca1fa38a65de2590df4ecfab5e273427e163cb27e650409889bbadfbdcbdf73d8f117ee8d57b76b56e7f0540c5958dd2232d8d9327247c8243f225057d5ab3b7a4dee0431ca7a6d589fd7777a910d3d47e5e547a7f18ed1c32e747d2e92dcf838e653e6a8ca21230482547c524efc1b88de9c6ff7efdb14a8708a213fb61f424b5268408ef916188037738a89e7895eebc02f07f18eaf1f411a1d5dd876cc94e9bf8f505c96bf5c05575e066d03ebbfc817b53f73b636773187a914f05cde14a03f6569f7e4a0c77cf5725a02ff58709d36a88c549fd7dd20672d26fa8037b88866d5a23d7047d8f58cbb10e60e3c8b34ae9c9ed899d4dba76d120ad8abea49ff0062f4f2e739f1d56c50bf37ced399649c10093a676857bce39f3b337e80856a27bf02423df020f74902f355469baca5470b2f097353b02881b7250f2d459af4796fc0e597802d973ed74df2e1006b32c01b75b7e0b8dcd547574a1250f938f0667fbdd9d99725518f81c190fe845ea21a7b181b298426bbe62486dc1fb54559c1f0d69f31d1ea3dc07e88cd0214f05beea052a56831ebf4b635f8d2a0d144d0338c3bec0b1356d680bb29e1bbb0dd90463c73034087e6f05b2d9ffbe85e318ca75deae5ed07ae10de2cf88db5686c2fe0cce0ad26925e8f92523b3ec09752631d3d40bd9ad0827d773bef7445530fa6ff60642d77296c2f3e984221694043c0feec3bfc98c68fc88f45edcf54f4244f121c01d6a3e2dca8db06fff2e0a26abe2adcfa0eff14f5f6f5f257b6834ac49081b647bb4ca079dfd54271d1c6f70798f0c569a88d73ba719c30dd133c27d3e83b4318860246a2b4d21cbb58dc8c1cd0c297f3624fd30c54a664f26d16ae2d72408f13606d250a54e8296f009a137a340e4817cb7b79d186bdf2896075e8b59c21d8fd51f4b47f6520b265ac3ae9da3e953cd1acc77638e8e605f1439b3293a952be6a90b1ac19defae3fc155a32338a950be287c23f68d6925f8219310cef0962610357d351879b16d2f96c8190c16df13d794b38758a8008fdce319cd42ffa13f2f0a4afafacac8937468ec90bffb4637c74d2fdb7daeda04e1f9b129399a29e864ad9c9dea96c08ca87e1f0829e9cb981422fde0f064ed2b064440490ef148a0dbf047d89ab3dba5c4683b07f35c82fddcb10d81a1caabd209d2aeec74946bf6ecf349b8f3218c756851bd68d0d618eb90521d08f7428e6ab0b79411d8db36e70a15aa4cb0c6ba4c8226ae091a030fd34deb983d3f814bc80c0b97190c3ba86c29807e7759173fffd94465edae6b1c284f663e40a7ebd7575c3629bed94d6e43b7b711199c32ad13b1a5b9a7d2f3abd0f248d7cec46d196b5dd3fd185d6dc9a3c4d08f39c2ad4ba924f5a518d61d33dc31049b67b9b3e70e3c282a5f6b0217f8e52aa49e51d929b57bc776bc988f37cbc92623e37903957ab57d834a15df11c5edb4e27d679bdbcca0ba4c3dbd34d304947015b4ae2e29454ba3aab1eac860087a3a340e70b64b290a04c13c0f8c61c186a2f51aa4ea8b27fdd0433f364fa2fb1f13f3892b4edd9635cceb0910738031ccbda366fca205e22901195f4a469be1081b5bcbbfe2fc749412bc23eae1650ebebc45b240c71bddf754a6eb3aac64bc3ec52945f7214952563ce77a9b1b46d0b6cf3224624b3e2e557463e75b2009db6ee0ab332a54037f6e96a5dca8c50836717b7ca0731e4d459b8a0c354fbcc54c27abba5636bf0336c34cc8630c54d3ccbf2ee16aa5f034a8b07a695d8e8a15e438e4f991784b2e3efc27d663580cf362ef480634764da5ed747a1532999603ec1fa1b574b25381cba1f32cb68282b44556b95c96e1bc2d36765a8ebbb46d47184556111d40b6af4757698c6e2fb3b02fd547cd77432b113e7dbe112474844b67d1817f972f6b1d474dfeddacf12cbb6a07d360a53f53579861ca6cb9cc49e5bbaa29a5c1bd2c8949653d682b7c8ddb6fcc01fe023a4415b8ac429863b7eeaacaed35393d50bf97d8e9dda4b144d2254e09ccc9281a01ce4b016338feca8446ea35eaf9ceb8be05a08eb7fc044783672f18592eeba51752d9b5cfb3fe0e9661b422ad2a834b40e61668436f7f7f91e8848eabf9df61c262ed1c38c7e8772857cf6391bc2505c01ceca7d7e15b35d05ef6b6bb081bbbb318a9454a790a5f3f43fc5121b974cd9f8f05aea6714f041780d0936c14c725cc52a8276455dbffe8a765a1d230a22259f37c26ca7681d8b74b0761d941c2266151467c3d7b4946d23e56c3a309dc808ca4f086e4b3048ac8787ef18105f10fcf9213a286e7a89eff3a3a37349f2c8f146151d16e435752a624daf961cfb65cd0d7edd2ffc8ace5171d617c8b22113161aacfe054d1cfbff86bc499f316dd1f0c9cddfe8a41aa7b22dc2014c65598070c817de497cf90993528e8f827366b6c337041f614ada970ae91692abe46b746ef6cdcd181d80cab2f7004eeec3d42b8724934d6bc6d40c69b5a9b9f12e5f9c91ea509ee12f5061754b8133786f60ee147f53edc3abfb12ea9effe66a678005ff77a39f7352a8d3786ae5aa00a7b23db3781bafd37b70879a66f8caa345f20464bcf954b5de5d55d77d12303a02233b5c0e256442d9611f463a1c6c60cc3761a3dffe4f02d33264f3ef99ea6ac2c150d4cee2f85ff05dea3ea65413ab02a58c399fce5a1da885dcf4d1fc93930adc68ab0ce778e1cea0069e176e4e57e40b8a6bac62cd7a9d8f75c2cf04f097adf005d3e5cbff042ce0ced200b55cb062d8dad4a0923df3c54b81639d5a516743258edfbbcbc529ef0b717a9e9e38788a995f6ec1348d7e5ff172129398190e69cd5feb6562c64ba59911df568e086e5e3c5ba2220e80a3715a95410faa805b2bef8f3766beb10e53c08f96cfd126d5cb0b397c955cf64d104c7ab693a0b57514353300f3d18b86a0755459a6322c6449224a450dd50e166bcd2e5ea8bd509142e5a263adcb298131c845322dcfe7e55f7a006c9469007c26de98e364e9148caa110801f0b455f738f140a55349a03f0040b084379a60b0b9bd2e233b2995da99765081db43b0d7267809bf4ffa03258e0d5fcd4aa2db5468c9a45cb738c1d459e7970c42550812090e304912290979b759ad0cb1f531fff3048cbe458652f4a2ed055c6a1604f080da259625d938b1b8b42170fa8cb295577d2e16288eb7516bf7ec9cfe5fb4a4aba5eac0ddad80a80ec10c5542f790bc85f6ca93236fb202e62b509a7022302b418c972827c14fe4c96c7a39bbbe70e899941fdb65601f3bbe3928dc769ada63b480204eb47d09563186a6fa54686a3169f4f176971f319a40763830f1ba65ff24efef795c7e6d4c1ef9e4ad1d4d66e5437e89176d5d0aba38409ba096b718898df363584aa8455aab47eb10a828fce57d317abe983a50cbd85441c2adcbcc95987d4644d431aa18e301eaac1f1875d85dd3b0ecce3dc33d7a28ad8b752752d1b754fcfa26d8d8002c97572234a440e5a8050b2d1c9452c48b8e10959fe1fa092f3855c0a3a1c591e5d6fd2744c045645e6390619f5b0f622a4fc4bed8fb61df52d7041d9f82bcb9798e026c2b8635a43c98757e2c5540d1126b84a5c1893806312828dad2fb3c9f3844c9cd07b231933f18acf30917580dac22234360a305daefc0d74d6e4b5e9206b50642eaffe6990705f9844063898fbbbbda695461ae64cf7e8ef9cd52c26b23d48d323275eb55d3800627e5302d89248880cebfd7b96a1009431b0273f05bdbcbc3532260797d94e5379c1ce1611eb5945376d64f28214f2c7038769194a02c295939bdf77dae7f66990713e9129787bac90e480d62b1a6d213b0f840ffc5eda9b1979d9690061dbb669f517b333bf257d22e83deb85594a0ac0c3890e5ec24d10dce8540dc785bf1d8f7871661c4d0f247d32c42d54641e127ce687c36eef4e7ad717b079a943df2f15855f9b3bca7938774bbc4951e3429cfaae0a922fd9eb95654f181c4d7f507c3f53ad3c4746aad1dc2e8475047f1b1722a7dfb7ebc1a0a05c82da11fdb19ea224dcbf6d6beb0b468176afd8a53835af36e29fa92b1b0991debb5c4e5500efca3fdb8af0508793f4a521945f771bc5793b8af3ff3cbe76c882a23bb60c83c32c0403f7d0ae9c8612f414f47608cee0a097cf8e3cc1eb0465ca172c1549ccaeee900aeb408a3f72a93fc6286d2d30dea128731b2375b22dc0009c73b990c922d83b58e9225761047327b799b55b675b612529ce75f176c8e4eb500529d43a368b2432a50d1ed4dae204aa7a9c55bc7500a386652d9ad58d171f69e3d0e57389e8c39ace7aa75c1f25f9377fe254552e5de4ec9468b34eeffb35fc6ca4cc774cc18452320b519d6a183aa6e02a7eb0179867b867e4ee1bc53cb00a1ff4e436f01dfa360c534f921cbd7823449b8e325087448f34973aad7fc4bc706b9f10e7cd28096b07df4c899462cc309c57499305b99a549e70d5129215be7f5900dba25d99dd45a0d536b06a0b859f4eeea19587b0cd7b710028657cf93a97ef874fcf8177da1a65b3c7387d0be22c276977d0320fe66abc446750dd0e2b51be19cd07973a2f4481c21c5d0bca3f38be722ac7d806c70820bf02aaf883355beb2897b435a0260f0732a0e7bd5cd937590b07a2020c33db317d54f86098898c784a58811a8b99e8e674b504475b772f9effca3dfdef69745ac9b99e90e0d722a7f717364dcaa023c0e24dd37347bb4c146924a3dbe78f87cbc88606e3d12d608e0eb174c6afd986cf1007da4c9e76bab6976bd1bf18fa1c3a823429440c7399847dde59acbaa94bbb1f28234d0a0ec719a38d2d8146f5221bc92c9f78c6855e9b3055ae8b1020d7a72aa0705fa856fa246065f3635117a5622eff4cfd8d638f5ba7dfb0421209b4d076ce96bd90f759f89b8187f5df407f23d7fd47f7b7872b46dccac761b7739127bc3bacbb78158babdb99e7bf57dbd2435f306e6b3392b20c9d89fe630dbbb7ce8d17fcef3dd39d363f720975ab882daa0c43baced04eafa58a93e488a44971860f04cb723c56fb1380276576211584bd9f2ea38d17a51ec33b56f0aa2563d233665bfa875c5e803f6479524a58b15bf0c7f443d96b5649139afac0b28230447afec59b0364491bee2a13cd0ba923789d76f9fcd152cd4695e4e0138539b4699ff2f74c14222b2861eaf93cbe2a42891c3c88be4fa2c3511ac3436510c26913652b73cd27e267e3bbe680b4534fd166f5d948b1d9335ed75bc0a3e81d780037af68dc7a9a508450ef8cf3d5b7caf3c7c4854b1cce228bf33e4b963fcc5752364e03f2478b70896ae7735796014e908b8a331ee55e37be905e6f1a4fb3766aef60022a6f8fb40fd26f22660a9c9beca9c2d34c028819d88a18f45daea3eb4607f15d24c648cb3c964f00e92b781fbbea571846013c119e79f6ca255e5accd429c6672314623f61b0b0d78a14c1fda922f9a82ee50a9e89bb49f37a93700b8d0bddd37c98429bb0345e992e2b37766fddadf299c4b0513e67098aa34ac2ac823b32710fdfeff8138f4d9a7dc9e238a342f24bd080d4defe05e4263880e3bcc327ceba7bc7e750deeb1ef0e22d034a844dd2e651f9ad2705bb8c206117915d2a33a47a908853fa648cca0a19a50f3f0c3a34d64288e72cc9aa7afe11b72e41546e00a60d44a3313e271bc5177cb022ecfd6f72b7318ed4fa05e96eadf57755d0b41fa5e4fcf7bfe35f03d847f8bec4a53c8784fa2e182f6fb914c466f06ca1127a207260e71d55e0ca341eeda23c13ce9e3dc7b8a3f70dfc147a398f2c4ca4ec6e3df76d79a5b4393e487b4de68ec9abf3af7e2f27df6f33ef745e0a17d685cc9cf7f82edf0d8246d9dd81ca61321f059a9aa954362932f2c8d4eb20ba604ab32e5622aac931200fa93b3e55626965e77ff815a02e088a42d78426586bb99e8ae577422e68488a9938ab3ed6c3597ca6fa659cce8cc47c5f2a2ff1280305b15ed0519fcfc3c08277e802ca6e95ef101c37d87882049d77db7c37aa72846018c7984d7c5549781d7a6c519941bddb4fe4cda3c8c2b52b5b272b37af7990a3d7076ee6a279812628dc6856632312ad92944c450091856569cf4ff80564a9e365cd19a83a5b8f434fa15d2218a18c86032b7a74ec1066b137a53cd94ffd7449d682eb4f570f9134aa30aa7346ea60682ed330103a6c4eb64b8e350079dd71e499e7bfed808b0b7e37c41a250815b337cc884aca08c40363ea10abc168ee8931cfae665ef4e7d5adfad39863e8a59e3b7b7b5e237ce8b7d2da31ca8da201af9beab74fd74f4532bb204bb832f2c0c0ca32054795e2f86694fc1c983e31b0a103849351f59ae3ec39152e90f41d0ad77f8ceadb4963160ec66e69968fc0d26eff3f365d844f23f688f3900b58aceedd9d94e62ea6683ea669fd68483f4ed0f1ce399ad110e2146fd19c7c352ba95ebf1da5f4992591501fc1928a758d6d21539ac3ef3c2b8ff812f8785f21ec1b300e73fa6185dc1ab2c673a7364fe38a7e48881592306488805f0a5f137d9736a0690aea84fc3e9440a3a9a0193864539919d8675fe2cb6a9c19177322f743e00a8fc48484e024aeeeed1b63ea188cb4f61c8663d2786ae44f9313e3cd52b1cf7f53944236408bd05be3fd118d632fb42acdf7ddbb0098d60b02b34983f66f8eb64b6e6ea428e19367a6a93571b9b2f28566a78afa9c254b0c84ead3191916fc217b29fd23749053bdf3653d2cf0cfb278f7f0016d0ce4b434b5755f9c2c2c9d3ce75f7093f1ba8a08017ee9e9f48fec8dd83f234018de683292d59c50e36f27a2db8aa3abc5a88177e0ed7435c85a140f1af23c5bbb158d487296b6a2c6c7ce29b7b92dcce5ea2de64344695a209a089c1bd1a0df460491fc6dda648e7f5045602e1c5321bc87f2e9694dde355061c15c48950fec767c661c4298902e83a465292f3ddc05dc29a63e586f97507c69e2acf9d8306f41b9be215388907218332a15015939365256dfa8274aa09e3e771ad4cf120aefad41ffe4f7cf54b0ddeeedd77072f9282edcc1c498afa1e9e0fcd057af4bdbcd845e986af894921a51f7ca6194c21f20941c50793903d4735bf62a80a02957cfcbc787169550e7f1a350955f9736032568642de54fef32217647ff2ea033121a2f0e1b26b93248a6a98d0823c8fca69c74346f0a6ee1652c26cebbe5614f3850f7d4e8c23a456d80f91920a5d2e196bfeafda0a2e3ec60c1c8a320435962eb4ef23a1cce44fef18738322a23f5e13ac4347891978cdb9c52845b5c01d0473ff9b7c952e1a5bb36121b3570fd7e6147f66585a9bb5ffadfed77a760ac93dc7bc09609772a529e633d7054515ee1653a076c32c9509c69343c4ef13d606552f601f257e150653a894e8cde6cee8c53b80c04f9cea306e031cc5969314d4e5ef0a4d679799ce98cc2a61985beb384375c29f03466c8e2dbdc2b49e95f69443bd77e3ff58db04bb1e4d0759a91f572c6d9d167f6538d384088969c4728cfa5fff205d155b79b6fcf8080f2e8b6ea07db99c34c5e2dc9200d6f47eabf99821f207d4727aa891900356196644294aca4cb7afa1a040a2cf4a939c05e3a24078c89d8a6a8075130ea06f5ac32cf66aa3b1db1a9cb4e55d9e948c69f479fd239f5f47d8c21f29fa956a18517d20fd9d5c66a2f4de192bd13d4a359471452cf2f96e344764e2efc7707426d5ae6fde6d7bb5594b74180e2d4be5b3d837708d182dac842acce5d6be1c33855f46842f75a62aaa308d78f849f1e0b880b689ee0ec03a550c85d860d3479024bf173e04137222dc84695688f3f36af64b4e98e8790064eaac4edf262d912d4d00925fdecee704b8ee071275e835a3dad20fc8b0f4a8c96626f6c7057151de540879b92c43e0264d98214a92ac140377b8f5535cb10433f66844c9273f6b8224b99fedb9c702e61f2961af07fdae441761b880f2559eecdd52e096ae2b276b501604d879bc55d2c955336115d5b43f1f3ead3af822bce9193657d1e5cb7d83d173bde508994de753c20b65214c32f473118d343784c7cb4f0b8f62e31ee79181f4163df5562313ce5e50a9e4e250471035232156d9194379093fa81efb63de176e4c090f58eef05378dfdb174d5a984962bf2f3a58aab8bf6d96b815a91debbb117e3325d60085ec34628868d536e3f043131949450aba8dbe1307d30fa0bb1d0acc97507fecaee98c86472f3698744da21c748782ef9fe5397b86eb95e2745ce66212de5cce1f545fe102581ff48ad38b3bab084e906097ec771f8f148331bb18e78b0180f95d3dfba8e3b68b63da7f4b979587944aed2e5b870d8554f04b03e67a6c0cf22575f05b3850ef4dc6f58f4b7d546d46d5aa3f1e294632d767c7c4f8a62de094e9a5c42056291191afa89b2f8117535135719f5ce50858658492528d52b7979c97e4a44fe4f593b13d0253cbbafa1cf4fefe2fb931a33f548faa3f14251c94fdf82c6b690cfe25a309bbc341ee854228b8d82f521dbe0103dfda247833a7ed5f237667c8d705cc98ed73d15a69cc507849917ac6110ba6638ad9ca845797afb9914eb73b1db59037be4cab3d6ef4b280c6bf44b63c5cf2b6a83e05f1ea210080ff772370fde545695b53844df3ba4c45ad2f3daaf4716dc3afbd369cc3e528d20e9352fff02e63655e95f73d8d3c25a8bed87792456e7b23e16e003332bf7d84a58c5c1c9199fa372365832e5398e46f46f29beb38a84d62a735a90bde80cb7303d5b08891aad614e914c0ecd2c0dcb7fffb2bb5d3c18b507ac6af1406983a76a54a3a3adaae15efaa170471d1bd5fe295d59f3ee612e456e840c23712a328967175f5b188387e7c2fc8c7f6bba3963750f71ed463b24615f5808d5a315075acf0ef7e2b5db949446e1bd2d4db2856604117a223239c3adc3ec07a71e5609cb03525b72e5c5d164a4e0dfcbc351d3844770722de9756b9c774f12c0ae082e7380aad12eb2abf32bde888c5eca67850867d91d4e74f7593694de3edd24e56164cb8871fa500cb1c00bf499a1cd9605f1a0d66cd05d4f44ce0c306fff332083e7a1e4b1979174630e81e4f58d98d502b8717a9e684992367d616bcc588dafce7d7ba3cb2d2cfc1a3b3892d2e060d75dd063ef3f5904c0ab54d91400e1aa3596ccc4cde5a35d6954d8f44e0035f8a7fea41157f16fb7baa3422f2d16a5aae87287e490dc60b0c972b015c74c982337b3768cdfd692f6ef0cdbeb00294f944eea49d4c1bdb5cf16953ee922b21567b5e8dea9fc7a9267c5d408d569ec189f8db753f5413f6a188b7a30506b8ff54f4324dc33f2d1fed0fe8e2224efbd36582f5827ee523f357cc3693af04a13288fc4e722236b97d3104f8db1c7d966495c809682ac56707cf09ef260a0afd3d68683fffe7dc67a253f75a36f841ab4b3044fe25516da154397d82cf631b88110c09f384bbbfc37d18a8d7f3520ce0ae6ab3cbc783b7780c4289a9ab5f5c720f3c9b95b6f3c8bd2db7b53c96874dfccca2d1b8cf9875edde4d1aee9e421f4e2c3d483ac4d9897bfdeea71c2858a466dd3fb4dd06e0792cf272c8b52aad6c5638f7356e4f684c4e8aa677c07203e579170a168906c03b34a351df1c3c0692ae43a7584a762eeca27e929f199ce26012cc1d567e6f60fabc80bf506a3a3285b590aa463ce18b5bebb783ee99a774e745849d271f1c0068a8a0e4835edf7ddd500c33f75baa41a164e15f6ce3d5a8ac8cfd76308a31e54f4d1015479f9e1b2199fc377257895a72512f2f8297ae43ce764fd030a4e0f40ad9844433c6dc6eee80a210475a7bb49df52da9a4e280d33df03fcc2c7612963f9a4e7b2324ca34098a2b750f1457d425c51670f2e7cc7ebcf4a7ee45178dc902565bb899d23f3781b672c547abcb12eef606ef50e554af2ab3c8869d104f94266e92515f256d11d5b6265903ebc38f82b45e2fdacd70bfd184581d4a1390247e1d8a4ebf8d375accc6ab5a4a8db5d81c1d4857b427d0482b9af390eb73adeb59e036588f999ca8e9e6aa6d9d9bd7365b8cfa90ba87fe8edfff29311438b9020f745a30fa1c1bfb08d145d1780cb864489ecf132e58cdfc4484bc2c768f1ee1832a307b19e426079858d5219c2012a589b62a036e2d00e83712199af73efc42f10a8dfb0e12fcdeeae989bf593ce05c5952b75417028e709cccf0bb24796ca0db71c11f66d6e42718b654dc7349465a8a51797d959f746d38c33430ae04896521ecd9abbc4d6189249dac24965d587e540adc4788eafb66b3c093cfc4650d58bd0f6d903750a2cbee723375b803136f234fdceb200ada5daab3538dfb68f77fd9733c014c2428a8ad7ecc7126249fd75f857e0dae8896d50338db3f94a4a062d6208f66279b2562f0a7ec1a22872992c93574c8ddb4dda275dc7c6c97676ba80fb2d1ad354544c981cf8f076f3430935867b4b458336d39d670b40b30a3bac70d86b1c4d60b7efdab223ff0a8d3e3075ef16a33ade0825f6d528fc97e1b2724074ad6f6d1d88b8a51f5b28eb9880a7412eb5122dae9ce23e2677e459cdacdaa9e8ce89830e286cbf68395ae694f6badda7913ff07122433a3f7d76c2d65573a0b905843e25a2e6005a45f54a7af479e0275d4748c2b2e0af8f5d87f57e0e5a346cac1044b47a738ee6920b323ae06a26cfc6f3c955e6f81651c91ee9792fed173aecc4ac49328354a07bc504bb91896bec62f82cb82a9bea18f3d0c022f13a2568f9eadc7ffc357e9fa8e265606ce19bfd8823a13f27b1eed8920b18bcb07205b33cdd3c590c5963f4e1033bc50df7f069689e6e1136c3e813ff5d10c99f8f00200d911899884bf520f93cf2da84e952273c3ff4506ab7a59b1906722b78d63f562f01cb8786739585e9059853ef090a879ead2dde653056d9b85b8e8be3a4ee3153d5284e4eb3b5f021b8a11a46342b46a9249234a4fe76f660e59fb2c0eb33dbdb482ef6a60065fcdf9841bb78e5bbaf398ee7a6d0c57893c057025bd8e6fde2ffa9e4fbadd3747459cf391479f2825e3a68a9261c98092c48107e2f096f732e1d290ac111813e7667829513a1dd11eb8e8e4b44e7b826eb13b2e972b81566918c1842ff755e646999da75118e2158e4e12adde0b67c0406b560c5e53c70003f0fb8c131fc2b851307c5434e24a8031f052d0d235b7f2848507b9239300922b354d50713338c9b47dcefceae0bbb362f0afbef527c8617a72bdb0be2ef7fa3d8d45e194d2fdee682b5ada91c021e70fde986488dda140bcf876063301c2a74244527714fe47652e7ccca9d679a0156dbed63f517745e13c7b1e8f41be05b872600eb1607ed88b3f5997b19e31bb8c24c736dd708edfbe020ed8512d38e3268e3df0c83f0e8e59f6c74d6f5f07316721892c70543de7b8962b4fae076839f1149241d582520d562036006009b26e712db6ef45dbe62e11e50c2304dbca31cc2abc658640febac838e995621a53a502444d050e7687d17f1591d6fd626a53dc0ff41f5d4c27896cb49d1032229e1c0d10bd2a7c3a665097f4102a24cf8d9ad9387dc12271eb242bb4d213664e6d64dc012b7c9282a7121a21323aa23a50d726f116ea37766aea661d056b1bc1381adcc337b699a894b0e755bca722a4d2cb739e1aecc5652c9c901211e99b0aa5fcf5fac853aa423184267a3a738c69e8cf0e7249f4f1b305300619bf0763812a6198d05ba64e5338f41aa89b0fe4472505da11fbc3b8d087eb3dd55469b287a7dbdbb3cb28f43e3ef052b210e5a4cfbd9e01ce16260622055072205958808df27400243f2d4a9aec8440beff8311778b85e1fda20e17b3303e66280890d3f82c434591455e7584d7e794d09ca408fbc086e114db861e6304c54d506cac863c8d5ba0a291f4ff7406c4a9f7a213fc9273ab84aff27aa9ac48e4782b07862302d078dd061546bd1506d80d4bb4a786f454f10d7a6ef4477c3f938d698b7c455363d29724e24eecd641d44540c3a957e02c8bae578eb5cef5b3358cb10858846dbed2e253332dd1cafa1ec2603a85103177e537442b8a9818ff664fc2b2dda628dcc28f6e4737377fb1197de55d3cf2d506dc6e3c35e859c9af0797996cecdaa8991b4e234dff5b1f181585308f4cfff43b3cf437b2b576f0f5b809ba702ab73a1d00d9cb7be923dbbcc8ffe68039e5682deee4c1e3e5bfa53d6e2f08e3480b55307a74a7bc30b75889d1ca97f679687caa9061fcc26247173e6631dae3fb55fadb3ce333c9dd4e344708de7ad543e93e24eaceede6a141466db5e88533956ac05f02d401e83d9098edfe7a1070cd73275a32ac2f52780903859583a32f3931adec665983a81a566df9c0e997e5081637023c4ad578136ab67fdd307aa940b80a84a1ffa737f211bb357eed42740957d842c596f7bd03c3ab87c89624e9bddcba19303cc705643c860888027e7ebe5ff2bc37c90b298a95e06911ef7c28860848da9057adfbc759dd6bb8e217f33b66287ff5ee06c4f0b7b7429d7e20f175d7908308844a6f5963f205512c4244dcf7e65ee308a130b8df857888d73da525958f694d79f2463e1a3abc0c31f9deff9af71c457ff3f4187d0c3f9f6ec9bf5f2d658ad3c3bc6e2213b267e22fdbae327416004e3037249191f2662b0a51c6c1c9f2018503f9d3950422ca377ad461fd248a544d6781bd5c34f8c3198468320c7f13665445c44e84baeb75e20ce769eb94e7d0d31d2556a21b8de4ac2a9e9aa3850ba88f6245cf38f16e45ab8fb80e3e48b520b42646b18b850375c4fddf9c093462f186af6e9c21fdf87eb90e9ffb226de1c4f47bcbf15ea0496841018bc360e4a35c191c5a5ad24a743e3fc62977bd1a7d7dd03ddecf5786e90ae36d1f95711d477503016c41be51df2f43057bfd59a8d490918ebec15192018ef3b60403183d20834dca262baa146450c90c66fdb52c37e15cb15622f6ca0618b8fcdffc6449faab0d1690add1526ac12aa2bd751517d589af19ec867f3cf7fe204f4af862d4eb34986dd90198ebb8ae5a1995fa891919740925066930dbc3e568d19939ceba05705dd638e5cc03fb0abd69a18f2db2a68150f5341f175d55766a86afbc911be3604db97b12a84c1aedf6c834852a46b3515d65cf2f4dab6f2db421196a1096114b433a38e41e780c55c38eda048cc5113f0c8fe2eef51f5a0be725892f219b0e99797cc9efa67a5d717d1b7f18a7665e27fd60adccc81552a67b482d42ae7458ac9cfea2726c2ee9f4e256050866ef4b216602c1eb81d293a157da0c6f4a08cafc11baf52ab7fa6633d49f884fba06254f5d4f43c9fe72ea04b753cd994ebd4118677e2e098ce067b802b69c3e995953b01b56cf2491d52215346396b2d979e92fb42812b9df1be7a747acb9fce81fd9c9e330d8e01736e3a368b0ffb389dac4f50341a84ea99511974e7562e458bba9dba8cf3a2c2fd078ced48fe34ae6f1d52803863970774c2606427b764c1ec26a3d4f499cd45f6e3663a8e0ea01203f82dbb6348c121e7ec6cba0962c10e5ec4133bbebcbc8c7a4e71f6fc58943a0e3069cd6715f5475c8cf8d4b7545d326b0a5e73b08ce428c5bcfdd912a0af26f83c6b92d4e0bf8881cf2475574d701690eceb2b1aec277ee2216706711559ea55f8ab51f3cf791f40aca1334c3a2e9f3b63970efac27d1decd57fa502663e2e1a78a6be17a9e738445f466a7dad73956e79bb390e87ae4a6d33895458e2fb8d4fe4369dbe8fda11ab5e0875d7cf41937376273998aacad6062b36676371fc6adaac136c4eefb7be2232460df7892fd0c249bbeb45a664bd2058798737fa878402b02f13032aef188c5f034d63665f7b6110e8d91a79e7b1c4ef7456f9be295dcf50cb53575ad08ac6678b95319feb78a7b832a439452665b7e3d71319a87fb5a3c90798053b62b26832609f8aa34d347685652e58ef1bd45e7f288c648c86f7dfa3c5238145af81429e5c4836fa7b9e90c2edbb0f76d78f4d43b933a013cfe7dcb8a4e5bebb5057f64782b62235f1a27beca381d6a8723b9bf1258861eab93bec9f25e9ef7d9952b87a9294600e8121c14fc1e6889808bd0e580c203aefc0e8e79ef6df8b9319a3ec09765e8994a78950870bb15f831155de16a7be25963cb2427ccb89959dac362b77a3f957f1715b3708865aa3b4722cb26a60cfaf3a314d171ba1d6d52e2618c2acd5838beb59fbb0634a1cb7eebe191d695584499bcd70e9f1fb1ce7e7448ec6b27b4b852ecc104b0aa38f5cf4ca640b4d11f7876c3ac97eeef2f4b51660e757969892ee1372a5fe35501da64584456a302841aaad69e3cd674fbb66111203080b77a796171e42a5701085aa18f49f076cb7ac0db8e2b89949260c62a83095096fcaa07423befc3538f7f039dbd6f64c713247ca011df7525aa919d9bc8e3963a0e223f0272f8cb3510e4912ea6ffc2be03e2893619ef7c125c4962f661f0af13bda9eaf1a217fb152959e66d7e9846856e2d4cba98e76c76ef5113a84f9e614d860b9165532f885549166e0268c22de6074f55e563f6075857eeeabf10b114f39eaa4a2b36b9fa646f856e7299fb4b255fe1d9e7b6480cd2898854accda77f58c7654ee14e4916877abfd31bb3f97d0225958a55f16ff4898310443557844c2b25eba646ee627f2eab8b6938a6d2a5d99403406a86667b66bf5d1aa94d286ecad9b62215cb9139def47679261791f7dc25606e712a1ce477b6892eaf63527f9de6dfce4dc841e2a8cd511bb664e84e10bd93c6a96df70fe01d00d84ec5469dd0b4d512463308dc66545084e24e5067b2f11d08b5ed41b1bb738d3e0900c7e140b4e1bd58dc6809adc38f738d60b16b9c161dfaf5d2ab30a3c0dfc4a5201c5415861426b1f3c50a535aa1376c765b11466db7dc83ded916e882ae8aabe4d0ffe5f6e422612cf8426ff5158005d015b7006248432ef19f8f7de3c1716b24fb6b92e5fcdbe21dba80829862baba901a104db46ebd7bc191b594f8682e755472223454e3bc9abe848d733b43a7c6ed01af1df484f155f14e0fa55662457169a152c381da64455a73ed9c4eabe1991406b29818fdda448f8c3069d10336b2666167a19bc88e3be941d47161f4eaa1c15b2070bad58adecb563d9e8415cb23ae92ad143d68c9108c9f6a15860b88e749a66a1e466ca8f4eaee54beb778a491b7051f17bbc3698a03437e901c716cc2474c28ee9f24eed2195cba8dd1db89362b9773482d474ae14f09c2a92742ccf4182bc781e72b8a052a0675d4bec4684f69805ac8e44aaf3f6195e81062463c71355d8f0459b610ce2183f5ece20221120d2a401d9b199adcf27215d5739d06a199b6e31e8332f6fcda7787842dece003df55b99af15f3783f0f8bd5d60cdc8680bb5bf0c5ffed71ee320231a66f8e15f250a2b38615193dd35996b3813f2c1772983e1212c0e04160ce0d33a450e686821b39761c49e510e056e022c34d05b67a908c4eace8e44b9abeaf41c267538e43da7061c95634b4b722a7b0ca2503ffde6f388413d272f5017b0647aa1c5227ef3e3a31dd1b384936b443eb6c7a82c8a8e2c2f3f9d10449da475d1e69ca79500405526df2ee009e0d70cb4c45d7dcd573c1119493eb6ea65dde8bdaf53f5e1a49828fb722cadf138ec34f88d0e4f0cf6b8aa4bbd499bb6af4003b57b7176468483ed235e6d91ae651ab789e0d25beb236400fa2d2a52d4e31ae6a1f4846844aa3477b1c0b055d6fa7ba339a8ae80353269e3e5308cb83910ab26725f9e746be1400755ee8f5bafa5336ef555c1974f352dc5d42289134f75ec03d55c98637883610bc828156f20bd9b65c4d1e22689322f5c3fb5c06dff161833bbe0630c6569c12a1dfab855dc703496e60a1357a9c556400089ff1bde13acf37c064a4c19e82f144bf130d7efe011d04fd2d0d48862f27b76b9474fdf860a9644fa7684bd204e62b79b169029c0cd1cf7c491605a1b3bf465803ae06ff49d8fe7aba0cf066cf24029c474a96fcea96f2177b43192819a4fec5ebc886bdc90e82d5c1d933601973236a1fb4394a83365d133a6de4fed4214e88cd56fab185dfd0caf6c29bf81ae09e1b9a07b2101590b6ff7f5a7d2ad49dbbb308b504d5c451f55f1250232a5452a7b72d9367a9ce2a1bc49414ab56ce2ee9ac1a5316617a33d6e546e1eabf636d2a1ca15b622a3672cf4d7458d7d47bf49488900b606506f68d792cb7a9c42adb0e7394f5e44cf1e3c2b8a88dfb3212776d16a4d9b6a60cd6050164c882006f278953905946f0d7538cc3cf411a15488db96086fbc919d8403ee985ef009fe2444d049aac02267dfa3437726e2c6f9162b","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
