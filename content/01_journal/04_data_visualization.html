<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"7961fa6e944c03163b3ffcf2aa2ff815a0edf8515aa4c9329ee43bb0afa559b2f45aca5802dac97e4d8ce336ac5a70dd78468e3553630d033411abbf430b41c79d78af5e6350a4dfa58fa0b200d735969fed0fd86556dfbeb787c6c30e9a6ea0e29d53702fc2a5565903761ba8b0fd8105bc90d76a946a0d416d850dfbaa12f3526b405c2237efbf2eca6ca290f389d4ae87b1ab207e8493a8c372d39766a3f1dcf7fca97741b326b0a4c9b7d13d5bec65e417c6994707d0d022858f1c0eb2e75b53fd08f0f68cb2292bd0f8c84e1a0375c54c1c8b2f008ea582ea8fd732aae8051daabff0e377ba2c2aecd30cac14f0a435329c95ec77cb7f29b5b504c51e21f7fe73b0c9e1621df3a0bd9d1332ad0d14be75f13d18782f0a95d7369aae932e7dd8f69f7f62e2b7ac6142c941d605749f054eb68981154991219226393513fbb98d8d042be6a6fc56f8402b17a6a2c869b2002d28a641acdc0a1e1e1396b0158604cde0636b325adcc18b65d51a4b41a394cda7293c35ef5d8b316e8c9d881a820f21154972b7295bb3faa9af17a9b3ec9b44faa53aef5dc6b2643f2946e1380baa7fabba42c738308b36f9ddddd7df699cec258815f465d0d7e6f8ca026b54be7618e71d1fdd661f4f6d88ca79127cc397c8e55af1750579df03b0951407f335d05478aa3308ed3011dd9530550a74d40dc24b23eb0a61955a40e36aac3681b3ab0263a87a12630cbc23374c1207f036a721eca45f02925e051125e23ce259507ed054b6fd2af236b22ab216759018903829db405d99a7dbbc5c185125b5ee8f1d080c1a2daa48dde68134226caba3691feb3733768108b951ef61ad769db7aa82a723a6d7867ec07eadd02fc5890d56753d0e58bc367ea23aca40aa6aeea8106650643c2192e4e8f95d1bb86947a35835af5da66d5eff22d2dda88ef735ca32e7543e17c04d75412cd3292a3279360113d127ba91ed5f6e2bc603522c52dd7d9a0fac4269f0c73eee60a538e9bb1fb85203731a8828ad0df78b20295f622b5a61830df0fa6e97ba0544d790ddcf36d50fc017e1d3dc354461d466128b509131488dbdab1b5a2483f7f32382fcc3d157caae9bfb44f16eb2ba6d076d76cb2f7312f07f84952050d477b16de026aa2e49c35ed66852cbd8cc97fc57953d3ef5a2f827afa2623dddfd9915f8e899299e305b22d7f53c1060aa15f796d2ce0afab171cac0c1e764aa63cea9bdc3df89391539dbb5626b2a1049a7e8f0197d7e70d0c84e12c8be0aae475ed4439ee08657a39e4afd0a08afdd96fa7b9abfcd73598f1773ddd07793c81ce079a43dfb5028656938a5bf5521bcf1fad8da611a188d16991316d0339403ea9595a9d07f9d4b55d8838dc964442393e3f0fc3bb7f8aefddc7a36eb233029cce1c605c4e8a14355d531f8b3106309c116a105dd5540885d6c48b0ac4793a343888e6fa8277bee5cc692609a7b82a44b6d3f2ebd24856beccea1ef37de999c262ddda0065b80d13bbc2e4dafd47c7e5458ec75007aabef16d250efcf6c24e8c42296ad667a2106c6b567fab813d852df97debb0425a2414a83f68019a8246ddc93694716bab4dde1dd2a59b57aa6c48a156862a6e5c945f14fc93061c5f0c20cd21bf9f793949535092531d03497147c66ed9a61142f39800f1f5adc951f64eca2607ac9423bc7f75cf3fa430ecf69e787ba582e729710a4ecdb1da1a71928d39034e537879b0c6023a3f22d64da9fa8780a116a21c763f14b393852f1fbf38a64df219f776004ad61c09b61e70d0dd25cd63aa6c1af789b9f7a3b87b150dffc9bd12ae512e29505ede233364fa0ab4c9f82fcd7cd780c220f186c63f7574a893204546451f52613f7ebbf7f418fc4b5d1506899928683b3cbcbde92aa2a07c3d1e3c20a0024ed5e39e0fc7935de801ce1443e04e425cf8c850876dd5fbd3f9e88b48f45ec81764f1be2f580ae2b4df4ee5375072adc24189dcf4cafdcb1175a3631d4042aef10e653ed2df173e20461d370bb88e436a7583a34d15424fabe81a5525abb559643134cd233f39416139a1a8a574374bc939eaf6363363528896dcda967810c45118bd4e30621b3f09d5129a32ae712ea7ef8e4282e6c2d8d8e78e28ea2a7e6583db9dae2d61dad6b7a29f922920bd5dff1e474e1b19fe8e2a43140052507ddead02cf904dd9973819eeec0b1072a76d84ab386744be28c5c0bbe40ee7d28bd7b3737942b0e624973fe797cce6f23cd2a904ae6ddbe780e0c4662788fe41b75126bec5312a6187b661d93881384af270af609131f61b9b27c7c68f6e55b924beb22b4437222f4e19085ded5e472deafbc2a27b24a2c10c32def5407dd3700bb87ac48899787121c17eba172f457337f8401431f7f3521550e5792f1d40259f49de2b3ce316302b23babda7d67c848e10b5636b934625fa7f661d2775c7008cd2158f80d2e8e2c8f3e53310504953e1925046a737b35923aaa38ae372e5edc683f281c8cc0574a6e074677891ea6e7ba5a79e3a7f76b3595e008f6e767bad9b4b9e9f3f44890fe60188b383db8f8c1d7d896cf4d723b64045e6001c433182a2be5588e05a57d180f20ebeb01de52ac0e024341a87c0755bec089fd566182ac8ef853af42b4811b59f5a7a38c1aa0c595873a4aadf6e653d2494d7e2eb44b96752e6e074d72bb20a71481f80bb9b0a6df7523b4a8c783a0dae40c346575268f261db2796346020e16ffe0b7abd7d2651f7ae38f442fe19d56ae94e93812547f7f3e646ba662875cec3a896201817f4cf3f88f060912f9191fc1da6ee769b75689ec5af66773cb324e6e33c3007e364b58aaff818293abac4d742f587511b45ef768e28ca358a09a82ba4a147df1d32e0d81e27da6732932604cdef225884c57bae629860426e854defd4f25d171fbaf5fe14bd8e35edf91e12e2a0c67fa8f4fc943616b2fb912210fbe5d6dadb1057e1d30c3a7c2bfcf43a494ecf0a2c794db30e2c4718f223909cafd93195463226660ae3bf414d7a837417e47bc15ec5f95e16d753d2f33baf934a8722957ec83a27b6b85b4dd90a1f5b4c209a4abfee89520e9c6e0f928bf17f24d6cce1b5e0358b98631b2a5cf2a32fc5c8581d2ba6b091702b649c67fb579e0e97b92caa5aec0bfa32b336e8f132a58335e08f593772a74332d635ba1774e17bb6751f1f62c479d22d2d408b3f7f0295f58b35a733a03e45086d72d50e98bd1ce05ac9cedca7214a9e72b5c685ba685ada18e6bb6be45f5758d12e006c497c5d6cd0b539d6570fa3fc7afc19d3646e7f92fdaf95984d54c7439dcb172c34e4446d48150caa6f711a55b76b23b68ca180d883da6bfe51ff1b643b9cb39185ba1f1f8225507ca1f520f6ffd53fbbae6820a403d3eae8c84bcfa8b6c4192ebc1b10f98ec710eac97401b59ddfb5da8572ec16db0ffd6d39052668b93eaeaf96c9041f4da7772e4c447e1fb4ee88d6906ea6f0473f12e0015f6f3b97eb9562ba732fdff22e0c48a38e795ada58f4f686416dbd559b89a519f4edde8dd5200fabdf50be806b940dec32307771b026b5e18630d58cb6d7fab52fcc9e158101e60a8cd9c54b9bd441380a8845e7fecbcaf48514a3a85f0f7f5c98dffa87eb2330f6a87d4a06ce8213fab6b8100d8ce7bc9df5477516aa939c6a2f8c871c3b9d712daa8204ee84b4d0e0c00aade9c4c60e287e7bef9f9beed86a8f4885828579a47b21913d8a6424ae4ccb29a9c21bff0441556d2d753de5c6f69bd0f518eba38c3f3dd5920720a5f0e328471c83bd50a43d3ee411475f8f14cb96f61ed1918a21bbcd21a62cdca71460b1f1e311e415f42896ea8d36908434cebe02c79b5587858f310a761e6bfadc283d70f84680d45c3f6ec3b2f73fce4f71efed2e382747477d2ac011e4724df6c261b60b3c1d23e55f69d86738239a4d9c1c5c3351736856cb5b6d9bb68c154568d87ac12d27385fec45866db83c00ceba8d30adcb2e3f825335bcaa3bb39f4bb41b563da3e5d9d473fa2b1bc768889293c5f328f1cc0d20065d233878711fb35cbc8c3ca9696a04404f80eaaad6a437a9b49c82b14ddbcf2a68823cde4fe5ae6e5dcc94181cce7b31fb23f5345b1463e9449b6aaf7429a024498c705b871525a79c8f7197fd75925e9fba0ecb53d5301a531ce4cde68ac758b56ff2ebab3dcce090cc441654d0f895182707f159fa57a0daaf2548ca11f9b15cdbfa94a769468ce5a8781cf03960421a852c78791a66fd786341a60eb28ff7d0974aeef2a74ca65180d57b94e38a9482714ede222e94c539fc24df594f0996ba8d91a58ccde5296f85f584f4ab4bc47f9d24038934f747e0096c5ccb28f7074ffcc58610bc1122e3a01c30d0daa165258f6717a31ab885150d076e9bac46ad9780234553761491947a66a108ea054d653d0714aa69f7a956b3d1ae8649043427bb12a685020b5a8542247bb1778ba3c6913e4e7f8ae8c17bcb774d5107da21d729ff85591bf9c05a343c29f5a77b4f2b07f53969c803ad71d14f507d7d646ebf73333653445389c3a2b08613a05d5049d3feaab9109a25a5dc12f5300bfe7f7269f9ab6ba6c3801c7f282e83f72b3a97b9e88e0db8e3396359c0d32ac98e2db3efc34641e7866f329c761299aed658743b4e0077acc944de23c279978d479594fab524cfd5fefd6c000f89bb0c87b04cffe72fa9ecefb39f1a9be6a93b6a2e25e0d6c44ac126c0199ae0561ac1ef24aaf49666c247a4f3d21e166d50f63b31c5359ec3340a2d32d84bb2d88d97d0eced3d8d122efbaa6e56ccd537924a1263de4d279861c2b2ca3513452974a8de475b93128fba2b3c60d46ffb54fb6165038bb7ad75f13f988e2e89009c68b75d815b0d90eb25b8a42b4d37eaeb0b4c4ac5044d00f4158841da80f430fbd9b5ed6249b2b9993e3ccadeeee126479f29d797ae89f42de50ab0ff5f2a714fe214263520755f16f2c258a1aa9eef988e319e3add5f7f59326d3d97a852c18b2f9077bb7e0d232efa66ac99a6269504acfeb971acac9960c68164a9322e4fab5c2bb3bb3492327ee73c2117d63408138d7a70f7be5e7c84aefc2df9a1da9f9b18f8b98cdb0367d7dc1eb99845745e05303759bf76a6045b80f4338c8bf461bd7346bb146b0d4111368bd3dcb757c5e364a24911e448e9844285cf3b8b7e004384c78927cb0554a26a3f788c24f9f0867d86746d49de601ab83019abaa8ecba0f682d6ea308525a755f2d78df0f2bd5152bd7da39cd73cf079c8ba4d448ccc84c519c617f54b95be697016767f039e4124aeb8cae0e49049aaaea719d8e3f96a0fd92c535fe30d18bfe71a60cf35b58b6aa31cec220ce65ff26aec4efa2d9d31bbd7ccfc14e583e96a2d1c5d4515bd884f877a6f4bda45668e33e9abf6e8280540ab4ba9fc122cccbf3afdda5c7a477bec7af1f209ea975d06995d1a767d672fba9dd2a55c8f4276100f6cfe3ee1d831891944a32e5561c67dd9124e7a20ba2d1230792965efbbfac33f201b6f84158f9fb26eae0ac5f9f42f3840773940fb5dee7836b1f964e1e88bb6249c50e74cb2230b79d1020b2156341b0afb2d6ce76bd75c7c9fbf91ca01e8a00850c3e9b02106de5b94ac2a2ae7a0d29c5d25add9cc6681a23393eb971eba5d1d3b2eb3e91a93bf88fb12bb324dc983d0b4254e6b6848663bb5625244d5cd2b7d772ddd59b7c599087408c9e72944c23bfe8b2f9190f756a85aff84c5dbe6f02baa7331e4cfa352bc8590574067899fe51971a15dd2516c606d0362c72f3314ac405cde5b256bbb12c3efc75e9d5b93508c68522c350f1795b835ba33946adf90c12a212dcdd031e461720cfabec115b5d02f32356dce9ee37834c8b07bb7d5be445b9542255107793b83ca037315e41e48b9c148b4481d6626d0d5f00bb71e3546ee982f78d5e44ced46d34b71e52e05f04948ae13d6ceb655d1e469c8840900409079df3f17fb1a263ee3504c2d82eb24d3e76d81c7499370b44c3906933a7caa29653c7f61ad4c6e9041587f85efe3381a034b4d08b71748ddd27b25ff96d21d332890bdb91f142465e525e5a06b42c9051a1b6589957ff810e362d1708664ca6bc222001f065d58e390d1a05c71c30df9f456553eaebae01df424452f0f4915c7f7febe0b3d963a2b65cd04aefa339d58f7706a25c62969c7324b3386a124a915d395b7fb841be69d275d0a24d0054da2707b6cfafbac08accd630e753655b2e1af28ac00e48ff36ed39ddac110b9a0d28125ffe33bf1a089cf7624bb22e4b0118ac178443cc6228a9dbf2a8ba36cb9365c26b898920afb64f3235c6057fe3c7ade0d60c28734568788d1fc9a3e10c86acc176f466c2cbe38c51aea916b92932f5af5ab154d429dd97c98995e316b7d383a910f83584553ae65b442bdd21ae4a0f1c8800cdc655a9c907ebb44cfd45badd25e47632e99eb28d280990553276808e02487de438d458a0bcf7ccc26f8e0b090e090763c03bd02b5b42313ee84a29f2a3d953699d364eee87e25222d975ea6581dc510363c94ab251d8f60320549b103911ede55273c5a54d26b7987c6aee6069eddc89a297d60aaed41c795868d3b9a0953f73f5bde2969ea7a1e4bb77b634d9eb2196b94798f09628ba8afa7b80a508188527124ab0e8f14e0cad9e1087c7cb5ff5552012b6fab0757dd36278caa71da86a08498aab27d03543f63ad0d513b8c75363dcb2436d775d4da17b837da222075f7f95cb8309ea97ff3ccf6306042b3341e73625a115b32327cf071e60d78ab97cda05f6fc6a3c6b8ffdd9b5d51f750c39ac50dae1c0fd32a7bb46592a6ea39248e8a947aacb076375c8c6c66fcf2cf357852ac4c56931d92e46d8499b4f1e2b0328602b29664adce9dae77bde1fa20e8ad799ebe28d631f6f236552fdfb23d9e0284bdfa99562671cf8b9dd1ad4ef5cc36d5ed3516858fff074fb4737850c37885cc1bdaaf55f5158ad7f4a51707484e04df8d38fd04367ff9e3035baaf6077426fe81fc18235764b6a019c9bb3841763e81cb3a45bd8dbbcfdcc628bb9ef76682c4946b06aea453b7d832babd6dc8c1c261cd8aa1eac269d8e67710a05526e8e03bdfe44e9a65b42552f13c052ff448ed22fb3648968efab6f454090f5882b7c06de08c2cc7bd19dc65fb78f2a2c4e89ac0b188df97baa9205dfbd60bdf10811c61f29967c99726640638eca05958a22280037a25d1b7ad27017a72b55ca1ba6ab65b8faf706f77cd85e8fdfdfaa463290f4bbd29b2918586db3b8285757d7bfad7c63cf62c2e98d6ead293233a7625943e7048668cc7f6771144ef7e04b076a9db14a865039a7cdf468c5b0f65b8a1131fe7cf7fa8dd9668906fbb47a8e63adf58a0023e876b1f81099b2520176fd4f8967320e90d80b6ebdc5b09a02f3bbe2028a73dc2c4394fff3c66e73f5baea1416f9f7c2c26d33a6747427a9bc3c859e64978a1e313aeeb2a8c6f10a8c9fd4f0f9915028812db98f4ecf90f79767373ea9796b9782d793f226ac3e000252b6d1c30e4df6fd43f3366a15be5d04a03273c020ac3a3371240e2d111e21a90d17c405c788f0ca1491b7ce15bd21041da70b6c551d08a4342133c5448a107efb04c53836b7616d8ce5adc1068b19c455515e57b09691005ac8ce74de1405ef468f9e2c43132d87fd7247fa0ddb4d0085cd3a046f19aff4a83c3bbd42d329e05e1fc29dc630c9756748c3cfb7b631ed470c519a67245d92fe8eff54298dadadaacaaa123abe23ca9ebcfe1120e7ba09e84f3a4fa61757e1561b658d6875d59b09b50f2c580c8ceef3d8d9fa46eca7a0331f1d9c99e8c68a1af08e3eb112f01f3c72a98d08cfe322bc106779e45ccbb61e14f6f8aa68e8d20bfa276ccd1d090ebde99496d1e6b4b492b2158f3775aa2066a33f9d03b61cc14dd257bcf7e7c257ecfe4443d742458b9f7c5ddc90136878566582f12d14b45110cbe394c5accc95907cb53abc928e255b6214a87442151a20fd8ccaf1d63f6e9e0d9669fd41e9ed597acb391b9abf1116c5a6e4b5eef82133f4be8e5f02e46964c50969b9b2ea53d1371071aaa246c6ac8f8542673d5999310b501ffe082dd17a32226f61e0f4f90de66638d304c36b5eae5f2656ac384255f0934506c86d2e1d769a16719282e1de67b171a3478d20c4a965338e39fff3a69934e6344d5e37e636db60fd7fd457e4e77334afeeaf1a310ac22eb5f75014e5e9f7186976d0edcbade7e13a69b6c8a0217134d9de3705b68a5ff978f7c0bb0a4d573fea81195bfb3814ad3892444fe5da111cd5e207220c8245d07e99ac3cbd40a59910ba7994438f90ca469f4edecec5d0764588f00d86c056e35fdb2ac3003114d81996a4392e03acc50072cacfcc95b76cea8ba6bc73148f937c6b163bb0284485b32e76437324106bb73953da798292d0af836702cf0e3308956fa76915c07048dcd9fd9b5a79b52e56398f36a7be5efe8e38a0b4dfb42ad522cda5f196ab46cc7b8a750d17546a0077762637978efbd5c2e2f370438aed1eb79109da4fef69f852e3882c1c3aa63fe71aeaaff1e8b4cbe08f8370da4043645de87cf38cbc32ddaea84b679c0dbeed3f04b160f8d3f7bee0ad550de1ef04e1edb557e38b5c97a47c62e38de44220af9af55ccb0715a1b4cd94061e8aea16161877a5205c10c12c8e80b57967fbf6e42ac97847236534b530dcc5ad42517d95904a3c9a54cbb6130b2e944f57cde28e4f61df013d8be92f12973201bab1535f8f861deb8d00a20b506bd972b7e3ea44b047e62fa9871121110187243206d3be31008bcdf7cf1dbe2e1d0c6fea678efd6e63386b43bb7307c08beb1f9d39009751397d24d125cfa1703d8d4fd5a9e8637438018ef593718b2d79e5a5d9e427d28e0a8a8ebf15229047cd981b6f1df99daa0a83eed5148c342e1a6f64e66dd85c47c8751b9da2c83eedd8fadd3b915b757b781af26798dab357f4bfe80f420c6fdde09c1627bf3da2934884d9bea24978e29f4a8b0471231b33e87fd85f3387d18020c2f83aac497c10dbef938c66cd7cb251cf5c794a87c9d6b8042c9c92ef8e014aa3c945c741b5c0ffb1462cf6adc0225f6c8f7986466720db4dfabfda26a76068e97b822e4d6b20fc04a10c6e311301727f6a1397d3e89708e59cdfe876769e0340fb8d3152400554af73c1d6e445afaccdd07fc60f9bb0338d74b678dcc788c1429617e0703a803daafdec4228ddaa8129e72549be51004b9215404b981b9abed4399c10a571255ea67a51d590067d701baa1e888d9f4f928caa9ffab7c74caddbfdb2f99efa3658140a67f94c6650644a900b5ab51e488c143728f2c60df60adbc2593a62a1530eac296bfbee34becce16d20d241ee845804eecae931a4d7fe48e8313302f6ee9c4ab3912efe71879e84d7b8af7647d886f9f9123188b12897c50b3d3d2d24c90815b1527ce2aba0971c1b2b4d4484517700b768d00a00db62ac3cb81fac0613bd216dd89c1a98794b4927e5b86569c1c814aafb86d0ad5aff084ce94875075c7be4c5f10256677447c66edef3df7a0288feef1e4a43dd9a6af932155a4c5cf50dfceb189a51ba9eb25bc0fcc6d4312648191f117b2d896dc5c075953e1b61bd7bec77457461849581b941f70cb2d0b3c3225d8dfc648d849318bde0aa66c04fa7fb36b44ed2271a033c47b431d6d166baf299bb462d03771973c09eaa8b4348dbca7b135a433e977632316b5be797ecc515d862c5e587ece7e817bd7be557e79471e5b60b31dff8bca20bbe6c318afcf02011631a360fa146e7d63b08c90b4055dcac9164bff0a014fca6aa349437855b805a57b900a5e4b98b5aa0720f2e243409cc0b4b2b0642a6a18f24d6b7820aca70c04a86f28b47e43a8e265b2156c7a30ab86f7fdcd10b5c691a2f1cfb1f424b76156f1becf0c52836db90dc8f2adc6933b19376d9564844dc26f6a10562e544cb037ebdf6060b693d58df3d807dff7b96249279efb27cc9ba7ee10d2e779234d0d2ed5db0afd06f38452efb129f9376b0e52419ab3b6e9889064ea53d89267e182674660150b349fedd3a677e0609b7f148f882dbe177b7e7e500c5bd8b2000b81b2bbd4c21c61c96f3e2b63285d3d00a781f40eb100eda923aaca2411ca2341e2f8673b35f3f1d047f60aa7e0f1f6aa20638e4af3437613f10922b7fbdf84dc676b5c529eda90b979d4587a039f1754618928be9e881ab5981af65a08e90f03a9db250f0ae2c3aaa0e243130626a6bcf0bbdadb94a9fb6a16555a59f8ea04882dd42ada866b245e53250e1c9ea68f09138c3d4c47e7143ecc315abea8ba01fa9e45e3de7abf3d1a52c241a9671c6ed5ff822adacc4d25057728e4be79e6a57d4526a1e5282ff3499c0e659f570fa034da86c11e6198380f0b1f3d153fa229419b7e9100190322543f816f1ce6dc65cfef40db2039b9838d8f1271ee5eeb95aed48e242489557a5805db96f25893c7403053cc7051024bb6f381ab70ac9061cd5e3e0063c8951b44ad8c2f72a549cd6ce70c5c8a7c9b8b25b3d789c4bd0e8019056b607ef1492e89f62adf48154edf5938c3e0429aa44e8189502e86da075d09a139a8c201085dfabe3ec224be344acd05ad90626696110601ec19bdbd91ac0fae33d3bbeadb63570be6650850f728d84d520dfce9f546a125f7bfda50f2f560638c803b14b7253146e725d41bafea2cbe4cd6b7a3009003a4a3a590889d37f9a1744a60c161596d7f81ffab1cc5950596a24026fd87cbfdab1e3404f7315aeaea381ba15dea15358fa689d1d09ce28b15b7344e19437ed5ebebb4c8320559cb22e8647f364b327fbe36b31427295bb127769e5d5d3ac83c668340c6b3d1dc47984b83175882247c319d4fd41b0832a75cc230e581c816e1801424e68b93deb44420914743089a373aa3b95393658ff6961f6c042946c9ab8079e93bb44a8289f4d84aec53236989e59858b757e23e9fdc8ae4aa839d61a27ccf4fa703eb1774f27bcf433bb5a8781fac0f2f4c8f107b882cd3f8cf22a1e89044c408bc790144de9bb8b295a161211d79f01171a6a1e44d5bcd1d3f4e191b7635afa6ae61a96bd2fe50e66d71c317a12cac1b4d0942273569d95f76195fcb9da655fd59887e346bdaee20234da2ce00a8266d7eab66df2fdf9817c2541d19b061b07fd76eab7302f85036abd3f47ee53f79893da9e3dda4dd7f9015e852b6a86559e7f408664cb5af90c24884f38eee15761c0187ddd90eff2efdb88777f9331d64eac74fc52ad839a5aa460855235799e4baa7aaa0ae6651e4ddc628af2da5c4f60b0a48f06db90d2fce222d2ac769fa8f06a1c7a7d5c2cf31b8804e80d9c999d85884590eeb39929561ccf3c1a3d48294acb40fd45956a72cd265c709486830dfcf221d52b35578a8e636cb6f71b2910729d833fbd9a4a5ccba3b5086ad7f923249161182b11560ad72ddfb7890bae1ac6e3ce7490ccdf3c776190c058945cdd7e81163c9cb9575c1ea095c214a9081caa27370bfe3aae1ad89320483b7cf8ca3f313eb285174caff7f8c45ea054b0e8f0c6bb9c87ea48dbf00588bbfcf2565e45bb3104351e9ca2589160ceb45a0fba3e847ce005a8bc8019b2fa02e2f2d97a2c67181a2ee77ed403ab6c76abbfab02696c74aaa04bf75ad21148aea49624c5015bba753620f0921cb42ead32d2c680359c373b86e2639566e2dcca09dfe054ded5e87bde30f061c0b238bbb9d166787ae3f7d8e1951d3a3f66200e632a2499386012471204c1870738d91ad3eeba0f194b456e802168951757fc57efb1e4f9612b53f5474d05f63974adc5f28355e2d770b0408a3cda6115954a1ffd3acb4979cbb4016b1260ffb2eab29c6297545bd5a9dbfa8aaa0e4c8e0cfbf03168b7256c558a37c42a0cdaf9ae366af7a64f67143ea75ea0b66803738238393ecfa492fd62146efcffb929591fcf0140cfe6913e1896afb98e229adf0d00133d07f4cc104ec0f09a3f66f9d75d716f397b5afac338263c2b6721361513a56562c3729d7749c5b4ce9bad9aa53230e79124e3408c618689da3be7271c4db77f4a79192233528944575f41a2979043eb190aa86c211d020ab801da10827ac09e36d7e08169ccc78ece64c9515fad60f0795c598205a62883a8535fccc87d65a46535abf61444b31ac108debb63c630d325f5dab18dbdb92e47a2364fe66e83c8f1b26e24e832fd2611b49cdabef04ea35afe6eb7d138b5379e617e440fb6c8dafe0efb6e7a86d259cc540407faf0db2ee79cd1f20da76166e76e57c395388c711b4f88383d2ca249d436a7826878b83a208a803266b46976b4cb780bf1a7f840225d53dc72edb88784fdc6f6328ccd939fdc50fab2b709489c29b784d54cdbd06f26626052df7def69e4a430ddcaa439e2a393f3fe9733a912ca15294e0bc4cbafa45f6a7ae51ea97409ad02d74a002dc7c63f316281bcaa960d547419b1e7eb8c1011064c4dc291b6c7ebf0a8b8fa3494cac53c39787d14280bf2b936111774414b7b95f6fc47fe69781179ebd0c89736b021494f82716c8de9068431f421f9a9d99c60dda94f875eaa70547582d0975460fa6bcc5238c5aa66314bd87748e547f7776207b910c507a68a6cf31c0c507986b619ec0c253070bda72ded630905b067839ac6f6e9f7612a95af848e1f96e8825a73c7a0e0a978ce17484912c327b5aaa1c234c76160eb5a5b45d6f99ab72ecfed56fe91c75fcd909dc71cb5fe940203ab3c26ace99c23ac67352757e6523f528f2158b390b63c4c00f0756dbab16fb026d5e9dad982d101f96b557702c673688aef9b626058b5d99fda728ad61767aa136a2c45f7a27387a4267cb3ee0a2002c714ca9dbd980d483aba5c9cf4b2db556abc9a8b3f07fb38b5af6708d9217001e594474e7f88f7f7209eb0158d4ec281a55a92fba680111563a5e07a637551d12eababdcb96457977ae76ed2aedec3b788348b0baaa749342bc7982fb5af3336e750b86369d43a95aa0bf167bc25df99d124e00884d2154365b7d82965dbe091961af382acd72793d3f4caf6cbf325333876a697e649637ad68ab6b21e867b7a750a6655ce97e26cf1d1a5912fa1d8266ca3672fd29d3f134529a069e8b14848bacff5e86cd11afde1a2dfb0298cb2157060806101b52abd4cb11e084db8f596e3145dd7c9b91f2c67a5a160503f993edca68f1b1b72565a65d14e6d827b576bb65986cc857d192fca4b36900b5a6bbb596e43987686d98655c4757850137890271064bca193ab0ac30efc0e45b363468ac918b15bda31a3a7768b36c9374757622ffd44f8248f691041185ca95a81feb1bb26bd5fcbdea72e1a899e15092133f182f96ea55ad002b26a9fd08494612310a495c4690aeb74a214a09c3ce058d18c5bb586b374cde979262082d3e9715994675a32b48cb4aaf08139e5b727d59a674f0ad96d5401fa09b54f0b8826c96dddc624db5e853774fd33b894e6d69d08b9a80245113e790ab15a7d77d14ef2ebd83a8f5566f9600363fb17db10832838f1ccde42431357e7d76f376c9108e70fb06024a850a5c5b460f5156f6128db0b4ff5ebbd6882e7edeb013c417de3739858c6472eb690d08120b69d7eb0170372101d764135c0760b01f4d3013f9f5c6bc6f7aab089f679d4d5f0cb144ee168c03a1af6928904c01a5e614a82d0052dc744ada0a115f3706dd4cd02c7818e3d2b046d9484bb7d70085138f4e6aaf1efa693295874c74e88e74b9c0f2c23ac804bd3834bbd5b460d22e9d1ce920680ac02dff1adfc4aac6f254f5b82f3ffb862b3bb770f6d0ebab2b106d52ff5e0c464dd5bbf459d3bf8e47a95ac671e3f4c50bea7936fafdc317d58193a149af10af4233526e681de3d4103bd9f0d693abc92c80f62e557510c292d243bbf1c0dd85be9df8d21c0fdd7a5bd3dc192b4ad661b2f559e5e58367f780448a41774cd62190640306e8913cdb89fb0336c17b3915fd9a103d4586002a81cfd4ebcfe7589b3b303b61c0e7f9eae218a00183f7bd534c574a0e3c521df8d803eb7770f8d8ec6bbbcf19980fcfebfd799e8fd7d47c45a53584cd119ade37b4ba1f4f5aea0ad1959fc7329a911bcf2f63fc443a0f935b7b53661917d349580720adfb7d3a5064ee1527a491d78f3419b805d60074fbefaa3e248bde290346c58cbd4e168619c927fc5926a9cb96051675189bdb6271c03f22f691aa61ef209455d3e7e3c16a5c707d9c763eaaee56d604f8a3ea576e3cbadf3037382eb0262e8368cf0435b3c73006f33da28533303cf0794b7ead85fe741e2e9e6b0033c9c57f7331155afd3b42eb1613b3c23924c2bbd9e6dff976b42dff8f86af11de7124a8c3a5286fac547e3b56dec1cc31868069ba74925cea28d18ac89d63b1cbc0cbd36c3654fe71af81c55d4605d0f89e6014ada7b15a3b52bd39b63c78feb4818effb1e067d80a339c81aa507b963c5eac66ba1778b2f28aa691a4aa0efc68f5d336df08f6424913987f79be7cf4f0cc52fd8197d0ed351b3ff47b7498ef702eddea82a57c13dbea8e857f73b6fc56f9ed78bd8e1afc71d7d18f87748df478b14f5d9b36801e0a6e0be04c6cb0456ba93e0d598725ed7808393fc7db12b075a080918cdf8677deaa690235a3b2ce02ce111538dfaf38da78a0fdcf8981d63c2242f403066513986bc0e975bb3dc6a8e170dbcaf38c0bfac7e3d820aac598abfb04f0a83b399fc80620288fade727afa34fbb823bdf99c90e9f5dae5f0794b623be13601f150ac6bf6688c207cabd3a7397bac2606d1161658b150689ea2000f1692ea6e056e2815fb4ffcb1b76f2f8ba9576c7aac71724b09ce257b41365cabf8fbd0bf003c2878285b3bd550b15abd834bc6db8c3d4dba6a7a6e5175ff522b5e06a082cb7eeeafc78b4fab55ec21b47b36cf00827e79faae6cc7cc02767d0ea26fd1ba58e349a09321997f38afe53da04aa58a8926b568e1b056bc71f2c6d509358ad43ea3436a5ac9289f1411e73c5b5db6779f88290cb440d532364d077305b2bbab574d5ff81e95d789e7f929836c1f8bd68fe9f5c90e78f248d075cbaa56395b6267ac72e77b12d0c3847b5a6c21bbfdf1289af2bf8474ea65c47b2412b0b0369dea80eacd12a9106271b4bbacff96dc9ebb2d79ab083dd2400bd62a63b559d9e521a2f6b9b977970014ee3ab84df195e950fbb02f56304a628e3b1120557a40f980986709d3a97000867ee9323d2a567c6461c0d0d4b8f00a7335a0a7748064b742e7457033f4f2309b26e5fa1d45ca66127423ba713e6ebc9cc35bd63d1489d3dea28ded916e9cc0baff64c74140321eaf94344cde9b5e671c9e650b1774abfa74c8c684c012f7412b0be15a50158c05906a843d086404e652b41972bdb4dbfdda3e4fbcf8327626c83dc3ab3047bd6a2354092418d5b4bbcf2ee9b9b68dc0154fb4ff7ab4f024e6be3732b683ff4ab2dfde1f78cf35cfb8cc5ffa880f16dbcdae4895802df0f6ec7536e48c94b8a19a150d756e19828285644c634e4b352b51e6372ea2f6fa5ce0c16d51884888a2f71de633889ad9e16e8938d64b45614c1e1a9408e6e91e43166dd236c1065ad4e9f34d89c0ca7e40fd19a1610db0fb70f73d649a9dde76b3ff68f9e00c6aac51d725c83c6e1c95e479428ae8989fb6e5ec3a6bcc53a0a94f73d102292642adaa2cc6a882d587b24cb63237243dee45cd092941d88bedc81f45f0508b626e44e5047c677de9f9ff4e85985fa1f2ab177e68d3e9769e1108dfa1caeeb31244a0afce5a1eb5bda6fd7c5034031e3542fb18983db8c801349f1084ad736bf6cbe9c820152b86928f44e23454ea74899b4d3187f27ec52a338255a3dbe14e8d0847c03abc45123a0179cc8ba14bc2d54901c6496547a9aa6ad9669386ce0b6b51d1dba263e855daa1ce4b71c76c43ce5a6c27e5ca4eacadb8bc4e9d8fb0f2e17c9e429159b70c8cb9d7cb81cadd2821a277bbaec8c47a8e41bcb17550edd1ad9b0430c238102267ff92a773ff8b1c4f1e5e77e1b7d875c3f996bfba395e01f562fe309daf3dabbe783ba33109eae0f08818c26a513a30f3ae4c8b8d26ea3c8e91eddea20c459ee1bd97602d969200eda8eccc05c32eea19d3225816bec367d63472ea1665922c871910259f348a9238f89571e39a217372cf4734fc62c534042f94619e162e2bd205e64c3b15306a02b23343ce8021bfd2820b19622ed9ba459052340e7d153d35a89e9230c43c6a090687e475e7ca0edce6430e82fccd9ac5cbcfe6d5005aed31c72f54b23b1236eb19bc6d021ae6a617d644fc9d56acef168e47d34a7630663d0f84abc1c598f44385e5d1ddf899a42f649d42ead4dc562e5af699ea0f65da6adb9a4c9cf21fd5603fc0b447a6c7e2dd3c359fe1ed8d7f2f43cb6762f12eff0636961e9c1b88841460682a9a1c8c5581fd2d85c2e3ec5d80ecc379c6b9842681b4e18c4fbf6ab43e3052f76070ee8db1585253780a74b496a83f7b03e41b8f07b1953f54b44b9988df34c71505a16b62907cb4a05799799f4121afdc9a4d347b42e2b40e60527e2d657ac8e036ab0735a1cae36a967bd58efe9cfccf71a888bbb08659ef19c323ee7ccd51c21e77763c2cf2327d16486c45f488efe3f95f786bfb00849c02614424d568e087f58c1419c8038b54ab7a4338a266ddbeb51523879104da7281f691358617b55763d025028cff4edd82aa739d92e458ddd78629edc2aab99b75cbced2308311baef76584dacbd6d298711007b79d017608a82ba5045d94c3c22d0d68165c96473f459f113c1019e90de4561238564199d3dc8e3e5b36a3fe43821e3a9b76220922c072e717887c983945a8172ab7f96ffe8c0f7c5d64377d54fa301a9aee951f631c810709e85389c483f45130859a77ef10104e89d10b43d6b291199f5854d35293735229bbc7a914584886f1f72de784b651215f42d47193ad2b1004b3956b0e7d0d429fce1fb7e78b22ce04a18dbd891be782e10a95e0e0d79b18d4eb4b9e95ed9dea2687b91e9bad268feba9ee277a58f2f61dfd7314e96e8a21ad3eb66a09a183e52f1bb8545dbfb0a6cec4a797cba59e374ac003c1b87da7040a735dd57e43705f7bd57d0ef4162c938db61d55dfc95265937e61bac5f05cee3116d6fa463f4462cc76c7346a54b8b5ba7021ccb6f9c101b2b2d8f776c8920999fef492ee428f37b6e358fee83a0028ec56ac18de7009e234d2fb847cd071cd4da474ad7fad8e90200289fb52f9fbdfa907ac331e987aecd7b0a1bc7f0970cc0d2378394bd14af5be5b387a08e1e7624df3e83ecaccfe82b89d950ab797e07577c8310395fb83d1553f98a290b4df533c49dddfa1d3367042f4a2c07846ccca263cf9803682baf50e4d36cacfa8276386827d6b519efcad672376289cde8d9beb47230f9a6c0a995e324558a7233b36a91495d5bf1c5231e7ccbbcce84554c6db30f4ea2c69ed8a40ada8474adbe9f028e94f23e0e177bc0976bedffbcb3b0baacf7dff8d1ccc70ef2dc9c1b0985a3219e16c69ce67f659ef2022269cceb8d2390af28355893871bb0c3117017e33c24b15d2f6343d7e8737364a905f2d3bf76b2afb6983946b7dbe5fb72076cb924107a7a2ab1735b9e166de5613f1db6d18bc6fa2718c0069de17cdf4c7f6ad4631b1b3cc6b30a8f0c16942dfe3840bbc3913a54b887ecef1d0c55a621c40ce6849ec9c85c898a72645bf21fbf630140888c29f0ee2b137c26c2923073972d37c756985d4058dbd84dabbeaff6feecb3e5bd1f1b10f74977437d5b8a93d74c5c3f1273e4986a09bed76ae8264ba7b6f83cf0a50f1a357c98a724c99354b254c93928100eb614a7cbb1b871f87b599e42ec38c87f43c0fc6bc234267638f9dd65c2acd049d07905cf66952daba51e4cf7148054fd6f18a0a983f583f0de67951282d0746973beddb1ebd616b5c9511c40dc8b62f725f80befce7962231edbb6ad0a56d0f777559b27841959a1abd060e553ec9a1c3bb7d24540e0deebb4cd90877b7e382a3df114f3d39953d1456beeeb12a667e7860faa9c05bbcc50d26fac733241f24d3a0ca331e8f09aef4655b14da4f36ed51fa5485c58a67cd6141a6a4e37961cdb9bd65d86ee424876d8d15d0e353da6d0dd915567d03312ec48ac2c8ed5d168530128e5f4ab393f8777b6782e7e042093bc8755d430db1cee3e5e6096fdd58aae64193dabff6b76ba1cf77313f7bc2f65a2a0ef8210e98b1ead3dae6e40fe846c34525537e3585fa8b9c3310f7878b61a02e7f211c2af8d27658db4a3eff207603bc5d02d9727145bdc917d79c18b2947fed1b44b0137be3383f0819d2c95268d6b18d294bdf63b2f7d3914549f6b7c537857e88376302bbd31ca9f1eb0b2efeac123cffd7a0bf716af9ac3870002415a1d1f2a97583a1617ec24b7a9234146eae3ca44c250e10ca96a52ec149c994355aeef51ffa88e782af823f55ea298f1801fa935c871a94d3514a1262a33f9c290acf488456647a17e9f373ea1e666bfc6fc929bc938e432a382ad33007f23964560c2a25082b8fdadadc14fe44e81f521439d4a765bd6262a4894d62466e1dce63bab4d0c5f1f5c86ab0aeb6086739fd6574ecd10427970047e3a2e3033315e2671b547ba4922b9b09984c09d8ae4cf6c2ea46f12cc5dfc4e57d6ed4b975bc188706a4affd78a241b71b96f5c74cb41420262fb45f4a81543063e9f4b6e961078d81c4b1710019d5363de264ebfba0da2795ab66315d40be65e80d32ce4ec39594cd9371236dcba884365eb542735d3b95932177e84ce17ea359a75ec1117b3176e4a2e84b1ab95017d34e477dc07bf51b393659acc095266d65d6a82a2add7ee33f1ca9130e2b3f9ca3ff8dd1b4fcffa2cbc840cfb222d95eb6e71d07542fa32992344afcf0264caf6d8ea5b30ad8379201b1e9b5d45b9fda5671d1e0debf9ab07e69c5c26a7aa36324ac9ad2c9d0fabbabf9a7f83c00d05ffe808266fbc17c9d34b033fae1bcae17152a75ccc10f4690154e509a5e799be33837c381eca0c5ed07e03b45f1761ba69574a5bdce01e4357092be038952038779e4f28b2cc0192299609b039cf221228bfbce5c96e32e0dfc69739ae7a5bb571c944c53ab00c393be18f407ae8dfe646586a279847d54dce619e4d96b0c4c7fbbff845dd82e4b2ccbfd6e7b9dfdce0012c7136a9ed458003d10af54db05de058c683c16f94168783ecca4e23df0cfb220fc5cc803ac2803f19993ac97dcefea32240b82734653f772e022ab07927655d0bc34f93eacec4c4b2b5351b3ff5d17bfb68494a87e2fe269d4f0e2459a41c586f07ae8c54d809eded774e9672efacc19720c3128c3e12a6e06b4e5881e7142e7f19e352bd60ea0b3331769f65ee219eb52cef7527f29aa22eb698df8e6d0e3a34d9b3211346eb123195914a18c0ae7f91ad5ef0367f8db92151ed4bf2c63bf09c76aa8f63c14b9c4e3e66b8af73c272ab1e2cc8c4b6600b1abbd868c8dc40813fda383e46be9bccbc3e2f6dc899e5dde93300837fdc1a6770a9118facb7e8186c2f1ac3414e83df75bd5a72ac00f2d668eb8a2fbd3f347bcf83041c060b95954427670b826fa5d34b02c348ea54e7881c82ea917a7c51510f035ceee6d5645ddb4e55089a91ca286a8d275a11cf70cfb099d80214e7a26fb68f88ef0bcd0e75fb9f70c5be24f33f71367ce624bc0bc16544d238837df8b5ed86e9101751bab18261d84b184eeff256c310d246073d69ba476b30ab424b4eaa02127973af6138c7aa896806a1b869d20ce3342a649eb62b7a2d7ac72062bfd80782692ccc75f2e8a78c641c1b85cbabc24da9d63ca953c45367ca52be1438c46bdb45def84d3f1425d9ab260932ebc763fec0d55b847a614b0735432484534e1d1f210f6244fb749412e92f42a3345d8df9837e7d10482c0e46e7d3836c8cbb5a290afc2a879d99d693a66916bf0dc4fb7fcd4b1f0d390edeae3291482fad78098c45a517069dd33d7f00e0ff4b946a6d280e6f34e0d597ec9a96ea8eb426f595932dd628d22693d3c0b73593ce8e8cb91c23ebbbf97ba0336bf23cb0cde4df6cc799ce1a0d46ae333e37616d775608081f2002b57be9ccc4cd55e45c814ba265fefb9e9a922338580ca71d35b6d348f5c3a1174a1d163586fcb0712663209e4145854984ca3ffce3e453a882b6f724f3977be1e9b4c8d61087a009936fd49691f6c8e770f07c608ccedb5d489ece28b9a1af3d5b262c0cb73fbf984adcf724b659ebba442cb8b08cca31bce7db7bb85b2c35825a65e18970932fa2796b69eeb43606ac65fcd22bbb91d98a810211afd3d42a6ed2f0f251550ff195ff09c6fadb112bb3fbe0d1e10cf79a8d78f313a3a152976a993e83802f253943f39798ba8528ae1214107f16a471a51228ce40d1d8e8a35bf776e65511a3b5fbd22caafadc27e0d2e2e3b2da084fa8b9d478595f9ffe99efe2e97e3162001229bce0ffb9b95d25a3dfe83e59da887a4e63770c1e5aabcf266d074d639dac71780cc02d149cb906b61fe4e2ecaeaa6209af01e0588177d1263fd2c0740d5d8747c1c9fc075a8633e784f4c00b292a7475831b626bf0dd3eedfb702528283c9b75b367a0448cf6b643c60de3c2f188fc41d2e7bf85b1f86bf02c12f697d500f4d66b9453b98ec805d7d79f8333d4a9a7643692264b04d7c21baabc728e51dcd480d7bbdeb1bfef56458c76609b3d2c790e366faa97497b5851e8dc4de6c66be1c503e69626af206c17cd46a1dd051cf7ba983615173380c876cceaac47f68ca0ac53e7ecab795f5b83780510a7ddf0050b1bb088d194ed6a7ff49bccb740a8c05d774f6622eae0adc1cee85c100f75108220bb07948fb73dbb884a9e1e0c0708d63c25bac86d07e244c4810a70f753e6ab483b6ae46e3509240b26180161576d84d775a362553f60e0b76de20890625edf07c9fc3caadb87eedaefc043b148f5cb8a270bc0e5368c926d8b0ee5d7c5471ab7c945dcfe570bb3d6b51c04251740de7156bce86b1a82ec04748f0cff566e45412963467a0c2bcd9fbfc4a532d9204f74d9ef74d25c0e13b720340e1b7b41634add015593d8b53bae1192f605a6d6cad1308ddb3230840c46e80b4fd21bbfff5993006fb51fe3d70bdaf4c0c6e8becb24f2e972cdefd80d09be166d357dc8d9d28c276065d68b6526dc77bb9d372251aa0ff51e2116c95d5eee58a76fc035e6acb2d1f3faa59bd1a2bdd52a48e6eafd39e4ac36748f614d680a052ae5871350456922205f6654d490c82ddfd489183006b3689d371c3757e1d010a2fc092b51c8a07c50924e21486560de79a2b4f1790f815c9a45bb359763a2fd4b27f24d62d6d2f875746c9b57ff1c6dec90","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
