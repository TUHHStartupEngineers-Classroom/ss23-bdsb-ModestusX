<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"387a25c26c019c9da20a90620c34ad99c7ed63b5d50d2ed0297672bf7fc02737ce1ed7932ac023630b0ed84c5dd35b0e85ded624f46fa0a42153eb10ef05cfc9dd01805375820b219e24c0d7a7bfed65cd76bd147ea86b0b6fa29d3aa8c07e7483214087bffa42ecdd38ab6a6051e599fcc1ef9a249ada30c78a9689414a9e0bc4f96083d9db6f767b0024d8a77c6ffadaa4992251071bdc74d7c5f20ec4e37a3c93b368d197e4f7468e480903f2519919019ae3f3c3eb22597128e7bb924fedbe9599b497fd359f990c40be1046de1503f6584e2c8d9996541456e15a1e0a89cf5c7fa6a6e9a2fe86bb97effda22c13858c5d9bbfd2c1a3aca96f2e285f3f38c5f832a7b2a9f973cf99293a0a1d10d50582d64b09827c047deed2ae0c8708405b9a82c151ddf088a5a836bcc11c1015b6429e7911caa926e7d357bf8001825fbd00f788ba2475b3033c557ccf2e04dc35de9feae0a654af321e99482f604c755582b5760afd2caaded853d8e9a6214b7c5c3080db24daf762814c8e31fbe0b65b4aa5570766424671f497a412a47a30e4348405d9ab12959eeb749a83ffc9fa2752d6c2b9cc7412c17e0cd15b2d6338ad670328c52f65dff45dcf21d9dcbf2bb747aacd33f18b3a9aea80a0f555e1e3818a5389651a32de16afab488c5985c45f4e52682e8e228f12309385a2380c0501368cfaf3d9ca9a801f1d9ff1aec1f90381bc1b4f6fad11c04867b209c7fc0dd1fce0ef0ad0cd09c423cfc1744089140511fd008a2ae82a5139bff99ed972f4b7a606f297051072f918940a8a7dca03a8c829dad294b59db2691051aefc81fc9bfc6f6561805142efaf1829726874dc286e797fa16ef7110faea6259bae930b21f9b4df4bc7c6d720e4d747eb252e4c4341988ebcc67c81c4f7ed3aeac28f083fa4b119f12dc4ba2c5702cc85edf58ec99959bdf708a6f06279b48b050a90ed261d7f36b7ad3e60f4284dd9367f43a6bdca9824d2242d258109305cf90b2f7275d619af0bce143bb7e95eb98c633c2a6da46fa7c2d0a61c2a863dc2e0907754b578cb6bcd39b1afb4e21c94a3418c980aa6891ac33447f16c36056219ad1a1e317ac44df3c0b49c8b87f9dd18d505d109daef2dfe2cae198880ce53813d807775fb11a33fa24c93565e4ddbb12dbe3fde8403cbd6f5a08051b5537ce3395317322ff8d21ba1c81b013ca55bdc6c6fd10fc28301e4758b09396c2e904f9c30d9ad5b9d97c0b0f2d780102fd8bf403554939802bac666fad8b1302d77266d5bbd150a819dda756b595bfb06707b2628b327391b67199309a2ee05d6c6c735759f92701f664481513dbc7e4e4273b1aeeed59c53901539e11ba0114aaf052087cc497d8be5580a5716e0219c38f29b3b7cbe67ff223c71b34bd50fbdd986a40816d9481e24064084780bafbffb9e931deb8bac6cf448d85e48e531dc8edcd22e65886a3ee6fe32763528de95e70ffe5f92fb609bf567544cdf6eefa6af8bc5219a557f1d3b386973c4ba6a4557fe400e088a8a71ea5448605efce56ce8cefd506a4bd6abbff731d5606be3d8d3f43ae7d79d428616ad16890322bcbb80919d12fc1704e257285455b64d56d23e26d8d26b032f771c854f005f08d3ff64a61d9e688999fcb2b0c22af4c31f78488189b5f8f05e9e6d7f87f2c8e522dcbb68e103781f09a293fe36cda7e54404a6a1ee6bd163bb13016915a6fd1e02ac824f9132ea73912d088c79a8f56ff571bbb73bbd476b16b40e5f8315b615c782a9844de56a9ebdebb92208a7e5f70129546898777639bfb46387daf1bb719b0343cf5f6a386c881f8b14065568500a983c517148fa0a7df1ad07ca2800e3288258e3c209c10c6c17d4331c1cbbf6aca6264617375f3a3209c346ed2e44b651441ba861ff02d84a6ded9c96885e38c627070b69adfdd16c63e36ed0472601b9d4251417edf81f458f2e42f1ed008dd4abfc51a3dbbe6bff2860929e40d953b8f36959e7407d98862cf3dc0f213f023139a4501255e3bfe2baff78282c8f784565dbfe71d75ef4ed118bac5498761fa47b907cb705773cb08f810c47fc3b110b07a784ddcfd1f9db756e4910032051d9349bab8d26cba094d730c5dde466111c4d43ead8b6c6f089935f2e44361b98b1bc7f524b0730e54bd26e98f8b989e6bb2e20bbf7b241870327e6d7a48a4ad72fdce41d60ebd4f933a928753d69e24a652828b481b184bb01d9abd802602af810958d930d869ba39f3a4bd543c9b1ae19ea85a5a6c90dfd0542052d78022bf6f3a4f0b7a3cfae8867d84721def609c31945e7ad7eef5d7bb04db0e3a6146f4e008568294ec98956a95fff31272795e42f2154068590d3ab903a91363ffb71f239fdb1053b65c277abf35774d02992d93d46fe939bd156446ce5bc7bd82c5ce89efe5ed13c34e8295dc93f7e5a5d9f97ab562bdc7dea4659aa52cc4a760d002986319ce6ada44d868785c585c7d850325416db989ef39bef2e560ec6e3258e5c11f7e74aa69b96fff436422df28d8191525b0aec5765ae5541fb1bd01d547d437ea3a10cc3fdcf5e2a1bd76d67b4deb035e379360ddef7eed328aa668d3bf38dec6dbb35fbf2e2a3250aa6a2f3d39cd103b585e93d36dc667a3104b3371c7a125355c8ddbbd4575b7f51111a167e41e15ef7abe0ef36a0785b43b20d52d21e5357351d40b4d269366a8c543f2d7175f23ee6beea0a3d1c4fbc299361761fe1ca2900d6933de4e4f209761755d85d3a81bcb5242b2395048931810491dc5a7be06f429570c85942f4489050054cb54d786578cdc359851ab469432a845fe898545dab16862093d528b12ed876874ee02a0aaaa5dc7b213e2a80c615edf9c03943fb9fcb7c28ef30dc8955eb5212a0baecc4f69b8f251aaa5c9e774a377e098643d12f2e346f4cee0792e0cf864b6e8765c95ab7b0742326e33866452683b5df81e25693fb4d4ede986cbde2994ec2aa7e63428268983dd48158ebdf3f937cbdbe5f827592e4dc3516db7a76d86f7869242f12c2b689f6329f87e9905c894ba998529da1fd7d096806e6bede0d8985cb04e8da7a20285496f99051348605cbdc2c3d9fbe597f94a25944c087eb9065cf17930ad8b6e2d1924bd98a3ce33f8243c7c084b2335e27da8074de795847bc789fa6f5d9eeb2e706a93148712df15af789862a7d5556a68765facc17b71459b594c1e2b021ec138fe391ad8889e2abbdbcf290246762734fb81bf9f70e8c21f560371ecde8c9b639ed54f9f660bae4081b31eaf65036b908f30c39d5bbedcad1cb8c6dcf5250871fc27d00c910614fffe1be7f99ea28845c2e5ca1331e303d4131d592c857a8aefb0e331de373af25eb257865324e5f91131dbc7fffe5da4bdf4172b4d124ad7fd169d80557a6c85cb6493cae6bb1bc76bf0cd1ae4e1fa5a2608928b859ce4fb76b3ad79e3b813c91fb5d04a2c7247a65ee9a42028bc6841bcd733085c12e00c40c432b45a292545e09476be7a7211f0b7b835d4ca104740771624d72c53658c3b81e8067c346fa3251303257c6bda46d5f527d10c09f1f2c6e692cf1941773139824c9e26e7494f20f18dbdaeb012249bf8924f4fb1601286708d08b8e9dfd2749c4cf25bd4b4e03cb76e9ddf42bf29905302d09b89c7e93d68207eb2a6430accb206c151c6ee9cf08fdf31481d065730bed98aacb0e130077f663ef2888bab16a433759cd42f601049c6843c1273d3ee538f31cb735e802fbc6638ccdd3383d309c1442255a732e8470a39ffbab5bc22ac623fb0898fe5162fba314e0f3e5c9cc0eccaa8a5d7cfa3ee32a0389efbe13198ce7018aa088dc2e6c00193d6ac80121f35609c622cf00b2be7301e15fd571e8e4d134aabde612e9789cb034592d8d1a5c2df990c2d392cbd995ca8622252c5dc39780c873a9baa06a3a239ebb6ba004111c2aaaa42d958d0c7975280ba8ae4ae8964513595f2e50924866aba5a8de426338b5227e666edb486ebde36be1455b99817c3440810163f0be8bfbc1d4649d66a77c1b51b8dec363fcfc87696fcce1642fb71c0ac7c4e144b43744eb6e2b6e62b5949d5cbde101d70eae01304189e9c497e05674bed6782b011f3a3b46f76dc7f641a6559216b4e93602ebf6638e177d43c686b63594415a48fbf0f0974299068f1b1459fe145051c912cca4b046ab1ea137498045522dc722352badd029f29ca4d9936fdc79830c5b4dc0c7a960e4dcc2c43f6d5e14ea6302dd9f76be0cc7bb90f05042dc8607f26a85327d992c945c8ac759548e72ee44671df7507027a4cb948d200ab3d3eadc364d81d3d3286844b1cc3b0491e3796313f5eab109c51762059e59c3c697bb38612e27c27ba4c03a32e8757893c96f9db1272ef74f596f0e2b6543afd3641c1cab52f1a38ef9d38402b7687262cd71a10d5beb3e2d4c651def6d5f3b9b8f97ab64bf8f5eaac50fcaecdc72d5fd88c14bb168b537d9c66e3c7a967f9809ce43efce7665d5e6f94ad62e28cdea3120bbaec597ba5b504ab0c730dc205b9c6ea5bbdcc121df9e38a09e58ce65cff50d3641edd3b4ab0a3fde5f584338ae29ba153cc877662b24afcec10270ea6565c3bb518eec4009c5b061dd57960bd53d30c36252e1b87290b26c66e743199448f25c842ee91d1fafaed2d0458e3edec83a51c7520ca167ef19bdb7699fe2ca7ffb54263432e1aac36485d92d07c39b1680ffac3df4545ff97c7ccff33d7b70500ae4c991936e3ca03d60f19b87facdac32d3b2d40a8a4d39d7fd7e0cd2f10ea61def9785e96f44fcc45ace42cd68288cb1189f6248c729c20b255700a5a031ca7f777ba9a0702f7b5a06208543b1022ab4506bb900c12bcc6a517b93281a8f983d769ca4ee0c52688af73dd6a89d110eb942d1d0e15959424c47117b61bdeeb4558fa094164dd482512f2b1593b5acac946354f7506daca533c26e01e23fc077b3b0a36f7c688cf3b1a433781031168277c9e55dfd775d45852069cd2395b2f235b459532dc0fa96041bdda129541b84ce2c6c4dbc6a431f50d40400ecd440d82926de5e7d2b36be3cfdda96800790d8f5c9c36931e9790ce3832237faaf15e17865d4364146a7509ae362f68b1133cc1648155f651347c8124069d3ac4904a4fd922e1c56a9b2915d675cd61ed79b314efe441adf2bb2620ebe4753d2ca8043ee735a1882f5839cef9859b33adfbd38ee36b39520618ac757711f2ca04aaba1cae106fba3c581790282b812592e8f327f0d393a2d20bba82d77c5483ae6fa4238e0c328c1a4260999771fa32b73fd9c1abadd85e57b062119050776301fdb850317d017e1240a42904f065130831c705a5314b6f259ec9077b9a9ffbbe202b463557c3fd92219c86336b8ae166ba53816dc4b8e5593b2cae3c972197a5ff48ffa0d2aec920e7374a7c74d9d781ca3c34930c3f41e5c762d59c022c4c010e0d86cbf180952d684ef0a11b8063144c3e080a2dfedb4a95eaba1429d600ed8781f12cdfb686391f2cab859a959fceba8bd2aa98039b91cced62f5da70eb1341979a44c634bd43b764761fc1a47a28bd0f86ed31784b3baf006a196d7f4fdbfa94f24770797dbe0c44c2f742abdac2808e2d6c6ddab1069f58fa268e258c52a56893fee9c309486ca0877bcbc682b294df6127480c4aafeaa65d5d07e0ef3d20a03d10599c44ec6aff70edaa15d4ff34c337dc30aa2e9d04cfabf1fe7dad397c91f7c521d6e7d8702fb8a62bce7cf26d674473589f3699d651a6ac276872ba789ef3e1af461c799538b729b6b8d312cfe8664e68d6e0cfea31b80b75ad3f9d639ec232172517acbfc356c94d2b01acfacbce884901410e3719a98248e916e83b92d9b26cf4f6ffbc30c1cd56cfd22ec98daf9ca8d83ee20201ed2a0989580b0cf854e8231e85e146018bb8422220c4ff5e02dc3f11b791a6cb88565f36a2d7edfe524f029597f18b6195eea7a5c59bc26c44d7951e5b4c31fdca1a4154217c0475c78cce7278ceedca92240e34a6c29c4ae149a795372623fe8ad0cad030615a7ba541f35a184e23682bceb81f9224d832af002a562cde5235222952c83605d1f9d5dd7a196955a9bf3237f1d002a9737cc2d92ab90c6250e1df6e97de707e6ceb36d8525f1662b22f7d4fd595f6f2443dab0984090e6bbfec22830bc02709ce2a497d21014e9f8367e8492e347a973385245533f33423dc9dab157a5b1aad000726642a04d983eb4351b7116a884aa5c87581b6d17642365475d7830907663ff9b09e5c26606412ec94b65f9b85f0f752949802d9a8d5178e6d7ba11af88e2f9aa411bf4243be7fd919a0105ffcf1899e01edb7fcecc12cdf6d8dcef9b067e98a98fe7be50bfc973b44ce83267ec06295026c5d399bfe2bf1a1b556766cda93f36b9f42cd74133dc75d63582adb688ee97e65b730a231f0d2a02671b990fd6e904787e5020ea6aa6992a2b936a6e82333d012ca223458854db592e469be9818eeeeb12567dbfa9d4e074e59e1f1d42ef463a43539b50facef4e861ad810e438bb5ce02e699d960051418df1e4114ddd7fc0d495da50ec439ee39e89ffd3b6562260a01a314919a1e61b0598a232d472d48979d5ac0798fad9dc50c631f5d55a2db1f6f8b3a463b780aeec9eeed0d75dbb9fec08231f65318637e450fe2b876adcd82e8d0f38f910077738ac7d0dff8266cf8e4b27ea5bf0da2c84c7facaeeb1ec2faebbd20e13e4060b3cea8bdb88be8a06becb8096f83611d7ddb76beb8235164ec4f7d84432c6cb9ec7f6e89d10916e6427e34f1df76d7f659d94dad3d5fa096b59bad84adedf8e27470f91e79bb825fba1c940dc3c42accdba6604639bfd4162cf4338676a4777433443340b90c0d40f73c298ed2ea2a7decc3b45f7cd5ea8bef56d6dc57c13389076026e51670363df3de7547f5c009d39790e5b8cfe7293b1c6b300fa756aab2f5ad6b03e76f04930e1f817650e6bec51c173cb56859ca538beca22cfce763de2e804a8c9848eb8e41eb55d872da240a48305d8ee1ec6089be7efdb6fc8507bbe9a08343b9a429c12d791901364fab2c0d21035a541b04a32179f59dd97809038838fe225e5e6ee352b2e65c2699d3ed005cafd79dec284dfef4600a5489eefe92695c9a4551cdb3536f5f5b10892a17ccde5393ac998c29ec62f25d206d45467bf310a7d2745c6d727d3f2a00b45b60db3b0a747235203987e6e038e096c35c1a488b51f3fc75b12ddced7d75154d0fc607601b81ea1d93ab528d6308c8abf270259395f7cb6534b7e3d25e3bc52ffe3b1ff9381e37af26c860cd132725b23d5084fad93ae53389eb0eeb215244b8d3c9c6cbdd954df37b04748bcea460b780fe91a581dc2f4dfffede9b8f2e4139a445113382977f4cfd6ca615e9473f8d24d25059745c69fdf3ea02a48303d76532b7207b17037e535ddf9855061096fd85a52aa90b310de2a2601edd09bbc668d5f49cc5058c691ef159aa4a9c176d56acfd3676c02978ce1b01fc8fb5f71a647797214ede11e86fa584fc69ef263f3bbbeba9723fb6c070f35b8bae904cb103312789afbe956877f8e80b263f7cec7504e596644aaca687466b7769f655fdcd7e6ade936f22bcb7fb2a0bd854c5400f08f62a884c229a542360c19b88aec1086800cf6997550bb6b24c32fae5b65fd40f51ad131325f0f8e8ccdf81e3040ab70af06666b97da0e3b1f8dd43c71ed03041081635b5e8237fe4a5f21a2d16c287c55c8c3cb7c051e30a6538469c6c1d051aa3d09fd65e19138baf61a7e1f33ece0e0df87501526e093c975432c562ae8785380df2e5b3256196b60079bf2895c675ea5ae0a236f5796c3285a051d04d27a60100ac419469b78ae8c0c880f7b312cae4bd28c90077a9c956dcbe1575137ac06d2fea0c903f8b86c5a0750233c77664634aa65fc0496ef995998b860c050a13d50a444e0bece8594f1627673d3553ff16c7c8c2e4270e1a5327c88e87c8bf144a0a82ffbd01156fd2b5e9b1f8a79728f481af725298e287dbb56a1568383fa623686d0355aa9b29835c67cce683c219d21056f05a9bc505a432c12085df41452bf0968dca35cac2bff8442aa65d78780d093ce5566aefbdf7cba2c02607297ec7eb787f6e98dc4faac2878edd16561ea74e599a9e5f4f1c44e934e1ad4dbe61f569448aa0875e42d214a287792b5351f7f8001faf1c35b996c25f3c9f5cb33f1b8c071ef0885b20111a635fb1d3e5edb1ed4d3b0ec4522d613daf2775d61a7a750cb99ecec3d3776e4fa6a35f13f2021672200f238b4b5bdec582189962764b9daf41445477b3b0137cef1658b980163339ce8a821c27e280abeb1ea0a22e716efcaf7f6d81bed18face1326f7b6c0677ba18f7af2b62e9cec77ac3a9d2e42a971f66cd91bcc3e0ac2d39718cd1eb41e0b7c37e4f5a856ed34c903474fc5146870ce121860e745c696746ce99098e5b46645e0bf77982edf586de6bb040c24e46f2544616406c46bdc61c460f848ede06bb430d1b961804b7a8cd099fd379948a58605d7bf603eedbc15d129177149a27c101eca945b9309520091f780f18eeec2a055ad1075ca90f19cd6dbdf6bd8705f61708808dff61fbc0acc508d4f870a26687d4649a0677929e35b99fa17296eb39104d9d0bd8f251b3da55eb7664201380eade25e56a4260dde1ef3d9c374bb96466f6f156451badce07348c36ca23f4bd89c8ac15845057f858e670b4331dc3f6052ac5322046d33e7383fc045e87d51b9982cc29aab97c9c338747c6789f2a2f24cb91cfbfb7accccda8b3ef78a2b43010aa009623739c0f3e258af04d1a60688df2cc9bb1e83d7be298e662b09064aae5bad63ec8e58ef13c57289200172692e34b3c8fed0ce4f41aeba89970fbbf070be028031647a62f8a77dad6921d6fc8eda807413d477f444e8aeabe9a174c59915a46375ad87d8ac62db3752ae14682c89ece4cc441558e384c54f76241cfedbdf7e61bbb26f81ec478320627f64db52233263b71e9b047e20b988f6786d56b74cdd802f5a30ea43f5674fe3e315a206c8695aa3d77a4ae431edeab5b44458fbdb2eabf3fd987bdc2b63cd3231c7935a892f5314064c7bb9d12dac11e5961a8dca86269a5dcf6c22502ba851b0be4cb8af03a59b138260e40b912387aa06cf1578dd32d36f3ec98834e9b4ce3651ecab1f3092db488c701f0cf67cf6083f5b0675f39d151c6bd8674ae1efcc57b6b1472ec3488b670473c653b8528f26649039cf615143bd2d6b0df95eb4ca78b66da73b48f13b430ed715814065b5be063352847713ae1c0c3d74146d132348df3ed504cb1b474605d5f67e92c471a3a67e7c24113b18f705d6956aaff508f0f0611ae4bc2c4aae2daa9806cb4aea8c1ecccc0867ee8be59fcc1b09ba355dc78d7ca90b9d0500daac59d1d8126c8bd3673f6ab2a1dea8da4539d3614fc519b94bdd16ba1072eaa15c063220d4cf514487b31e8ab6ad1317a8e622b2f184a297903f9d4e9a727d633bf79f7159d8dea19181dba14546f77caec08cf32ff7fee8773d0d10be49e61e1c34583b619c8a3c139b1b9e5ee8214f5b9928f06aeec9e4de891b1479d4b52952c801d5ed6b3f03590e2cfadc0919b06b8b835ed7d7c27cd134f2b0407f4366795365b4c0bf467d49ee1b1688ef457cbe1e923c2490f36e462f1d304f9daf4fcbd7c98f06506cf94e1d750e35cc9205e7e8a9b4ee9a0b4996e65d538824873ccb55d982716c0f96b70eadbe10a3a2fc036a26117ef65f0fc55b180765c3a0842a0e466d1b9b063ad93f116f95a2470f4ccd8dc973fba5366f92ea4569c8b56d1531bf717d5a3613b8330d66b14936347e4d66264bd479f25b411af5d4468b9dfaf6c444d305a276e9c89d3acc83ae86c117a546c70f033efc24cbdc23e1c6bf5b016ab2217dc433b35a7d9a6105175b8283932243cf6119178fa10c09d76ac6a6f24032892ca81c7e91da00c1ae351e8049ea3cd4f1b7f602bc733b63dbcbde00c5654f24f47c9d2389c8298f7dce4bd9fee02e36d6a3a1cd34fb7c5a21a071a6c255c9828a6a1f472bea0c9b9fddbb4099699813fdd39f198709dd456d85c5b20ba93f467603e6dc0335cdad235a1dc55689a1631d7943202a83de89992846b4449bc7fc358db11ae56f98620c9ef176a0ad8a45d3e05ae39dc07e16b9c2b5db8b0e6a3f5fe9ab3eec970e17d5555d795cd76ea731f26d1aca592a7aa3527aaf33f9a315b93ec50c1bac3fa40ae148b2cad99aed2057ae159ddcd5ac9554def453c198144a097296ac6b042bb39a1f68db2d66ebeebb6de296ac846e0a5262151406ff4321aaca39ca9d7f97587ff53d8e0795898f561e27675363cf0fd48b393ba5093bce10fa37555097b1b1456cba57c258a675572df73ba20309b3459c542fe200aaa7305519dc6cc95f3bb68822bdcca44b9ae195b968c99d211e39197a0f9446ce97dc0942460bd465afa0502b2f9438483b0a9d27bb7cae7dbfc39329c01134c71cede128d8a3074b00d7a98be5ac3162d64b481526e347cac2f69d12b1ffb0bd82880f1890efa3cae7cfcc212685f914255beed3a00350dec7ea6901fe71d0b06bb29bb75a26b9294686e0d2aaa85fa704c1b578831bcb10c4a7a08d53b416e69375ea60039d8b82c832d51459b8b3150efdf4bfe061bbc920872c3a3152e51fa7f7cba8c6d383f24af9676085f5ae38163d625d01d8f141d613bcdbc127f5bb8af536236b00e8b6a7272445e98e03aa1ed745eb3cb7910dfdccafdc02a8c37381c6fb604d6a173129eca5f1686f2ce06cc1f742ae25be355f5f536ae47257130d9295bffac932bd99ffd87d010fd2a2d31a979d5e9f1a54e4511541282853fccb5f1b0858956451339726dd89f50cb66b8597b4a4a35650000d6e3871a2bc1cdc3b9dc0e733711766cf6c6540070ac2a36a9d14072d6a4d582879ffe27b783967010bf84d80e2758afc8d0f4951cf8c6ce323667c6a7ad980678a98e2a7ea36f7bfedeac04bb819f2ddbedbceb6e1b719e3e78e40236c366c690bdcbde72c26b181e0dee08faf4fc9301290adeaa6ba4c007682bad59af7bc7fc9dd963e68e2aa6b01f3e25646d018e36caedf6c720ebe6d6f7a94147e8505367d4edc96a6680f2f0103ae7e7de45e28bda2b7a89077717120f736e974d9248891a0a8f1f70b9fa681dfb947887d4fc7f6864ce355de7b820b4a0aaba1bdf9cda38cc5dd24572c7f2111bf3b3e223b0cb6bbf7a4b3eefff7ffb3ee4302cbbcfbe91025f87830e0dff03fcc744c6015e700df174380fb69ea154c9032657db9ca84f31f131fa271f507d1f402cf0aa72e49c8e3ac7453434e661da45b0413e0d5a9d6f12cfa08fa5fd7b39b41d5dd5ccf9871b15bf1993f4e5f56fc1a3a4f8c80ecb50e34c30eaf56f5560fb6ce52e2c290136f5bf2ef4a25b4d2acc159e0e01d405320c1ea406b5615dc0a0e32980aba592b55f8e42e38f672c92df4e38b9e744a47f94daf24cfa0851f4386c81b63b6165c70b5115a69025f5ad144a3589eebe46deb94e0205cc87ec0254a8235916226ef08c3103b9b0bbd22a5abc3937d346a3a1c5cd40a1c0ac2eed3ad31640f2e6373339dc54d3d0c90457dd958cac5f7f53906c4e2aab246b950f8977d66c650cf71fd74e8fb9bac12bee3762e49dffa2ca669eec8b05516becac917014e0207b13578d1358eab67b39b36951264ca2e2f573cbf41d87c213be07e3a2548d1b36ed41e172b9c00cf4600962d4860b99db116f400784652bb5896fb8735d51bd81cb8bd7d8870fc0a359fbd560037eed5a999396a15b8d30f104c371dfd51600493af8c36d3191a785dba1be6951d419eaf9a0ddd23b608b380f1d75c631945d606ca0d35a992b139da9d4049afb3ec354a20a019f88f7c6f6f798372c813f25d493fbfc2e44dff11fb9c69c69dd4fabd571ce666a02bf092f19d59705742bc240cebd7517e7e79f5fbcbf8879caf4387017afbfae1012cfd78024b25f36dcd4266a0a2a3f9b07dc5ab8e8c5ead5b2246fe2c359fd5ee090f9f2ee57c920753088fe4bc717c4b000f10926cff5be2c18257d5c5d96c2422f554c56a0b664a29c04adbaefc8b64251f27a39c5160b531d9816f829dd4b09ce16a4136336831eb88297242306d853c3286983d8a767714849ac8f134d5833910798c69689c78528190d49402fdf5d56ea871758ea068ed955cddae7b35e01371328280c134e0374269d5427749b12ddf859bc1ccc54a14918829b793ed9088b6f7e1917d727ac1fb3450a2b769f6a713dc68240b05079f9e86bed2a8c78e888fd8718ac7751435155665d0819af07a2a5c98d0995eaccdda18ee1b9b688010381ccb4f7fd9c26f73686ec61164d26ab0e9fc94dd09ccf10b4ad9c481592bdb1ecfb93c75adcd7724417b5b2d111144d5fc971fd0d97b4afa008973c1e54be814a9b26da17ca382673d26b43897c9b54b58a0420d3041359bbc0cf737904717a35ab4d0cc75a5769d5e9403c0e05e38f0aab641d53eae7509ea9e4c0b7a981b5a1fd24d8e340544fe95eeceda11d82a5fe8de54649c4222f5a1ab943cf5a8d2bd9c806ce7e89f00d3114410e4d9e8ea442849a2d7fb34970b346c96ea0e874cd11f7e309a85f13450d512d99bbae012a3a1aeccf7dfeead92ba0cdfb5cb293e084a61e3dde9ffa07ff441ad851c02dce57770a6d09b59450b41f03623d5a985f0cd539d6320cd4f4c1fb7788b63f13c23a5409502f1f858d0b80c7240084032fb046cce2aba69da8d450cb05d831ec93568b9efb6f3610e99eb2544f9b22dd83f818de7909183b4727fa6ad6a300837fd96e24df502bd043b651395841d9402ba0f1669dbd7076a4ac8b06a25d1f071326bc4f95228fdc710d40e6d256cfa741697c607b7b5384ecb03b30cc9844be283c8acccfacde5ada80c29d86abdab4f0d592f8588c244fc0221710179003bb8960fb14dec75910bb3d78f07de31d10562390d927e52ac34d98fe15b3c182d9026a06661f1d6cadfb911a57df7f7eba588d78f760b2cc70a3c11c7641bdaa07a596c66d3ad0f786e7e1ae3be0bced709aff351daa9e7475b5d2e4e47dedac390cc513aad09a58abcd5f543e0cd87541f51ede7bf8f989de5daeff84fdcb334f8317633aa7b3cb5985e1aa7791bb8d11cfda850156e4834c9cd5228fb72da1e569bae12575e6482eed2e60ceab6e3096deb4a45426a0bfa05cbf7fc641b396396e648f6d8bc7f50b2744adae1d9ee6aaca4919b3dba0ee59c63926e1f6c3a7eeea497dea2a01fd52fcc4a876524781340b3d14c8fddb263f15b34a1eb0bf89fd7f91c105027bb7b804fc15e9ca0e50be5a3383d6c7dad143406fd9d36fe7543c8c826e70fc558ad78a7c6a250918cdfc42f279ca30d75c2c97ada8ccd434b603a6cf3d57170130051cabf585c9d77ec415bcc3f36fc76e6ecb118161ed2798496579b12a1874a71d7b46f21dfb7b006cde8bf551b9a07973a3abd4f794d13ec669616a8268eece1a5af70c87a57f38efdb91f582d4e5c31049cb7a49dc96f1e5154b462a67910d732905118cc398f13bbb4957c99a18cbdba0fd6c53e6ad45fbc6dfcd7c8bf4a605749ebe9da7b261768c1898e342b42e9ce7e3942de8200663b9987f76184553c00690add1c710f4d2e48ed14c724489ff996d3085195dcf32c9a6d723e6b96fcc7eed66a62d3ba5a59a02aa5e4077585d09a29ec708db5f3a07140d70f288aa326f71f9cdf56513db95556e3ea2ecc47557373ce11a3894a35d48b309bb5d2aef33e76c435015def9cdc600a8001e551c4381630246956c8524d22567083ffb31a4572b5d9a5f486d73ce3b7e3b780ed56f9a31008766578194fd0ebb22e2e0599557bc1eda67459c0d454822a77a9edc297fc8ffe5b417218c19aeedf68f66706f7d8dd83f8a524174763757aa5f480242a1bd4eae2747b49c5f5f4088e1cd9f84d3a3e3cf99c77c91e3b291846342c21b5739469857343a77daf292cf34daf0e3447c2e30a9102d57b9030a253dd416fd3a04f47073f16ebed764e70c0cfc67ee5f563315d2d1663da5f81ddbd96f4ce2cf3277816740387959962191babc10fe7d7a06b72ec91a68ea9a32eef320647712576acfef9b3c60dd1341d3d4173e526e154ef9d90ff1562ffcc1cfcc44a10dbba9b37aa6951ee931695ffd999442a736225959f8fb3d7b3770a42b55eafd5b4c2f14a19c6e5b6f7ffc9b1ce357d6bfb9477e050653b95726df3923ea459397e6d5864eaf454ebb170571476d544826306e744c38b2a445dd9e786d8a4a3db1ad3b9ccdffe35e5ab738a2b36b78789aac6d22209e115f6a2f49155c4018f1299454d3d1297ed331e0d152206032a9773a64a7bc64a4f64f1c77d0914aa1059a77705de24414f17167a32a46503bbab72483272efbacc8a3d74ae49e105093be02dd5cd818c64bed4b7636788850cf62254dd3b26d64ea2c40e798b245eff1b8108eaa258a18aadb3bb7bc3e6a08bd122bb9908c82a575bf7ea156b1ac59982f2b613fea072ae0af556454585e54e246b5ea2c41f7d70a6b5c3541a9683c431c3981718ee0ee972617e65c347b07edae8186315f3057f7a26bd8ac52a0956c7d53dd1176a7255c5caba3b59d28e475d879e3cd06698f694e33631b8b0a5ae59571151d218f89bba0c82f1d84c33142d2d6cd37447cb5f1cb8c4d41ba80a6818b34e8ea81e0f3e9cc26c4237e011f6909b138576694a3e95e9df7ed97023d24106acc3089befb88a0ae379eae84bb701ab902091c5b807b2e039a0ff8ed169edb6c9e6c25cff5f3cdd25877aa778a756e2e63525a001962c6014e570c0a6733cb11d5e06aa965b0ef6152157e5c19908e5a19f82550ea6cb1ed1d32dc562e8bbe6394d8ecd3a0177658a217b16466de9e7d321a4a93513080f1321849befd2d7d412e60b20e69e3b030f6404437cbe5c09684271d689afaa7a0f8c8f2787cdddc64bb296eb27e92d9e975c8583736ba918be9076703114d52c72a6568ce490f8c9ddda2665343e5baee2211e5d6c36b9e9ee55d75c05883a58545991f4820ce4b0d298cacc52623b1a029818c410e512640390568bd6677bbba4a18195142cf9b2c9d6f14ae28af89f7b15f434343bc277d3f49399d4c926e2efc043f0db592ba643c431addaa8faf50d7c841466076ab3f9a4ff70921dc934009873835f1e490c52e08586c53ec1539c669c74a07fc6880cb6a4d08834517469050c5da59b70616908e872dee4dfc0b59f1397bdb5742d11ab1202480442ecc3f52ecfe935d3f0242065a464a8a7540161abff0e9979928bc679cf9db2c0a90b12e87f9e8af9ffc1d0fb768094ed3622728eeb380702eca6bd2a91f2c85f78ccbbd621c9d3465cdf64ba4facb9a831b012383ac91299edd8a403a168f66fa29fba433d36e5d9374f4c87242f3656e8e00deb31ef95d8a96bbd6f31d9556256aa8804e725b3139817d21b8fb213d71ece58621d096ceb26170fda7f75f57012c8faf10fc93d4ad68a3a2fa49a6a4a4565256de8c34e0167beab03d8a3679baab3648204c3dc3632444818f64b3f3111808270674296544f12bf0bbe7a8f36b30fc72342df0e8cba78dc5fa4cac3a542bd0880baadf8bffe9aadeabddc574a2e908bc8e6cfaea95614a4c80fc89a4d8067054026166dbd2db1cc1870efa914d9c70147c96536927195cec88afc7fb9ed599ba13742e1fe80c2f9e3b57bdfd10dd6832e710d20783df52445466726d5ec2b3bf992df343a385b679c5a44c9a4e24d1e63e9e481adc35ea8d53b8f6a1fe8f53ba75db5494f053c90d4b57fdbb534d2cc664a7a74a6e6dd71cf6f521e5c9b5942c1215f978d0e5c9fa99c67e64f4288ae59e106d5b3ddd8b061fdb4f263e706dad5061b8eb7991840553b01962a87acc2b48fb4655e032ab4acdb8f4e30bb06898b9161719b91da9b5cebcb06f286826fd9e58e5cfe92a6f8d8a481624d0c66e396c5842a33d03275ede0dd7083c20d1db432c665c649d5bcf55178c78ea815262549907de4a02eb855e33bb8fece4c8271bf15bc57446e1f9dfb44e7d524db2a76c7956aa8b049ef0a46f50b1a0c5df39c9cfb7b79c7824a2e8677085ef622c0e61c01fc5fdd1eb5329cdb01a162189a8877e3ca0031ac027e04f5c2eb6556676b4a05afaabf8d0755c0f5961d30c795fec4a14ee6ed2b31241abf5e62deb00df1ea6d90b28e39148936b31bf49382b83a13dd4a1aecc179c2f4881206c0ed302fdcd9479cd9b88950ba246408ca8ca241e587379606445b5eaf49e388f3d440cd4ac3e28753fb345c8c29351db7876ba432ba28ba202929e6237ff8ca06ab68c656e8aa640a392fb9fe36d59423101aad3c97111f90c9036bb9db7010025cd1681ee702632d38855aa9ab6542c2078cfe51db4ed1d6ed272c2d28a6f862687469cf9fa5839b209ed78fc78b68e1ad6f194dd6d68c4f87bb8f2fa4e9972fa6d643fee7bf18d68420d5d99d96a5f7c89962c6dc959c147bd18260dbe0820c556d01a5c37d2f43d9b407cbab303f93d8092789e605c55d43631c8f79a68300073b95458afc5a8bdc00eade1351a9406042457e481de445b150e0e5a564124c95c51c3bb07a4591cc608121cba12c52c93dee1f82dafde4b73187c2b127fd4abd8df48f5f1038a7a6c92c055ad525ae0a54bf1d9486435f6be78aba7adac0750b00c708641233fe8896c805d3be05a4d6ccd800d9477f3521818da9cd0c59a667f938f82c0facd16ac53eada50a378cf1f7375b5dfe8ccd2bdda9f453536ea2832e03515e4d973f78d377d90bef29c5c1b13c2c46fa99e0c976c01c25845691d8960b68a1eb34a237b9611d9f423475e0a6e7a47d330ce4ea539b9cb71b28fe8aeccbbfa2efeb30468413ae8ba4e30941b3272de3d87ea2fc133b3c0fe050213f6c4ad48b45071ca908979c4f2d4c1417948358e06ecccb3698c0744f9e5358ad103b82b7137e13ac0643c6ce7910e1dda56cdcc64e1f7dfe6093f272c69a8d2cecc6d996aeb8ba742d9013dac50767626ef3920282b8de86b03c76415011e2cdade19d5cfb72e590f07c1fecab99d8655794eba63cf19887bf85cbe60da12ea1b5de1646928215be69d88807b694d7d623eb01f30e544723d1dfd463a8626f73c50db1f51ff549aca92f2f7d5dd58cbbb1bbd1f051663edb4f9f3e84fab444c96dc0b1144eaf8ebb840b72425236762e373b660994f66031d84cddb1407d19cb03554b198bd5bc0cc4a60289b0bc5a35d5ea38a531ae3abd225c4baf25b2c1b11a997d6f585a198b72eadb933303f5dc17587e22353c7cdea99d0ed2b306add24bf8a1a239bfac8f89bccb7f7478c38103feddf52c01d4f67ea01825b4f3a849668d2ed337f6d86c7866e9fe32fd3a62d43cdab10f271a05a09febb3673e20ac912779fcd7be5658b80241723cda3ba24018120e23a17335b07af870b6fcc857607006f51427e05ebf8ec8c1d55821f26149ace252137b574b0c9dcb30b487cb0841b78cff76c07273ca4f4357f5540a5ec2e2b4f6334c53cfe4369a41b430c4d9891c9e4f39edcc344d6bc08c2a7b64c88177e723889429c6098b79bafd73b8f28d6f3ec339bf6fe11abdb6434bfa6bc6d15689bed6e048851c6d0f7f6507dcba0df115bdc4f817c646afae2f98a4fe843ac1ebb8c947a58991b1036f09771acae961c8eba357b6505970739dae1f23b0adf6ad8461bccd9e5218c0738eb1545fe37f461692d851393eefe21bf941fe21f7c54c44710695d1d5484f04834439514a9261cb71f3563cc5f8b4cb98614d52a67d0eee209ed7253b2dadce9ab442a03eefc76b946b699482353020e506dd41702ea043733e3e2fa5e2d3c32f6150f2aa31556bf65f13e824125fabd57a44f98f833fd7ce923aa08f1dd583357d0773d4e38d9d42884630fb2326eae692d8008e5b07b04a0463509e85f0547c9a7fc68979227b46826da67c7bc458562ad4fd2cc5f8f878655e878dee5e58b62df14f444ec99f6769ead342b4b12af15cc7d902f0466868e7cc8f9104196e1d7fc56230d287fb4727272fedabd533b3381811e7c6e19514adc7c2ac3036589a92dc9a0e7c9fa22ccca38f88ac60306554aa574ab2636f931b68fe62775476315540ea9ddd89c2811437f3833f042a0bc9ce8b1fee39418313c9f2df2bbeebb0efd4d667184872abd18789509be11fecf07b6a11bf32586b1608254f87e96a9e953ca280374d36a0c7ccbd4089e40be27d6e6fa2f2d96d9f2b5fb0f44d3a793dd758c14cafedfcd9439836e3d742b18ed406a6da4f4362688947b545bcf90f7bec74a0fdcc22f60b6fbbe6f9e9a9fa7790888a53555a9bc872dbdfad64a584fc25ba575a079261ca03dd506d7e2a52a5e33721e4c048388b528fb81edc3f0e1eaaab337e6cf63d91397ec3b00537ce3d0013efba0191aaff7eff69d8507d56a03a0d64370754f0e0e6500245ff8e98853d42db6f66d6b8b7d47cb29af2312a4f6584e6eae2cd63ebb126ac0d84fb2f8dead575c22fd05f78853d3cc9e1e273fa320855343183265ac2cec47fab30de977ac8a051c119816cb0288062ac341e25cd41e9665b4eafee4e726a39de487fd8f1aaf6bf8de8cbf25b0f26e5eada1faa57163c7ef45050d2d3bdf4ded570b104f7b2604a246ac4d7dc6da09980c65f146dfeadd1ac2e881ecdb6cd92937b2e7145f4acc082d08714082ee33bc38d1b299dcba54ca7def85038d9afc7e2b92f424900eb00b8887f1e993d621db98e7a254572cec326f4be944bdc1d2f877fb327e985fb3a8ccd25e7efa6eb5ef14b39babbc64afb0f41f7b17f866f8c4e90a35b8734f066e1ffdeddca5bc3247e28d89e044b3dede60599b946473e11866eb2f48a0cc5d8d4dca7c1aa6a3e1625918a113a44ba8d05f3c3ac4609a33e6f9b951924fddbca722790b430491bd1910dad1698254a89a3ae0fcc4c20c1373e59b6b68e0482adb37e04beb4e316c9436dcb5e8b83dee2945c70e1a677c5eb6e28ac27afff7fa27c533909eec636549dce8d30b9f52f9c4343f53b5209bd13071b62523843fefb901b6052465f411501f03a5a06f7a7921f7e8f82ec93eef33e9348b9a2b92bb4f4acc9dff89e15e39cbe687d9cba13a207ad1cfc1292c32c2c3bd75c51d93f8eb7d335292b6cf565d021805acf38f87d9358c53b98b1395ea955ba635376275317e69161a3d544c420c917674be487ec729359a1eb68197a5226f6f52a0a364fa1870ee9cf71d5bc6b32fdbefe8c6d81095a8fde38b9f96880e71761272a11b29e944c647dffca9694965999f49e1b98bbb45fceac2a530d2b5e17f4b5ab4dca460a609ae6ce18995e9a76e99b587c5e3405c7d8f85e0ecc790d967be2d4cebd350550dc9d10e12300043c36af0cd2c6146e9de3e513e25d7c4dc1296a8459e9114924e2bab97336a9c12a8342633ff604231ab48d6342a23520ed02dfbe6a7aeacb42c482350f92e881da68e4283510b485f482a4598118065ba0379039f065f8fc8ce589773f8dffa91fa9a7a3c19ee55938bf61d7f1516c416bcdfb15b215791d36a4050a258f6e46ba51cb656694fd491fc020825122e94f4f90304629aa8bca5351c98dfff7e5743d0707b53c488d618aa4824bb6900f0ebd975da1ce67fac9408b7ce97f912ed9f0002f01a1e1cd136e972308f400447d3ed2fe98f7d340ba14c7041d6bd8cc2d8032136460101216b7dc8be64e9218adf438327e83fafb7fbd89d32beff6315ebeae57ba807bdc40d188ce1ba8a08bc0414a3e41c14c321ac26f4f3e9d69749af07a74f6be35e90ce3147c269754e805f7be3e016ed37f4eb2936f2b0ab6cbbbc6b2ccd0eb8f4c8f3d57ea9f37a4d22807a36b7f49799f270ebd16d75b45f98205467667f64ec039d6a9662c3e275695c9df3c2dbfaa4472d8b51811ff8dcd27929480b99e648c86d634a74b9c23b765e457d7455319f7d65d012b04fec4d7784ffdc4dec19973eaca124b72484d945494d02db99037c796ce9c3816d9574844ccb592915ce9ad0eff73b6df59683436cc1b017aa8a7489f965d7a3ce40db8a4c692aada9985b1e7e27305f359c7f9aad4c075a8e93ee6da3f9863009baa007c15488c56c398f084197abad24508b155c8771cdc62355397f01ee2775ca10803875ed46e2c96867e5aa3c60368106802dc73563d95d0b0db2271817f49e03775d69b06f32226bc546c54c2b7c2c8ffeb6a760aef33cff7d32444840b030e63176e8988c9dee9d7d0564dbfe682603c0ca3f02c02fd17966587bd48658b8cf2f753e4e186f48e89ed2558b1152a18d0777b3f3784e18920799da993509b851e6f76aa411d17edec5c8b932e29be3aeb95b8d1e5f0defacbfd9dec1dffa410a28f5d037cbdb7268e31788faf6fe9b62f06b2b3c210a9e56789c3f951961b55c99ec537074a8fe341a3578c777f8804b0b92af17e9b86a3d24b431c184cc9499226fea60c69756c522a3786c8b7bc90f6068165ad7543d651c70c4ce9f63546bc4ad300e26e2cd02b891b28c84fc4dff057c82d4c3ff7e5522f0b9f46b60826be283517ab8736fb415a5829e7c9347c4dde5700697db1e84441a70a94dd8b30acd6cc37fb6243ebbd102255559a71910707beac97b96165442871ffe6b40a817ba165b3e1c7c088140596991f72e9c073898d26fd220c56f9bc1d4c0d9a4d403a4cfaa9eef3fd117c8fff9c9fea624d845e06507604b13e39cba45bc467ec1cb174c899b23f1e0d8a4b40268860cae0843684e36500fc949275c36b44e9455cfbb5120961fe36e6acc5448bae3bf0bd358c5e3f0638f8672737845b062638e20b8cd6fe55b4e196113788996972200d4cc0d078fa68c0664cc971a4ec45720fc1872c878857a487b22bbf9cc6177173e47367a738cc4ef7ef615b9ef60bc57a259bac1484c774b1fc28061ea677989cf24bd11d8e620242ed70a8db7cf13df3fd4cc027c1e8f303bf8789a2b1ff8db48ff496e34e44e28cc3dd68bacc163ef7c8ac224ea2c284af364e38aba4a342ff39f56145a2fb35cddb08aee3e3ee1a52823d2ca4b0323516a50b2a9d5977f8adb7150075e172d1f6223685106b0ff043f8f27d373e96bf454e888094db178cf3df14f386768d380db8028307cd76b6918a1565adefe84e49420d7577306b31e25861cc8cf7a300dca6d6a170e4485c48bd6932990751d2b27363dee78c32782e856904b023cc4dcbc4c286e1ced98e9f84bded7cb8be7e90206b757cdfffdbfd34fafc373eec836d27281139f0834baf5f2ae05adeffdef476227f268f3244325e98e5eab5b80fcd5b55e2c0d97f3dc55b82c6556d237d22b33409b0ffa1bc9c44b66600c37eb4079","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
