<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"10bf3a16857759cb81e58fef8c27c4a961245b213c4f6c2500fad6ef5763c691307a7fd37df7ed3b5f657effb043c612fea6162c59f45e43250d80d3306b35182b915f64281e57fa5f3042ac80569d8c4d39d0a1c62c5e3b0477c17b50a7c5d466070f647dc775228d1bcefff2f5dcb9cfd0f29723225a8f6a62bce05e992200f301552b130f153bdfd2b6b95c658e9b7d9289ed6672b4400f62e37f77b843dc61c94892c8f656787481c48c3098225c852c4b2f131d0ac24d345bfec713cacfacea10370907ab20e84a733a36b3c8bcf48568da54e79cb634bba4e31726fbc9ede9473101d9c0fe3fef7c72663076767445472687ba6e90a59f66d2fb3944391e6dad5652046b5d096f8c10e97b761526d124b672fc0537996311820aec741224302b050233288ad7447e3df79a68e0e8a2cecc2e1dcc56c89d1d8f177c88902bbff07ea2092c147b77925c50c9546749265d0004b5a485af74fed3810c09d80225da50b003411900d2178070ee969a1b1092a000aad40f3d4c11fdb7853787968dc0b17184aa07dad44388ac0a44ce8ed9b941f659de06783e13f1eba956eed33a88d4d64299151a9cd56ac7d11ca97b2304f839b52d06d26525f8190397978fcca39f7abd82f858bae713be51f43f53940992c4c6982f70cd80f8eaf9b46833fd399db74d0da17781381f7ca153f74d4f631938914c944c0538e86e0d29429f354652b3f6457b940cdaa5ec3e630741b50cef4668bc4f7a293bd6d3ff142106dcef36652965dd3e430cc8b11d172679f29dfd43e1f75496aa3d56378b0d2cd037c86327f54011f4601031f0df2d9aa6be5367a70a235c5aedb7b6fa99f99819550ea1e95cdf2c2d8c66e1ec534db779dfb5879f69da7aa6c172251751883d2ff7c18a6c159a238cbbd218748cd1d9dad224ac91602bb451e45176db14a36aef997c107909a361ca80d0b25ebe91493625fb9239364ebb017a56563ff8a62ed1aa3bf9a8cd1306f2134a6f5280c8e1e5cbcb8d34bf1c402bb65381de9f5e9df14d3eb03b6542956830ada6d60b59f6d97c6537bb5a3dc01dbed16bfc01e5074b1fa634bb6bb1c08b9a924d4ce78828583651317e2e6fedd7cd6579c620c12acb70763f1f04221f21316a4da88412d144d55a6ba2d53e96d10d96f9744a62a5db33e70dbcdaa85a67768b26db7e04869e0071ea271b5801496c67193b9db035a3abad26a8da1d763b398c2782056a32bc5de17945eaf52aab87890564174635e3a0b3d727a809dbaebf09143ec8e62e8a1fec3de993558f713249386ad5168eb700fb6e54037d0d5442bc88e88927c4f87003f87bd2248e103ca026fdb19a719a1c4c15084421dba9c0f7f2ecbbabd44bb335cf162aa10d976745c0bdf31b35b5a7361703b3b5bc492810948d2cbdd6f7d19656f7502ed4ab96ef83a4b9edb5a5e21bcbe79462c06852a5c2c2b9d442cf7d915723547cc0d327b59a785656d1a03c5962789b0e28b6853b0bcf770d4e3eea54d7453e95e1a54b523c46b50bfedf47a63ce95633a049ad31f73b2f43670f5a6689ddf434cebf116bf9005e313304b3769b3d70198ba9807657a1c97e518eef04a43fef2a085cc1f0256c6db6df52053a730659ccde161bbf29bc1139b3f16e741977db76165260cbdeb8b424f73bd1019df1b67ea139e590cd217be76121c26d6098f61f33d294316023a8d828d4b5cabfe161e83781d451eee2b1a10197302572e2a1117030ff4554bcfba37c141405e8adcfc3472f794d1bc41f62b1216eaa960b21e78bde7df68afbf949fcd2ea10caa5c5576fff908802e1275e337887051ea65bc3867840edc96547c749e71f40940261639238da946c343c351291714a3a94ed00322a194b0cb110c386740af96bb1ed3d9433c8d09b7a1887914ea8f82fb7fe7f961302f7cd21792de1c529c1954f7bf78ba7074702424bc627002a8c122e93d973822756649a183f05b76ace3dde7cfd4285e5e79d232429537b42ca1e8552dfd69657b46cdc8b416de946e8db5e416280d57026ca3cb6ee83daef2f18cc1f914e266271123aee91ea84b7e415ff6ca35250768dfcc43e8e46f94f5c012c49df4651ba832a31dbb1fa5a7bd92c5ac93a9c64059a79dc354f6128f18ce7756004b8f1785e2baae9e657c6af3e4eeecdf2e90563d3e5fec560b3fe3e1e6099d5c425f1d5e818ffc062c7c13d5b584ecda8f6aeadfb96b9e170f21780a9cbcfa4dcda2e45e6476063b5e483c7c9e7917e9a0e9ca597d6f117e47d515d7415e2e0df4b61ec393a66e2dc504f8ddd4f004bab1b9aa32940184fb7714ae3f9f97c7fe30a28ab093de196ceb82517398314773bb4b78edac2ccece96c4347cbc2b8f0a6d918e001781088350321af4cf04a4eb277f34c6622b6a617e6f75ce036b8feb1237047346fbda7281eace6e344cf1b61ebee6abd3cc248a1f32494dead5de189fdd78570bcee09c576b1b46fc6dcc5cd44319dd1458f6da0e758a70ea2f03f46e85b22256b40856a82fb3b17560e157b3a8ece57e129fe6f1b3f112ef1a8a2f4e15fba01fc442133dcf0b8448333b94f6fdafcde46d0c898a741449731b16dfe355ab08488d8db9c3ae415fd13e2124e3e381c9ef1c8c98b56582f7ca822cbc68057633e12a44120ff2b6207e4651fb06438b6bfbc7b3ec201dba63ca2695433673c20f366b0bf1236fefb6ab93d1a56f332c2bdc71df0e77732b9124d16a037761d92ea6b920225479957655240c96c73ab8e59e934c82f082a82eaa65f703eb6a9d0a9f365efdc051bcda1b6162fafd6bcab7486035aacb12780b0c1baa33913cdf848510bd2d8718cabcddefd58db749b724620836eb961e61d39868760ff95433815ef7676b74b97fb1dfa32295e52ab3b04d9ef6df47b8a394d70c0f8039335233920d0806f0a9a8700a05580cf93e047a784c8da7959cfc1d0d06e8d9beab36cb7352aa723af9f06331d7c68b54667d4382e5ab0768dd92f603941df8b2142de923382346c080dffb1e79bb0b1cf0892e5781ead0956e8849cdd4cbf6d55cbdd8c0feef9ad75a8cce8f85e5a83705c070fa3263e296180e74dc8468aa9f8e58e5138f09c27047e6f8c66161661d1099aad9fef545be7278d21aa63a4994e8d20fb53e94b5bda6767cf16456de38d7b52c667ae8f083336e385690a5bc3044f24e536ca09eeac132482aac6b1a6034fba25b11d380118fd0d22e87269493138bb05e558d0b383019dd6bf20a3e06125e3dc44bc7b73446d34dcf025737da480ef445292e9ea8a329654eb390b08c37b1666bcc18c167cf2e12851e02364e9a7e632792a74cd3253c84b38cb31020c193de0205400c659070e400d18d0991578e67c7887ffc953e7449f2e1ac6dbd3573439b0ea8d3d9b4ad9d1cf76fc0a55897a7cbb04a54309bb8e9bf2faa4e0b267a8f9c196a52102cacee7c7083b75d56fd130e5d637128186a0166edabfae486fd98b6905cb2725ff1b39506bf4c1229475b54fa6c5ef3083dabcbbafd893d837ff46fec3413f1a5e70cab5565a737c5aa401389f4b67b46d9ce0d6ba64efd5ecb114a6d195a074574a7f2a82f91df5e4f7e2efa1e58b3671b32b10077a0199e97fc213567c45184d7946a00251fcf367f6e498e8b18d7d3258df4c9ffedc080106b3011d3172a6f749a21bc4e49faddf8660501b6813a0081a480b625bb0a6dd38c6b20f503525b867527077b1aa50334b39a0f45f175b385da2de5ca5af9b58b600810c048a3da531bba700a5bebcf4ae92041ad4e1b7f3e13b6b2156621751f1f0744b28949aa833f7ae3750d705fb406a758ed3c063a5318b0425fadf3ba32e08520419f727aa1ed8207fe93f2be89321f27838e12910fcbe16654065fb028ea9ffc6be4b9c277bc77c333543232b6b6e14869446aecd87f4a4962ab07e28ebb9f6207525d318a317c95e171ff0f86945b305641fb9d0c3503eff336c5eb1ccbba5bb5277e0630b02b3a7f12662c96e25c21db2f7dcef74796a2d4f4e28db1fee945db7e349dbf1559a7846afaea3a82ee96ade5378a706bf4441a1e50d5426f3c30e18e88d6131b56b91e5da0539e3c88b433cb460c3062a7df63ce9197cc2772122139c3e630e60bb4364ee500b35e33da9936f313f107fb746a29c349a7e9dc540d1fa993831a9a5cf352839c1bd15a9dec84277fc310d1303740c68180047469a4cdadabab048292e5dabc41e87dcb50d3ed24d46fa7c8338459fa02d830c5e896bcdb9b9f3caea4f7bbdee49b06fa2ead3bb1f569073a86f45ccb4b5a516f966488fe5cd100408f99b26a4c3207778fc70b4efd81c416acffed868f0d7346a92b158207c37832721933b1c705432a4a9cb648b6c1d9699e1abe8038766668c55a495dbe2c569fce9eef5a0e7f0423b5ff653962414545441816b2f50d70429967c4daf8d4ba4e7888a76f4e199699d7552e08f22fb5a03663f8692ca9e788d2f166f37fa4bc185f4e8089d9057a4b61cb18119084e53284126764166f14c63679855d5ad16fc15be1a92c20b74f1d312e99bbc7a92ddb10a004914e0bfba2cc7a0cc078e9af3b58f536f1887baab8f107e1b73001ff3a62a5d69edf4959a2a22eebeff8fd6c495461e3a3c2a405f752a004d97c584b9513bf7795e60d09175ec6818913ad0b0efb963d80a4465e196eb91a808062d7baba553c5a8f2d78f26e5d0ce5d4e1449005a8f1a04b25642017e355eeceb3ee3cc483a322d7649f2bccc3d7c8b5d29ccc7ad47b242be52a1752fce87a3cdf8f755515d9d1770aea75374d906f7241a79272140c213453d1dbd110f2787f0cb5b0e9640d51e67c2987164718e30f4f17e227e23f9f2bd00309413291b1dfb25dcf96e4edb2c29fbe30bf29df947504bca567eb066443de8dae3d7e73f20f471f01cd3ddf37a77bdde3d17e4d5f8b6bdfd3a786ebc0d6f5ecad3c999e87f83adbffec031c0f04c7b77f5ce8bd1cb3ee57b81ef94c96fe4b92c7f5fdc1993a55a925a80712846621eb38b10f5b1bbb752c76b9d6ca5dc4a44fb41658ad4a9846365cc2985d0e69bb20296d7e32277a0601d8b47f12070af318bd5a279a77104edd2529d7c8b3d9a1b2e40a27f255c2b45a9a48153ef8f742d88d1c1aefa01479f98cc49450ed5b1145db15698395c2139b1321802f5948cadf359ce14315064a9f404bf47e3fe5637ebd246ac16d2b9fddebe70078582c33fff2019b367b5c7720ab798f8ee6f7713a561aac488ff49e30a812c6a95cc8574c4cad010a93e62c7ba90da801d4844b7873c061a0701deebb967f16ffd2dd5aac785fd40c6c03e41faab6f66713388afd6af87773939f83a965ab0691f7bbbf7cae428fb129dfa36689b642aafae8e6c52e19afb1dd7597848b7787587b9aef1061b129c808c4f4480a90643919f820d39de10f93cdbde1e265a030585d439f5ba83999365da58d4c581ce4b9f82d9645a1243a057060087e288ff8da2bb0f4db8e973fceb1178c935925b7189fdc4c81ef174050329aeae2a256dd7b9e8a57ff143796bb684edff908818f64ea988674c5137d6dd276729f0976749788ea4bb02414462ac81f1c96ede7789174fcf3d0c697ee9d5fab5e9c44dd76b03786ab9b58ba55cd9a1370598d0711a1627e68b166234492db0cc00fc2b9774b921c89bb4034523d9700e207e8adfeb40907060dc10fa6b0040bb9732aa31b1a2b2398bf4724459f5ad53fe720b3882bdc0a0bda069d9b6a1dea931ee46631f88db4042d14d265e985a1c7b83a39341b40890ff24ae1ffe9a14fd5f65e962e5e63ea5a9e0572c1ddebd54d614ae76940e4ba9421d351c2cd46064de251c6bda499fefe7445f33a6c734f930a128c212ada6f90d207d3075205034e92489c65269a30049dcbaedc963f9b910a5e30c3651628540ea6e42e3368fa88fce3f0b9e828f5a3fab6efbfe6eb805f50d2d76f4fe3cbcd288ac70aad69c411562683e4ff20140a49aa3063875a87615bdebcb0329f7e3efb05ca82ec8f030c9cedcc75fead6a9427576970e5f69ba4ccf95b6e6d0acbe2436f7398e43aafa76058e6c2fef1b45724166d3237d7af020f6d65aba00e1502f1adb4bb2b35dca50ff23d31091537337d01b68dbca9ad9c9af7dffedeaf3fe45d9e7b63607c42ec80178a52c6bdf441b361b1a122716edf35dd58544c172f26d7c331eae27811e00fa8cf5f33aa5f4cd9111d29e7815570d1082a393e087289982ebad26825f4c142b4a3e70a43ec71dc36cadf338dc6ef39a547c7fe5b0301a926415e70ed6d451e59d395c3ba5e4d8baf8a8347100a8f5c27642fed67cdb46e42365e4ca30b963fb4302fadc305a5d57e3de2ca2ca77192b0535bdc589d385095f562633acaf4adab985646bffdb570d8789ecde5fce1c0a47a627402195bf3b6c1629d01a07eb2d224a4e147b2f1e3351f27c29e895202baa4560438684273dd1493d4dae6fd10d2d7ac9e15b9b7009e8bb5a2cee6a391f389b0a1918f6dd9a69f55c97302dbadcebe2e00b35710396476ea21e6d1d36fbeb0adf97b3c1cd2ac3db8991fbb7fb385ab618c12f1740a944362a8a3d20838daa15815e4c79825fcf599642cefad5b5a582b9d0add3d3e894e677ba8bdc841bf6388717cd2f1eb5f9396e024c8e309fb8bf70a47839b74b9da074f3a32ac9d2c4fab741a30ee56c2471c3f7d33384b7ba263cae52d4d061ca7952051d54ab817b85be315c75a942919bcbea15f45391131688b218a411bf6b53c9e96df0b87e8bd5535ab9554b328210ffd9bc4bdde0bf4a1531936d1ab46a60b467b461c993be331dd9816a8880b81bed2682c7f4d7e6305f7141915f109ee0d6de5a63af57ec738bbd2ad368f0fe892a826630a89d2606e4686db64e6d29bfd17aa14121a5d6d7532e382e710b898598472a3603c0201ef650beec93992f179008d98e2b3ac3306fe40291f8e4741cb9d52d43617a2650812181658361e87f85c98cf05f7c80e505f47bb4ba483a890234f49f5de8e8a62026d64dc352414f899ecb9f5782fe8291be00993325f5eeeb76600ccb3e719eeef836683b7736266d1bbe52b609d44bb3d31e3a508e0e9f7baaaf5f3117f6576e244a4c5d0d43a84fee32538f792b9867df43a9550856b37a5785c3ac54c36a33583a068e0d88bd467560db4343e9df4e3d572e966db3bfc6941e419547cf3fc206785082e1ae3565f4c23573ccb390f20732a8614741b3e6c0bd7b3847db2cf3e52e9bfb0a130cc5d8ca1c12614d0bcf90696a12297c95bc6340a66cda89c6a6b1ed2e983cace7edd8e54432275fb5270b317dbbdd47d2e57cc1a323e8123f821a8c139ea67b15660753a83acb094b47b66b1814461eed013eea4eb2e3219c9b7b2a7ccc947e3ea49e3d0b1f69ab89573759926c26e0fa093eb99b011aeded419d77f2543b5d867ea035d3be8ad430fcfa2a75589d26f530d7baf9af0687324f639044d1d1ab77db23c34d4370b11e2e9821be45a38733a7b4519b8545bed09cacff418bc88b8f2426067cea76cdf183755651b7cd44973509e01602daa743507fee354bd8b944f26bb6d600ae7b4b3a311dddabb9bd8cf44c9115f3831c33c2aad548fb56c2e9fc373d66932a38fd3a6ea98a6bd1f7c4ee69c05d960cb4706344853ec12221a13c9d20e22e9ec4637de23c982aade6823cf4bda7796b1b0d51c2e306db35cd309dff9cb021ab35bbd651dda468da812a01d3969cb1627a77cff1c6ad7be4e26811a9350d34e10e0041d9d3610e4a5a95f767104f4959a310a4aefdb2962d8a7d647c0a1c6c2f298cdbbcacc4fd6403a2a8e1232e8848dd8c3bbb0a2b01d142302481f0851b4aacba38f925d89374ffcbdeac17c89688b270d9bc2d6a60dcd32636c9d5206a6dc6398cf17d1add2af9c60f352a68af8534e3a134452c96bd6a3b1a143687ef21d526542b8fd191f261905b8a0614763fbb0fd9fec1f6e0faa2127efa462055681c80975760a718d9ea081164890bf086c94e1289ee563fd2cc46ab05c738e3946de09c87108af49377b7261c3b10435f6db7daf690c74d91310ac7f811aa15b4899e1a370407fba2718ab6afbf9410fe2cac32218ad0aeb3f75eac0d616c16089c5816404212f38458f46ec2a23ee54e48a5cff58da2310b15d124b703937c2082438d4433099a03adc4f6eb29511d5404c3bf43accbbdeebe5740cfdc973b8e05cc3bf7808ab0e1fc7c6724d0be97afe597f0b2105fe9b4576b5e33355375e9d4847d70949fba907d87c8bce4002e4238766b0752756581dfa9c184f86aaaf95fdf863ba9b5ee3ef8f37238d8efdb42988b8869359f262d0ec3404b6894c537dcf3f4d052743e6757615b54b06808ba37c49aea4e5dde8172450f2049c8f76382730b0a81ce10711c4cc1e25558d03b3ad43dc7083cfa37e425121f5a0356bd594a6c4544c58eaeeded028a8a4d908d8b71cbf1b348c483bbbda378b223d696678b45c111b6165d19fe313b75288a3fe22750524f6a43fa5db25ff97ca2cfb737854d44863fe8370091f20b2202c264421dd1cd30ca086ae87db6509f985cf74f4d4d0c9278f34303428653506b00a503218632ceb1398c30e3b8e1ab5f5c0d511bd9de6a0a83847dfe7c422925fd6e6e58e18a49fa4d0b8baa24f29c57931863ebb04542fc4792bd23962025ed67a9b4726a7f949fb424c9a7544e61b4c97363aaa71bfa88544b7f1c0d038ba19d8af55ac7f47afc785300d5f0e18e42dfce484a0933bf3f6cff35d6e96f7a586c6972506ab7fa17e4909a734afd1f95bf6048978fbbf234956d4ef85c57a900373f7a84b49b00b2c17a856aa58bc4c1efa7c2d6a1ca3fe97c5839ef3c9405449e09cbf57788e99037adf10f9f7b1db36e712eb1939c2dcd0971f19166145cbf816a90783c550f47a7fd763ce360ab7d9fb811250c70b656143d7713a8d0b0623d270dfa2c9ccaa1833cbe544b48a6719559b3864898a97e7ad95a7d167f73f9e7f7676a4ef56c95ed4f944397248ec4a6f67514e948fe3bb40e4fb1da197786bc09d3244134c3431c4f6217b04f341fe40851d5f3fe35b7fbcb0b55be9368c400dd8ec4a1314bdf35e6e4226262beb7af344307ad1f6dec3e262d9b265bab23ea2c5556ee8a528c88697399497aec1e474e3ac2c6daa8cd363906daf97574b0b33b54a6a45e5e2b44004a621f4abd63bc20fbfeb0ca35d506927c98c5c3f28ee1c77661e8079996b15ad1b56cacf54be9400fd6e5f016d8b4ee7146294d75b15a1a4e0fbad294f2124d36bc7af5c26fdcd6974805d63d5d9169d2ed79171be4a6409719784a7eca17189995613ef4c2face3a05c2b26db0393fdc0a22a6c68440214f58f1f63f06d29d61435b0270a9af9ce0712289bfa5b17361fc3d1ed2e770a58ec00126a2e27bbb0d05ce6479a103f7d527faa3be73e7cef9a894370d803438728896c6c319cd41199cb94e364a7299f16bf3545f033007761f139414efe721a0e4da3454aa6c5f1fb414023a36617958613a5c49bec0ac34c14b6ce7f7db272803b7f650431ca6e31524cb1bc61ab5c70d8636a5c9511a14cde0861eb318e799bbb361460b60ff14f84c330ab315dae3b6c31da104fbc3a9c7ef8a60b94a65bc20e1abbafb644f8a9223bba1eba4eb2f7e84ac2e53caa9a1c36f5916ac1abfca36774556f75fcdb292ec5be88e5e7d45e0f7a0faabee88d1f5e466cc9f5175185be7fed9ab4c0c44a07e7c867f6d2116fb5a338a99f0cc16d2281ba1d53b7a108ac8274b45e959be9aa2c9c6ab4b306c12ec8fed508b3164badfddbcb504ec8cd3c8773c4149bc337726783c870456a91398e0ad4234fe94678d6e515fcb1448ce062a1387236e0b51b4414805da4c9b83ca5002544d5ea33911c3fea48584bffae5cf81e79dd94bf9efa603febc8c02e4b948dd7ab9b314e1f651cf5cf8882703d6c210ebf0bd0a51c03d8c513d8e67b51c62503b01b4868f9ae2c79fc8c691d1c3adf4a5f0230372d76265a92c4cf2cd03b9c320f3134006f284a26e684d83ebf68876f7db89793bff4b94dee4142e894535078c7cfef077b7e7708a365a6b15a9403334cf468b3f9cfbabdb27bc29ed6726dc2b26d2b11944439c3d52c479631f5fc30f480b44dab19e3c5cb4abc4a39e420e1f41990615655f32b0c7a070b1d7af890f57455a27b0e317b14bd32604db3aa52445dcab28f6800baa75886b16406544b4db39cc211d78d8222dd2eb3f7537c97b4cc41d17eb92ed24f3ffcd0a8411cf2be8e24f7cc693203cc271033a3c1f0e64f74be34797eb037aa0a6d737fd6f6a6c9cef00c011a978ac7550e8364e49d0c82ecbb8c14948c89f256ecedbe9f3984d16eacdbcf5b028a6c4624e6bbb15ff486917d35fab457e5dd3fd4a85a26652022f3bd731a8a8d28fbb5371e83165cb783a488a11d406a404bdf82b66a606bd877fc7b138fb81551bde51287f7d7d789441950f7b528fbbd0b61c6b397959516486fe70b4b76402e668b652f31b407dee4750c1185ff355d6fa946176aadc263a37f741492364ce0f321fd7c079b347eab868526ad170e117529a0fe81dd23cdf3b10c1f9cfc7240a5ba3f1674beb46f07368e6c2b3b46b49648201940950aa4303affe60325e393cecac587e4e0ced615c790637cd876b6f2f3da23e9864b05caf9f4da05b8e491a3fd4131ad9fff6d4ce46887c9295f22b20c8dbc2fcf89a3d5799a90eee518a2121fea887b1ef79d197c84f3aa6d25faad1eb65d9453d70eac06bb2e27e7985209d660906552fdc155ce752a2607d4fa63324cdb63d29a50bbf2f53756936a50dba3dcb011598b749327c1a9771fa62ebbd31e0e85efc62d17ebd2f4ad7d21f51f7fb5eb59f428edf04306513da8afc13202c4f4429a79a955ab24eb214f3e6f9ccf6293857d1a1612478b8a41c25075e6670d095e89936c8747db651de40f6a322a7afc2aedc41f297a86ec3ba7137bfec200ab788a00de3ee8f8e28741add4b9d81ec65c189200fcb6224432b6baaef56f2365aa8d104f494b44779a97ffe965c6aac99ae8864fb03ecf9b48ced4433d1edf75f37a1218ca1536c98797d5f9156ef1af03cb21e5019b70ace455879159a221697f365d4e6060b8abaa80a1a3c662606649f95c1a7fa1329ae733b090f92fb86c613a5ead086672d9f14ccd4e58a3ed19e7bfda978ba12fef04a1a3169af70e82cc926315a7a7a32f20332a04cf9bf995fc176ba314e565850c08895fad232896193278531a93801caa3bfffb6bb584f7a86c28dfee7719564e0c86b252155073e5c36a6ba16d693aa845a2ab41633e3f5aa8bd36edadb961a497c091a4104816bb2a557ec9231de7310057bbb50f60d94832dc5cb2e8dc0c2466e3325b51376225c54b06476cc159e7d9d78603642307cebede43e556f5a438488f4e8fd0b4957657800a8650b95be60335eb7782d822cd6ffd400a618d99d89bbf0b498424f70848b952b0b009d81395d2c1d48e02e077d1371bce552a9d963636cf05501e5837f3f996ddd3b79eed71a2709d8b33edc95dafcca57cb308d1a9ac4619a9f3c74ab43358d2295664f65b6567f4a6e63afe8cd4d4ff25b3c6c597730c9e88f6a4f8fde7090d7f09235328e0c8ad5b9e5c36f739effff20a112fc806b7f90c73f262537eaab1a91d5d1e262d2d5d1e649f162439293024eb6809373627d10c81519f4ec5845e8fa8f322a410e6f33bc7bdaa434c6af393fc8d329608067743c1369fcd598ed6c0151168f0aefff63d315b16b2819aecab0a218f419bd883320f62eebe3ce246d20c7383df285f7136bdf1436547648b39c010b6faf3b0be909e21c02f16965fb79b16442148ab3a47f897e0b444b41c919d09ca720d766994bd61a2b06e46f4c92df4129b6c8309fa894a4e033afafc54835e834adf22bd6338308037b700d0f1e52ed8ad4217b67130f54a9772f4a36325fc13a7466ed9be1e8f961b5b1182bf4743ad82ddc70bf356a179bcd054d3867428ddb80c65d779d57aecc308514708d5712b729bc882e4634c276cfbd2614149a5b757cd1ec479ec8e0eaaf7b449755c5f5c55fa12a4134a77c442f228fe29f369c3bc30ea3b6c409c14618cdf896cd4dce966fb425d636f770a3269e5e4c65373199202b6152170af705daa151e735a2e8183fffa10ec022c5ade7b725b8a0fb7f01744fd3e3f33031a81904908e938385908b61c45d9af8b6820279398c9aa2ebd8cec3a83a6929a35077d5c4534ef81de9f05bbb1280d8848ceb3a1e987f5d005cf649515111e817260867ca7d5f5c0b889994c79ded4e3586c155b80ac58cc30f5e395d739b85b8429c75d47b860d715d87d28789955efb36ba5beeba2ec40a8bb5fc712153c91ad1da6ceb0d30b2c08d01d00c66f5b5f26ba3f5d6e436925dffc5e4f4809064f263393d58e2a0c3d683b3653135e574b3a99f2f8c595a28f65d252fbf4665c366155dc59e2af565609ba1b1de45e8d530371e64315279d69f039df10da1850529cf3e9150073f2683f071ad958801e6ae52ec40acb49a91479d06be6831c63a6d10843e6c3ba05d2127cdbb109b7e549081ca321f97a5b6b20dc1d5bc8e28f5572d7e3df1e0e2882f3c0495dbf497856d06ca42ed4af16f606c1b72b9172d50c839391683e71f584d8b97d8801255e62e2302ee8b085bd456d429a56281c8dc944e8625639708dd3054039d9ad3d4671a60ea7b47da820b3042c3810a1568b64be74bca7cc9f03677f5441d65dbf8522303234a9e61041e9f03dc6539abe59e269ae411afdaed29ed37c72015de870d4eac0e0a003e788aaa98e0c9dbd38ad439aaaf04f8cc53c39ca6ec5744fed49da2e0132d7fef5416e6171327b6c5839694c28944c9e7669118afa0ae3bcb97970456736007e39a189a4e07df77871e008aa46e9f6ad5c066dcbbaa3499a11a889fc316b5a9db43b68de41ba22901615f1e14d756d1bb74ff91f6d4e6778fee4aef66b9860d37d3d2464c0027ebeeef809117289a80795bf88003b5562d6f1e9c621093cd2f7d39a2315dc60d68f8725c5773414b340dcd29b406eafe22db09c9669dd3415ba59c961ce4e11ce25f67eae7755fb83632ae3ca2dfb8d4628fcb2c3004b4cd24262d0bf4ec9920fbf92348a9a7f5e037a3088c86d9b8a144b029473e836d5496b36463958472d213b813130be969221352d8f08d1606f8438c6550d45fa7084601efcc06ccf9dc4217d3e843009c1e8dfabb7dcc59ab05f27ba388a607004e703b999344bf34d05664e182f306c776dc638a209f0bce4d569ad10e3af2c3c1c04e4bd792c4117d7d6b73d2a489df17d80520b297c027d572d5f9ceec1f43ad1f89f3d50043e991f60398c2c8e7e9c752fdbc2e7591d7cadd4a82ed230ea1d178c982663545ec2ab833182f1a1c63506d460617fb1d1b45f7c04ee484e57de4ccb113e911d4acb2460490a31976f3671927ef7a7f38644aeca73d16c6e8fe16b94f0b790e0bbf40ab16632d364e3df7a560015f607fbe04bf04ebc2023dd8f6654a0193f402337fa96d666c60890b0adbe148310b092c927e59480bb0e0383aa05bda01403f3e49dbf515793da9f3115d116e2bd8b28e13e19fe7dc8b424cf8c3ed869f933f19ce37fff537945cddceaa0496317347e4f9b190faf9b5ee67a6e226ae11f04118eabf32e90363fa85e2f79d128e474c14b956e0abacaa32507484d4049e260cf00ef9a733905600fe02d2ec71f3c4f05371feb5f657325a65a7fc7d0bd8d02b819da3a262fa200e854384437cb7d1a9e1f82577b2e9a47ca9c9ed980dbc3c84c8d8b4322fa22c6e9a84bfb51b2704252f235bfa5f25408c0e8f2d49c24441584c7eaa9eed22886f1fc02e1af2d2a0cf53b2dfb1e8dc16da14e2d4f063f081891cd9e277d1512c545fe5ff73538c114aa1ed01d0424d9bbb0e9a6dc6459984dd305bfa66fdf634794aec13a4553c55fe595777fca5e4f31c82b2f5d108ba38bc8759ffbc8a564b6df0fe2fe518c3430d96e15bad15f321875036543ccd382c44c982f9575e38602d11e65f16a4bbc65f94331c1f39cd67874445d0bcca2bccb8445fa0fdfcdfcd88c936877cc50dd6c7a4733bac8dc7e5202c0da991ee64e53f4ed52c09e29aca9b36c3cbbd8ac12d76480498d6d7a0ad9634842e8edca3f01063e6382aa72396af2930a84503d3149e3970b727543decbfc15fff2844732283db7e4bafaff23a773d9a2c41045f9b2dab8008ab6e94c4f4af5bc050ea0e65da4f763207da5cf891981d02c5b1f5b879cc107b5a7037b9209c1cd3dadb492aaa20ccf317a8566cf60d38e28db8e52045679b3b43007618ebbd4c3968a10c86c1be3bf37cf29699c1a29af82467e59181eb287703991a10bf72588ba532ddc1ed4c7b332a36b3dd282e74c53e2d4ee45fe944c7a03ef838ed108b5c9a927ab6dddbaf8ebe044e5ac582ffb0c16936b18a73497066b171c0da433c0319c6eaba5a3e2a5f4d5e345e67da831fd74e5d77a7ad20596bc9b750022e7ea10380e2aadade40748d3acca4848c7c8d723e5bb37902c2aa89aad9680a993eb71cea925556ce01e12ac69637c33a4999c05d38bb86716c19b34eec92e6f1bd653d1c9bd8cf56dd5cd646844718c64549e83d6cb85d08ea5bbf52c2963b8c76ac8f4c8ab68b4db4249e5f771e2485ce7909f15eb8694ce5d639ba98a50751f160d84afe5d3054e6dd37b551d514f508a007900b0056f19a13efb34ae541ff161ac71c440980842298dc1520832ff1648509a58ea3be8c49b319ce55a8304a40e81e7fd31f14cfba9adb8a7e314c36d4c8d89eb37f21742e683d4a70e4a8c3d8785a0e576bd82c90e5cd81ba6460ab7428fdc4ba17619fc8ddea0bdc11ecd1b1ca410fc2653bd3a867f859445dad6a6c03635b2bd3e0f33b3aa6346cd7c27fd6f4bfbdd15f692977098a69ba6527c79cd7fcdbb351cf3de7167b0bf21ce5b772265791d2138bd7239a16aaf47277281d10c99bd10b2ac2642bfaa8d0a4a722e1ca5c4f7415f7ef1a16073f51022983195e6a605a9435846d4ee39e14784c3679155c647d351bae1a661da7b7de997d3c2453af71cfa0b72672a6b03670aefbb52f96c3770d81019eaaf73368fc24991ecc8493ae33a4c1522cd6477fc82c0140f980604381fa50f148fe034d033d75975f04fcbe82d894f8ccc0355931b0f141f2a5543d83896be16d926bf2693ce6d080f7c24191fac8159d0b3cea066958e2941c7393e2c7b799cb92ab82ca047b6c8117fa65ce68091c830e7114a45fe321f344a7f2703bf14d0696ec0ec82e4626975cdad72090af3fbabe8e364f6233c0c7b2fff7cefc5e2e9c3fc97b218aded92a69dc22e22c05b97502da03023fa707d094689a94c8abf6ce84b7373d75ade3c4e2966549357cd1e0dd26124c0860be4f9b4f7a9bc4ac4175a1daad871241968f60d23cdd31e83d675732ea3d05afd8cd6d66896a60917c067431088604ccc3b8081b0109544d44743b66b233a632b925199e39efc602d6d1d1b2b2d8b22e3cfac6edbe3bde182716c64414e492d93c9ce9f5c5ed88fb7258d1af409f715c3ba5c0ea92ec6ded7052e6183b4c1d42c0a321c11b31b6a036822196a0c1016a77184e5287c0cb1ef44c1d6bf1d89cd999259b2e516ead8e42d7b8ab4642d8d22aa74ec9e6ea17aa7d89001787cdf04e0a99e8463d6273a7be8418e8495dcaebde3c5d04d72600e4fc99448255adab185d240fbad52329d00f0c6ca39cbc2ef03d1d3be6788bb4c44c5841bc359d6a934e924f70bf1c6542c03635d4f5968f2293d03eed4898cea15b70b2520b27e09ca3caa96e35dc7f3015490ec914cb53789373ae535d0532a604cbb1e7a91e28a210514d63ffd708ba1a3498725e64ea2a5ad26c0432164a8b675d76ea3eb2b2fc0098726e81f18fe7724b7e81c4e4120a42640f740d72dcdb1fe2bd5aa4ac802af6862f6a1d5b4ef21e8179cff2d539b6fc615603bcd2070a23ca868fe38b5ad9e6809a7d9faa6182e0abe816058156fe1575c722617a84eb32a4cfeb1f308f6f24c28158c3b559943aefa99f3511c234570c2ccd1ab1febe2d9e41f392bd329e34b1b52ebbad9cdd7e6930f6beb0bb56c99c26e1936d687685b98b10369b32c6b4b0c909fcb9ae4b56046fee13fd62376138a64beeb05c4367a4acff2cc6798ef2d609f896df5101f54ca6b8f932d45c8482d9d0660c2b1084c788890a36bf15854638a6a13f7f50ff7e9c86592a6af2dda2caa0c8f0d520f58418ffb82c1094c8c1f4230478ebdb751824261b1a3c0e844dda1cfc59e1a69d6bf251a4ed5660b66b7729fb6d6606c70232e80cf0bec62ea6b5359a602ebe889a52fbaf9483ee13a13a42245ce4c0a07659dd00c9ae3dfec51d80f3cbb0e81668192c1344ad0ee6882b5eb9d64d4662513cb8330008af4e5c07f49b7a809b1f35c27b4b61659f93343b8f768f2e62a1f26cb1abfd703e6de265b73a275e80e7cb7cebc12e3bb1aa52620a279bff15f6dc1c129c50fb61cc3d4f8cf7628f71693a202f3bcb69c06a2becbbf37b3edf20af6a8ada883851edd08387ad50ea1beab78a44d45e9ecbd889b175e54e5ca509f5651dbe58a7dd29813ec4c342bc445d3c365f508196e15635bc9262038db8ec4edeb830a59a2b4c7c0e296ca2012a5a08a57e83b7c4f6c44556bc3db00f23bee64b08cd1ce01de8e7083d4de0cd2fda50fcd26f1d27764fb24b2e0b7a3c00ffe5acc742d1ca797c4f55e2a492e35b79c501613329327884f58007e5525afdc8f3876b9bd848c25f4acbb8a9e601058f646a294d9cd29f19de9615ab7e63844a2549cd7f168dc5ba589c1e487800b904ddd0f893eecedf2ca2f5fb5d3c87536f590a5db56daefbd13029459497ea473225cac6ba168c2d1cc09af003c855232a4a74e02184f7eb1108c2855dc9fc2fdaf203f0e47ddce5e03ad13411b991f21ef3331b2905d3777124b727d1434353e12f17b6b38d6e665ed6b222af942bffa74501e8ff75196467e5bec7d506e019a8e4d15e017580bb70587f4f5d66f6aa657e3a23a59a9e171e3ccb21e8f6d91869466c2bc4dd31cb8b4c0a795266e448bd16c567ccee879b0593c8f4e1a8d632d49ef0023724478d598482e996e9773f23a0ba660de6f36c875e8ca1de680a3651858bd446e19e82208ff207bf8761fe99169d62eba160169792c68fac461bc1f58275fd0a038cf214779f81f04e9538e8465b4e121047879484536c669d9c9a6708f883bef5223186c151e95cf643c8acb11a739550b63f31bdae6ff84d030b2bd4a844951f18cde7a7826fc8e4b732fdbcdfb665b9969d2005113e25a6295e65a314070de48412762c32687fa3d8e791a697bb096a80028478dc059fe097eee7df7dd391befc06a1111d76f3ee900217251776176e0bb73115ad4dfe742f7986839f47861b236c46253c9100c69937870781d15b991fae987055e482c3bc4e90406fc3d2c80f6af0ddaed3517be317120471d3d26a75ab2d3c6491219602fd06161574219294e9c2f71fccad413e4f435e5601b6d23427b7b24cb2d90712de1f958da7ee8d9f9abf9a8186b96da0f585e4fc2386fc1f7d4238f63227a3e481269ddb4826b51785a56e6422e9744dd8e1f460803034b66cfaa82b1a5444b9f56209be1b4eed4374525624bcd0bd66c4b758674ebbf76b746c0ae967f836f4fc0a0891a24e1fbcb1541912e19f768d5b5b2346215e13744141fe99fa4c67053c464c9a6420227cfc2298e986bebf68ef14c49623191f5587dd2db1b90b2de70738a228d121d37339617cc71b8347cfffa3e02e04219d89c729871d605f3b6a8d8d0e9a468034a2f223d37ba832b248d677e8accdd04535df5d0f62cca8567e000a5e19ea94a9de655554609f97ca24957b40a33901d534addb5bd0050003e706ead62b8a8911987b9a18b05f4c73f28e72a424105e32fff9833e32eaf9d31810a733d690afa9b96a6df89b8d5b0bbd47d250e647cc7926a3f8bcb43c1cb6490f8b448b68ee9cca5be0ec57ea672d088d1ba2248d87d19fbbee3de9f86e2438f477a8367d1f62f45c8083e8ba9e5e4dd9d8947464f2d3d01bf30a973c86bf6c381c362d08f06c5cd7d6a1591a4c0ddd0e29e57eab093d5296330e24119d4da03c4802bf3668d746b0c2292bf0770ea602f8b4b9c2feed8ec2a4e65e6fbc49b6235317d0c5a2dd120f4dfe422e41f9c1e901a8581731f6506d994c521b3b1744a768e7770ebcb4dfad29df77f6895ff1e31fe702bad036f4fd4416731f6885f2452ba1761d1a293eb525dc57c6f90ba47a3f4f5e63e93ff71f41e574be158115d1bb36952a0315b7b3c4c5290efe7276d23f99b37d832a582c872c41962f3c937e939bb0ea18f54e8d8e0f828e7d98080479fb941f19ac79408b7f67388af4dbde0a139aa7cc381d2657a058a4801fdd8d9c631db1cc211c30c02531423e35bb82a6952ab40be41ed6a56a7f0ef79c50a0c33c1fc89d580a5dcb6f0e72d8fbc7c1cd0d8c5a9150f5ee3c572b35f88e652947cb1a1fed4f1e2cb08ac24c9922c4a4834b449ab70a7ac2d22f66cc7651e565d73aeab4502b5761a7c591af69ee8808de49754e298217a68f9cdc7f507f4d8ef2e0e81ee80caa2b2c3dcd5673bd1f869c40748366ad76ca76e979de0298b55fb49a25a3db14922d750ed7eb28d77e77bd44e0bad651e790d75908acef189df7e7c78bf14ffd8a382117cbbdb0c825d31a537880a0503dc9f8576c30fcecc99453a425dd76a7cfcc784387903eca890c1d54433fe7a44e60c5f15efdf37fa9c503ce3dd48c702809a4dd2d14d7eaf5f97bbae1b764602bf9f5909557a0fe8df205732b9cdcb1cea825512b9d8aade2ad4b74b62a4cdee195b4844e1af914ac2c5e6d478331f717a21fc5ec94f7591840bd37d1830e24427932e36f9d522d6eeec44e57b6d685375cfee5420268569cf76a6cda383fd5aa2c4a9a51a59098ad5a8a87a7dbefb1ee7ea520a42e7781be9a4298aa9b9a49a50a421290711869edbfa719d78ec1107fb71638d8bc324056f5261fd6e860b293caebcaf761cc9c6bd399f941d294c86dd3ec18e482b47cea091d624feb6c3847f0c4899b0ecd88504a042d5c120dfedfbafe1463f20551a61cc506406524500d71b9cee2508659befb5547127c2966c92ae2f3800742c8c47dea3b7c7694e34fe1c4260aad02943bd8df85a8a8028ebad5216bc2bced6d3c10d6812906fbbd6c0fe947cd03155eaf51015e6ac29d813ef4862b9744b898bfbd92cdac04c3f51c2b872e9362e46c3fc3dae0b9e6c51ef5c878b3950e77950752019b32b5151e1b73ee5ef246e019c338b8d5196c094d89b98969cb8a2f305e9c5bd9bece7e1cdb8a060ae51eae42041160368f450e92ed82c1011d91ece2789835e4da113db34a5d49408db40c870e9215d0a40e2ea1a1991462e3b6c6debad62a393b76cc1d8237a517cf5ce15e22dad9628fa6ae7df5704624ea3f80de5728d32f7d931035e9f6f90f89e03178c6910b096b40e2cf6a26576618c8f0bee2c9e36b2252b129b561657f57390ae4daa1044fe96e0a66c161dd6c15cfcbaabe4972eb37778d1d25e7358a83961a3096212e969b9f3ce068417b674ed391ca2b0d8ec7e9da2bceeff106f70cdda0ef32da17f7803d348d60ea680f1053b7c9991f78075fb5c0046e7d2a3252fe4ee6f8e00016b1995ebcb95ff8906f0a6bf016e02c2c4f1d5c17b74feb7656fdfa7e0596c5fa1595cfa96b457cce5b0069a4b429c2451baf398063f38b60305e2c790e83c3ce59b3d35928c62b51e8d41bef4432550f9b1afa129367410ff174f26ec6033815bd3617dc8072757647d80f0af48751048c5d0af7f3cb23d922df936f1710ec03347177bd8ba26bb6803917837bd040d1f091c5f447b3b6378742ca6dba35ce2dafc6b901106be981f001cd299e244a0ed46084f5916bd99edf3fd68aa5d6ef00d5dad984f86a62458893cdd23005c550db19e44faddebfec4bdb5976ad8a19b8071492226b763bee212dec40766e843671b5f42c6d770cc71e2d992cb75302d7378f081e8957f6ce89ab57369488e23ada9ea9cb4fafc08ee3119e1b9af31d100be653cb533a8e2a4a7d5a0d015a3971927770c0e15d6135eac823ef75806b5eacad71aefd745e70f6e8b0e94a6dabe7c75157479c220dee123991e6319e9611b01534e02d263a21f9170fcbd75511d5ed4be772b4e9286020f4883319c8b90e4612e7f27769557a886553436c000c4057090245284946a799fc3fcb6571b81868d1fb55ee2a1e6d8f710471768df2fa856fe74c61617beacf7d0d9bb976dc051e8935d805dbc6311c3fc38e6f038571cff34e07523442fd4dc40865d36ba3c6e60bbb5c5e8cfc002d7ebee9d95b2d026dacbd3dffb0ee3776e43e53c8eab91ec2d302511e068efe7f1ff9f11da3f10dc419a4e4b67ea53938b6227d6357a8ca5bd67ea89b8d32bc6648ab3c1ee03184f8bf1330ebd587149672ff132b389e34fc68339406cafeb3855408ea26da3fc3f413630912c027eb7627787911e77e5ec7776fb202a9db7fc5b5059d905ce004bef7a94255d3a7211b7bf7537031aa9f6f9a3fcc35f3921010674af41f657f99dbea434bffe52b5daf629dd4067222aa3e9b719c590b56c126fb099182d36791603e2430044d6b71a790b3026bc5aad9658349c60bc5894df36fb8ffd960ce863fab8e7d8524befb32d2bcec261e1a799582c576867d521a517ed8aa3327ad367472b8d90e746761e07c6f0eda0731b4f10d79ef926aac9bf4632cc202d7ae7024ad5ac260619a29e3e05d80c31f862b191a4a2b22498b7e65a429c993f12ea3eab4f8f1206072fb77e647f4d0481f2e5950f79eca48dc605e93f4dc9096e0ab54f072e32f0bfec397f7e964a42d3b1619626eb158b9f20be46d56811c3fc76bb9211e4e23323cc34673c72cce04a35c66bc6fbb5bb6bb8c899cd08885db90ce963563b3c340564f4cfbbee9e9e98adc2818b9190f6e7723fd663a00fa348ec88b514e9d74b227522e3eae4f16967bbfe1dacec895b26f6a868eae6f0127b30917f2c7e9dc08685b639859dd4008ac2e54c060270d32a9a28158858988bfe5a00e7a7fc38ff1af16dc1c1b103a628561ef81fc5fdee339dba22c531dfccaccf244474fd2b82afec3870dbb62d70d987bf3fb91c624bb6ed5d256e262d622836267d5eb57901573d8ab3aa0d71b97eb971ae250bd8a6c2857f09eb111f03831f919e7d1c6f2f0301930387a98783fc56fb8e0517022592abd67cbb7cf17ea53a85c9720334e0a53dbefbe136825dd0c5e1566093bec770ba5bfc1c0c2a65d255521f64c05fb37d0c553fb4d5137a9b7","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
