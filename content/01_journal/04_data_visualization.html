<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"daa794010ecefa7c436a694d2db99553dda6956eec51506d3495ce23ac720bfdda85acc8cd2f17818eb5f84a5d14fbfd29f40f057da65bcb3384fc86ef029f75906c947efb2ea9e73cc1d40e4892aba588a5e5d5484ae33589caf7a038fe9eccb9afaa0e84711143c1db1c62ad9bd378e494c2638777c7bafb9b88bfac6f56a7d0979dad097283f2878c2eaa125c858b8e0b9e7e005b1dc840b1a21588d44a792204c9f83008bbeb3bb82d5b3e6d7fe1f29944d647a206f611a76ca1b1dbefcbaa6dadfdf46dd57a7bd0314cbf8e74792dc6b2034394497cf891251596eedec2b592625fdbef5c4d585f8d8a240008c4d0a0b9d825285d65ce164373977e57899b597ac0ee0ff265d4bad6506df15e6c3d9e2a0b47f036c29edf20d97baabd89bc43fac34f75ca88473b162362ff88846926f25efdcde55487333c7dd0b1215fa5c5fbede04deb1a77a98d3f1ed26080b52dbd6a9075980bda4d350f5c5f492c35c08db21f587524595d20c71093b1e4f5047eed0ad3c85970ae7b75174e3c58492c36b9636c2be8bb1b8176e7fe7ce1f971c19248aa376a6b582ca5e5c37a63d17a01f04d1bce8ddd686cc7a731099b000293bd485603e5ae593616ed406695335dd242afc074bf3e8426e4d096b48dd01fc82654b28ac35016f6e520f1fa656d728d897b159b24acde598779fd2ae1a5cc600d935bd33794d9264c9940de13095c9bb18eb16788542c1a5d8a811964ef97247b9a6bd65167e831f548a4777b9006d2adca84f0d38cb816e4a971879752c77bcef48833030380151cb9547bab1ecc77efe28688a09aa2c65b5c45983474a41a2b7babac1c863adf410a10ef00d7da768c2506cae155d4a70af22a7be3be4b47fdbc667efd80acc38118c9315a5fdf4f3f2c3f1717975f299e0d655b2d4923c17fbe3bcfd710a51c0e0a7080d22ac451d8652789fe7533a21549a8f05a47ec0b8ece8b924fecf67d1003422bdef3ce8a18554dcb97d03862b759fd839434e7f695322e95b48ea697e33363ba86f67a2b9ed828427e84b2388f214cffce4c16a0d847e226bd0dc39b2b87538f8b233e70b1a072ba49086181cbd39f7cdcd5222405a105efdb9d9a1d3b1677179969d5df0607836bb7f0b1450a5631a0c12c0cd9ff153b943bd0ed7c9da1ff5add3c0819f14059db71d662beff349af172a35deba3b7ddaa6de4729bb6fa3f5681baf10a9c1ff63c6045b5f7dcbd5c05ce70d0b1915e17dabfb5e8c452b9a64c9a6117365cd667ec325694e74d7f0d7867d1b3a0e577debb03cdb5c9545f975c6b517919f141c48fea00d0616fad62f9cff336013987ce631af464893801ed8a7397625a73ba1cf14dfc6598bb9ada9c2552a7e5c4f05391b367ca197e037dea02bd93d1cec4e977d949b445d1bbe7b107a6801fbe858d6e9d1a465121ef06d3cfabfa7070bfc254609099e018007d6da28164a690ce14c38a6ee1cf64e1b89f9d1196fd2eb89a29ead7d329c54bec189fcc6abf04eda52dba82763d6358162cc01ff3b776c811f3b40174bbe71cb9356c9cbcb7f6dee9565be15a16f9a913dc1f5b15e5bb078523226e4e9d2561cba994267d7a4eaec66339633f9167c1f952bed1e105bbf3b6271ab7438ab7b8f8dbd37683a96e30f9f6dd67ea478622339a52f5e4dc57845093898970b9ec40ed5d0fa49e785bc608898c8abbbc2c8399992d108ecbbfbadbe5447e87b90d54a68ef5cd2a8992200a41371966ab1aba3789aa5abc93d00545cc93cd3af5eed2b2f0c5c70b6a60694941400e164252fd6f06b63fc59ed406dd17c2c36575e49ec79723698d289e25c6d7b0080406b94b16cbafbf1756f49b055a7b5a8b6d59e4e363ea4717b756e3d2ce95abb0a6168176c3f14a77d0183a2b1126ad137ca6ca7a8469c0be948ee4b6008d88200297b5b91e90df2efbefefcc04d49a8b796514b6660b5ccdad262db209a2340614905b013049aa0583e9a1540cfbde9f66e55b2837e04d7784a1692a4a04380e8183f852d7758c84d30f8b1553e9f5a1123c76c83b73ba1af38fe1f5bd8a789fe6906e958f5e0df14fef0827778885016a2efb0a414bd628a86ff1bdaae7c57718fc7bc7ff194dcf840b544e3e505572dc0fff0e5577242a8bd43e442863c5e2d2d9b75a8e968c0d543091e3a98b580e62eb8b19333bac9e711d6534234d457641269ccd435cb5a3b92c3bf4ef2cf26b7b8f5f1b3429d73c91e2a52ba6c06c6cef46729b592debaee848a1eada3ee54dde71342097247a8f30cb3739e7c368446a2b976730ce90b859f59e1f4edeb7c41d259ce1e6a91c7016c19d33a4d6c1a86f8451f720dc406f23369936e3d67c56e7287d242e8c94d318dd1b7e700167f13a08b465b0979a6ae2556e722d19377472311ca3c99f064f7a00e21a4b9aea79074ce67910916d7d9c0a5e990b7313692881ca9b69c2d7008a655006482bf3e0ebcf8c4180ae96e1e787d233b2a087378390b16a7fa9c8f8d2c49ba7fb556075dd1540ddca9e7889dc9a80a275bad7dc32dbb41aaf806c236730881236ce16806ac66d790c11e1a26bf8b18da013560543deb0e5c434dbd6f31a83202ebe9fba0d1a58ca131c182795a432fe763219aa84f34d263f70d515c08953297d824ce3b2f7bc0bd0c03f48870eed3f4689b83f88a44f4c426dff3e33323a8342c5a13fd577b63b5fe717c49338357b91e5babb67f0fe6dac29fd9ab5c4419d2daa98909ceecf9b5a6b9318a7a6a1c5576619da89300c6f79a0aba284d8662f477f1281ec91fdde255c6a6ab847200213116c0ef462db773b65130067496b8a032065e33e5807c4e6f3c785d91ffb156463053ed42873acb29675848927683016f5e001c8253614dfda67b87f1557c2a4aeb99bfae3e31887f1577b8db186bfdebfc0c27e5e953dc19b1e6eac84cbf7cfe94a1008d36749b31dc67be87dd801da5a43b822917149e237de647c4053f4b61d5c407d6831c035d41bce883d6ce5d36bbff9ccc2f09c4ebc771f80eb1504d60b0df9b406bf3ea2f8b2909b7adb529f4766f71b0224c687d91155bb200893cd97cb094eb68c2097b35239ed5ba4deaa6a19ac6335774c7326defac8bfee4f9cc97882de9df7040d00068b5354ee344dfc567e8164501e6bdbb6cb9324231e3556cc8333390d39720d169e1f9b1675fbd263f9be31e8abe4d9c7c1685543bb1308fd3bdb05e5e1ce30ce491eb7524ed47c11bfe871fa6841cf3e8e0b98088d0815b5d9f6ec610393df22f72fc66ad06a24356dfac2bec641b3411db6da3de9b60ccafe4a1ea5d8a087a6d8d7ff8ae0a67c96d3f5b614a6612f847ac0ec862203b1c1c389e94c2b9cb670c7c85441a6b0d44342c85d8b1366a53ce2bb77d34c05c0135df3582026e52849be2948fa0f3cd37b519cb3b13089913a0f118c339d4bc115af4249336d90ffd2b4a4a6d259b813be11c316356b6e52164d16ed1c03ff9171d771faf7f386006af99f15a817f13e4449f017fbafe9e158844a47a5f7b11e661c9f89d511bb0e82db7da3973db231c089dd05a740d209d365cbda2ecf43e41893dea6980fd7792b2b6f627666d2d367a71f2e6a9fb07584ea658878052beda498b0c3316b297eb5b90a9cb0a3d08e51acc7fbb7c981052d61e320d37f5252cc2f6ec8e7bd9ba0f7d06b7755eaf186b3a0e8e6e555f9d25b34a478755dc28dff0909cd6a1048334899280cbe21fa4180dd0dce7f73c9b1fa530cd3556670782282e6cdbeea4cf7b2a9729616137edfb078e07cf924b85eca9bcb0d7b2789a5b9e478306cb8e9601b51b96c70c44db3a5c917cc1d4e45d3cf3f5cb4cf03f356fbfabfd9d4d079de65927ca0b8ea929e760ab7c8de366348b59aa214a46a6e743cfce245c3d1d4ca51846335333bc2a9803f3e849f6a11cd3e9c1d8e43da2367485cdeb6d646ae7f0f120f38327319ef367316971eb10b0e07006cda448bdc0ad82b9a978a9bcf463932678b9a5df57a75455b33debaa86eabdf3f8ae0c32bbe968fb271bb7719d2c68bf0b0f197a9f72cc33cf86a199c0b3b1ec2c2c98f41cc13a89dbb38939e438cffa94a1c4dc2c94849208dbf68e7ba6c5f115bcd0a4f9e6ec32c60294eb424866af05ac92eabf5936ce5fc2b5d45dc5ca9db0ebbedd83b152374f726023efe07788c079bf353e809d71de8bc571a99c23188258faf5814fbb5b953846a9152b38310d3161979a6c44f729448b982f0f1dc01c215e8d90ac4c0d2978db369e47447a17232d12a03af7cac6811c3cbdd7c63d73ef1574e9b12d2447781b44281be357b3913c85f353acd9135d2370ef39640049b49d5343fdfbe6670196dc4dea211aae92209d64a9d604d9a6ab46377f3b5417aee34c59aa0500ca622576cb284de4b6237a5ec3d3bf5b6fbcd3af9d4850b19060f7c60e29752684140bcf31f1ce816cd42a3763bc6c4a158b18e1f5ba4eb06811e6f30780c0bd6f84b5be6fd02aa2c5b2c928bc3691b85281fc8ade36be6a10e37ee5b4bd895efc470ec2aa313b11500ef918c04603aa5d704f2ca56180692184099a7be790d72a6789501d6dc2d181d0f54b75a2dff354872358e5c6c53834ff0b49bb4f1f662111e41f1653b08773cebb32edfbdbdb5dbe7501f7d3c18138cc01997d1a52bbe811bc4a17dcfdbed88d094ad89db3834456f0fd5357af71c2d44c2f3e62187372b176a3fb197748c766b43c6d23e7519d5d5d74ca6670b900dc76d171fc02e521c70d70805136ad5419918ec12064a9f38c5e9390bc88cc46e05aeb82251895f9df41c1a941420de1b9d27bfcc54a5a883247120315b918d47d36a009dc0d92d3300f5d3ffdc4d5e57a307b53a82105db945231d3e8ecaabdedc63defde1653629bee1ac2fad51d4824562275742d5dce4734c1ed8b128077f764e138b73aa6d1ff5a0b14a19267f7323c836200543cac3fefb6f4254ee8304c20d71f46b7fe04f9ce8e05726f87cad5eeaa7f7d0c79e3f9d6c3546314866316ae31b8f31af45748f57449a8b8376af2f5f0218d679eef93cd2ee288a398c27cc98aed489c9892c0a8752c70838ffa61cc11704ab70a9435f0bca4a11c1fc9fbd83b6d4ebf5848fd24e7f5e735d951584809095c741059de1830d5a5de07a160ebba1a3ee1226c2663e65e99c05e8461f5a92f9ad6c076d5a3c61ff8775a446fb5e76df898471317564a9e2d2903e7681a92061118e527f7699106faa8fb66e7329d5b46bede8e65cdf9f7009404d06a744b66b9930559e7e6df21b0d11681338a0e7e7e6b4c5433acb8eb1d50e2f109e9b15d3e8a9737c81b47fb2d8e9550be185700a15447fd1f3b00eac0eec592e841cc8172144e62ef49f569f64bde4948ebc10b1539aad7df75079fde36eb3a71e08b2cf7cab5073e5e85abebc6d824a15ed2fe44012be02eb003e9f24004d6b3a1e84256f9964653572572d2824b2e847824f59f050e3a42b16808be96b241dc515942a300d6ecc9e1fab95bb95d4dff8b42caa6b0598dd3225bd6bfffcaa236a54759597ed21c4e529220f00c29f70dbb211155676075c81075c6c5439f3af67d7466ed91ef22bc8e90556fde9b4376bd38a79e82757706b27960be039a33978adad129ca1fcb66adb57adff3b22fabb41462cb9290edcb415702abd9c5c18e1af53a57a0517f8ff1fa42507885b7a1e13b2af837b90bd948e704b029efdb2573c584066c9877caa635eee8ed5f3e8348d25d16f4197872060be0c407c1f323650c32b4b31b910c0099112524f9821f1c926c0ff94683001777e295d54094bd9a5ea4388e1200fb856485a017ba26f0d899e9bdc986851ed55fc20a0fb641f208b227d1f30ee8d82255eee034ef24e5e471a31aab6e3ab20f6b9fa054f89236c4e736f5a9a05b14e0d3a7e748d12f480497aa018a36fd698c00af547ec5bbc7b34553e225c0e0ab868851f62dcd39b7ba9f8408ce12d2815477894dff9dd9b92b10bc21f3fd7a16f84cef3ab784401a609f043aeaab953360717049e59a1d5daef85f5b4b9bd9a93d92a01dcb97f80d043b3f055b7d81a0f232db0c7e208aa1619e756eb6fa2ffa792546b06ca30c1522dcda5fa8c1417468c3c503cb1531bc3bf6a2bcb515514a9fe1ed9c83a48534cea7cdf74c6e95b2f52cf3e5a727dfa9b14ea6afd91c094c42da6f0cee7e9024ebc5935ad04a62faa4dc27fd0a39a9c869d947f064c741f89d23017e6d1adfe81a794382d3507233ef38030539f078dd1702924f3b5ae8879c98a4bfd9bf207f64d5b2935982ac38b65ca247b0c7b57524e72abddc93a9d669a44a10cbd2f9753f03697081f7818288a68f10ba3f1ec26cdbe23f235278a5981fb42634ebd98a83565738ff19c997fe101cd457fb63a64c1c5a4dd9b5331342990d27d5da2694260080e0fc2eb2b338d4cd1f8c2a5b8a2891f7cf8cba809349c9d183c82f0466536a0b2399792b85fe758b35cbb18344c21a0acd13bc2beccd92edba39dae84fea1846cb6d34316206c79c4831879841dfe96616387729a1c79d4f7ca0ad39a7d2fd8f7ec1b9b74390699a8a3409dfdef6dd0f34a16db873ab912152fb954c4df91f7df268920117e13473261b70c9d31faf97dad1bf10c69531693cbc4d0808355cb1e7948e8dcb3b7cb4db0295fcc87359ce7a834c2d361a8b40094bc8c47ff0968a3b126f7b549252fa922a2dbfd9a82944ec1a66ec1159eb21b45737e66cf5fe23194c77aa8872478f24c92f3f9cfb52498da27d6587fc267de33f838577b8b7b5837a8418020318fd522eaf1ea81152379e89a4d235c4cbedda6e459c4d515d14b605ae6e5526b8b6babd76f0eab0df7574a6b166213d429435c8bc681ba654a86e358d98bad40c88b37adfcb79e245339f889dc7f7a3aa69c5c78dfc0aa57e59ba201bab9840b86648445fb65ce9e246586076b18d153d7f4e0a38932613a2670e17f610f4b2fff7761189e07a18e7a407e04a9dd98c4e9e89a5c807f6fa2df6d21deb317dc07fbaac8718e79e3d441ccd47d279518ef695e5025db07e3dd954bc1f7bfd8319f1f1c5073edd3352720ec7e4129a99c37f05e005f7fd20b3a306ca425b49ee7ff4456577669518cdb36b3e75de258a2f8568980cb5c12e183929a66ad4460d9942eddc61f06cd8ec9132776ccc4a4fef6e0c0d3ef02a6db667631e8b327861a04ac325b25ced7c8b0cc616aa84dc12c17150aafaed7034ab9774e0a337a90cbcdaa3e25f45455cc47a8fa0f10249b38876a8fc2f2ad1bc4f1f75a3941d6c1203708a919522b877db2c392a6356eb99b459c2ab32a0c0a97142db0b5027c49388740e190f5d85d1d3e316ba306b09d1e9e42f47066c7ae2c2e15fed794ff2166dd978a297bcb44c9a6287c69485e7b6f274c0d6a863692ec8af718162d6a2cefcacdafad79ab5503385c6994845b6b800fc09cf40ec0ccd71d90ddf2f4fc71c4848b9b0e012c10f0d6e30f002552cea9c89ed1898c863d3abbad6eff0fa928296569aa34f52a26b9fc3fa0e178a5d10ed7922ed5c7f3c0a57a2563b4978b4c45f3c0938ac2180d8323e2b7060e06f2b1bb64c9b53ce83e344af9c89fa861ee1271e3ebb14521d3008f795e4a9b5ee69640b87c8d8875832138f3f1176da46c9a330e45b489071bf38439b868b8c7fc9f91c0ad5aade3fe44cdaed713373f008162bd13b831098eaf03ff923708a7ae7c7398ba7064b128be33a19a59ba9ee12fec0697e554c28a426ca9b5327e2f6c933e365f510b07abb8ffeb31f0900e79fbaa4289e2ea48e3393e314679ea08d2c47c3ad8c552b83bd3c92b77b84c70dd1a1dba3e5d467ab447a3460c1695f8a8833879d745c38abad035fd4b5d8458802fc8273356c13abb07df2f408a3714e2c90876f8c4043b61e2f09f0499ac0cf38be0e6dd5d125bba53194e8dfb5461d8d53d2d98419d2ce14a843361559717de2f31bb5909621aa6ec846902b0f12c831c5c5f78d77f81eb9771c23ed41c556b8615fca2d5d9daebe011b0a2f2bee8bedcd1c0eef7cd29082f1bbaf09e1f0964dfead29ec731229bdcc6e5b2de4667e9d035b38f0ffdcc6c369b5f019d5a0c34b21e0e2e0d480bd253a190bbfec7d0af20a02675de00f5d9fc64cc19febee61fead95406ecfe49b7cc36f5f51eb784066cd33dd7dc59e732ab4332bd93416566292215fb956b3d6962dc9a7d90b4da620d19508e6597e8cbe22f02475f8f52b80b54c7284808790de6624cecd00b8967315c022e81f6e57cbd2cc3f02376aa03376b6c692fa4c12fd3ee1e27bf534c1d8cca5a6b9736fd56c1e02af2cb9eab963e28aa6bdb5a31145444f1456a14629a0c3ae05adc0e2722a2708d7fa37fd49adda5d816223eb7e83f1d158cf00a8000d3597ceb5293189a2b4b8c60e213743ba548b128a7cf6ce9bda12d2e5f84eeace68694a20faa09ff347d959de1dfdf57388547dc7d026e0f2959321e331ec8afc95ca894c73fbf4a3ec8e19ca943f9828314329b3d97530a621a19c8d68de68c60c3d1c453cf04281e661f0dbce18a7dacc8a55ea757c3460606255a87a7f01c74c1ab4d7b01e1dd994808b540ed0b1e141286367cfb434480f519fda804851482f75e1f8da8e2d957dfaf00af90047452d8c95570bc818b0981d613b62eeb3468f5a279ac4d70f536ad0545773ed5bc76c0d75edc479343562bb689dd67dd5fc5e04a87814b79d7821173331c27d0e73f516080844125ae3d1e6a4e707f6838c4580f938cc41dc6fae9d4faba9fe414bcc057b54952aae1feab63de197b4c86eadcf1002c6c6f2ef0a528c7e046edd40cacdcc925f7988607f5caac3917a55180e1b451c25b0769beed128cef241c2229881dacb2df27b303f4025cd228c959c07f80fe5e4f670aa2698b2d7a92c1a6f2f7e6d95471cd04cd8d174295d48a9bbd96c1b97fb18f0001779f4a4291d61b83d6284171c4ae33324618d0544b938f2ce5c662d3f1dad3f76eb5b8c951df4d756e7cce0981a52564e5a1c901b02e3af9b2f2754db2ed343130485ca8b5418c83cdf513f66436bcb104088f133a95d3a04c3aa7387e9357e3d36f10ede3bbd4b9193434c99bd0ae0257591d2463b221ed374199bca906a4b02dad55e72f702b5247d080fda82a01ed60bd7bcfeccb590f8155ba55ff2a27c309b0e9bc41fcfa447d31803d73e20238db543f34d6db79516e3ebcb69dde1c9fc38800c00343875e4cbe2284235e92875f5a9dcc13c2c14c3c0f1348bf5d2ac62a0c3c3e29d7a0dfdd74989170ce3dbe6b288326b0b458e272567d3f535bf73af5a9452a4b045a58eb8251e12eca8fce11160fae70944094752b589fe829c3cd8c80a6e625758bcca5fe1aa525da19595b8ff166dcd086e29acf85ab0f235ff6883883f02a37fccc66d961387bf8076281f0d3b8f07de221403de672a801267e1c1f385e7b20a449c889ad93b86548ae9ba2f6c2929b4db68a453f171ca4f91741bf17168fa638715181ca6098962c4774bd486e7991ac6a4de7758cd35c456b9e6fc794fa9530345154769419ac4453256b75b55b7b24e25e9933fb270d644b5be0e0634a8f04043215e9bbcb5bb0b382efb85863c2abdef5930e498c79dfa6fcdd86b0588ee31ccc89d23fc7bd8e164591cd5545faf91231ef2e88b51cbe81953ebb8cc6f9a79d0d2605704358fdcd053ed04488c5b3220e2be9cbdce81e6b01a024eb93bf9ae93d7c8ba308e0b3098325e7f160a4a2a7c3ba489b0dfb112a670ad37ea78fff3e491a0866bf95410a2f5575d5c2438079ade2011ce141952daa1b06ed678aa5321718409cbc13505cba3179caf419449ae688371631dc1a64929758c6f4a480fb2c0e8ba427354c20c9cff6d6a63a5ad65729e724cb689ecc714def053b5a9bca10a0a99b9366dbf07527e51548a203285fb247d99c0b1d0790a8a193bda62e52c06dafbd7c8bfb46b08168c6ef8e4630f835017561c1e60a07f06b4e4eb7811b7df9f3732d4f4eb1266e8f7a207e652733aaa06db7c3dbd2ba726d72cc68c884d33526f94f743db3b287057aeb1a41a4543bd365d19e905c9b8dbe3e48a30dac7dd9b7f05067ee40b617de069f2f51962220776f6809c43b76a502d8a3f9ec5b5e77e0e9e500bd15700ffe9ab62f63ddfe3e158707c862a984d4838b716d07d685c0b02b9969161eb68a07fb7c5044f9fc0df76b497a95dedb7c562752a2b2412e23bec0c9b35cb7f7d1fefc2af2336b6e9680ab30f1278aa58b1f801ba107112f3157b40737eabe20ed82837a1f1ada410350021c3dd32c72df5f157d2cb8b54883a3bd270f68814abdc04ca8943030739e3b6e6a9c41351f2077102dd61f53e59f7b306a11cb3b09881d867c74ca62d696b6481bf77b343b09f417f15fbfd64f6404683f74008b3ded11a55bd43f35e8f1fd251df74ac6e9009b74803b2dd5e5287b4f73ac9d0e4d3d1303f5f1d2a336c353e0482e9bb3c21b2f5611cae143f7ad0c66684f4db16f407c38d962c015a425432bc3f262fdf7bbcfff34079129daaf1c17bbf697d5115d51478bbb3adc5d78a0843cbc3f6fd213eff9cb9ee5a3a19f77556a3edce16ab30ca269133a1750a5f17401d777038cc64e0b24a0d2ea6804296736d58e3087d950dd673912979feb9dfe24febdeca3c75d7349d2bab187a26f275165dc0fbc2916678ba3165e9eaaa69bd164d08a4d25df76a5d474c09cd5677142260ca844fb3f7fc3b730f2a8faffebd0c812501e48dabfce3ea235efcd3a02945b8b99e7044d7205bb1ef77821a23e2fdd134da8d531b1ebc1bba102158e227ba53bfc1db0d8234f4c3f6f12de9c78a4a4c4649f4d9dda48bb51e1487cf659741e81d26863064571823c1a23e83d5265e732782c530722309848054191cac86f611b52af2413d68e2affe57532c3e405e10d3761e2b108bc60c40736e0074206f659a39af92bed2baa55b8f06323d01787ded685d2ba0c286eb165b06fedff2c44259a38917c38e019ff3243c569a7bb98ff554b5cc2c0483c28ad54f36cd8a775a527fa0e3b5e92de0f988cf8b67ec39a671b28f3e53a4a56215cab77a403cc4acf6b2683289b7b6f5e780f8149faea345f3846abe9564a7ff7f2fc3bd7e4bcc2a7ccea7a862eebd7a59f7ff0218529bfb046f0f2d8794f90a18e9f6f7480cc7ee6625e3d6f2dff563724e19cfa040e6ef89fd31be2eb5afb0e3faa30e23ba970a4e1d84d5a554a18da28b6145a4ffc6105280760e8bb5d7b66ff35dbb70e45fef3c79cadbadac1d3331b2739f71908f8b9511a2e37f886b105a2cb5fe00056f52adcfa46a33f464794d8fa9ecf3f06874ac0de3f672e3ee2d1e60200e0231a2586394833e79aa023fae4cb2084a6b65e30324d83ba3fe6c6c80a818129a2c96484fbc26b930d871b018ddfa7a0d500c2ff6abd5fd305198475cc290d5a550b65ef1699d3e85c890344efc4637df24cdba6f96bc37d839134aa962141fe4335c58db740320b43e1f4716976cc5baa9954938ac5de0b1d1830eee84b8f960db741273654237bfa95f990fdc8d1e27e6d0ba7593f92b21793a073b264faaa401f385b692b74c5f1e7caba8911dad45acbead875e64f11ead5ab09ca273eb7b8d1e2fd0744f605b1cad3ae1816f8c95bc3844d8582cbbeb1e2ff5a82dcb7dd8422263118b839d8f8b8e5c9b02173bdf56d26fe3e49857f4635738b68ec1df71e96c4339a11b923051b210324748e0f8aa297023c54f2a07d7767655e3846bb9d78f8b426b5299e754b998f5e364f65119d75d429a15345366235cba3e0bf0755364f3c1217183f5535d60559ec022f878740cd30140ae21b64d0b35456c61763bfc7610da0975d57d30286e74d585c5b031d16ebac79d436ea6a0a8892040ffef03be9504444bfbb8d4b287e7c00831cfc57acd7e289ea8ef94390d3b84b371478a7e6d2b52be3e107c18d925444adb81a380a10413f44f08bb973829dd1f14e94369c9de81d8293f64c3b023610a04bb76fcd0b5750c8c6d0813d00dfca2c9323baf66ab46758b98473b047d9679dc9c9c3d16072b04aeb0cf414c86b0a1bb464a630234c70c1719298d7162f6455d8b40e1335a6b68387ad4bee005ccd8a1c3db411436f8e0971a6d006e2a024ff51cb76b0c6573ba30cbe066614b0206ab4ec62ea681f950f1e8776b10464ec5f9e03c97da51c9eacd3203025362bf11c84c25dde1f421c7cbb86e058979b62ba1524c4b96ac887fca77415c54c0fc91e26065768097771cc6ea5df5c1e5542192ed08d294f88a2abc62a61afdc319d53952b6404a597345478500d66133ee2d87a8b0f166e5614eb845d30e48b6849b5aa4d4d3cb66f91a8de25166d3fc31f8b5be8d3422f313741c096a0689c1e813489844f01954b8430ef614c2274918abc09c53a520202f31f2673dcd4187ae3d5966d0745955447b3a0454a0e676230e6f6aed1e65b7f13090b99a74ad20006dd9daa64fdf9f5ca9e688eb63257ce0c74e5ea7a9649ed6705984040a068a4deaa63522ac2a30c7e0242f4238970cd09737ff473b4ab56898a2edf9823b9939036b410a365b98506ab4e3c250c5946feb159ee62b7da10565180512a41a1437f513fc69e83b94b6747734b47205a6b8506b3dc4138d8dbc180bc7eed956d5af02f81180417e00e8424374f19c109cbc49d38db1b9acb0fe43374355e7603bca75737b4863c876774eac4f8d039fb76e0c1d5caf4f8d851c5265f57efa54800c0e3f97510dc8f6c96aa5c4d90bad16d2922351ce9f4dd5f848daf2ae3f65f39fe91e5c6e54a08d0b0de1abb6d9bff0f40fcb6061c4656c70522d98133837d834b679c451d6e2049d06627590b19e88fbc47dffb60d749b15a6d8cd4cce6ba79b758b51f792434edd7d1a792472b5fd2f503ae282e37cad7dd96c185cb3dd4978d64816af1c8ec1191015af6140a03081e7fe9d15a3fc18d00dbacb2f347f2619310c55b6383dccc4714eddd7683d861d5f9162063561b2e6430c4e40cfdf0e084768d0100505b524558692ae2e532aa4f50413a4a3456b4091725a24d391ee01cf16652bce3df5b19b5e6792685397cbea6e72ce3d32fc2a3a7d83c18bece3c5b0ac974f6208ff6a5598a98f589f9d3d5fe5cb305535aa5680ae4674344d0afb40e7288e49a72eb74a3430e52d0d9cfab95d95d033e28c4284aed2f273b03645a64807a6043f12ed94dd3ee68d1ad1a53fe1c40559bbbe520117a81c0d2121f56aee66eb0611219bcea61efd7e36dabfba411f4fbe8db7acddf537206a5278ff7a4bfc7c6ecfecc6c1ec49f4e21eac0e86801955587684291f76c86f28a2ffb127e66dfa8b1c222aeddf7e4355537a748679bf342e3985d349a023501a48650b08571b235f08d5a9fab80290a50793b09f0db7bc09ca6accea4e7cade079e0ef8c47bdfe19f8ac77ebc5f6191b14d063d22b67f96c27cb3acf4fbff63027d5efea94b9145d2698b8c37d41a7b2aa27a9444e8da9b00ea05cd73d87e045c420701866f517d2c40cb71fde3582d68931fd89358429216f6332d91f9df9417a3bebd6d91b1c000e974a36032207e29fcd8e558603e946a601080e1115b48ba3ad5b9895635490bc4d0c75e35b6d02cc7e071dd8e7d764a19aae8ae2c5bdc74f629c202a7bc98d7f47d374cde3f603d6c4bce7e3b24c5aee1bd0d49ba6b4dfb8692d0281eee64ded009e50ee70fcd21fd6e8ea4eb1fb1c44c4f2d83eac1258c72fee1c8066e8ac275c4d37886563daa2255b295efa12327dcd1cea38b9bc59e24b1b7810c422b179f6cf5f5cd85afcd0e5febb27b8792360af3c35567a0bc5837e95a1253f7075d8924ddf674499d6bfdd0dcd4ebe7dc50f05181c01f3b8f4a39dc05ce6cbdf2cc1bdc558cee2fa60bbbc5f97cd37490dcb108ed129898f669a8ef694c268e8277d6a30becce494b3f54b93902a6486caa6059833fc44a4314c9da0ac3c6c137ecf012da7d77f9fca2fe89293135e7872cc97472137df7e0897a65c1500253f3781fe8fb5a111014c47a1087c67070a1464820e2b8f9e943d24f4e195438f8a12786349f1c8859bbaaae697c8b8d7569cf03c7e8c5b34b863b7f2b2291b9469aa1dc09e46708f30f2ba20ef1f674fe1857d61d21ddb996aad1d7f82d4081cda8a23fe69cccecf2fb6c08b0096f1eb4c74da70e2f58d633563d5e5a6b9975d75bc8466e7ab61d4c646aa28916643fc9d0f5670ef2b377bf2ea1ec3939ba3bc54158c8ec09c3c4a1f188c37f26544d079945e30b2bda8e0be663c6b93e1dcb595e7aae258c6b3a95c48ebc9b3eac022323b4b6d90180c68857db96ed441bbd1064c6e98a9c6bf0637d205feaf8153c90297176decbb37ddb7475523582f5a38d0e3b93fe343832db89c004ff7fbe5075bb59c4f58de715a718248d5516a553f22e2d54add3d5fadf2eb0660f1ceab197f102dda59479688ca3188bad713cead32bebbe39d671d4d216c463fc20a0e832b5421d757809c39cbe4a25d337069e6a902fd244c914b3a83801103d014ac3b9074ea4b3c3777174e1863b899e615fcd1541da1cc48fffbe0b53304b8d97cebc340ec29c8854ddd0ce310c5aa3c86e7aa816f15d0eb63cee16bcb105015f1cec93fbdd9f41f26b591a8133f6d1cbc29763b144195b5b2da173e63cc76d40e55a71c9ad79731d1deb07053768c4f80747e277423638a1b3ca91f9992c026cd5a028f7f6cd1e3b14fdff61aa5150d073d5a10190b3ab9f6a97beb90d149a743014b66d2673b05402de6cf7eaed9b4d0ddf270a1a585fd2a81ae206460f9e45f0767508d37fd9fde35f36659c74a276b4e99ca8632f0f3eba88be2a4aba2cf5063ea9daed1d7f2d648c1af2691bfbb0ff699f48118317ee619d5d68552d94f2e1e1b3f1fd31dafe388b5a88693bfb8c7c18929bfea85e42750dc17bc731bbcb61104b02b6e15cfa382dd71297d6f15b8b49b6f9d941cf24d483483b0773d16ce3ec2041ec4169c9a276c3ff938c9a8683c0f7bf77f7d2ef2cf891b46afc6410fbd921a632bab1d16d5696905a5e1350f3f9cb8c43dc476c64ed322215195325281e86e15f3dbc94af4b373a394cac579b405cd50bede9b1c7faa0f9d3911e59f8f3a90ed4ea8bed20566da71b0975656576daac01c3b5344658560bbb989172081867946378b158ec08698fcff2ab7fb7aa323b64004e1b73ce3dc6840d2db03ecd1bc842d865916c3c68b25f4b9315737eed424c3440e2ccc3e389806fccd8c1e13d7d4d200c97ce8e1126f2c20982956851d2850e40f72dae7063c31d18a03fad96c31d965f089ba40f1ab741084c04047f47d33b0327b2cee38588609a81177462a79b9f6454ef84ac22b4a5dfe4a032917541dda8322e4d38c810adec815e711cb62a31af1944945e861950e4396fe31353c3921bdc7546909f46f8cb6fe2d0cb2c39c3523c883db1c91f749b35e721023ae67f3982e31c467cfe6390a717ca35f16bf3a3a11a0f352653cd060651f8f523604dbc7046ca2e926ea9f1ad52dd11bed9157b5fe1acaa0393d062394c970393f58be0df42c61c3247f5f1f14a65493f6c70662863517428e2f9adc639f7f403021d6cc9f67cffed6d5b1ae54b2c0d7aee402871b7833f4cd476d1e812bed49dbcd61ac54e44f55c4240e6787a7a523b57c0a52bd1bee389a4922e4f96a4462b89d35ab7640a60c30ad13893a53d36b250a5b3d8180f3057c779376fdf9c1cb505d84d0642cf56b4b28afa6850aee3bb9fd24f74ef86b169b9ec2116c431195aece85e0bf7d4e510ed7e3c4ca652048663d9b24eab6e03b371e458c038eb6cbfd18241d5f67db5c606b53ed221f8fca01fb441f452b0d31319bad59e3fd55b5f4f4487a1749bfcfc9519943868d93b822c69406fffff60f6d1962ed841b98f953349221c8e80f01522a93822ec4e351752ca630d7894069054dd99d17f79d4247068db3e9ab3aa6d8ad9f104e043b2714de0c57026a1afa9f9084a13c9660a397895e0010c8d28270a59e7461f6aa027b745986efcdf40e61b0a4168172d0d5efb83f1264b79a338532415884517ea35a8e599ea6767f5365a667dd83199be1bc4cf15e750aa3420701007f31a41380e1686f217855d5d95c5cb8e93850e22f754b394ec3fac3ba40a011ba22e6f065bb02275d78b57cb0df3c677403a5515c3c73738f69ab02d7c809aa65956ec35c57d6a72c49c1bced91e1fa5565b807883af3abd4c9a4af77b25c374854dcb130d342ee415ea5ad3ac656bed14468ca2ea9969d0cc1108aa400ff7cb30f22f838e39d00ba6542ce501d29cd9036f42d7cea73cd6dcf84d7dcf564178908a967ab482b7aa27f8eba4d33201ac4b83cfae49bffc68c575ebf704d1f317fe96ea9ed874501cc138fd6526e4504bdc22de3d80298b37f14db7ee390dedf44b80433d6e781adda4d0faca5ad543c7e28b606be9b95cb46fc3f45e0aa6e9b4f7fe0164885c586bae67ecf74d43114b55f63b6e278d975f754d79464f4be278d1c5a111a30d36720f8107e20cdb9564b4686786fb16d111e6f9afd09f86078ed690f97d77459e84c991d4138ba2545bba4bbb55ce256dd7f162577c2da74b3207fc9f927c89a1ab3c3dcb586b30dca703776ab67e796b559a88c41ebc20d48918c458eb47dd47070b8dd62568e9db4b262a02118eee77f3926c4e81216c9d04717d2c38efe5835f3aee7c443cad4888588955783e7aa336a2b5f7bae45e4a131571981e33c2f131af8da599d8960ea1d548a8874d590c393c36293b55ef7a84c2786ad520faf1d1557aef0f1ac9b5e8be989afc3157eacec86101d5e228828e710466bdee63273593bd5571f9ceaec1f433d72c758733529878234fcf8a51e0b06952d282d486552e71791632818d3c8812aa6448bf73199e33d7e99c687204e8d6553e5d08735fa3e907910eb887a00bb4ed1d3a4c79a8b159f006f83d1b8b482d81b04ad0d7f885900126197aff93cc8b5366d391065b016938709f299aa93d1ca5625de9723f837f509125d109716175dbd500d728c846ce0e96f2a3daad55a35b8dcbce4b9985bf9e592e0d8e2e7821fb552653929767cdd22db121aa58c5824f9aac71bb423fb0b115ee7e90b7022921cf95ceb3db8cf4409fc83b173f16e868fc91330ec12dc777262502b04be0030afd7f68b76d6666f6ea9483bfe595be0fbb7586e24522cb8d52539231d774bd173eb45ae9341126e94dc167d2346008577b8c026a1f31c1b58a91c16f0c093fe43caba60836f1817b0763408a0ddc48be4a4e715639ab6670e86493318bdcf984aa97c2dd8fe533d4a8557d1d54f356979fd19d5c8fa434aa6873aa0f7623b99358182dccb098149c72841ab99c31c5c19e32dde5e8c3cfab1a09c5caccc86afec28b29bc6116c94cce911d98765f3cbacffb5df36c1857a287aab9fda5d6fac9d475db9463e40d5c1ca69d74d2ed7c5c2620c7244d0eb07b00db8ca02eb8dd004189cf7900b7516ab7902d6bbe28db87c423b670ddda15c1d4c69ddc6fa4c2a7b2a2fbd6f6f409cdb3aff64056deaaec5e0a1fa656d98a16587d67c1bef6cc73e29ee12fb9f80f80b6b3c4612ad138aad593dfad19c96e951ab094da4b891102ef9e2e352783df5dc9eee7380bf0be1baed1547f2f17b4d9e289c0a0f6b028f8c0cf2d02643d12ae6659e0d0b87a48286f3f44e5b5ae7e3679708d2962c76a013616aedc99491c6dc97b62e6a298264175c6cc438843ed4235d7c803962057730a73dab30cab760e762f53d7611af8d19c64334e4befffdca8d968a567038c77a15ec2f432122892ee6f3f6cedb3eee7026e96c13f7e0a0397094140f9967b83e84be4352881d9f9bf831b5553dd06b0efeab1a9b6bc6f1f0b573a2fc3732a2d934fe5a494d7ceb41a840631ed4c32ee6eef579d95eb7c4f7225f5acb5fcbc48941f5db38f4c18f225730901e47fd7a0e13662144d93f5b4f68faa91fbf9b9d10faba355c45f8559972c6b2782ba8d1142466ae5d16f4a2dc789157c63a1b8814972abf8851937b8df1c1c0d85242f7975c8cc6ccccb957a75770e55d670ac8b90bb23b09c80cc9a0bf178f401dc15432007cbdb03d5cac02af3ce5f69dd47fa4412856f4225a58a430f80bed934e0847759d8a49c837b44750a78c48673fcd809496c04db912e56c1e312feb4daefd47f206130c292bc814e5c836cf61bc2982574fb2aca8fb51c69c0dd392570dfc51ed77e5b469efb9c3961b57401e8465cb2f31c22d8c875426bcaa52a4a300ca9875b16b2449f4f600bca2d6cf8ec9a47c3aa8508782f167369e8de1ef0e369f3359717d42d600d571b23e918d868a5058cc289208390449520abea39c1fb6def7b1e4ae5f5b00ddb7b5e7b7d08a524783a6d08c62e219d65d4ed253e13a53ca744d300a9ee3a95a3c5920dbec468a1b7b102b7e83efcdb6a16f74edb54e0b46d830a902660f6f89ce672b5878b5b481a318ace720893e3be630f564c4edb9ca4b38416a4a36552e73039188a6013fecd1027585e36089cf3d536aae0526e7a7cfb4d470febc81b94d3896fd5f1108c3ce93f1698d176c82d3babbdef5e0fec4c4c9cd6d700f74bb965eec485ff6f0f5c633eecbe42a8ed1e574f3d75a79e1aba08789b752d308950888ad91b5522a4e192411e52c21ba473aedf0ec9bf845a3cb1b0781aec7dc1319e31d609bd433497ddbb5eb30e4efd81bb36d555e6621cb3ddf21a8d7edb5cf0f885950ef88f2ff524083a6d05a5a93492bd3235e55b8ff144e0a70782a967aa91fef2fe0f6bdca4690a26f7728400d2195e9cc17f7e205fe7ffe049590f3c8999606f97390855fcdf07edb8c67a130ad2245b23a232738d94215616c06ae4faf97959f0e608bb704b38378a2256cf3a470223bacb98689b2bd847c3bbb2d5179df0ebafdd31986959cb667c71bd92d119f44d2caeba673bed556854291d88b8d3afc1bdc1b3111bcd1229c8bb929fd69810577fb20ad3f6126bb589fac201e7e87a76976239800382f684ab6df60e8a9f74b56e0462de802e91f859cab43472eced825539f3dc319c6f11b6595a25575b221ef2b519ad214f8ef15976516c9aa410da3901ad61a95dcd940fb28fc7310ce6829937639d9839a509613abdc0682959285a26e301c75e2156cf1b79d6a81db5dbabee91419978657fc157184d56de875a21e935b4cb6c74a4d4588fe0fed203f426758ce14098728c024223b5242128463944df2003fd364957eb9d5be1e0f81bef1f2bcee67d615c090d717b3e73fe74caa42b7b7233632847bb593c3f3860e376f5a09869563a090a66de3182b28516510e0a1c84a58fd442c4591f134c7c72e2c35488eae6b82a3e226e68bf7d945fc83fb2b466d29e0bde0db74e82c33de1f6b70a392a23305981672e508ec23e3f2f4432f99a6209d22a193d71bc5fa9a44c1717958f2baab10bc88756e2729926b170d665abbb04c609aac30d997f9d24ed2a4acd79333f80e43e7ee34ac4b0bada96fece9c31ae02c87ed1b41f54d7d681048b32e6dd9d7f5bf061fe8f7c5903d9fe5579309120796b5ceda61b36cc76c18fc91f7dc6dc83ecd68b024f80a42d5c02f665098b2ab26e6ca29e7d85ff39aac405e884076427208d9879f85b6ee9606444d12c2a24f5513856352692820c71aacfda6a05d3d795de5b7597928b9e1284e4e828b578bb4b7e6728edce6c498fdd51df8d71ab9a6e33d154befe23a84a9d51ec8c72adc55fd81b85b01d313ea4833448e40f631ffd7a3a16b7afff7999bade3b27b1fb22527240fbb209c41448cefd244a263e61ad5cbb939c9346547c7b45d884c8872c9c564b6e6e9be92b1921ee79f1a24d7e6026d9c25321b25ee57aad0773642ccb1f1f5130d3cbef25820f6a6b57c7dbc0eee683b3af91376b0ad3b11e34292f3ca8e897e3aa39edd0f50dc42e94b2c4326ea1d69c7aec03fa0d4b8e98fe8bd318c21419ff6e81be835d551d7f077adf9519392e1417844d782dd4b513687162364bc8128ca41c5ebea643d1cf9aee6f4e32e25c0775e5ba3fcb3b45b3a385d417ca050e31632a1cb71399d09724136895b01c0c5c7822f4871c49e53dd04a189459d392da6af584b62c783c4a50a9ba7211267605959f50eb43aaa2d4d64d9eceb351d783616d8bf82b093ece5be879e1cf33aa4e5143c637c2aa232f62e729693e7ad31d17b234c464b6b9190ad75a70232c303486a37c5a8f76f823ca95fd352e31b760701bb8bafedbb7e9f0cd8e1e99a6d7b6f22cf13e7731b8ad77008bf8064c2a63dbbfc545e08bb05551172b35c9a8139cced84693f8f23166538fc14affd13152e45ba2b1573bdb7ebb7fee90e410a8cdcee835a6271475b1ab9a3985398c57177c21e7eb49f08e5afe20bf5deb839a4000826140cde7e2e891de33f0b6283849d082cca1d659b8b0fbae9e8e1aaad728a6367776f2ce23ccdf22f3c9d983c044d1dea3c5e6b9636ea43f5919acfe0ff98ea3b77c0b9459a54d0222d6fbfe7ea15967054ac3b25ba9d5cab6fddfbb5df987427babe19e5f49f5868299f0db367cbf0e6ca96014da63d3dce7886e5555ed7c762c89cf638afa790f019cccb554f2c8716606281c1a8ea4cfbe85d6935144b7920a267b373d87382dd54e5f7cafdd902d64f67e81ceacf950aa6a8e797886ebc151e6c4f161e41095b58d01bbbd863a4f9cff301f48d624f4251501beef6ca1194805fff74601498972afb5f4e2ec03bd5486595f8f16351c5c5755580fa54a067e79799058342e3e71409842dd8c9feecddce9387b0949b832603049ca60d5791833a4dfe21718702192cc6071f752a0fb13891779474857013e58bff33f36fa7b8a9a221a3f82d29e8f9b1b983ea3ca1ae33982e0b952400d93eefbde5742649b1ceba0f24d28590b677a37d559f44754f470365229b6503ae402e23dedafa9a483f274a69369a216ef3f2d3c23b8743d97bfda12a8415f839a3a4368e89666ab80aaca8ce8ebb4f58d6eddd59d455abec89afc202ff62967e28729e22bfd7c1b1928e1dba30fd63f6f9b1f25c4e785c8f60501f0321b93be3ce7ccce8608d14535bd231b9c1210b3853a33960981da13048ec6cee49d0b6d1b51faca2bd7d1c212c91537b91b5194540ce420ee9e5dc0cb8f52af81ada9bb670fb0855ea7c134562e24802d71ec9f052f9d7bb450dba052ed3ace01c6180cb5b8ddf05cc7a6aa3200cfc60db89b2aae27e28ceec976c098b195ad481192369aa0a9e5c2ebf62b1d95a7a7a01341874e08097e64b5134c531a9ea6746560e3130d0f7d1fad18295b2716fb987a9472d4cbe4e98046953d421f6c88bb7da4d261190968556969a64181c89a51d622ac7eabf156a46573bdc420e0eeb9b5180afd16117a035a14ce5c794ee0","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
