<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"5be13837c4aa889c0ad6e5740fb2aeea43146bf649043cbe73d6a438998d4f5368f7fb607679de33de68c4bcd3b4399a709f24adc0c7bc7bbf7df377bcfb39d6e425a84bd78a089e32f3557ac351481be86e0232dc5669bc5f75f6f7e43a35b6da234f5afef2320aff956cb45814f436753e6436bfc0a6fd3251a9c7080f973941ce578013a2fcdcc455eefcc592b86f04ef46adcbe56a2f63696dc3afddb03f16a734438bf4d052caef7c4f86d7322be5f41f6277c267b72a4b442c42bf30439c46eaeb1efc06f453e5ddcf52632fecc9c854c0e7ab462e0f5cc9330418f9ac0d41173060322a23034a5e95f79aeb935280de41b337fc393e129979f7f685d63031c566fbec6885ebd271c16b991ba58fbcfb1da60b910923dd320108de89b52b9d5344bb2bae4fcfadfdaf7fedde12dd7ecce26cbdce76578e29ed8b4321da59e19c095370ed9c4132dd18e699621512c89a74f74f2bc677a6e4f0f3e0e630af71ab8421161a6b7c01b611f76ce3b71a481f87287902d9ed21c9e5b68a3e3fb06de7f2e2527c648a58a72d42149909916ea94c155a3cf84c5db3d8734fac592907088a077946cabfcee21caedef5ff7f361e8c8c362a688f83d23fd2531f700fce3f5711cab083998153d6a73007b3daecda766dc6f0ce5639793d0dc4f8cd59a7d0ad809f2ee40771e85f4c413bf670fe646cac6f93df87f94aa6dccdcf9f7b21654436816a4be58b546cf50854df2904c0c2b24c09ed1b0f4a6bca1813801dc39986d463c27db3a75e4c3a233928342228655609af475166115dbd6657d5f84eb65f653a2badac2b57cfc292f20a0e744a8b6c748d5b48e0f0c502241dc1388e0758e890f4a303d08f13b0fe92240ff6eb3f1ee088a1b4d38118519ab72025af01fd5c288b49330a31ccd19dfed1f3cddb3ea2ef698d5a54f0149b4106178805dda14536f0da40c3a725dcc92acddc98856dedab163d2abfcb7fb4f0e300108733a847f8f497a13cd775cd029661b8fa55ccf405c6251e4cebdb77f8a449f348e4cfaf2acd6e7cb4fe0cd0f637e3de92c6c9542f220c69dba1636bfc162ccff06bf0f8234489a6bb098dd97a9e34a57f00635d55ba32ff3477c6cd1a039df1bac146119838ce9dc849428b00a28d6a7953672431fdd8288b4f5c6d00f0b425a8524e69c9d6762938d0f9db8a47eae658ad8383fc2653a17d89c6fd22ae5f1bdbf771c2c8bb65c67742ae08c6e304e546d3030fe623354c8f19ac2c141f0ce5634c340b4a8bea22d9ccc4ddc19a4cf8e6782ee0563c33d9188892b51d90c69ccefa11065aabbcf546dbb4bb1bac9107d1545d9cc02458bbc44c1737b6cea156995719d4ee5e6fa6a80a41cd8da6170dabcb3c6c4170228c7a1ef836de9d0c2e246f66d131291df4c90ab8a091050faad58ada21dc8b82aa4fe0653cba72fa1d9817d127feb6880f5d783f6a196e015f86132d5981aedf33bbc131f95825a36957bd2fd9d418cb188dc36dc922d566f4ca2ab1908e7d03bb937de6bdf53306d9acea1688664b830965e69ccdf220af6ed0ae1eed74313eee809df322bf2790ad044e275a756d0390f910a3b8ac119e39cee552130ffd57bce37da4f7656e4c2b262decc89595f943455877b2652c7b877e1aca733aae83e7f3e9227f206fe555e238a7cc29d2779d50cac8b2a287a42fc49ab6f3f22f8ecdce9d5a44ac2ecb85329d1875cccc2765632ac555c8f19a4379e98ee825c461c210eaa3ccf1358937a45805e50a3a13377fd5f7db5720a1f349d5edfff0124dfa1bee3c7038d66d2a655f4ca3a12196534281cd18c28825a5664611782fda8c2054f6bee91f25e00d2868a776be7a9a0f95a2e65314056cd76a6fd239dc32138d8107e0efbf9d0cbdf84f0cb4e2319bdfa3cf25bd605ba75c971d903d479e0bc73dd836414526161d587a069ae61ae8bb45fbf1d471a63b981b8bf1ae1035f7620f211c6ce42486f1116577fef55ca7b061088313e66329958d9ae64d0d7dcbc2e03fb413df893fca93127ceb78a69333ac6014184269732da3d09f8e1758746f3745d2fbb5845ef498f863a3b63d5e30923789942584c923fd82ccf9d139247424d1280f6c4284a0d920f43615604090a0bc6afc5364b1f8e4d178940b9c92d7292fd5184bdc495a91668db3314c95ab65215f298d35696cb94c8be83b71ed6ad6c60bff72d17beb370cc6c86317824840df55fb1bd4239ea3c3e2af668460c4effc3f0d3c0ced3e73c716e55d2b24686e3726fcdffba85e7ba028862abdbffa1bbe3475dc240134964c930929b6b17b6a46e2443051380ae22c42ccdacbd2eddb75b7410fcbcfaa29f88353058c41befd3a1b38c79478fc15e1f41fb5d7d6eef8434a000536e9932aad53d29ea80be3aff1b4614f330044e42f5ff3b2e00244a8498d559dddef0ce8337103431e3b557ac5be06529541a52978b98ce60bd25e021ace81172e5be9368645cc2f9758b0a58dd066cdc5f4de0d79dc216f378a1f8ac976fab5e6fcc914e2236dce7a18109817e54cfa3b442d74a2c95c483d6985a5252780ba7e40bfbf7c9d95abdc91dac54ef1403fd38df264cab2361b0d039dc2937d1ec440505c4430d8ecf7d8574028aac1362ac9f58bfa2a7860704938b242ad89e74f587496e9dd82be2beb4cdac3f74a7922047a22f6acce8fa01ea22c582e27522bad4fd55fb515b17b4560d24722419a2c695395a89311cc7906b8e16eb9c5abb960d9f89dc088b1e7ab55c7143b3c45973962d9fc3c1de23091b6c4fb6189862811bd7e7a2afd90f854a7a18f1db4373b2d83aa611806c2f5cc1bd74dc2ebc1a3673ffab456c496216a88ab5740db4e5b521683826d9940b83260dabc9b20eb6ab8fcfd60e586b45ddb8b531945ec944b002de887ccdd316193cb24c9cef6987e80dda40a106701c54148ca22d0c3528b7574a0d3bbb1afd93a7af7aef87b40eee2d67b08073925af142d4d19b4837ae961a71ca0f65b6765759867e30aeccbcd066447a6fea3ce052c884e51bd07f51c424129de90e5e43179245828985dadbdf9fccb92e763b377731226ddce0aae1150dd29c1681044a94f3664c1d605ed3b8e6967ed734fc18882aef1edd375739e7c6468189167ba72791a0f1e2bf974edb12b598aef551894b69e62cb35f86e04bc31e4599a1040effe66dd3b0822d6330be353ebe34f7508e234731f998c86284f7166e2a8e836f17625d12735095e5e425ee9a8b5858f6edbdfb111873ea735b978d3351be68bb95c3aa0779a9e925e9d0a788d57cf4e87a1492dc6cac9d81a9d184e1230b23963bda3f7580800e5f132bbf6a16bd579d1b36f54e1943edcfdd4160c2135dd8a405aa6a67a60fb9706dcac5570466b3ee38d2ae40e9e20d3340760151dbe5ab24d763d86552b97f3e08da42a0da1d6410098aade031851a92861d9e9af2cb300948ab2fd3f0c8c5f3ad769b20788873c27185d64436e2f88e2608907ab117c843c7e55fa7e46ee08fb30ad7414aeb814a574677751f9817f6e32224a90af0a8256eabba416b881ba91ddb21d76cac363d62d95933cb9948830434d48bc82764efa5e3c378056d0d25f02acc336861d4dfed584905b0638b4d8303d233e7b21936d10904c65329bdece78396fa4a924de4694fff997b9b50107d7dd453db6a838462f4758d373c59ace36ca0970cdcb5896e0b09dea1b69f5408ded15381f4b96e3bf44f120fcad1db13e8d8d300191926605b216bd9e40ef61f8695bf73061d44ed979941f2af2a6bdf66080662fc5dd9b1e325cfb9ee14837b6fc01ef4460e4b2c86cafee4e7384dfadec9f9e76d4fbebd07a48d5af3bda89b0c71e8e467b7d6fbf02ed5840b85edee91dc6d992eb4098100e8a48103e1ea6f329261be2ac035a8ab450e73f6a2b16e1ef1adc4f7ffb00938e6201ee03d38b7cfccb10563de1d1c36bd622aac19f3ae3e48584d84343a6694aa1dda7f3d90358ec6ba70307cad585b95af6bc54bc47767bdf2cfa4aad394a7fc6ffa04c5300580846c927f1c3cec3665f25ec6fcd8251d494519b608ab1a0793b8e295158b74f851fdc0b1058e32896b65d2cb726ff2a7ca136a6f2b8e702addf061b537ed50c603c5d9d6f235ebd5df5b955d1e747e7980f528e3283cc54f1f1ec7d4d8dc93a4d0a4990640bb7a8dbfdbbefbd31dfb869b4c950ff23ac656754897cee994683aad7f0a50db8da58504e58d62fd7952b307b19fa2ba57733fa9da4730fb619e76d94f9da181160cef0754213ba8df42549d20035e3583b99214d27f10b9fe9f4f00f6c1ff812d75f39fff196563657b1b42ebf6fb696f5d0646c309f6bd5ff62087bb81999dfff6e320020068dbb71376a3a03297c8ed9e94e88f2d7cd4a5ee65009c50ed4b8e5b814c05c74f4f98728eccc2b67d18dfbb61c50aecdade823e79efd8d75029bb5506245fddb979ff3dbd85faa4634bb283f79a66e4790d992ddff428fac50aead0ef8e04cf1c6a3f5dc1c93d12540b706844292f0ef009a6665e2d155564d201b08266b045b79a45f255e91bf19065da3367e17770bece1bef4e2f91c3476fb79f871e979aa56b2950dc363bb98d02b976efd88f38cddaa655411591424c20ea26ce8d50e5518bd39eda3aeac9c1f47e613ac960f58b3b67b392cba6a21ee88c850571f8f79b1d70dd0ea1506ba20ffa8339b0739a73a0fb3cd3db84508fe6f3d050a31b95a0efa34dce03dd9346a8c15ace317a4a2d99f9788d323b7db2f28db089238c94f71efa81c349044a563591764f45ca336bc3db61f14bfca723bfacdf957b85deaee7800bbbdd8ff6abe8e0dec023dd68904552aceffbd93e6a46fcd09cfea39bffd140eb71bb66650dc7284fdcc287c4fb118d56a3f697c1ddae73d9a5a829fe2b59f2c947fd437180f3af74041952d6804257a1f7ec24fe28638fde325c7a0e4d244ae5eca8d85632484217520364fa68162f0a27d6d94e74f3514a0356652bb27f1c8488b48574b7c008d830500fc13b37ee3a8d7f69e62753c1a6f83ee6b52d9be8a3b28e59e3aa36c631671b10d7e237dbd38c7edccf6e2d8bfd68d1168848763876864a39e5f3be560327e0ac6f65610770f10de2296b776672e2d4af6f593ad3bcbfe521889d9bcbf3a8532cad59fc6542c32f41de7a1a4a9b8c1e39a97058ccee2561e60964cee3ba0d0f6edc9b481c262c78b41c9652ffbcb1e8942bc47c36593527dbf9e574459a748c3a06dc1ac3cc884d65aaebfdb86ed55b8815f6c195789d3fff3f3c1bec5cd0ef817423ce6c6e38767c60e5e88ee785046a0c4583f64286f7f720cf6701462c09610dd8631cfd89f3287d9b1ea84743b37565602e2eef218d175f5e3dcb7daeebdd635001cf9606197333c3703b66e8c2658d98e067f121ef3d3fcc8d6e736d1467d3c6a3ab2c25f00afcd113e4cad7cb8a79eaea599935621ed9b6243014c450066a7e5c9de31dc9fe166eaa978efb2fdf5e72f4f1766a0fdfb52467666c7f367adc8d08cc30aa2e23bc262fa333782b64161c3a3c41367768e33c159351b6206d2702831240b75185a665c21a3edfa983341ba3d3b95eb2f4a12bb7c0d12834e916df99c91ec5167114cff40b1c0d60a48d5631131bfab68b55fccdce1be9c13032a4c4228cd46f6d1d111e8bad0cac1e94e011fd4edb432b813e66d44d4081b9da1f37e7654764264dfe25028d0fcaf0d4db5671db28fcfd07742c54af42409e389d8088fdce3777743653145aabe9d63db12a5277ed4b3b8423fa272bad168bc5ce5b697c603dafb218367bbe9b8827ce1c9c65711b81a272c21440670a3e295c6dc396c5d7df36a871d33d482bd5b783e8b1e5d65169351116bc45ae165f3bd8cad8515e5f7071d65b907b60c8e3c26194766550c35dacb7c1290d7a9492532bcd68e97257bd6cda16d1b4ff99c437c6d3623080523a1351ee20f4fa2c0f11c8d195313cd101c2808662bf6bf812c2e385b89122f792f58a8f09dc13e36e808369b3ca95820301caa5a3e77b20a9b408f2412e3e00501b3cc919d60b471b4f9634bdf5d9cdddfd0321c59fe8f90d8af44c01ed26201e15c4f331f05c672627e2ea08e3939ad19ca89752b4f76576236a1cc565e0bfffd5cf23f0c53e2f65e96d5d1dfd619749f2e9506938a8d5fef200567d1d477a949599746bd13b37fac7ae50c1e131ec68a0340df0c78de3527b29850325f5d975b3bc90ef45dda8eb6ce0349f90e0ef5b059786c4718c9c24cca7e0134dd2ac2167d1aa827a5961f541e58150fe5eabb7b06be4ba74372eb6f7a91f12151cc83a8117ffb858b1c229fca17a730d7a19de56b7e1acf61d16b4627e7db0684a5f89768628578d39e0a79c951381eafd52524fc40de0ca487da26e07cf0d8bc68ff36fb2d744f369ed8b08af8bd75c22d2bc3668ac7c2f5aee4c1959a71fb988cb9a557e564a0227a6c1e253f9df95ebb3464e3be22abdd122ca0b61929b8ca89bcf1da347c2a418d1fa83fdea908a9b820176d9efd8df8fd257f051a7391e6bda9b9c87ad14b2441d3f4784fd2fe87e669bdb77db6993fec48403a408f2e139a657a5ff1ed5b3e2eb3587e7a8cdb0809310630aa2ed3fcafbfd94b7999016fd352a252cb24a2a6bd3eb3c34b2a66525eb5d41816dfc1118f46341501df56d1d951765c819b7910bbc9812fbc3fbccb6ddc58c19042b297c3f936d8257753c056308b7f9b05e03d9aa3465c114c808fa8e7eb7edffc7396044b152d3282e8f7c85ab89fcc2118cd2dce9aaba68deabc89d2d531036734788fd05eb9a4b506269489373541f9b3e503bffb045e3a80f1eb6c9e6dda206d24078291d967263fcc62858e3f46f880e249521980d415e629c91868cdefeecee4fcfb312929c4318cea21be699a7269b4ff34f7aacb25ae8a017aad856b19e8b9fa77dcee19045daa9a8559f581058e50fdc5edfb359d521564022b248a144a229fc2aa323be34cffbdde647d64a96290f56db953b2896426bcaa23d1b9734674c3cd2968f3be270f555217e8fcfe5feb6419dab924bfbeb6d02dbff37888f9d4196eae347fad918b9e90afc7e636ae2ac92eda5223302df736a2135eba6116bb2c29996a9c9817af4f0b5cba6e8f1fc57a54ec60dddd7fe868091165c2d6caf1bd7f164266b793440615229c502f02c4324aded0dc2abec6225d1d49e82e4353606421bfc29ce99f7a5fd69c6dc7b607cf942c9f2bab740c6d434c2edb27321cdcfa76841495b6d6e0669236ac93ff04a9412b0236b8be0ccad34eb3d0c501493418486002a5e93058de9d8c3e28c9f7626e1b6a083d77678b404d20fe70d6794aae6cf7bb7c04554664bd540a61fc83faf9cafaac05d6d6c733f854b811e32e54526efb7122e9a0bc2fc914d3662e43b0ddb767c93959b353bb6f104c46c95979e98f04b39c8eca5cfa3d84fd2a6d28bf49158f5a5da9385379614b8bb29379a637fc665a4701a4dc4aadd097193fd6dd67b3261f1c63f1cdc465baa1f86f8a80504eb1d32a7676cd76f4556ea4cf3b8c1718adbda9d1d687e2ac89f3e63040f5a6c8488b931674644e8dd5c436d8d629b94dd9afcd178907fbf994a339d33317dfac7c1ccc92ce2abce4b074b550367aa09ff63a31f05e8f2909e09927f6ad17542dcf53b55e2cdee0ed3ad63e9553ec695733f4ab0f25721170309296ef9385145f89bf8cf59699f3046622d1a885a7c9cab809361f7ad73ce7aafc3d409a50015f620b3dff1ce2a7a08dc0a4d1695a38ee61a587801fa30e7760f0a78ec2c3938394c74e226c1b666e3d061e79124c2ee091e11df38991637dbf45318b2b2787b6b1a97816edacd13acba451e248a66c69d2baa062804ba3684719dbbd7572215ce51c4a6f8e7bb936c373d6c0db61f85dd8a33633eb6165b562e69d17d600d85f013458a2851abd97b842d16d6e1ddac48a7c627ddc43c15ce97dd729e5e6368e4d6df1b8862174297b1e3f5ce37ee02d4ccf53784f86ef382f3e0cffa11cd11c396cb52ddf217e7c9956e2a3c876fa5c236d27ca0b9f3d6915f96c8b38def63c6f34ae2a016da9877826c753867f7a5746a20668de1ad56178b0e763344801da553f9f7ffd6d20ec4f45c480ca479ebf7eaf93642c6180217ca8143c0cbcfa891d5786cc6b0e4bdcdf9bb6488432fdeefc884664d7faf687a55fd028158db84c1d996299792bd1a17ab5a0e14608ce3d7f3b4267109cbbc2b769aa0ec95663a6aed35c2ec660e24e0895fa31d6c80a35bae803a356e1453fca464f47b61dacbd2fed1f77502055485f846a52193890411f222f92e6784feeba6c4d5134e62641fccac8d2d5f1f7406487ee5c1cc82b21844b7c40f7a73e8333b65bc589b0edc6531fc9c8c0aa2ab52c0e70226ce005467a9789980324c0a1038afd280cba6a0e351bdac1a2b0f05b33168103139be2ff2a8d0cff5901f0d2b49ab2cc563726f793e91a1792839a7d43824028b1118406115fea2e547b57c7c1cbc0b1c0f376c58a874d8b17a65645833cee075358d6e060ed418538aaa2909d028d71bb684babcb7c87f21a3f7f75669bb9d20521f1b64adecd2180326b0f340a07adbf61e2b2c3e4c2dcae45416265fad350bee1f45c61d7d2b4363ea42424e36d5090a172c33738a54f4c1223f2c8463e10356b1db2c038eb8f0a61dea564be84fa356050e12db910dfa55e91e0314b71bc5245df6876039facd4d3d8da9cb2fb1fe1cf86b75f596bc07152d19d6168b49e1857b5ec2463faf9dac70c9ee2de77268c2c8b83adbb0e38d7b31b1affa7e1e55a4a8a0425336943e4d07df185d664da2d2d75e65f4b1c303ec320fc52999b7492c87b66ea5173bfdd281c8688cc4f6213ff3db80fc1517c59910ec507eadc2d2d819b7e6794c5c8b8eaf4167bf7e63fe06e86eb97d1c0c43a19ad2c713f08c259c26c8b9c79f6207d4032b65d149a0be770388426542e13dd51c585480a435216d7fb1086c3d02b9746e18d7ad93d51e9bbd02870262468805cce8597c6e93123e3f0f19f04a393064ce9829b9d5759f9d38def607e99c1c77ea6693991dcde17851bb7a0e7db2a92234cf1a630faaff4823793c679453a228ef65e953f8f19964787d05df27838167b1e4860923b47b22e13edbd4471aedcd946e9c72b21e3941299d69fd588adc30c826bff2293acc4d26fa76ce4323e8288ae1f18ca430b96f8108ce350e6e844864cb0cc614d62e709317be52028e451c8af796a5b4feddac4fea910edaa81d2d5cd8f22c404e40e17dba4d5dba8be63049ce80644687002720c7b75a3b70a5cd83828b347b502bda390694ba766ea12edc647a3adc2b7d99c26237b02b7bc4da05d13edcc5dbdff845cfd46e81d8f1d48fdfb4035a4f2860c8a949bcaa4ddf958546e34655f1d2d9b2956bfa41917224a9fc9d9fc00baf95c0ae7f5147ed508b29703afb894633533312a3ba4606c6c00d9e8d592302fad15957bab0bdb52cda06f4b6d8de340a92cfa91d289754b892a8faf24f9b03d0fe3e1bcc24f3e7dd78fd13054fdc0a872ae7bed081a944cb2bc5ad4751ddfaf11a2d4fe8882642896b5a37242a150726ac05bcbfce0b88338ed7deab4d2a196ba2e196576cb92bbb8e4cf2b90fb82f2860aee8de5e059c42ff0bef9e8edfe7ab6519e4be76b92c8ae3f498d72cf8f8933a9c752f7b541c91582a73825d6f9462e7d5e47600c86963253d933ec1a4aa510469359e2d3b903f502b5daec989c437a098866067cdec215536b1f07ed341c0ad374c696523b854c31d31b058a78ea8ca7a19ffd0560f175951148ac205621676b594a9ab0f16a628faf771f72ed5329ee665b30ea4e9ff509e4aaa0147f65982c7e4d80acf7618c37fde810d629dc16f6a77ec03bbcddeeb178e30110c95b59e36e42713e3f28b5ad72232f1fa59f1b9059d720e7ac068833dac91f3cdfe4ad0884535330a504ab32886e26d94828042657470af9ad508ad0be6393e3dabdda5dab8fb780f052160e25859bb917a54aefd85f7ab9c7bc445e591fc2e791dbad2ef612978bd803143fc1f7283dae77d07b5855b4ccfb24160ebaeed6ea2ed9709e7932f0193428ce5015b02c4f2598865e2f6002da5f9b28b4764e7f462c1f075c0c18d6bf47883ab0e8de966c0dbce4aa6418ee40067d120203ffa9712fcf64562356673eacec4a9fc20a11800798fb2ee990c10e86d8ebddff53becd29515a7076f8ccb5f4f4e9df9a3c429c664e82a03a39c265bbed0ab5807d895853087104c0c740bfd6ebb73d78262a791446568ac2862e9f016548bce22c84cc3032ac004041a8054c7a5787a84d7fde2ebf1af3c9fd85a03250b42144d7893f83a6a79cf4538a1d4755aaab37dda15e44c8924b7fa37e70b2296b76a922aeb3a456861f225b3c7f8eb826d65b9751864bc5b02ef31942b0fca80f99fa042e1a322073705697bae5f6882784d3680cdede324258963ed242f014cc60b69fe2ead3830e2f133114b4c1daf219ade016fd3c1402255c661b6b0e3b983bf95d90f1fdfc5a0e26ca4eacf23577eb29beb808ac27420cca403481d1c4d73356c4fc3c2d98a1e196d76275513a55a70e5ffd40a58310c3ade714fbc50cd1c6c466b8bf8bfa22672dfe7f0ea48f261812133b55fa53b9f72fcb2b47c62787802ee252e4eeb60ddbab7d7ee7da0ab5655baa16afe82581dd1fb287687f99ddeea6456dde9d19bdcb536ae146458db4d6ed540a0e7b47538d0a4c5d8141d9bb11331cd14e165d978759c1802a254fc42744928f3f33e7a7de6a5c771f35c8b92aa93a898333a62a5fc6b5f5fd779fb5300bab361a417d148f0ed33900cafdb7a45b4c2b235220bf730d7d28c6c39af383e57d1e040ac033fb8985912f013dbc923e42cb2aab9c7621f3633786a23a7f046d36cfb7a36ca002ab363c6e420c391525bc53a849892814077ae1db829922881baf98f0d45b8018fd583b5acade7331127f1dc32e2718d6ef3c4a4c29ebf3a874ad1caec1d040b34f30b2ab9bc1f4741e6be89fadc32a3253b58680de9edb451b225c5d8250255124d00a61dca0022e3875934a4c1f7c418fdafa6ebbe753874ed861c5af8a2066f3d48cbe326a22603591bfa3d16e647d8d0e67c51d1d0abccb27743dd34ab74589dd002ffb32c48d9be31791907f0e0318be720215e08c3058617736e3b1a187568ec228d39c6a43b1ae239b1f83b05cc34d0af57338dcc0ac60628ccd689b5c1f9af437b15ed3134ffd00c18e83f280113040cac8d4ed34c71906d025b55a7e94baa81aeebe2351b92f2e025877c051d90ce4e43f5c06f25faa3643abbf990adf2fc80576bfa5e9efca0a46c5184863934fba2f490392d701dd2792434af50ab5529aafd352d0037165281a9c70096bdc20cfd4a6776f667e79bfcb61960e9dde47363654f7a3685717722c6d77f477fdd6ea7bffcf7bbc6b72f7aaa73bf1d7c631d02b403ceb3989debde778c229ef714537f2fb85d37e4c64aad9584e73ef6a98fdf0db35ecde2a2d79f766cffd669aa9f198beee1066e522cca5b72d00e2d4efc09cb07de9dcdc6197158d90b78a9b782f6f4c04dacf107947d2869dd89c80524f41c407c366943b827f6efb36d17223a30df25039d628bd58bf7f0a67504a6ab2b9c766e63587dc60c10ea5dd34aa0ed938206174008e2e5acd059ef07494b32da0a50eb359f08c1bde38462a63698c29171b11326312ee774e1acdfe9c5000a1073f68c42cc77656562ca02a206262ffae03e2b694d975c3657d94bf597c8aff653ce9f6c3d245ce210e521617c4322c9633c93019d9ce468f92daf3945278544d9857308b09800a09f7a6593d14d83738d0ad57ea39b41f4a3e0c3b0ef421d4b8f7a766daa0342ae2900d41900f2059c038b8bf028b34be32fd2931c2cc80bab66ec0a33b0734b7284d943d5db7d142322194f110bc1e7e500223a48e91c709da5991bcb2f2de7d5f9ab54438c3c8e8a4edab9d2d2b21fbba411f72e4bebfbb40d937cb77f07d81a769de059845ba70e2c1b3d68edd3412f4db85096c56e87f13fd410e3c39c85fab12e24c4c3b7e660ca4232554cd156dfb5329d25c5078697ad700ff3bc2edc1a5611391b3a5715b1fcb599e233e73e2152d07f74f6427a7fc93675d40b39eadf3d21e0897ec9254902d1ad814ecc215355a16c9d8321400b4103a9d94c38f87da4c8dd4cda7a543be72596a96be9db902dc2ed00d44f95737a4d9ef1d4a88d7d31399f444f99aa541c266bd4e1b2a9287a7b2269425ce4139dac8c087c5833c693290c42a1721e6331109cfe06f6ee35ee9ae24b9f5615357de4d3564667081b8d27bbac9a07a420a4378152ea69502968100484e0599d2bf278050a42e9856249cbb16a55403ec05be02f4c43c7a59572411e3cc62cfb67cf0bd59a331f3b457c0bd9ad578988eaad530226ab77d96b9e253f8dcd105a2e0dec531712d9a38ddc82590c0f745931e582bf7489b9637069cee251dddfbc452d12d7d87ddc9e7d50443e79a1a3d8d0adc0e96d700471a5d5e92a471054b314e28f51fc83d43c81b20ca9addfbe1947bf44da1fe12dd606debac00d71123ee878769125e5b599680cccdf5dcf0fdd6faca3fc99bb16036743ae4412cec749658e17f78b9ea62fee80a97201546385ba2aa5e1166c8d6f2c4043b3402c139f7f63d059659803f6c79ec33cf75919b4ee52d6232eefc8591ab0f02c38528ddc6366cb24c8e2397cc7bd7a9279a7f9f4426e6eb782b76c02c60acfc106bcc01d855c3d7d7a68edd6f4b5ea8f1f90e7f4a2047aeaec821844bce0cf5c158d58c2b0442adaea8a6d12a9066440e8fbbcbab49bca995d73d50142c0d58dd23711e545f1207f607c220a422103c2de81421408d34f51067fd8f4eab97596fe747f671a3d81ba5035b98dbb322b733cd9fae67fd7bdcf11ff4e60c24a15d904c407c57f356042797c56ba7b02d77f126359855f119e0bc0af05eb519e0a54db47625121112e9cc750418bbf56cc11500811a13de432b2c36e1e9438b75b65a5db3b07408b08de67fa1b1549dacc23a9a4884f21328904c5ad3ebd6bbf58c8090623d585e03cc60e9c53bbd818f09cd83e8b1b3feb172794736a658b3a93f98d0c8c36cb322b176d5565b55715841ed4ebc958fb6825c86b7d6b066b31541fbc434958ac6b1337b2287fd359fbe59b55fde59cb42d38be4778a28ca91008030118592e2ba582ed2d8407d4b6b68bd1d91a41c385c3fbcca52198957ac1571c5aa721952e0be74aaf1b519de5a0da81aa8ef430c95a13c7984043bf4337dd197abe1b75c262eb317038802b9f860f309d49fde714e85400108bca9d77e4b2b891fd2a0f3702dbedec9ed9e1806ebd4fab8823f7d6b92ec2400e84ccae506da325d2a6ff53094a686ace12fff15d665a8245a6c3448bec333745749ce20ba25c7b65815ba463ee3454500497a974b043823d9e4cbc42e06af2be06abd9349278886fd1c6fddc72120d386b9bbcd9cbb57d4a62c00ec4aa351ad6edd64c6f8ccfe762036646604a634a27d47c58b541af169672ababf8e73ea7956a9fe3ebbb2864ab024e9fef700575db0f7eb2d425caaf7272996dbebeb22c549e12867660a79e6b60a79e040328ff4130676812515790588ce57a1ea3f95d1ce275cbc873ae21ff1665bd01f5407964478aa5a74d18197a36adb552d41f08313ea0deb3ad0efc2ffcb5567cecc1ccba1e9518fd5f59c6c80e9f3cdd7ceee3755b74aca7c4667df9a907005fcc11dd5f15e40aeef4453c45dcc4eca0aec1fec13fde249d1c3c40f1f422a6092fc8dd19ae8e866bd2185c5fd32f83492a96693cc8a0469e424edce55832b39b1524aa4941016d8c3620b1c8739640048e0085cbf8f60ad172716abeddda4133a2974b68518e3c8e1b891fef2633b0baf8db92701deeeafe97f4441caf523f84222abe0aee43cd65ebdc9f0914e479a8ed77ac577627c1efe433e909b62e95bb13b0757f2f6e984b30402aa31bf398e2e2acc74ddeb779738e2fac4114bdd5603ec1d2b5f9169547360727eeb83c1e4bcc5de4d13101189e679a985fb4821bc4077d424f5577eee7ff32575bdd661c75299ccad810f8c7795daaa07711dd99b68c35923a0e3e99fabaf55a453f938ae95bd2a1de5b1e81e8efa6d2b6880ef87928814e977ddb5efb3c3bf32ebb46e7a00bd60e4971ef4b9da530ff53657cd704cc63b964885e0ce1e25f1921fcc2d670dd9876411878f23da9d58309748db51d3ff81ea248d13ac404d2691012efd99f38f7e88ea17829b6ba304c3879388c782f6e99c874adadacb7270c434149db438f972e32670bc374fad9cca0e34f6939598c6e50cd58b67f436d729040094fd723df6563c1f6abfa7ae4efea722f2a119f090ebc4b276fc5925aa22db544e1d03dc09e767d05329bca8df4e1c3f2e3c53841d351c786252ff0f677fa9cddba94389761cdc62fc9ec9994b243cd2e7fdc8bcf6d4a6971f0be4c670ccc5d8452c035ef7df42026fb7bb73478336149ec11ce2a29cc6b0b35e9acd2a324e47969a4259da33cd4abda9ca7ed906b4743b287026bf6800179c69249c7a452eb36ca07e98f691e02f3479e7e3a8ec953428509f2bdb274b1dcb21abb95443a13fa6389a7e777b8941b11958b555f491ebdb2ba9c998e84e322434af14e7a0f9dd4a4d2da33f028b7ca858d86c1511a57863be9d419fecc20772f6ce362bf00607a671d464ca4b5ae7368ef272a3ce6f1cbe932ed6502d18d7d417801c7d6143ea486f92ec01999364b7b090462acb86d27b321c4d9f6add6d0f73de92acb39cec34e2234f23bdaedb257796e939beac84d10375e795671bf7262c0eeeeb0eee87cab915b26a01bcec9ab309e99a4d9fc033cc9d6908453e988eed365992f3e276d5b1b333eba0b73391e9a5a7a9e2c74da37edb31420060f8b4a85e24e6dec763c391e271a34a0c0b15e6b2ac3ad1b6607cf131bc214d017230f60774cdc473a6c8276b506dcb8ef418ff000efbb21e4958f62e39bcacb750b82a3e3b6219744ac25cab41d9f4e3d00e570d55e314ea0025d8bf5579c5c0f435b3df6db98a079b8f2070fb782ac420cd7c557dde36b63ddb93ec4b9e4626ecb3f3058e271c097ed600f060727dd959b2078de8e50c412d0b4d427e068fca49a7dc2616946a6eb46b58ec694a432db61b716eae69ad8d621c242a8eab73aeac4dc821fd1c4c1f8ee28e550f19adef1b26a5df8d078085f9fcbd7e90c172ba5bd85d66bfbed7c10aa9af483e9d4b0e9ea8d77e2ded176719bd4e323b71684939e3477d78746a86c8da414121a08144e094e077d277ce3e22619cca915708711bf1eab5a0072c7e8b6665d73cd8150c79fc67a063d74afc5b832411d1ee21a5dbe1e7da752bb31b1e0e23dfc7471f1c6cb72e49804f87b2c4cb0d1bda5069f7687eabad1073c7c775759ac9a3c3e83203378e7bfac8a0e6abc2e805a5744f7d1800296db61831ee6f2d99bdfc2452da9890b774007e1c62b53d5391df13126a920ae35f936155150b6a0cf44004f4886676e873f668f7f38a626984c37dea0f9f4c5127a4fe72d6926f9e0bda952a642ace52db55b8496e6c547cca8b68ee6a8c9b06538fee32d21e0c9bfe66ac8ba191535362a17714ef15c8b847a734df566ea079eacd5a9d86042bc40fbd0dc41aa84f9b5fd35adbce0bc5341c67a6fbac0193a3673e53032331cf21abdcb1f3fd6803f6421735fb33eab531f01950553613c81db654b6c8ee290b5eb1cff771fc7c3d8387e1c0454e7da34ce3e55bffc83ea02b1b56e88a1e20039f6396bdc4d71294a2e8437b334940adf2f90943e8596d651b3c8dd6ced9f5714b5bae149a57b00ce2b63da566432cc1e8349709a696e0b5b9685a4b8f2e4335b0e40f3d18c9224a2420d52e872238ff416b4b778d68a8f71ff1ede823ce166d2125a34651e4e426202d9048e30cfb1d39c336b802c5ff742d609d2ecb90e6fff2c5975331f7034558bbbe0ed89e95ff49570c5c450a784fdaa594994ff2db6afac8665cc20b541432fa6d3e2be96f3550f1e55d4fdb534e34cca6a357988a9accbc34b845ba0b4f5c3159a1e9aae20b8403006950dcc9edd4fc60d6b531bb480cc8fb957e8f0263156d62c3ce81aa5a9a79dc5b147c14e224bb68f262ceb73f8c79cb4ded9ea8bc6d3051cb68f83e4760aa093214d8f71a117dd78c7b337892bd497c1d4356d6b9bef27a532bcad874b72b442c7d44d306ba3198c937b1253fb5d510d7b9749ea9625ca7b26d5d05e70266ed9c4b575716847373617860c4405c56c709fefb68dde8929176131335bed2ceca8383fe6df21143ae5a25bda3de39cc3a9f80e337cda3488ae02d986aefa9a30008f6d5abee175477e6b418afe54d9720995f16eb983b3b9ae1b737d4c7ff495435329c41e32aee1aed1ab438904c70963f8bdf9787e19c786e8db23b1d60eefffb905d4a098a5bd6e07ae6b55e474eb234ec167f073ad540adeef904cf1a6251f507f350eab6d26b61876ccceac363ba08271e2d333200cfd813d69ef8a2986fe3ca7d6827cbff7fed6e07f37e3276e3d33c784f98b05c7ad0f08ae64b20fa9f032f398b2c9d8120fe9cce439f8ff94869edc4c62a5fb9aa3181247a38630f2ac27b474abf99e2eda1350471c2973e2238cc37937faa6708484609f9395d9ee3c2340844c4c822cf9177b10b1409c87a0a3688d8a6b31f31c48c3e1f1282d9ab1bde655b7248e737c4c45c5483e9ff910c659f31ba292c65e874d53a64ebc50bba1306b7c7a821aa01df3757813349d347b40d9deebc5223beba4a3d66f53912f355d96cb6618b5453789e95b7cc75a5b5f5a5a92485d6cc21fdf4f03c8d0d9292d21ebff28ec2c6f79acde0cc1ae8b8a3ff92724e09d8c79ed6d06df2b387085a281e1927df2e76218eb51a4457f3fdfba9cfca53f38a2e8e796a00a2e550aafb5c6525b64e44d2a5f4c02962cca9e40f3e2fdb8ee229531892f2195778ee1e9d716eb8d2f09a8d239d0d419ba1e45c20cac7e9c41948ef4de8bd221a8e7c9a0f01bf8a402a7ced97482917d255e5a557d0964f20e480e257af18634e6a37b84c69eeeb4f72e5e24f07bf047cb15dcfa7ed878b014ac50c6a2f9235cf52b7b861809031dbbf959a8ec9c0f58105ffc3f4a98d259e12974721d240a67c04de9c27933b372551b9a035aaf8400d100958b59f87082ee0301b1d806a04853122eab48fa41ccbd457cc075eb9018fa7a943b4a7ad9d1c0d9d7fa7ce00db71886b333809dab83bea5f75437d8724f1802f65b4311f33eb30e72f35cc07ae116e8d07c2f0df2d4a05efa6147e4edcc49d2bf5b95c92681c42276d2c4f0fd2e2bd1cd170db48e48f9f7557085bf1a12b2748bbc21f1ae6353ad5afe40154deedcfb336da4d0bf72fd732c57ccfea2c96bd115f15b86a2b8053f05251a993f843cbc9877d0e513c9c1590e17c27c4f6e737cb5bb3e8a5742da8e73035686a1710cae3bacc1b08285a1bd92a859b2dbedcf7d9ed24656c59dd8637902ed27c47bc9dd3cdebeaae076f67b7c8467d5021be41715ea129f8290ab4ddae3f4011267037d7ed11328fdc23a4745ff8d4e5760d96cbb1e50a91355e6803f4a65de58ff12385edf3ea83427c73caefbbdd98678c5f6a5d5db8c7171750bb527ebb75a497c4533712e8328042faf0f8cd61fb5d2f4ecb335bc947c41765f43085ebcabbb666ef8ee9d40ba825cb980a061634c044806bcf029c41511dc2df82dcee18a1223d03372e0ef85c7d5b50830c1e58f650591ee55e3e4c43dcb1d92512312ac1eabd286f1cc1604ffb9080681399e89ecf8bba68207ed5ca143c4ac176b21fb77ce5de8fbc804914aa73c15da59323b78fe437cfb6f3ef0c8a354a3620ad4d184a7fdac5f5f4ab0c014461d19a9ac74d4c4f539c68bd932219adcce3938b0798ae29b25a085f6972d585302f77094035890346a8ec5ff6f0bde38a44e4c079735c9cd055ce96580645b5ed37d758469878e98c74c29a1cba8040e1364fe135d0a936981e1b5ddcc2ff336eb4d39774373eae1dfcff2eb14a5d8f4b6f02de4fbc31b25e27e5a4df43ba838340b80f47d2f834ccba17b44e8e00ce5d737588144163cf16bd8ea4d3e1ebd4671f769f2da25f98cecc5aa5352671b676ec074cbcf5d6b1d238800b3ccd8bb7f29fac840f43f6568e0d8364e3bc9a5f061b6feca8b81f5f9342dab55f3f5a134f6672c423fbe63c3572bdc6fb2644c7a9ded2c20dfb124db998e8d6ab6b3dffd2ee006cf3db8517c3074fbcec64dbd41d60b3108d54ca8d189e5661a9ffc01d6ff9d79c35086c623d552873fa77fbe96bac2d54a470307f797c3f192715fa627765b4256c9686611224d9f3c7d29ae1892d21979ce6b41a1f5fba5f2590d31ec161587d88abbda5982f19d23d3637f8b2faa58f3bc52d33d70651216310e6f956b55e9e46df4a0fd6b49fded3860c72a0b83275694f4725f137e61beac233aa4bd37c2e14f914ddc829d0eff5e5a5ca898b22b4ba33389974c9688f0d2e9d87284e9386de183297d54985e731422f8bb3619c63c5b685cbfe467a2355517a5f5514064b83b866247a2349386af044a36044e2e87572b305e027d227d962be937be0aad9b456940d3920e485de2cdf8f0490a3932a3381684ad7c03ee60d5b72e7ce18da4ce51dfde6cf9da159455542ac0726196a8808ea9347283a89e5c34c0f3ba2528417bcacc4adbbfc8d1410e0a5c8e2ce8095d4be6f8dcc34945be4b8091e4f6a3972996c16bb542aec32c69a8a90f427bbc021084fab9aa7ca54c50baf33fbb9e80b5c78f390a1465aecbf03b6b7f4bcdce327b974e99cbe87a6a09ebd54534f554cc0a5700333686bf8b4bf70a72861108a4bd2f7e408513a0d318ab9c5114fe391bac33b4e08df3d93512a6cf80df08b63eb70403c53259d7e8fe3a5a580a7d6fdfa26d86d2a4b1d59911ea9cb6026c268e7335a4c24ccab52d9bf02778ef4729b4d4cad518755768b12890c358a633126e1814cfdb1b3fd2fde74970368720b2fa6e934c0fb4347c1089d6d08c884051cbe8ce88ba028bee038cb3035770f9e789bdb4d5ae7d2c5c04dcd9a1cd78121872170b7f12dd6a40d066cc32ba80ff07f3903a50e235e3b694422b3c5a6f25266a2400efbcc25cc8325389ab2f2126cd1a05ad894b0e6ded5800c2bea93af4f678d3fdf3fd529a7a9a8d3d5431ffce396d86eb2b9a78359580ca0fdae613fc598cca38bfbc660d4b801544e485a2139e40a430e27a48b427ef53a386000ca441145c5a5e7b68d280180d6a5f00c8d566f9e14fa020af26ee69d0f5b499e830a4416ec2ae438652dc61a24baf30e281e895b624d83e0c622c6c90d6dc0166ba741b08c3f9d59d550d8486d4e0b77f4bc207b2552cd634970520a39b05107fdbc6f7d47b1b04dd0836d011cf3667c822ae2f85be5525c0aee33023cdeb7925269643c3baf3363ec1edada3672a4f60c40cad89ac2604376d61f684f37d1d998c058209e8249ae904abc35586fa9b3badde1cb9f74bcd94a435b561bf68829b76acf7c2588fbf7c5ca309c18fc449f4df3360e6e4f71c6e331c4a850dec15316250ba5609739d96e3b0ec84dbdd6bad9e1879f347a7e156b20fbd562abe02269054df9689b3c7a0bc56ffd4e43a28943b80d65de893a0f7f7b7475b5718ee82ec90bd85b318db8077fd4e5221d9395148f32418bec3814f18752d99b1e39013859b992981899933850b009a9a6fce393a97ed4ac18cc11b5c43269554acdbcd65b7861e88d58821add041a159edf03aaec070dbbf74c83d5e2aeb1aca5b9a8836603d4d85dd4bffcd6f0c6fe3aac1572f3674378174ba868a281d81b2b79bd6f36cc7d7ea3e2a3f40e097efdda65ebfd6a35445674b93e71dd923effd8d1a78cd98368ae23a3ae52a58982e551078aba0adf3f91733ba26dff80ee1278a58b74491e68204e4ac675866cba231103153b9a990e983cc9c9e2abbd496a388c16cfa392fbc240cade4914a37c4e8604468a7021991d0b5303885b73acacb74361bc72be1cfe22b469380efc8a18d9c51e64a17fc71e3e6f9092d97d2ca7bb068f5c500b9c823e1f0567a1a9f3d104c7986a6585eb8038b3144d9395e2d72b96434b15acf1741b847aa4c712e6773f277b5d9ce60801e27ccb7526d3f29e7c279d87b97be4a6c11924f1918651e0ea10d328958691c9ece0375da3723ce4c2a1187d40320b8b8267b4c3b036094834b60e4576b07ca420ecc4cf9e559f7543c5b6eaa4b54e1860885571ce92636a0e7180ef04b401581e88174df0f27dfbf3398b935420a6ed29009febde02791122b85991972039dcb5590511d0348a79e0d23387231fd53ab5dccce34c49cce7db6224bd740e6aec42b05f853b6a140ae7cf4f7fd2700e1b36e34dfafb8610fdad5edcedbb2dd67e6fabc6d9db2a22ff11c5ad833a0baa99d088c2a593992ba1c6e4741e97063882093c56eb9bdb8684d46398603ffb69e447a2205481d5e2e22dcf067d14f31b5cf76a93c9dd8c8287326fd87978dba6230c8649462e9e5a644b611b788022ae07c5977d24d22005f1e66748d394f8ea4b872b62f7eac348d430d63ace4001fe2129b6a928927f232899b11f2c1fc9e5e9b70870d84959a009bdcf9d593ca513a43431a6e671cbbf0656f9c9e0a50e85d9472ee3c83cfc564440f690c07518f7bd19e72fed28b97f83b956e2dc5c5b9410d77dfb55c88f1599fe430ebb4e3796e34631f6c7b89c69f642e0e2f0777f8812e44445aa14ee668d7e586db4403fbbb5939196a8312d46a6d034afa17837c9682587ae3c4aa8ab7e1db5f632cdbd55deb9ae6bf0580b15b62a44243f157f4e15f9f60ff7afea10000831baa48e4f376d3f81d811768401b4dc8603be0e1dadcf3d632ee5b822b94c37b6fa5614da07e413665bb32a47070c29b118395bb947770b24429dbb210b06b8dfbc780c81b77e946c30964120552e6498997e0f55fbd72019918e246bc2c95b2ee16b613b95949782800686fb49fba2a0723ce58a2faf058c2a0dfe884464bba5e1c03da344736566d0851431cec61275fabc313b9f102db44e1171f6ffe9228ba1decce3d72b8f89e4793dbfabb613abc494bb2779f859745375f5cb141ad4d9cd906f2a5292c916d5647d771479945e67963c7aa5446ec2b8097d8dc267a39c7aa0bd57cd75ab2c37679962fff3e37b19d3bdc256c94150cf3241b38d165847d9161568dc3072da6e629e42d32c37e87133360b55e97febb96ed009201df99fa9a282fc92aa6e428e313ff40eea8c1356ef65d468699f83493a7db3dfea72c740ac2273663b616bdf6df7a33b0f5b320f476b2dcbf937aaa83f5d","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
