<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"064d7519c3a4745d9d9d1185eac70f42ab9987ed5485a5d16d1d20f291052a85f9a5542692697abe99e0efef3fbf39fcd99da969591c9ea1a4655ba5a64b095405d7371e207f0163d3c084d3b5883188b5d45a29dd42b894fffda1f20fed217eadda7e6c06614e686325fd60287bf1221a608da15fb442d0904fb867682d8eb2107e2da57499d62e4f6f6e5ec098b4def90eafa65b3c405628e9a45a2edf9f4242fbe9849c8d23418bdaed25b29856aa6959021a3011a2113ee6c6e0f50ba4b7ba133dfc96cc7d43307d45c96e3809be59b75a7e69ae13928460cc0d1dc1a4a7f7212aae5203ca6d780d71d0b40cd228c5f9b9c48ced8c19a8841028f03463b69b6b683e263a00b853324e942b2d88375472cede79cdf09d5bbb218dc2bcdf8a1ca0a337d3afe451b5c35c647292b0ec424f7ad6d9d60fd762c528df73efafce6b06ca4bc2cbb9b8be9628dcaafba87e651638766545d6a91d6904d9698053b748f9c543ba7de4da9f532bd2e2a08565de57cda186a8f0cfad02ea916c29e27d228a488c743bbc4b92d2dd48a3e972020892ccfeb3d5ba7790ccbd1c8e50504b75ba49c05e2ca6924e153aab9a314599ea744dfcb9c28e2f1f2588511eabca4c11b5f57597595719a440fe89371039fb015c298a85c4f37b7d665e0f4b57235971f9e5b0dab95d52aa7d4ec2e8e5140925462c001d7b5de4b6e1c9cf24f62126ce951c9c6919dd21df02e1996f72f28e5f5d3b535034c0299470224d3bbc4b59cd1ae0a6e0d9ea64ce3257ac3988bcc3644f32bae0cea5d5be591e5ef5bee693a0e31df565874c4016dc88a3e4a420f591cde173179acaa9e400bd812455eaf8a02401cd275fe1d4f5e9903ee3eebd9d4730a57a1719d345a27f7c7f9518fac85b2f11715d9904dbc03a98b8c52070c9ac63085aae63b60999b76dced46455212bd9488bdb1a00a7705f75854c7a813e052c7e4b08c9458994cd39f279a9c2781095a16d83f7467a69f7949cf9fc5a82d1eaac03378c63664abcc22ac6aa7a7bc7901b1c68b8ee8e7fcb3c15cb41c684f47c90a28721eef5247173c2ab2bc7209a942685e1a486ce84e1b2ed4f08cea46f23f062525caef8cc2a896a3718af883db3f7cc169c19186ec95bb69b7e9c48d9da36b19fb188a86691697a4afcf5ba9eb8c1162e5c6b1eca37f79d86cbf1fc104e61b45e1af802c1737a61b6f4e8d3e2ecbefefc6fdb7dc5207f0b55c0eefa86377dd305146c29a68c345871466ed01774d9f09b4302db5daf6d44e3bcc7b3e5ded74b259ad781f0e15bf30136d71b0f35ec8404fcf8e3f3ab6931d4c7120c6a078973074baa31feddd34bcce86f3450e1a407e6dd6c4a7f005b1cac7bdd1bbde4c006d4957bb321726b17330c81b062044638595414e12196fb211378ce1f9a6576c1041860db635405c15c60d961c3ba7ea175e5d064960dbc1ccd4a2e8c7b199f3c4092af7d5a5efc72b2be7d7cc8f0b8652f1e70d093e8add273b086fb43803db844212df656f1cb4b03279c9f19eb5f461043bd92136474556438a6d970e394afaf672c05f689653004231dc9771fd68b3c4cc187921a7f80a898732cc14ddabf89a3ec5960e99b94d9d3d80a49522a7aef55445f208638a44165b9d4be9a721981de960eff520170cc318e0812a28b1df1ecc069ee5982c03b4bf46939f918327e6899f87e8c408fb5a9082db1a6bdedd155dbdaf06c0658309d20daffa82926e68e34bd89262bdf94978dd33faa245518f0f6825d01ee8e843ef26f327d376ed65c6107e44131e086d7bf6d07f6c492654cca306e3149f41e7670268e8068c1c41d8bafe623640221d00598ae255b69f07b8f2af5cda414802d5d27b93505ba6a5a27203f7b960eb512bf881cdf667715cbd8d0c540dd44b7eec695eb2426a58b7209ea86b0e62af780c912c0d8b79895603f2337fbca574a712632a775dbff25902a62d3276b779cac05797366aa13ba71f4a8f8a2dabec67c9755a1f0bd2987b0f562b49d47cfdfa1a2e7498dd2d0d1d90a06c9d9c4d0fdf7b048b330bb79115861095c2b108c3904f7460a77c4d453a96e39768b31504cd45d5e4a6ff6fe1f055f9c61e9a12e74e9df2521776b5d04643a3bd3e7537fe1460bb5335a7d06ac42b86a6aaf1f375d96b6c2bed123eee990da1492fd5b5f3480733f8ca2c89e2f2c26118b9de9a7a206188b04f3ade472ddee452e247eab27b2a9bc6da7d3d050ea2570d32c8173b9bc9922478298bff4cba41406a1bcb2946b34f37a3d2e4f3952ce58e6bb45741b0de7a35f0438393e0d9493108e941832fc9a7e5fcb5428ec6ea57ae08207fd3365a52d4ac7ff0d5a5750133a7db34ef043b67dcd974bdc839224842240caae20c3aab75b84e838f21c0546109a6e892801125cf6c43a500831c25c4cc3be87759be9814b3a4faef3e39a5687970d81c12601e2592dcf17751cb0a624163f7fb834a62ceb86e4b89c05e2c8052625855a9b660bba17eb7beaa9bb5939375be783b76cd9754ad0ab350dc41e704980157a17054ae9652a08c986ec1a8e526830128c841a371f564de9560784dc09475547a8744b4a36206bb18554b2211a187a27f0ef5ae53c04a05e7181ef664a3dc5d2c7c6f6806bd1ccf1fa6c0df54cf77a6d39943001a556457881cbc767c53d460467409ddb4a83c3ba0534dc510cc5691f14fcf1707935cf00319118bd88e8f3bb12211519675e98589f185f55dfc63871b0bc280e688eba0c2833b23df0f2db8ce9857470d1ce274b26af3766bfe6f4bf7f6dc77ee6b6a0ec90cfd0851f70ff8e17e05394f0ec819cbc26290a21247020e40e32a8660e8077521f5cf8e0591a3385d1886ae36e970964f9b16f15078a2fbebd1fa78c552bbe02c869d69eab62aa6f28f62857e57ab42f8e3981a4344c12541734a4446baf54c3e8805dff4b75958e75d0eb215aa783c9d0ad5c9171755289db48fb7b5ccee52a23840ec631202bc41a36a1351e5b112d5c8e4e58098ce63a20eb4eb29274738bc20a7155dc20171392c50a55ce7498eef0962376841b818a86e8045e6e2d4a003ab14b17782c786f42c66babeb420a4bc6a0d2b75bce39313e7cd431c9c44c6cc55fb99b0478c345325fa60120f4f9bf5d140ca4a8b2d8857d2437ffc28df46687dc3bea0c98d01214ee5f216250081b21097c53693f45a8a87d92e47599810b804817d966e6ee359745aec853b8539b36beb8820e3ed75830a40928a5e99fbd9478f2109f08b75ab6aba2344e63c4c34a72a9bf1fa6132f8184ce7dd9aa833a4e9f15baeb6c9d90e9794e6f08524100f3d1f86930ebaaffd6c82dc820aeb83cab4343a22c3c9252d84ecfe7016e5d32b0d63de4b559e293359c6164650cea4f616f0b8a64afb3d774b1aab9f1a0e3788d00b9fbca86af851a4dc042aea7b3566e0c38f0503607188574ee731fd2f627f797b92cb57b802f87ff244c4d59b68a6a827a18de75e834b9719982f5d7ced1db271a3092ace4dd740903ae48269bd914a1125b1066612c6e1cf2b88a4d1434716c2eb68754c53a549c681372e64a673604c5b49e792c2e9295e4e7080fcab6b7e1bca76362128415019ac16e87c4906f687a480011901a2d23587764b9accfc4adf1e9c19add8b06ea473461d8228161d27effaaa58351751d07d5f08db590df0f670ec6e7aaed12397ab666150ada9b11e06573ad11669bfc36ec5c69e58b2ca2b02ee9a1245830be8efa7e5b147761aaedeeeb86625fa069cf3e13a07eb59988958bcd34ef78d317c790b6894cb129bf85f2138d5095ea627bc82f0a2a54b7bb071f14d0d83de15eac3d8225a9c564c5c17ccf480e0579794f713ebeedc409f0ecc0ab3eb0dc3dacd0cdf315302fb3e65d4c7f44915d3d752c6ef5901c92c88f4cbf84ea7190342a685553c46787d385ff2234663cb3b0a723f5f01020fae80d32fcdb78fcdf4b692995cfca1c65201a80e7142d71109b3f0d42b1ec1a5b5bb11df4f3d98a92659244bd008c18d9a226123f7d00f8e4a195db6b7efd4f321e13909a8028f6fe4c5b84d24a189266ae506ee0629198b6a5de3c668494ef29d6ff17b362510f47a550757621dd96f062c0658b70d5c1a9b564318bb6ee226acd52658512d4cae1c85c15d92033b166f8bc58379c677cdc94bfa8310104e1963c67caa8c3b3c0e3515876e7bd6fcbc781fcaeaec3af52c81c1cdb7d4ddba886fbdb5b39f2fc059fb67e0428ee5a93a224be643a8ce4225a033659a35cf178bf0e5ac1994d76e92c9f029d090cca739e6db6df7e54df3c9d4d33c1531ae2d4fc32f735944464469295c9ec1ae90dfd389c5009eedf0e4ef1025a39ddc4a1d9377bff70d2150802b839b77ca7b94c45fc26520013e3f594619b9cde89c6b514bf0eed2247157ec506f17052453c1725f1babcb0fd6cb7c684c6d0491adf075662f95afbcb10a0d66d309ea34dbc1421c087a48a429f803753d8b68c7ea8930218a00c3648b2b2c22587f9140d4f4b42763b2ae8666a48368e5d6aaf204a394a8ac1bd47652e876651a6e264a2227580496d5d3bb22f4098b133c33d623d3aa3999c0ee57437e5b36ffee979a26c1410dee7c0b3cd119043c3e8a6e149acf679ebc1e679d6a199892e329ea2b6da4be5a12c4a885f03a241e2d45a10c51dff47b8e728d35c42707895b7638059af27cedd42eb6f25914f092beb5895e61a4256477b8726c61112b973359bdf4e80062ce4986a24b9f2f65743905041a24bac8619ccdd66b1d0686e8b07195333888abd337122054f70d17c5a0a9e0a62410d0ec0fa3fc913051323cb269902ebcdf4f642b534002573d17165113463ab352f9de4029d1cf4d1c0b06dd2b98cabb50a2e5f9a452ee55e39fe315089c8330d2f306b9ba57368a39fdd5797d6ac1d18ba91379ba341e2443aa4096e4be75d2869d52c282b2c30251661857fab183bd0ffdea1befba9952caf2a589117c120e73c07230462d1b672d018fee4224197334955b2bb88f55c033338e5a7755fd9a4da8d27ae538d297c6afa0c2a40fbe310d6f10948215110e37929dee08adb5c90dc8ce6f727247597a16e68666229c77f31acc61a2e045c6ac759a2048939a2807ae24d8160cae55d880984b02623f64a93190d8bf063bd7b61056f589b1094789c69ddcb09197c2348322dadc1cceadeaaaddfdd44ac0f40b0039f526849bd9a1d64ff505e6cbd20a19c2a0b1a00ffce011ac89c114ddeee1a894a4aa9710796cfee765ed1aa3f1e438fd25b67aab76995169e9af10bb072c5477dccb060914a9071fa459c420bb6baba4f4fd0dcf334903626927a231d8f3e598f9c7633d876e29fc2dcba47c493f2df1c26ec20711b9bc522a549be035caff91e5e290c7c34d86769f4d3cd5b9a6e8c9b4337aadd141e6c965552b7d9a89f990df0f255dee1a189f141e1c78623e21241cae24f31fd5af3f8adc14d15f766d358ccae32f36bd061d109b72c17f724a353ee84f975813f75025c910a0eb2757d0c384101795a9714490d2ab9f20f99f1342960463a95a8f8a5ababc55b80af9325a415b911362d92e12c964587fcc305b31667dfa093029da3cf1b19413a33ce7336cbc71d9065e21ae01cc808a5546c4ba8da0e1ce49a85fb16e876388d472a617b97dac3e21e88248bff536e2aedd8e5d6aa753d3486b88082a282f522702c1ba3325e94fe8334043d12dee4f0aaa592cd8a45705694e095487404db9a7fb2efb92ffb0fbd669dc7bb88841d7baadf9a09879d244582acc59563ccfaf17a17f7e0153b0219c8ca695340a1c3e9f519eb82116b8b01960fd7cd36758a334b29673971ba5209c75cc591e01ee973b133c59c91b4259e66620e547deca0c3c8205833ad983364327eff5eb5a3fa6ee60d005a7749cc1466fd2da6a32a80df361cf556bd882d4898caffb9acaa4687a912b73373d3354661c00db0a62f8f1bb4750415e341078ecec7d6c4ea7370757089e27121ffe1c345c55c72ce5bf93b074e5e2e032462f41f8b0289bb1c8da7c2eb18b6299b20ebe71098798d1f304a0ca1a22e3fe0f06698d0367d424e1a3ed848423443227241a38c5d9c5b88ac22a68c746dc88e7983d0d2a254baf46cc5f4ecda89f0412d77035d8c6b70b9b378bac4e97fce238ed3b283027a3fb78cfae49897ef4eaf69f8852204a9cbb2236e3eb78e930a21652c28b0889b51b90c9722d633db74dddc5bd26b5613a532821cead37c135167b9a150d4b4e0cd21c22bc87f720c8110cb0acfb0520d4541b1e65e3a7b791b6a0ca5e11181b856fb1f616db55b17f988af29e27e595431426f98577ba4bf83b57a0a1ccded1003ee6162cd7ff1a4aa442d2c0d0aa1b0f73f7e8474539e7ba3281e4e732fb956f059c0b718ddf85a0b993ebba08fb7c6292c14425dbe7f6c73d54d7305a6d02173debc17a447292177aebe3760e3e48299b2b97159a8e7aaeb3baba84392ffb09855e44dfb403b1a9543fcf1f18156d8c93c160e9d391a8658741dff4e4171975ef67952e129db8d2d857fde717558051079b5dd0f3ef9f1501ab59c2de932ca82c9183c972095c0e7b543becc4c3e92c175d913669b6a2e2cd4d37128ac00d46154393b43bad31133aab99582ea8b2f51df5f83307acc584f13acf25c87bf17a5fc59414235969eece91434b274b7b6855b03361cdfe46351a2817ef9eab08327d84717f369b0bbee92438aaedba980b263a939e3159f3550b71805ff71adeab98cfbb5d5e1b54be643e20390640df67bdba658d718d86ae3302f0ffb3c67849852128b6381a3377ee7c41847c09f4294e67cd0f76515d2576597eb2b91dc2613d9bbab3fcb8aadc35f79fb765b0b50da270020698d8ca2259cb6c60af6a0bc8e4c0d1d5a5e5c766a9bd33be71a6198bc5931217041c565c49f4f7c60d8c0871c756e440445dd02e90ba5e3d6356b0a577dcb59c1bc1e421bada9f04bdcbd4720cf0d15b2f3cc1e0759af5ba7916609ffb83f1d0f2429d6102fe96997507bfe6f1ad0c0d55be436d4d86ab3c95b0d948b8447930839aae26c2288560315f0169645138f252252f3e1e3208dd02613ebc2e9ab1ba2b208cc441369aa0cdcbeb0575be6076eb0ce2e7e0d46f5181d0520640e735b3526c3f83d25b2464d9176c1cad9d96cee0d4d5b012cc152256ed94477e2d734b4e74463b1523231ff7d412ed727505c28853527bb54e362f82cf9cd7a07f8fab25c9ae7fe38aab6ddf0f2e61f0cf3230fc3342e30598ffe22f0f0ef247b29cb72b55f5b65d550f84ec2988cab21a179f562d6f3e56f2e0a0eda47566634272f066fa51071d64ac4abb8aa91ea085e357d8724d2d5c4f76de2664ec2abe29fc39560b9c2a3e5278ea5b3d4f8f7433957a8104e5ee7d1adc5451495f810d6a556d8b040f0cbf75e55075b155af6ae811e6a07dbb611e7a48c5e9e2ba806d4132a6c095b871234bdd8959b3b31ef124ae60e3e1eb5748b247d34bf20479001cf8c0a8bb3959ba90c87f8f4daa56837bc2f4b038ac7c99b38174be9e65c0efa662d453b2adb19a12b6a5c3c5c26ea035049d9a4a937cc0fd1194f9838cc26a4821f12ae09238750ce25614b820d52434d830853958bbad5975c7927cf41194240ce6e6b115dea5eacb9f6e51fd665918a4eec5e92a36a2415ae9caaef80256d87de2c1a4f70fffa03b6d8929b3956d6882375ccdc114b98c7ee97632766bff830318d76d3b3bcfa1521a429d89964e7372fc9c37134dd812d9bda573be5e69ded81ff730bcb58969e3ff497382445e2ccf89acad5e5918a4f6b0f226c62a94c6125ec4de1e33baeb6504940cbbc360f32b3b2aae8784e5454667661e77c6fc8eb502cc97c50478c2d3ee72423020a480d15ae80768361499980dda47e27a1afc4ff7c05d8bdf332091f6a0963b192d39f9f20b0a6e8660bc68347bae60d32c11d12d6d40325852cf5f37de1aa03ec2b5a7475574c8b7740c0ff3388ed5401e6fe18bc1dcb575b6bf040569acd0dd7c57df643cb0b2ceaf1dec922c25bdeada13c84af9b7df19c1c268c4244a354d31af8909ae4ccbca0b807a5452c9efa315839a895599c9faec73f0bf9b107e5bc0b9b00d2c93653d4bcc061076fdcb26c9e163f4bc51267f3b47e922de558155c28cc04440e02b4fb06ac08f25932864152c1f571821badfbb06f034a8a553efad66326203dd6ead2ced84b4f3587adc064c598bbeee1df8b2364f45c32281c1c0ef4b85c601eae4160fd59bebfb609cfe18fe232d6ff813f25c60ae6957a0e739c34d5091ee12a13d2bcdc841d13de20b0f1242d3f76f927d63f1d47a79c7cb8650087958555e4d05b0ed1799e185487342762dceb6d69779167158905744db20b6b56fcbb1673e0fbef5025abca6d0c014fe2fe3be7a1fc863bd7964ded121f55083c10905b394bb09c37f4e62d277a56e352a3c028ffd8da29c9640cd581f3ca0ab3fccef34cc65f58d4cce073236cf7df95683a1525498f7c10e4ebc56b3609afaf4b5bca3ffdc39eec52357fcdd8ae63b49df40bae70412c5b1be051e0f8f1e3327e3d0775c2d5366fc569eab48d3a143cdf8f067a27b8459cb691f05bb55fd726defb9076a248002debf922c32ec9e8804aa8cc68275a4b656e8658a0c904b2c725384ada153a93936b3272b359dbff3062f31285258cbf1c859ccc31a6f4c83925b93122cf4cbb94f73a82ce8a86103e2ae3371718e5ae6e4a4c569516f74d44193dcf4c12d823719395e1b6addd3958a2f56053f45783e48193e5bbd724daa73028189de0f6f8ef0c7b64fca7ec80b3769b06d1bd2e871d5c97dd42f80e19d2dbf16143941722112cdd55fb681c0ad498c36040b58bd733a45593d666194da13f1d3f2a4865663743b5a8799c593108c20d2863a137a2c8d85e61bf595b83421f2ca4dcddbd63ec60322e9b8b739352ec1931b7ef9a9fb39ee79e82d2c1cc0cf1ebe586457d9f0ef81eb4aef00187cd8319955f602775af80a0fe9c86e3e81b71c366f0ec66c5fa74dad47b5807e454eb9a796ad2fa117ae37c5f67a0dcfbbb726d05f95664342f2aabedfcf58f99f2469a7358d709622b2c1c9db6002df08a7dec2b33e88726d738f54835e68764afa3121effe5a5fd158bef3bf407fd18f5dd5a45211081618b25ed7a1793cfff95b288532d011a49b7a2de35628dc29502247715d06d0b24f6989c0d40b54d1cd4f24b5bb591ff604bdb2b5099def5c68f3187255c67f73c632764e466f8ca8c9e75ef7ea43ae98ba2ee37f343533c71c555e1a2f2a0d95d12c689c34f798269aac5fceeffa6b5be24c1f4f6cc4ca49f40f2238f173c7a2a94c6abf165f0d6033dfcaf6483221b4a3b3a3eecb7180988189300e5293bf2ed5126e6db562a2d80807a4c8121f87a6a621d1b02bcd5dab6a08c952c3635aec0f7cc67b1362f0ea376d32d4ed032e1deb3fd5b99f0eece472ab75c97b1a7e9b87118b38e0611194b9ed68e431cf78661dc519e8b84ade767e37572c7c61e003f9e402d2cb6f2d7201e5ca018d727bb5ad2443a67d7ae70eab4b84c676186b7948ba6b5559e8bd2c7b9b3aedec20e2a3653a03490610d732c869c3794db4684d08c4cbea8a1fca45ac756f32dbafe2f2e9635d831fde8921089a0aea8b83e1a5765d5549dd94e97a9b4738c16cb37d4f5a02b385d89264a90c39c6aecb9424196eda9fb287b625b6330ba95313df2ed7dba60238262702ce5e522011b2fd02d10f70f970f040367e507adc442cca66782f7452f7916d13f43d8f9f1fa6355138bf9254705a683b3d2a5a331b78038ee37490ee6f7afb2a923389b0dd157ca15298473bfda8bd683794af44e94cefabc63e45af525c61334bdfea94e77cee9e67218c83763903ed11a31af3fff8d31966e5c4f34512c674bd3ecadbffb467ee966f610d71ddfa5eed72cffd6ca76a6b415cb95717578d05140761865084d1bbf5581b6d1c72dc2e4b01e69f13668fe26a14bac30c717eb6e88b7bf56491dc63ffc4e4504f88ca5143dfcf70bd9bdbc3e5b5d903c91fa3b1bfd3df95154d6e842e9f91f30c2990d4e813a47d754d56c9214999c23622a66245eda6f97e95e0d6f4c6f9b14570ebbdcb488a4540980d25e008287e5c17dc8478a7feedbe1aa3a34a4202840e46b076350f9eea093138b5b60367697ac14cfc09edd4b2566783f07b0c25438025556757a2b5720125f5c9175eec49888d43f5884bb20bc36ad3979f9ed2ea634d1c8aceec6b3a4159c9645603442754a9ae974dfc44f3aee9ba2b43afd337d308ddf615070bec6509e7dff818e0791248ad3b56f4d23292277f1a1620fa7d7f7688dbc5728bf4b43ed1d07aa260f12b92e9a28d26b8ab4f6c25a76ee2a4a46875e762eb12c779b6de0792ba190014e3aefa04f33469ab5d0785a2948cffb8ec1627665fdba6572e1749480c652f856fef2d9c1080aa050f8c8785ee4b9698d66f746ffad8c7eef7f7da314156d87c399f211a6e3783e91e8e3cf8108acf4dc726d15ff250e27947e32c682ff7e9bb5d0f24f9df92f62687fa2ddfa6a943c1e96a4b6cda4b705b1a16a638a556c0970c972de6135a071dc30f8aef3fea2f22792a90c75e3759d021622d6e6bbdaffedca21f3187ff272f4e5d84349e1d950bf2c27c3ba25628a4d0a155cb2cecbddc3236a28e75e5e3141357936da71e693a3b77a471945e49e5ea8487a3a4b97be1ff1258410b77b0f0d66f51e897973104e1a6a213493084096894666dc2ddce24cb0ab1d954a6955904b9e0f649674dfce6230445fa501f243c5a28ebf7b80bf9a6087ace5f5503d218dad6b05f4f3a7dc88454543f1985d9dcb36627628e0da0c0519342a20247250aba1444e06b7e6ceba3311c8bad4d8e793f42929aa04d5afd1edbd4b3c79342012c9d05b8063efefe092f1521cfe519c906d9813f33d793872edf49173aa3d3634c445ccb5f58f52f9017c6c65acc31bf3700a2689f544771d0aa48745f988d7f64b0f622c1b40c899ecf52fdf182ea26b5466f0ec16049627ed10d70571ae3f02beaaf214a22672a34a6a1d8f183d143273b223da7de64e93490fe1a8af0313e0e99698736c080421598609ae753ce414b71c451fd9e0e24b822684ae817366922d30771f60b5f1f8c5cce97ed96b381955215496fb58238ecd7a31427fe64ef21ee6df1cb42adc6fe6e2c1b4abb45b87f5bd4298b91ca48e99d3861f10c84c7d838ecbcb7df7a526209f56cf1b41d4a4ecbccc7e8b28ae06511a58fe802ced1579621368d808e87384ca0fe6fa14f3027b96b7501e9524ffed3bce1d48321f90173a5c49c97453476066bc04113d0e6acfcc7cf0b15c414806d7508eccc24180e24ce701373b886c263f10304d22806d0ad0fa72277b5c9819c3122f1471eecd0d3f9ef40aaa033f9d4ac3e618cd48c6fa23add531374957fc0a869de50e8243d18f22c3e21676c9af0c59a8726e8e3f4cd877e3548f588c234c05c834f2b07af524da81cf698ddfc1bc6542c039fbb98291d76c5505112a189f3f93804cbaf0ace8270838c33abf2da14e9b9173919b1eaf6a5bffa9a8723eda77c1420a3fdfdbed9b3a7400ec00d049f034d1afb7a08a17a42138e753b7e40bf12ba7e60af4b62915e13c773f67d0ec37472a0a12d1b5e8f0ddc9a257f69adeca860197665cfe6a6904823693cd74bfb8e5830c941035ac0af0256d7a931cab1f4a016f937a7d711bc76f6f403ba07a6c5151cba294ccee48223153fb6b343499a4cd9bf448deec18ec783df41f8fcd6ad5ce434ead9efe3a8ac6892daa232b1f595c3babe041c167c49e0977c6e34d4dea90aac4b8f5e76aa0ea3f0dea4746090242027fa13602d259ba791273c8de78865284bdb5462318a8fc4668d8f9c6ed14d58c1ae6a4c94c622dd62965fc5d1109e188969417a1f8985b3e01dc32de97e2b3f0e902ca819e0549a22dbdc1c90a04af3a3a346344dfc69816fd6620b1ea7caf1e4f8e1b973c0ecce720e68bff78e5cc4b13272327dfdc87813a2d6c1bbafd0aef294d11dff689e0821105cb4bda655980e50f3cc0f3755e18451bf084ea5b6850fddc5473b5f830bd75b0a463d3d355802c504254a0775039b7aa7b2d587be17daaf0a0213b8664a4ef9867b70341a03479b77d2d145a02f4e314ed8d5d82a6f0261ab9f344831acfe3377010cf3a75bba4db4a5e97a5a658f11a5e003955375edc8242371157664488f5807b9f8466bdfb56276bc4605601c4c7a48410b319d670506b5951d622dbfb3b8524494a4016861830095429ffaf6d1638c4cd01712d5888bf781c4902962063aff6821eb2c47558c51d94020613248975119060659686504f03aa5d627f6622f90303f3f76d5eb5d38429b63194148f950ac0cede872fb463822874c8ba9d65372878cc8739a259612ad4d0bc601c74617ce9f6d4a05ff03db0ff119f8d80152d2d3cfb7130317d96a2999ec4030b67e82b5c262cba93bc98309330a1c6e0610b51c4106fd4bd2e194409e88d096997b4b8875af80beb1462eb01c0f67ef02d50addcdde97cd5b457f1d926e781839187b2cfd6b0f10423643bf9a282072e574a238cc0689837a5c569f070f94146e44d10573d9a77efff4175b0fb0c7c9082267264ceaeffef8a5bef8fbaf57aa05825d30a2657beb0a0ae5627fefa70f29349845c9f785576ad7ca7f45203bc0ae59df3072dc4daff761c1df3e88e8ba1cd0f5617b982a8afa1fa81bdaca9337bd3cf836df218cca4641fca73d8d885f3909a69aa859a6432d066f6a1768ce6651900f83edaf17725dd3fe73f4d7163971ef4d6b269df70883bd12fa057fb0e559ec9cf9e1d2ab45f3d5ad7ea33f2a0eb179193c0b8dd51b58369e416db5f83065cbb24a1fe35c883a58929d70792c9cbfce01b880c825555eb8d504579a93fc41c8b9af5a0fb5a1a795989df96d0bd91dd4fe72bb9790770946dcd71a036eb9981a10144a5748d80011e3380ac64206f53830f6795d65b9b2fb98e4c1fbbbaabe9eff264e7a1b2b332a01d6792bd1ab0ed08bd36f96485f02d774c4ad90aa9e2dbe8a360a9cc5fa4a6b47f73984edeb537bdbfc517a19d1ef63832787c7e8fb22c448c1b0b7aa36c24b2b3aaa4cab80efaf59a245f161be4afeefc6dc6622bc2c3a2544f1a34490ba28acdb8bb205c9aa8e0eb7a80e78ea4969dfc1bbbf402801c5871b208ed62ec43d700a4683ac476aaeb67233603e7f28670bf2ab61a4b14565368343f8dae8a741892eac63d0397a9e5e2e40c5ed42ebd429075d7e4a0ac967f168d3447e9769817c8f2332f2f824e3f2087dd4008ec6892ec76cc5af2b2aec2289370df892964df9f42eee78e985574b1082e80a4d5f6f973c4c7f48d191c23b6d9ba6f7d485cb3981ca3b06eaa8550549c3b9431c539e915a92033670fa00ab90f19779e71df9a4cfdf8d81a5fb9e896cca44f50197f3c90521b20a42f67f98365bc195ca5ffb2b390068f5b81b1f4a375537c596fbf5fd3c1c1324d9b414ce4db1a6752f60b62a86a0169d87ecedd7f9b65030b0535ac07a324cd5aacafb54bb5541b10c35a3b7d4cb4ac230ac7724cf0502fa8f3bc20c29d6a433d442ce0f0ef672df8fcfae3883dc7f77a32fe267bdb0365e7202dd5b2894805b7c47c0719126a778bbe20016866ef2039fe39697aa0fe1610158f775229aeac54efede7d68360c86a3a66abd9dc0e8dd3e7100752730d38a322d27e6f3195466684c24329045955471c3a2330657f90fe4aa6ae611f70cd4b1d5b27aa9805f27316571d64b7e233240826e01177b5d6a0824962f6bbe27a80b48308cc17933874915def1420cb707be3b5cffeafbfa9393403e81db8061ffd9ca814bc4cafef98e395c55bb0a1d705db4fdbb805033c72e548a276cd0d337022f6e3c9499e6868f84c0db3afeed22c5cb3c00977bd7384001815c2b4b9a958ca3ffce3769ba3cebe63d0b1f88bbfa294343a4be8ae73c0203bdaad93fceace2ce003e51efb3addc6f408fa85dfc48f2f64e24ab48c51828fd954f0a173d9ce425cad511f45e253b7adfd6f5a8136327e581717950b0e5f575fb26c4f53783c77d8dd0846a80c62da3f07b12b806b2694f8d3d7429bf064c635ba85f2115a35fc0ab8322524e9023acb3428415bd7d18458a9c11bed1bdaa5c735fd4393447e3eab36f3ffd917f88fee0e49408813cc2c2fa5fc62b5065e0bb8eba493e304417503d1c75d38eec2f9437e0deea890fc6f0cf311ae20134a67614d9370d06543811a5967e3d28671ea1ca2d04488b0922156783aa4ce687674c0ab97311fa576798b790db60808ec25e1acce005221f1d393b49249c5d551652ae8e2b1489c0a4debd9a7e888a6c9d9775bb7bce21d4db7f98d0d57a9833258486594a4b1dcffbc3deae57e062b397e71d597bba892a04e79b756756d9f8bb12872020781faa45049ace999d55eb9d3411cfbbd2ba087c645e8b189ecd4638f867d8b8382346053bed5bf664c6bf5f71e692fa22cd5080a4f2ea587f8e02478f5fce912d8655c3914cba5dc4df10fabfe15bd7b249a7382bc27cd33186c2cfe9385f87ecf7d8c640ad56f93c8f0374cf597e9eebc310d0c11caf375896dfd6bf26c8252103389bdaafd50df7457e2a77bb2bfbec3ef21a07223bf62c98f066316f79afd8634d2dc35f0945e3bc5cfe565f5e062a26ea064465aa745f1b714e35efa1b28449274ae2f6097fe54887d2ad3971124668db0585e67510ef2e31088d5d8df5224af432bdab894fb33102e8f99db060ad1d85cc030b03f096c86e9f415935806940e8d4bba8a85a3e2b1759751102dee29a94fbd37956a49191a18a5b917120591e5ab95c132f510a336dac0f27579b397a17a848dd8161a2a9f31f12e1e4ae85b3091a1d2647275d576491c50af50bfcc673ef60e56008bbe4bf496e37ffcc7661975db940f4af7e53791d7e8d13e8fec7ec28f60d2fd0e308b0bac58b973b1473b8de2e587a0b4591393cf4de48f2b10fda3d4d482be2cbceb7c928b0a8771eedb8142754ceffabb65c2e7f5ae0e670d49804b78f2a046140485f8c3eeca182f5a0bc9a6e2ce46b550262a8a5f988175b7721e4eb5f5f2e276ba590da39045717641df62d49187a784b1bc5c4ddfd95f9fee7723e8b9ca0f3b9dc7effd7afe0c0cf6b4164faf56e3afa7b204d8cbbcf896142499754932f4421cd9c97392abc682bac8153883336152da13c6e991ed522f53d4baef842217d408de9b6587bf48ba1ecf4c6e5b42331b373abf79ffb4b77c4eb45a34339e9c2775a57c4f45d95a27aa03cf119299dc109ee47abadaa986342add2ca2fceb21db7dc4307a9d805934e24925df3147856e096783bc07d47f180630bc55aa1f5dbee2bb1e5fe0d387b433c69020f66a4b49def393e08649572513493cdb9251871cc76f81bca54e1e6a244ca3d7d0e2044cce2d963c5e8cf6dc7c473c7010b3edcc0eb7e6987fb3b390598a0fabba05b46ed2d01183643b0da83d72afc89731ed756e521a1c9c234f97dfa748a8f99ebef6566f6ab92163a2f1e69ad8d664d11a90a8578bbe2409d5672b6ce9a02f564a4e5cffaa2e368b0c17a119d529f061bf64de101868b31dca7919463ec7faa58f76092bb936329c69b808e049b55385c5dfefd40518cd1559ae9116ef1a065e09142ed37c4cc08f16fbf8e3bb69982de6c4ad00a40b196727b2b02332d7b9f3f21f213a871e8b1ae578adb82bc5a8695951eccef858fd4531232354b1aeb52442120c28e2045330202e275151458165f5e9aedd8cd3ebd5796a3373fede8003911494dc5d6f35cbd9e7ca50207da45ecd186cc7e71a3abcae3f1edf6b38a621b2b8994b4ae9da5a3d8690a863b23bf21218169f5572811e4928458f6038dbae382cbcef9ec9459af5bb028005d2b7b9aea124f81c779619591b54aff7832fc55a4bc0d9f0b9cc2dfadf2337e5fded8bacae4d112a20ce4eb4acaed84358c74559d202f94f0598b72267558b8324fc02caff8aa85c9a010e80babbf3ec0187a4d910c7e29c5d3ae175ed2ab64fa5c30a5f24a4d201c2d97762a17d26d5e3a6f0342e504b7d893de94f3c06761a6131525fa3e030ce342df1c350c69178436e61be99d1ecb549d069249a3b4000741fe14007a985d91bd1a3d787a14397597b997f03a9dd7bf9ed15ed8f5195f8f5922576d04ce8335a4c93b6fbd9541d5c5818e664a680fc43b8902bc743216f1f926ed05612b9b75f49727bda8aeb88e6eb50cbef113143c5c0026ef406d602f93f59a1711822792daedb355ad31fb31b14f418c4002eb2709a81e3cbab9c910e64dcc9de89be78fb1ffd4c568828c4b852631bed039d3090091a1134bccc8538987e5c82e64db60cc860e9a948424c9d31c033914fe130196418bddd36c66eacc5268b1167e7b0f179140e9b341c5e39b6c435ebc506202c8ee0093b9f4391b8446947e4dc4961625be53294ee2eb10e23a1f37b627b26d690c2c705a0b6335506f8104350cd1867a6ae3f1e2ae3f5967fe635c7e24f3ab9fca4311063a0178bf7892f4bfa581e7d06396f68d0969e68981fc8b091e1f664a6a04de13a603b7dafc8c7957bfa871360ac150c40865b400e0665249af35af01a72abaa70892671a69835927c588bc24b43b5a0fa0b0b86614aa5f4cec4d8536084f529a8d0f13b84c0a47e572cbe1c95479bc26c514361f86234fd1b4f906f07c271143bf897493f4a94f53490fec5ba8c97b7f1eb6dd27d433bf8154add2522a013e55e85ed4926b862c3e080e1ce84352ba124cc2aea4bf9fdd575f8d581396af4c5258274db6a759ca37a03ff5b90d44aaf40eca64f4c331f35ad8a29f8444bab24949cb31e41d1e5d5f67b2e40fe0727e886d7327ffaecedc26f27a5f4e9c319c0d9362c0825a8301cd709d731b119648c53c6e1f56f893b04080fabe63f0b783f19726f94d423d15c91fd95809db6cdfa35bc9725cf02c2869dd4d52d045265c6581d48d940b9e0b2716148de1a8b436e79b96e1980842b74cb91fcc42b66906c6bea1cae25c25c9f112d5292520060529644ed5077cdeca0b066939102bf44619407730f34b7789f701f3f7b32b1dec3aadee28aac47f084449ff18670a78534e786ef3f8dc708367b1b767ffbdae98568f740dda7bc2b5a69db852be6a0aa3b2a5586db2b67b27e331cad58ba43f1175e07d15ca2bd53493088ef47d5928808d3da8cc97df9aaffb90caa4a4f268e31c7de90ac16146cb7f7fff6608658b7554ff8ad9bfdcdc5c53810eed5e0bd07c8326cb4424cc5e465631156d29d456a09f43846b51ba6aa9d8e7d47073a4ca0aa3a453613a1b6476ccf0fcff9803932902e7aa9373b7483ba39e780afe1e9ea83c5c86c9ae2beea18580a39a54f791d897eadf42a294c521800ab5c113dd059a309429b20a0ccbaf748117710338a17b880168eef6b71840b1bc85077e02cc39ef64d3e9add8f392d579ce0595f5f707b46f79236024cd614bc414ed248bfb230b9a7e8bab16b83268b32170d7fd56ab9826aed43ac5110efbc2573907bbc67f5214197a43bf40929fb4430503b559857f8922c8a8a11a9c55d1f595a9b8e2a24833899e52d72c7fdc201a923d0b904277828556c06e7667178f0643c253f559d1ec92d381b39815df5fec70db4c93de399af8d340d43f2cde9d4d9ecb83da6388482a0554f4e1e47c7a603b1577f02659363f1c84b093ff93c4aba8c3f2167f5543cdf1f2d3892dd2246045d9a9054efaac39978fbfc5bc1c439f5763b2ea84773f2da7a4de0a6eab4ed561b903a277233607a89296810f3afc77c552d3bcf1e739bdb638af1eb4f4cf7c83d6f11ab20d07a1c8b4c08b9ea4ace4165b9a12eb54c3c93861201e1a92742d180c5f5163c1413a1540cb30654947915bf3ddd4cc33e1dd7f68d7c1199a07f660dfdd479f98cd4d74ab10f2ac2d67330dea4db6a67fcf4e3b87601fafcb42b2770ba0dda7caa9112eca67901b9e9f2079e4d9097179bc5d06dbed4d6c9434dd9e59b003d334969b2c13822df77e2008e296dbc67b75cc6deb206d4c6ce628ac5970ce201e11df5b1d1292894fce2c59a769a695657ff2637878f11f298a1ff6affe13d40a4089106aef1fe2d2acc1b014d3d8d042e08814fb6b845cac858a6abca9c446b096f87d375cb0331dbc866e1017b0ae21281a3f9a4a08df9d933eec16c23eaf60eda391becb667483b0489397bb9ce25a44bdd86cae842fa9ed52c5d17df7265fc1954bca4419f855e05e7c86d3c362493f9d4fb373a5c99138b82ebdf821961cd1a5a3b66d2cfb412110021434ceb49cc6464b51aa78d182aca574b6b70724e03733a1cb6c7dc2907a70c02edcf2723592bacb95f7550dbbd88734c3a147631949bc98a56c0c76e5d7cf852d00fda91419a07bb2cd0dc41e330d4831caeb2771536cd68580163338e7df28155b0f588fa7f75c548d0dc6ee17bdede27a708bfbde3d1cdcf81fa43c9326bf8416ee23eb29053a5eef5cf54d62fe9b14c61229f914c75c697c8015ba4062b7ac0bed2016543aa85b80e6ce154ba39165fecc75afdd74dceff106a4cbcd17f61e26f1df4d7a6c3a0c4a5556e1e24c5431f6949e0a479201f212b6bcc22241c4a1528143b8869514cd4591515d920c3682cd8cebe766577da81449d3630781f1821a87bbb214cfc8c684451e1333b8c1993d31e2969893836620abfbd82725bc2681d53f91f524a5ef4053cf712cd1387d9c8f38e1ef4de21daefef0283b6656d474036aa479c48cd9469754484115e322c562e97ee3163dd49d23171d3435683e999111ef302bd0803ecbe1da5a305698ab020d3e9642b5f2b41e45aa8f7fbaa0064739f067f68a1fff1161299e2a484b83bdded87ddfe174bbb603c9bc46519da2e9a53511146611a5bb36f92e9308f6092bd383984c31fd038156b2acbd814f5fb0c7a69509514c358ae8d975c10eead95d0f122776c48ed2cb32d48d0168e52e04b6e636d796b2c1507ce34151030fce0a4eea038fd4ff67691f1b757a7e42600696c526faec0f807ab39fc9469bf25eaf18f7592b24dac571e53b0d34b1756da8fd3ca99ada6a806ac827137eeec4008058f54a0651d9dfa060c47072683f3a3060027e068351ed85983b670a2616d76e1ff808e5a89b67047dc32039d4c60e081bd17e623cc9dd849c28797c99af6b6da4cf0cce2f3b619737c3be48c7a85a08bcab3c50fc3e3955df2a1e60ea35211a7f7736063b10d91741d965097415dc92f65382b8cdb2dac3262a6277b70bea3777ae123154443b937aa08cf7dd05cbdb84823c3d481fb162c5b66cd16cc478cb2b8f2d5730278584af52def179b1cf021f7a2419c33f8769de0573699a98de76d99815fb0ce701abac062b5554050989e31e103a448fd4a9875e3012e816a6f3c4b381000df7fc1014e7bba50905305d86f68599132edf6ef07443be2a7516d12b4d56c7a514200f3810ce9267b6a544d3e7a8191399f294417ed205c11ddfd9cec14a66b5ba60f866b631f94f88d5a639326a99b29648ace713d23ca62aad9637b040e4a26add6156ee08d81f42e393dfef8cc1c41994be7c1666235beb17682a9186ecd10897c453ef8bc4d44ab601165f0300fab78c4303ee39f2208d53e68ed0ea9ef32e33ca49f1cb11cf0f834be13b07a948fdbec04df51fb88f52337bcc9251eb0d7a42590de29d26ec930404d58be0a47f90acbaffba09062141518cf10e809e74a6672911d5b1ed2d6cb5a572b14d23c204035ec15711dd97ea63988e93b45156d611708f617c2a150e3a8956e5b44b16703a6d637e7ec9d67604b63e02faf94abafe40af21b09e7303686ca1139db27be44015dd3f2b9ab6cca363b8135e76f0458cb8a17a4e97d8d730c5f1d1929889f9d77f8b333d10728dcf93e882734e1156c027084e679defa59735ca27fdab0e1c60680d1a1fa10c98db54b1719065aa64830dc7df4d20980632fe7adcd8e8a67151a60dd0c4ac6989faa83a89d839cf9a093ded427957739616252d071f6ddfb3fc167e358672669613508cb71861bcf946d6da1f9c0e0f2477eb183be174401fec2bb4ea837c56aa9bedc4080f8ccbe5c8116c78012a2cbea50f9a03b89ecdbe13952e57c3072974e278f15e112030717a589f18f73a9319995f2b72216e0927486a0a7e664f5760df5bb06806c90da3a71aca025c11b0b900bc8ea4e3571f88e9ba94efb813d89224ba8d2c4a6cdcf8fc2822a8bb47dd704a7464c6b8799c62e992379faac30c75f4c78e2535bcd19070e904cf048124510159f3a4bd8c2840eb111d5def4c9a31fe32d3db146f3281a849c9fc036c90431977d441ddd752553f0e3dffdcf9940fa3fde0647c990b8194971b8592dcd4e8933b523120ae0f65015f045f573b8db8d88d5fae4f520a2095a7bce439083e6090046a942b9eb382e2ec14c3de6c591f550b4dbae0966f32e72dfd7a1123a3619c8fd542f7d0e71da41501bb672a48da97f8728591e5c2c7062cffa42dc8a18c0312d232ec4a092040909046c11f5294dd190a4c952ef008819f2a7da36c83b1cb3e42432568fa5b6957700ba8cd827db64f1760a183939f51ae6f851f61ab0bf08cfe2115af55261132b4f7483eabafb8e5b8dc8faf621f4039b9a99c7992ed8689a26fd247b200f92c9b7ecbe44bbf5e9626122c8b92abc00c379da7b7bf8252591437b80704b37aae67515c0fde829f428b301178ba11d41e77a6e7b38d4a469ce1724d096ff83939fa67d61b2fbf3204664552d51df90d49db71b4abd74845bf77d6de0515e25984a9830f2a8c912fc8bd64feeafa3ac444e25c2bcfb5b949452668401efc433340a8727b2fbf2bb8b07b7e432ab00fba6a0faa78f4f4b4d47b0a76ba0ab47c0111da968a9401b61a86dd563386232a9ad6db8cb69f24ef2ec48fb1be189c04355e9e5d1cd11d8e19be5531c20e882a7950cc017d1ffece0fdc62afbffb95fd301faec1911e21b1b6f98b45fcc7111e07935500113886cd0978e7ecbb43c4ed31eb44ac2d37a1a05c3d6dc90508797ef74f16243fa789094ff82aadc4d9506f7d1b01655420986c138cadff6d19155ad7ca42ff5c788652708f0dd2d4c718c427e48040a1bbbd8806ba06de3d740d55a69404d22e453554271823c86ca82d6d7dca1f934e0e92b7ae69170deab8db4fa9479a40a254a82e5af3f890d37fca297f2ca472467a171220b14d75cf346763f2fb43a58b982d5983ea27b2252f0a3b2b7fc136ca7b580e536ff17d18bc418adfdcb7efc68321625bec22e675040bee3e0d9a8d3071544d655774ef0827d0805aff9e71fc17ba9befb2edf5ec9270a84bbfe6a559372c5d29cd47f7247492584a6d2fa5f8d3971e3e7b5ef3c6168f911d9","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
