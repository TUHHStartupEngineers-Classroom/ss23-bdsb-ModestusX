<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"566625cdddd5f75b8d0da07f53160937707b936972a950751af8bc5eacda97ea862a151cd59cac81a9b50f371f09321c5fa65888a418aa58771688a882ababc63ee14edfe33bb32f81edb7c48dba45149b81a080850cc56e9d926b46279ce957f1385041cfcbf0a3e9228d4e9e379d197a7e447786f8c1db20c3cc7416194f9095e0b899ec2530ecc682a0e71fe81a13df7c13c628aa7088168e41c9df70b86ea61ed5a8d72bccdb432054553956c6aa84c725b17760874935876d9b3b3908eb85ee28e74ae1063c65f45857f24326ef706c70d6558bcfe4a19f7b0bf7cdb249fb6194179584ab304405d23e681402d0c9519fdbdb84df07233c61537b09de21c59b632564214e67465c3dbf9686214d715e29f6683f8f1a1e4a88ed15d6651c97dcce813ddee1af7b847bc46d07244ef0ca37ed7692d781dac514628a00785ea99b79009d98cea23fead3817710a06bfe2dd1613449978f8f6ff1927cdc04ad7623b26428342650090f4249d135d63e215efb20b3b9fd2d542865eaa7dd7945de81b9d10d0d1e4dac7bc78db7a5dc9b3f784ac79eae0bec74055746e6b3994379cad19f973f545333aa4b027ff6efe85bfc69cbe3859b24d4f4696ea9687e599526c7d8fd58b0b9074e345ac70e52d919377ace8be3206c9f9e9c8092c1268ae09c8a6cbd0145c23a0095ea52efc4b226828a19b4fdb54834f41627d9aa5ce1a050406a2cb50338b1e473d5e79e6dc762031f3f8198eee4f9a966a7d74096108c5d5033215cd670af66c200e9214f6a0b80025a3fd11ca9b1f752b4e37accd617fd7cf2d85f20d35f974fd301bcc9bbff209b485f9eab51960a8d34c99f2690cea6cac6d45164ed00076f3920c762d16e0df3ff95b9b70a9ad78b0da3bc0011848a8504f5b51dd7dd9e29dc7d77c4df105c5c7717050b2245aa5d4e3d53d9055894c99908c831ba7d94dc27588f9306e6ff22bf3b99d0f67390ca8d4501cf3b6d77a60be56a9ee037d7d1cf90486f31f15253e6abb16cd0c183f8f34564f46814a24010a4fca040e1a88e18291562a42883adcab41c6ac33d445d9029b960437f7410d4237c569b7524baf25ccf6f06c299bdb3df880ba7798e8a504e9dd822840c9f4e6a4acc0c9b4b9a73a429aa40f8d05f95a73fbe8f794ce20b5aa8b66e7b40453bfff4dbdf39da3eb7b3d76cdbbe51aecf7ccb21fe6a7766551c6090e02a1eeb54229410a6aa167cc9903da354974c99328e04417778ef789ba44b71b2330c9ecd36a22fe273b5b530f4d2a4cd150440ee7666306499d31054fe4589d8f1d7e31df1a80a9d6c1853d8c0bf94b3b40744bfa5e0c3433a422901d0f7ede6b873119354b82ac955e83c345d14251801b6ac0392b705c4a0544174e8ebc8b3c89f261df09ef843cdfa6fcab934a028790a1e0dd382a9edd1832df7d47623e2de3405ba49bb973dbda94e1915a5aa6343520ddd7d71dd503169fb1311961a5d2f160a6eca66a1b3dbe3b753116a3730e5af036d879fe0f69bc74e29b35d0476b6a637c5df9b55ffbc4a92c9fc0b1d044d8c5c4617213ec36b74de1babef0c850e25ab359a002e8c78e80894117770e5bb5c9c8f5aa38f5ce192b4e6917b0b8d435c23d0cbc5362db499e58ca47dc8cac8975edf37d65b967ab4d182693bc578de15357f352bd1afbaa52528b5b141766076524bfa2051e63a0715b8306c48f8b06a8d9ee7598bb1dea5851bc4594969332ab5f016d78a99ef95c146f831f668aff33f45cdaf7b305f470d514eeb1ad6f9e0ae3fb291313eeb35dd923a190ebe5ed47519295a0b88e66354bc8c17603260151d5ff4597abfc58f477e6c7b940b678ddda4b29f9ec35c32f7ce7fc5e1a031c5de1ee77b4fbc82d91441bfbdc8f5b283ab880358a5eff0e3dc85a52fb713be5f37bc70a79cdc1591c735ef503b86ce0f13024a670f4a095acc62116a1452e61f2c4016917069ec1144e266464a242ed8b5861c408a2ae689739b8b17ea1b0fc9f619ad5c481482f26d5a2aac8d4473188dfb723b9afaaa08f77c3d9d1f759e051540ebdddf948578fdd403b91935fe718b4232eb0e673ef3fa73aa198b1b74c4019512b8e03a089e29ee759b1aaf117009cbfa6e6805e6799d2e6d1fe39fb22e12e7cb186ee19ade4429f026fe07ccdcc0a72d4877fb5f93bc2a62608c5fc9827e1d196515c3670c75377dd2b0dc05907cc4a6381927cb487a0c3bce7c813a92fb165ffdbe6bc35d5bf2a12f2ca1d27d412cd3e3e1d8a9eac0ef6ce94ae40d82fd747c15270168e80273104d64a800115c9602efb3ebb632ac5867cac3a712ee685a9df9ad335998b88d34e9e420d3b822111ee720b23c1211ac62cbb81b4cddbefe66c3d74525a89695ed8138eb3a0e565cba9c1eb2ec5578be57fb63b9c13184132a2c8e1909fe0961ec606acc7fa71b1caa7752d8cac4200ceac46d0950c31f88697b6e69cd7f8e1a5272143b6d933c25935e6a56f24226e10a3435b16d18d01356caa8af6bb4589c7fa1af141a6a1c2634b08c00ad745eb7c4f53d0ba401114552517b1d3505825d58c460a644bbdc9d2c361f4c68717ba81d61d1804a67811d779ac030ccec908ea4e93cf79c09a30055e8c87852b033f5faa605ca4f916586b1ea62fddbd05c541fbe3068e756a9c262b9baee97eb9f5e05ae310da344f561e675bc75209e37783917a6ae71415ce28737a5192c5e43ae6bf1eaa05638705f8112807e942e7121f862a641837dfd3be4970f7bddb09348bcbb11eb52898be47b03b601ef51966dd463004f0ff6cdb5844d6b965c7bd7ef6f940777b0db015d88d272bb83dd005ae97641c5d83fe470fb762ae39b21e9ea77226d9affdc8f7bc4d2f0e202be395012e2fd8f14a50d0eb18fa68183fd115b882c2e6ddb39dbc71844eb557ea6d7dd1d7921fb79baec819eb577d06aace973565a3d463dd1f8e6cffdfe603a3b2d48a5674f344a1bc309fb3741d8d68bff049ec34ee88f8c8e003321dd2d3e15451e7bac56f8c6808e278365f56bad8612ec0dbc0e1dd4937196d7e8cb5b51edd0432952fe588cc9dbc60375f0a229eafe35a3034f2ebe6cd6b6d4387007c72e7db5595625766d8ee890c363e0c66958fd92e90f4bd9d7a7d113f17b8dbae57e664321f37670df93720412fb8d4db4990ee57b65ba2a9efc778cd8ed71155a2014c6de028eb29da048a76777bdb4b6821b844bc022678f0b90f0876269d01877afdf5055af4a1107031f1968a062b41bcc62a5101eb4a1e6e8be5075a675a6ea27cc398e992226b46bc92e7683d5cfb680ba74a2eec848fb2b84b10b733021df4663d668a7c7edd146d9b68261ba1fb25b400dedfd6f3313806f8f61a92f5507e1d30c912af2d643a3f21c81f05e1f4551385c61617f76387fc859f3cc17981cedcf5815d960c786205b34943804052e7f58b110667d59c9bcd07a4bafa750c495b0f5fb4b9f5810fa06283e5f30b332835698b259cf7e5348a814d110860116a1b9a9c11c07f5306f157cfd4cb3677d4b7088e9476361de455180fec72d5b4c094d4d62984969a4c3cec43a11e902b7bef8e9b9ac3764de6beb0e882f8f090826ba7b10bae6170ca751a459faf9984ad9858e10b040f4b88309b8f7380480cd62b88d5bb0aeddc2bca9573d7d1981c9800890dc19feb4aeac890606879f54a32be6fb9d526b03fb003886fad93f68baf50854fc163cc72840a84115ccf17f123ddf7628ea1952863feef980e9567e5cd67b17840d577c5e9984dd2bc630e4efbe45da3f2065c977ec7b2aad4f06462dc9fc8a26ca5af6cebd0a9297b2e0cabbd629a1c65b013167c062914acc4616ae2147f95919ee19aaa6f71ac435089d8087b122ab3723f0b5fe23c933af8c218126c07513212804072b144c0d9fb55bc686a346ad2fa5f1bf3c1cbbd2c71396233a16a9374fe8551906422fc1ec769a58a65ad646cb88b420c2e79af0cd36a902ede52b868385f85cf74a6f91cffbce5ad7e7ae345d2b21bd4f888255f7116198937354d76ebb910f243ebc70d0bb8e9383fab759f314d2c2fcf462fa2f3c90ca8b9ba90fb9f3ca65ca263876e80af1aea89575602c808d79c70384e8b2ce490432b3cb93cafb6b2954b9108958acd89faf8297de06ab3144b52bd3ebeaea48d54e6536ab6cc7484b2ef8430eae636b52ff5d777f71f4088a76a907222b1edfac00210ad95814b1d097fc67d3271f327f8eb7d1d3f5cb2f0e52de59ed804aa099c4b24a4b753c6a11ced457d598744f65b8b9f8f16becad43241ce1895ddb253474c7ba7378180e90f3bb5ce2a714ba728d4a1560c0a5fbaa88fb5780b7ac9b98e43504c209f6b8ba4d6ef76aea8fae625829152dc0cb806b984033d1cbd327434139a114fd6e91d56c31a3a5947264acaa92885ae8e80f2affbdd0afba3a9297952b24e66b02af58f946df8f2ea06b059659b1c76406f5a327bc6ebed58bf671b773dc00308984aaf39131db60e18dafe38567611713b6368ed8e434c2473ee38097c8316348b6d6bae859a077683d390cdc4b5766566221f33527ca8a36591003d0e4656df04925b19b5fbc4a667d659e66e3553840b5021eebcc0ad4241146cd3107714bda3c7573302d2212dc20c4b1ea7b01b4ef79d14d7b9d94b4911f84441850505665fbee4684a201b4f18bdec43532411d8c418e06842d93ca974db10926a60db23e0e33d1b8980c100d9e9ef1c3e46b72a5bff971564e4bc6b0bd6e6c9e7f79cd24d56b398238aafdf4335ea12be7a31f1bcbb96fe836e4d1495529c82479fa1c1d210e8ee411545c7da357f475890acd7103fe1b733a656ee7fe69fc15204adf724adc74609181630e5ccd5a329a62e169db7d47b4f255530d730ee8e27430a45c988bc7ae7184ecad0436c801b55790ec7dc9a4621994159999c984a15fd6e48a7f522c96a9a4ad33fbfdb25f8ae3f0e7c6bf91688ba06f4666e8e0700c3e2b0e66ccfe62eb7a5ef3ca778606ee0465cfd5e7eada6e230b71756b3ae233ce4df4bee6ce9d0e7f7bb2f00a2fdde435436568ea707790b644706dcac69fce0ffde4fd624e292786691a3b33f1fd719b5dd06e0aeae2fdf1bd95ef7c0cb78b94158722b8cf4d9adf8457c4691b99b140c23cdd31725c0b505fae2d600e7a48f39d1e0db2c97f2c5ccdceae55ab4c04260811e77066e5f7d255b5d5d86eb74d45419361a43124a82464952d3d2d22e8f25cf046943f0443b8dd7e7b49d7749075323ef668b6b2014445197dfd766a5969608fa2a527bd12f92b80747fa4b0aa80832c7ae2f11f7981c70ef82c8afa48a6ebf5e2c6d98043a5da97ef851e7eb4fa661686414b8bcd2110e3d34fc8e828ffdcf22ad0b60ae4872dbcb0b1a8bdab6e11e9001a2d57be32dc080b35596a7977fb391cc889d6bbf3ecdaa80151e746bdd296bc90af7b94124e28383a8df8ed26f0ddb12e11aadb8407c7d12e96a78789f6c82556e09e83c1c885edfb62a309d487eae7ae6efbfaf7348f8cfa438d8188e5cf88eed0abf8d38975201d6235cc57099446d3435e51a52debf8b1c1188815bdd99a25b08f137161e4b8f3ec0824ff84f4551bf84304a964fd355403d70a25f05ee9f76db5b2321a8ea82c5863c73faf4555fcd08b84ef6e84ed07fd27a442066daa651e6508b9745a5ef8f9757da771784266156e5deac5444b790686c073e92d92942a84ea731ffcf5aff9b1407fe0410968a94d0a61b9191f09a69560fa27b83c05c01b6e7c95e6ad5a1a74adcc6d367ca68af7cbad71159d326ac08949662bbd5d685956b9291ac8b570bc23189dfbf23b3f48043605fae9a4f3cd52ee21b4513c8f9efeb9944a9808396575cabc316a7da07f3a6ad4af473b75d46644c14a6eab28143e353674005a99bc1273f2483752e35054089368d89f74bfcac0d25a7954ff6ccf7ad3fce4ffbe3fa106f30ffbff9026e7168ec5fd1cb3708571a6cd8c2c02ad01190bb9f39efb2e782048e8c79185c638a5cbe4da0c68f6a76e7e375461295aa6b3c423153da90504576e1bc40783bc9711ab7f1d39daaf76f045d8b0c03a21ac54ba67e6a08b4f7f510c6c0f9be0443c821d62b1b9c86d166a8f21cf5444c5d23bde864aedd8f54b8c95b34daeaa64e2c751c69d97fbe4d484d05cb233a3038c97fc84d2d645d8ae3ae815fc7732d3a1a2af7d93ec7e2d4b2a760ca323b89363571613bef295a102a7bdf26525da5f8dd0e069839c4452f7eb292db199c7494086ab3c146da2818f23411cacab191fef80fb1dbbe0277acf995c149e9c4894bfc086cdf78cbb3df2f5a7c1e6cb30d5a4020aefe1b9c7ada1fe6d53d32840c76b4a22aa0a20dd52b0067e1bf21f0e51db492f6a62d2d3d8c1bf2591f2e3aac92f57089c6b73bab1a9fba886f44df3e965e457e8342a2e81f9ad29b86ee0c8c7420684a357cd536d786746477b40c0ea324829dfe6d959aaa0c52b7ae164d80a0d9000e51e1ee68aa274ab8e1aa8b9fc285c9c54903b4110728daa336bb111a1529158daee06d137e0ebbceaeec17d9a201c5cc451a008e050bc39961491857b36e7a1a43bcaaa51271405275180cf39bf38a98b33b936a147da852a7c6709d652d71056a7b498283d7144aecd4e53b1b71c14eb1bc3893f1210de57e9fc93fdec755cc8f720959e044fb11d074a9f036ddb66d98ee9b2bf2eaeb88d3516c4f280dfcd8d5e1eff1a12b2ee401ee2fb215927bc4d6b7495c2faee15fbf89026febb45fc5fd9cf55191390e889f4eb2e5452196f6e90fa130991873e0a5b77798d8b233a65d51eda805b68d7e76b61c922602d119b064b2430adb3f665e3ab62d7dfbdb02cfda38d586a7280f0f7f0cdb213adba624c2863db854096115ec88452165df23ac99693ecfc6e10c9a3d94696f5d3eb96f6502d3649ebca6a5a0f7d3592d1d30d95bdc069bb7b51afd5d1918b759fddc69f392ae3501de30fa63312fb670ad205393790c2251ea3ebc9c61214a40dc026727493d51cb4499a4af7e6dd9b5efdbd6e663706e6a0f6d67ad7ceee80e776b249e7d2ec8a0e05df9f158721948a3d06365f41943884ee9932dfc6831e52d80985ec9a6a744c94ec1d8c13d8bf0fb2ec18c78a210b003cc9e93871cc1a9ddf037c0f8443c5ca941277659e8b9c528e53bba0d45143a8ec26a912c9c5dad9ebe54ae21dc5efdeeb8dcca5674c905193db5aba0c22fc470d737c71cc42c4f2d988ff55ced625859f7ac870194866f61137ac83b4db8c973455891ad9226192ef10109e2f3f652fa31023ee6ddec83bc30895d9e87f912be02a2f415e04afe74cad75f7cea0e4fae39903e08ede8584eb5c53404abd7a4b65420f65221e575ade8163b62c0b05841d476fe166d04499874c39ab701bc1470831874d7a343fe9f31e3120596a2a64b438a76f422c36c5d15efab0936cedf459aea307f7d8928ef42efaeb71907d0bffe956a2428057ea5f4c9cceb43ad1d822d79a03413e90434acc323de4509902ee82bb4c22610ce3826d8e77ad396c42bb46bfb5ad6e6a3934a9aa3a5e620b8bd107f090a07bd00f29525c10c1d27f0352c3148f431621b9499b7764b15bf458c990135625d0651d13e4e27ef2c7c2e289a2aca741752de438f9962dc08170fb9e2835cc3759cd3dc8c7f8e53fc64d1af76b1e1a08f667f9d3ef2ab2794849b612562b212cdff13fae0a9e15b58e3ee4b75413a85096eb2a7ef2308161bbd51539c7c21373a3bfb6f3345e03091c897a00696391f08fe03f98fa7f3a35c6ef35c325a2718af013407a6b8cb81aaca1adfecab08cda36a05be5f9aa6d8d776e19751aada749c122d2a5d34c7cf2f7420a79a510d902642954b8fa4fed80942eca398c2a45a35abe783f0d6de0d74067a8dfe399d4cd64c0ad81849f0a677207678e0e90747c3ed265f063f0d4f950c9f86a2d24be5119c9fd2852e6bb3a43ba73fdfc2d82967d880a3d71430cd3264bc57afa89540bd27ae1c9e9fc7a892313ecf2a819d670e800f8007ac8cead169caf4cb21513dc95d31bb1cd023707e75d90e621b00641180c9176cb31b3f32bd7b22e8422af4d79988cef1bc2d84bb03eb5e863c6a5e97754427bce048dbcfe8d9b644bc722e3454c986f8976b24384fd2212f2ad18f13e096d40a5de1d1682172a5dee4ad1ab77023f826719c0e5b3352cf6ee090af1eac4d3c7102943ca8c8c0280efbde9e8540bfb103d8abebf4d3cfc7fb9d49c1a4b66e38ccac34de6688dba68856920bb6753a9cf1c83f2328e63e50f1a471899106087dd98c557e7d480afa952bdcc4626399992bd5481a85c258fab6e3ed3db0f1e8c0e4c8d929b965f9877283af3976e549296fd8e5f6f31d7eccc9037f059d6768e71f0950673861fabbc13fadaaadf699cf35072bb131ff35c7b9de0eefa0fc7d476669ab23b8ef9534d6aa5784ab0e0fcf5c3573ddd5564ce5e8a2aa42b1614b717835f845877069bb5eae680b0b06e8d29dc08710edfc73065b1f82f7cb56fa51cb16dc3c28b5dbb6768c9dbefa1f471d854e85443d95b3aedbeccb5e61b6b1f51203fd8829b5d15954ac6bce9729181cbb615a56ebecc46485b20f1e51c4a9c9ed702783cf2927bec73821ee2b27a9eb7f7ac5884b673133b95663c894329eac09c22ee712ac7497bbc3ef2483d2d2fdd848ce39a7eda3ce8b20ad0a80db75da5982a8f1c5d8dccf093a186f5a241db294503e1189f10830eaaecb5eb7179c97acfb57eea21e73238f30cd11c4c623cd8420dfcb976e94e857a893e34fa5e435825faa131c6003c8a207b23a1ea1b7388a3083e98390b1bc5c5658338f6fea0ea0f10b8872e0b3eee68675d0072aaa56d88a9b5ef5420acba0d9f6ec8328d57a74eba35dd2876121332acdaf0fee246da8c0c20294d8b35b2317a3a9a28692bd57e490c2afcc00320842025a09e94ff8f9ddf4090b433938b22afbe5c7708abcf16b73b7563a851f23e0b8d52c23241308e27fe543d2dcc8d6d7f81b54c8f0ef2ec97a8deb349ce717f6ed5a61d67fd7ff09fe6105d139e51a3c32094c76b6f0934548cba5b961be10433eeca4a270df45bd1d3d299cb44010f85527a13372561db0be1ecdd2238ce18c00cfc2e5360858c2d6643912cc6d32a812707e6820711cb17f155d956a3dd3866f63a2e52874907673eb9c1be4ad23a51d1a700f0fb7b408b9ae9affa51db5e2cb1a941e9b74ce4f635f09fc1671f26639a26c62b3ba592ca517aca5c79b94fc7652e783aec11fb49b1761927d990ff7102eb8d9b3eda00b66adc29b786e43ac810cfa9aadceb0e07f8d08ffb13c66e78bb123e551f8524d1e2aa600e312f169ff0391495b77f60ada004bb7f39717a4d88b8ab68cdb18790536bc997ecafef0c65134124f4b8bf9529c41c2bdf3d3e6467ae330852b5a88165981dfb357f0bb5ff8c66b27a76ae35455fe94d78895293ed26de08f13cad9692dea83f354c29b93da6d58a86f5b03096c00bfd87f2c40cae0c531ff0b723182b2bd1310986ba9e6ddef7a944f96078c6ad5811248383a47bbc7aa9162b800dcf59841e5b06495c39cc63d162381ed627853528faf1836facad1012ca481052df4533b630d12d7cc4e48036e5493262914745ad1fe44c3265f0e2b3a3f5aa37fc5f9ab7a47695326fa07d6d888cf5250a936297aef52b24a6acc4bb0310dccb2ccf53c0d626055271a945de640420858838f6a7f5af3902ae6dd842bcdaae445030e8f89853c07b53247d93ac31754192f3fa72d217dd387b1b1c29f8a2a25ba14470d952a3a55a022b0ebd90d3b98df8e022663f98c10e9c4ef8b7b81b256849fadcf3ae9857a4a3c7791434ee00d9fb05b6ca86918c73fa7cc329b480a2727072fc68c989d3b3a8b0ac4a7303ff3312f8244d6c8a79dad3b4ecf52c78e3f770e3d05375733e2a3bedb3bdbdc7ca2878171bde5d8f11d1f841d1e7fe02294f37d95a53d384b6ad4e6348defc261c27767b7f3cab3558edc262f3fd875a5e6d3b478e2bffb3bb3262477292e9d5b525317bcde909dd60454d5d50a03b3e86aa71beca6be6d33da0a198ae7ae924f27a04336425d71f798734da4279aa6deb9338cafc45ca65f940c38ec69c49e260334f8122f540619f01687ca1f87dbb08219903e68aab40ca64277c01262c3edfa441c809232f6314ce29aaae94505f3ca0c3bacc5af8c33e36fad39b5795fe279be7eb3e9cbc2cf8118c66359b55d5569ba5e1ccd5afdfe7d0c95cc2ba596ffed32f07069a6cf5b065c5f951578788fa47165695aa269983c82706ea3204e9ef94278035bac325490ecc64c02cbe2308ab970cc51a19ef62c50707b984e44c4b70c6721544ec9f9a67caede819eaa5539e671eba93501b0eaea95b3328deaba3e32b6cb215bdca3843df0ebd025d0609197c46c24fbc125584f99e4ef56b5d9ecfb96c30134ebef4bc8897422afd00a54ad1399d5a2ede0957bf44f033b07f4012cd46762c03861afcf986ef36313787fd753d1b3c2a7084479dc30825a14e24aea30aed44ca0f90f5fa03990817927374549c7e51d64a7f1f57aadce50a5bf000102141ca5cdbae305cbd4f187ae428f032a7510f2611a626a1b1a6be04cbcd0d66240d4c1c4c653739783a3ce8b72313c34224e28e34c6e4dd6b5c86948b0ae8b2e012d53cd6ca95bb09150487e10a9d3ca114b32366c04b409c92f94db330f089b501f9296a8b37aac9ae559a0c934740de1b93f1e5e83974f605990c357e991622a6a1b6553e02f901f914818eb86b449354bba3e11cdbf97d67f0c7e5098ad5d05b00e493b7f28b6c0e9e9c73c41b2a4872dac8b010b540ddada4e761f7269118b715479d29ae6f9f59c2187b8cc2f5bf97f9b98bdd38abe29ad7b1b4c61592cfdb5d21a0ce6426e7b066cac13b2a10bc67d803d60c13f177980d80690df442b7d5e044bf048eda741234a4637c90d71345761d136216ca764fed06a8e96572a7ef77149adb6ed9bdf15e8b016e2aa70517f5bc0a2b8331baf74c7bc21b1004aaa4a7612119f45fc91eea66637a92a13ff61ed1eaa9558cec21d25afa0455a2b10befaeb90ad1e8b29af7ad4048b39e28027743b3022fdd57e496bcbfec123466f50c718872c59c02e94d385c3af2ec04b2c65c7aec867ec993b735f50e6546363c90069eaf44c11cecda444f852032dbbfddfd48ceaf1b10f38870779b074146dcbdb5303cbd3ed8321dab51377fd08cf50ab030a968f609ea6c82e3b1500a209a56cddb9a491da99263ee573f3add876e59d520253a098c0a9950f8b86d623518c5502e1aefa2afdab25ba5b9e42cd3c94462493d5d2698baaf95b28ff0d5fbf97cee4a57bad5617322d0066e6b0507a5ff5d1ccf8fd0b63437553a2c771ef7eb113a9e388671c4b070da01586f02ec59d97d49be530dbafce5e1db41e8f2a9190d4eff880146ad5a52a915afe6d3b112d5248876bb3be03d80a6ae078d807c083f4b57302aead3cd7c808c4917533ff8f4ac9eb91fdc7b790db6fbfa29d479a5119ee7ad4c4828fe9ef7e6975ec2f76a26a19aaec36337b69a1eb44d9a0d9a7c0a287f69820800d9224f2d709701e719cda8a71c2efa6b101d210cbda34feccffe36e654c137870b9e0fe389496d7f2df1283527f776eeaf5040fdbb863ca1854aeeaa7757c7b89ca4ea3cd21c591ae921a91d353b7bb420f55ae940075b0826412fe66d3859ac3073069b1e965a0fd76eb8216afff00569354e2f18af39e4a643dd8bc759d824443163cb0330dd1f90f4b321c381fbd0710939f8e961b0d1e8fd011b06706ca0caac3d5ea0a854f4dac056b0c036e6c63b54ae6e5c8bb34b5172124f8f7d37154dc9ddd2808fb4b60f6c9225960d0f7ffd33eb3c774b8df4603504cd2d716eab55822cf21df1ae852267829c27fd67b4d23a68c06306db0b14e0cee1f8ec7dfd31907620294ddbb229edfdfc885bfc28af2f9fd634719053d6019fa4c49f3f339a748972d789dd53c1fc80d89a311d4dfc2edf8f06d9c8cf373937510d88980d446d65fa98047568862ea5f34f5f278c0f972bd93204ec0157e9dac6998080b129c9c4070a998292dff276d1c9d6c44a5a27e9df0b2c7ed4a1984deed90415cfd907ba1d54142b5fac714c1638f4071bea521730cb448269a8cf65c3dcf892d2f3a5ebdddcacd49d0f2f5a19fc62c6c24023cbf0aeac3501d1c25a12e3f247d6a57d3e25e426bc49e7af8cd3b3546e1344c4d5c4fa7e30da2f778a708703e1b458155de805b16bc9b82aec326b768950c7be1703a7a993696863b0c72d03fc55ba5d9acc63490cba79ee5f3bd50fd0a00cf3d24f2c1cf382c75e830b1a126ee93732ff6d29af988d849d0b466eb74e250519bbea92379742a0e7a3faa776a94ea38062042131eea4809b76b2104c3c76af74e2c444ebea6aa5ed3d9d7ac245fd7217dec91549b74ee57e421436a13eb4f712f4ae2fe487df83d28f3ba5ae914ca970074a1a58887b59d4bb633c416abe92ba14578361c553576e6252389e528a22e05b47b1ef30c2555893a9affb026b6133abba95c1e3c95d3a3291b7169a06fe82945ac296dd7196f85fe997f9fa4252d1d4ae24e265692d6ccb5d5c817243b9735f7a7c6f0d9212f7ddafaa4a40716884b653e7e1bd173da5c4d351c24e70780ab783b3643c9bfa7abbc946c8205b287185c1adac462be153427089f3b66d8c3d268529d284b76e16aa6fc60d235d1d8d656387395b680747e86acc9e79e08dadcd37956d3b8b49d8e7ef9d428266db8c12df6a672db45a5fc347170f0f2396d3c21d686a38cb2021e26fd1e51285a96262f05139dc2b9864734de9bc6a177db7b6a68b1584883a59aa916240b360247850f9fbb922054fe65a7c0785173c072b4a79a43f039762281503d1d02da3d260b1fc82e12f09a732e7cbf6f0df638edaa66ff26192592b71bfd0daf6042ac5e24f81b1e248d3f18ef850f8bb5a3847fca5e514d9d8d9f2caa63a8faaa83eb3ea3ffde36ef5541b8498bf643b6d00ec796b783c15ea836598da3d4ec79c3139544589829529d6964287cb374b818793228173ab8d47664d230b03299babcb137995fdd2822b2f7da1eb39bdce85170c9cc700159a40f4245310188fd07ac370cf699c092573f370e789e5d3e019c9eeb749b755632e5c24e2e808ab3fc47ff056a72072401b86856ae10b8ebaa02d4315e4a459e33226850887bdd4a2cff57ea5b34afc814c953a2a9eb70aa5da02fbd8af6cf397d82ad643a71d32eda13dcc08f8a3d0130ebe15e24063db9e50bf0da104d3c506c09606525940e0ac7c1dfc703f788fa9ff163af969b3b8f189569ec376f869bb46f176f253f6868eed45defdc5452b14bb3138af35230dbe11d7d86369f740f4b66f5fe499110096bedc988e20a28474f452d948b53fb72da86725eb3bbd7f74646fa1d285242019fca344b18612a6aa3f44ac1b5665d5817f8bcef8a8a7825a0bd5572e6b21a12daf00a91b46373ff7888893cabfe1fecb18456752eb62c782be4e28c3ac4a5594fdde22986031ddf9da0d3d0c45bc4e78eddb10e14eee9b6369ad8ff9cf86d356f736c990e9966d0d84d530fd63d6a16b7644d3074e6f85a18b183af534f822777d63d7837a26e0dcbdb6968c2b58b89adde9dd80a5a1e393352f7be379ae9dfb53b5ffa160e5a6190d331774ce0f29ba71c1e0e781c49a7c841e75c4b99149e8d8a92331be36b00d830acdd2295449e86a0ec8e9a4a594a2a7cc36d9bfb0512b223cb6d86cce2abcff9a6daec0b44709c232b17938cd1b731191f072f63d6cab29c44fe1b062161e2b99a0ebe043e79c0d74554e9e1dcffd2072fd9307ffe26e64d55f50374de6566ed36b83a91bccbaaa79877e17187a7014eea53de9fc76f98da69c3bf6e67a7e474fbb62a14637dcd7dbe8399236954731886df8d994f51cc5a8beae4d1ebf5dec34e827b622957319da1b39b7744f32015daa3ed5532a97bb28454ac3eed4bf188a56e4b0fde773373d201fd9e7c8d3ac9e1b961c2e37a1f028985b5451564417085b31778e5b787b9d69ea43b0d9e12f1a1ce55bbeae0c555ed3725c981a2461e1d4078e8604ab85218b48cc17072e698daea8a515b72d6726f783c21899beb5ff4a59f958d1ff68554edb64abda517e8ca07ac496c8a2d1b374566911303114b1cf894166104dd778ed9baadce56e66e1325d67202c0aa67654cfcfce7ff0e4879ac94a1c8a126fec941f6ae757ac7305f8b1f41bf1d90e6d871665b68dcbdf29853c492d363106f9e765baa9337686e87e06cc133439fbb26ace4e4e5d194766e7c5737e656b3baca09e06f0dfda7f5c5dd06b5c8574e8a08e810444040a6afed8e5b556ecc04edbf00e9208a9baefe5952a74f7c9b079a3b35dde2ad30a1aae5a4bfebc63b546ab9fd157b23bfd0a6bf38ad725570c4e7e9e85b3847300c0a9e00e682035f4d2ddd16a33050f5db437c6905d8e0532be9f34a13c9abb943e87102c828873e5ab45683751611481bb04a2eb4251b81433df26435aa1d7341a09e421426ce18b485ed5d4e7c75adc8a58cbc083e5a72de47777c09d10da53291b3f48119fb18be14460194d178a38866ad4633c82e693f361a0160b0d506ba94cb15390c96c848cfdab3800abab1787fa6f092649222b1c77601dbf0fd54d70f5a59fcb67b894d1feb73a57a761c42ca28a30674027882a3cc189467340c17ad54e395f7c96c0da024446ff62853916d84e4fb578399719bb0cffcd325d80a5745c8e3b55dcef006a415bc8ef7e405f480758f5d9994806ed0dd808b8db03453a13a2d166a82fe2c4f8edfa35d881567fd17e33bc75f7d505924584bc371f568464e681867c1e8599ac921c6aff59bf710a0c0e4ee3053c044e69e2a26b6aa6431761a79e225fbf09570f98592b13b474cfdf9a8f9a1cb19791fbd89717efe45142dc64bb1d2bcdd025cd72b6a17b05a67b8b2161eec3e988b5c7acb39ef7ca788ffe6ff5c4cbc7ec20843b39b49197b5be9ba003eb370d5a476933fbff64eb88b7a06b51a36a335c81ea22a09037fe1cd70e91e2817d4d8c7536fac705207324cdac952cbb116f9fcdbd16619cdeecbb0ae98311ce22284937844aad25c103d54639481b5f46ff5a9c8322958ce14c87220c08b1fd1b56f0c381449f60e67f235ab814dfe493548ae33904611eefc12b11237670f9df30a5b2eecbd601bf2ac86e62b4a4680b97522cd46537ac838c9ac03af911908331b815cade961185441a8ce7ad47746d587876164b921b024899dcd967af94dc7cd5ef3f7a6b955c0ec9207afc457f98cbed7583cd6fcb588d94f5943102bce93dbee5cdeca59d2a87d49355c53947277568f72b40df877dbb515bb568235ac8fae9a37b227f4f357123db1f7fc8e7e93c91855718dfca414452a4b21bad759d868e7a6412608560dca5593fa79c77f86aa499ab7d9d846d7ae25752c10dee776c218343ab6fd6dccf195f899126a07e9b95270eb0b82e74bea8fcd0addd9ee6d856c3489183973c507063e13bde7232ae07647c44ef810d2adb3380232890f6cb705b538ee98a227f653bef55fafc259fa2773a5b376a48b68e577b1ae1eef14221207d2cd6b7e527af6fc00a94431b9ea87285d0e7d6622a38b0ba576a837eaad41f908d8aa45176882237996279872f42e423e8be566cff9adcda1632f01f7faeb21368ab90f7b853fd06ee40fc42bb9ed2107cfbd58e171db683b452c4e6c73aef3f1ca0317bf504976edb7c3bd3c0c21b2c4f817742cfd37126a3523ee0c9d6e5cdb2074f44ae8cb458a38cfc295412a7de44cc3334a55a9b07fe7079a6454bca6e42a767faeb58d33ae4c18ab8185890aee16cf64a51253f4096f41bebf3e4cbb13f8e034ecbd904862262ef3c0a209a90b2b23912c65a55a58bdb6080115ad9b3ff29049fdbf99c68735436de568b0d3afd7ddc2151dd894d2e2cef0358a15bf0e7f235685e47f7ccada2aa1e1c85ec7b8450efae78ac05730f16dbd78c2fd798621d56076fc22dc5ba278e5118be84e391126d6150ffca0138b9e43a4f0473d465df8f6f140e80ebd33675b7ff524f2351cd07b4d4779dfd23b21a17deae56b6d9bec29dff0b3ad68e6503bbe76c856022233cd400d02b521c8ea42adc8a0141ddedc6fe55a27eb5566a211f92257fc9474bccf33882115483c889faf4bcd619523837d11c0d67d05ba323505322b9777bb9e55db38c6102251d9656035bc19f75417dd8108236e8cce99387450623f4dc6436585e390e8697aa0a8c2f942d58e3bb147a09a5daae16dbc38862541f097718fe5fa4b42b3ea11d2f9cf2f27bf7fd8d7791b5ea50b209af8724f951fcb9eea913a75447cabdfc9ab83a4cec28d64e0b6439ef2481dc0c63b37a16616b38b48b3ea11ff6d8bebe49714b9422129b4e3ed6cfc6e2fc6d48a6e465fefb2b9dda88a1750a0ec63c4017cff13cb66d0a6891e2dc93cae2b19f58d165d3806423c2612540a4b5b03d4b3314dcc96b4db8ba168455f4d109dd2f2ba5aa720278e66f5b87eaa21ef32d8822bdd10f48ee56c7a421231637d0270a7fc0f3a18fcdc3fe28c28a05d229c8d7d88c2fbb75c76c0df4823e19d016979d1748286496b4c0a457d0e3e6c603c0d12039410d8675b6644934a2615f145e68e0d32b0ed47fb6474b397905b765acc89a365d8668f8dc955f6806cd5cc053a9122e644a6c7fac504d6cea5a94a4a8be1f521ce70aaf64523ac4ef31b075ed779a941ff213a3bc61a3bd8211d2ca60d20fbac56b73350e394b7825234883f0530424f6499f87ddef469bda4ae8ddb23315e35c8e3c0379061851429108b802d4a08aa7f36b2ef1dafc82566c615868d5991391a610450c10804ad5a1e2ea25369775fb2b2468c73f01fa16b018727f4cccf2aa9980a61f2c7125a2623f4c62280ec2ef25200ec17769442eb2e9a472afe592d85e08eeb33602b7157a1a41e2359cd470d728593dea9450831090e6db94d8ccc0587e9043be8adfae0f67f9c03bd85b844df04d011123dc4e7a259c88b78f42908d3ce493f6b73ba92c36ac041e6db1509e377c708f27842a070a81ffd137320c416052f56c0360af8ea295837690fe34672b87689ef2c877027dc059e049a4f79e42d8f3376870edcbca2e65586709d777ab9873058d44aad8c5470b143bcdcd662c53694eb870c14be62988f744e6e13cf012d3dacf57e22317271999602ad156f9d437f36a2c30d3dcf1881d0715bcd48c44b8840f4e0ad6f6e584ce76e1c6266d4f6b32207bec8b4308a69d2c5ee0f640e291c077435a6109b6053c93da53bd83f99cc56bf9fcf86ecbcbef51ec8584aba4fef88b70236b0daff67d686f9001b5a05024a540619fc93a2061e1d5d599f4bc5a5287c41dd771c2ef6e69c6011b2125f1e058e869f0a1137bd77f14d0af802b857daea103946d25fa46f4be8fda35d0c82887c20a999eae108dcf7c35941443b3216c2bdbe85a7c7125e3b4aa2e0b96f7c823427e0505353859070ce12d31ae10ede90cb3f2f9b9e03047ef6b96e2713d3a608be2ab8c877d7443cd6d164e4462647f1fe2ad7298c4e81f1990f412be0576eb6a120a1aa6a7af2867f4420059a4d2e2ab44cf58f0fb6cea63a5ff57fa3c2b739c8ca45be3746f90efa568d4d9b6caf4535bfd3a2baa0a36b447ee20a8eb9c4d3d02b475f3e625ddc5b49b25baf235e2a3f018c0b995dcfcd7ea120d76ac414cddfbb7a353ba557c58ac81857e2ce502dfabf30e500deebb40250981f8b0b80e0efce263ca40cdd6b8328c81921ce8db1f2601175c604c3e312cd73d721227e846c12395e2448eac07af197287338cecea9663c5333018e4d1126f494577b475ff7741119f89a9ef936322259d55d699b3cef3e5d164827c0a5abffbb12abdb9c275dfc53f8eade430a1da217fe9cafe441d8e6a1ac9f511ea500289222ffe9dfb81da87579ea8168bcdf066b688750c012a978dd5662b41e3be97e4f38b246580c73a8ac85c7ae9a6afbf475c234f9f64e1414cffd090ec24cc65b0e26c3503c9c587026bb07e2cb9ee12dbc7fc37b8f617a075a651b7b5e447e822f48aa9a9e410a59663ef1693164bb55f984ad3225b16c3eb440d8f3d4179c486499d1e29148a9767679bc8a88653505276c605f27df16ca66b0dfcea6f3e32270abd95431fa943e91b47184cfe0e574c0cff3625afe913892f63294310010a1bb4178e209601f1ec53c9d1f6285953e29f91e1ca17f417003c3f1a0f39eae17320c2bba5746fa6aebb05b6a72cc13032dba5dbc89b0a3773259dc97df0421dcbd2bcf7d25ef655b008ef2318028b5b9a6a5047d0aa565815b0661edd1e24ca24a00c7a606bafe3c5f3699d07aa10c4e4c1f36084f25c90f4076a2e7d2efd3e78e61e9423ed5cf41dd6ed8ad9e385ca976322037ba91fb985e2f604c1767d7d68b403c4e970e41c52a7361bcf9a4ee5830e8dc01a474b44ed144b846873b7ba83f20c717298295120051e18a58ba25e95105f0a96422c54da25e1d5dc79f5fa97a3b110a319a861b953dc83de7780b87979a4ca34e76f8fe91500a1bec286cd799d011947fb1266784a3fff534b67e5288b481a6e54d5a954ccc00743bb66e20bf997fe66fcc4f7f48c74fee851da390f657e9a57f9fb1f3b6ce4231b6f052a10392f9876a6782631e8c756ea203571b8d6ed9da29254eb48739cc91fe703ea337a2df2d7fe68617497fc77dd5180c18cc86dd54cac8dc72093a16f3aa51ac53833e8e28324c67603c73e49f004106c485c8afdb72310c77d9588a9c51f6cdb3eb5d8a24f5b3318530bc607973f9931e5d6a118edd1cd72fb1cb2ca7ab105c2d5694857227ee52a11f347b0e1dbe9ad2eb34b4c60d43c2533d9bd098ba10ac5ee67a4d2a0081b2d160c5585bdd25975601affb5d5ca6d45d805dc60b8807bbe5a7a10492fddbdb95ce2fa3f49b5153c2e971890b1a5dd140aa857f5852bf224d40576458c4bc6e9691dd57fbe6658c691e474b627f14718d2a9c5977a66cf2a43c7624850e3edd9164bf254d2b273ada4cf303903ffec4980ade46d1916f7fa9e6f92df4d37c5ac8cc4e1dcea481bc9954cce42ddfa3123f7a7796b90c52a1976698680aca5208211e16ef380bfdb81e49fe181e947a0ecdabb77c761846b48ecf3eb14c16095ffdc83921cb317c2b6c73b49cd2e34d7dbd52ae6fb54c5696230d2f3706096ac4c8dbe27bb97f75713830f5b4f104d29432e7424e55d2a670ad07d80fdc6af28931053744158e5d4141895671dd4e0f41f74bbc8fb36127db8c1a20cbb1f760006a8a53c8ea96f124256348fbd61401cd1efd598c7728e48f65fae79641c28558ab01cd261c4d699c3e4031b3cc0ceac4f942c25c382bb4be4c08cabb03b980606c4694b7cf2a8fe5745d37fcde5b1bbf45f5a16afd7ddf573feb5ff2d6855ea3ed73d797ca571478bc48ffd51325a4786c0075856950a2ccafd11c4436e465d8f3bf548dd3156605d1b79b627425a37c78b417d9e7814ba4d9ce1aeec8495082ecc8d2001c1ed93d1f5257d3a7682a2ce27b20d0dd63563af75379f694923a9a359c71f857a6d9815b167f2e7e1de26e0881d6822278dbfd5b1a636060e0bac9dfee9d7fff80dfec826d11b4c17028e7a9d3b5402657b75d4568ad4c05977f4552d3fb41f51188976bd21eddd0979e19034935e5fdaa4c1de392fc3ae36c1035b79b618dbb0f662f409ab422fcef50ef710a900f50f692631296c55d16e9cdb4f74066639cf02497926136fdffa1d9c61291c6fd32f0171745de48a0646a8b2167f71dfc5f370bcd3bef13008f2d090e9e2b01a90062828e2744d9301364140ef3a529ffd8c18e30ca88afdf5292d456a20abe6cc268589a8ff791bdebc013a4ac1360920b79c2d92aca0d6d8113a9e1c8c17897590edce69e15829a5382443e9c91a5d051b22f9a9864e15d7051e8bb9d15da095d9a43f3bf9142266271000017e4a31342363fcb3faa7cbf89ffb62c152950c9198bd0bd034cbb3d7e7cdc09637ca38448ce1f17003d9eab5e986a93f5129da3c424902b176f53046ef8b070a8e7996efbaadc290750db75eca3cc3d763fc91bb286f6ef75e59e9ad0cd9a8c57e941a0efc63c16c709112111fc06e4639f9e4b00f099938042ee85d26ad72298308a45dc310fa8526d87a747075195864d14f02cfd33a8df5e653228443e9f18a1f643abb49b3a409e4bb81b876056eb087c041cac49771343a6af71aca50bce6c0fb9b74723ea3ebef2c8072683599efe14adf5a546b78b6d92a90068cf18a29fb10f349a6662dd124b497960661b3dd66382def00993449b8c946e9abadf1ad1058dbcccc542da320ab467008f46550f6ed722d94e3c99a8f6adc6ae84cc012778a5ecd23a748df4c004aebeab00c46703a08be8c18a4fff494cbfda9688a064dabc3970cdffd06927bf96c2e701cbadc42ddd1d87418db9e9671aa691d1c761b469ca264fcc8670d62d6493fca6dc6a236e88cf19e7f53a371565c4a7b05bd0febd15d0710b826874da507fc7872f7bdde403030a39213f6214ca0d7e4b4b3f93d0f6fa727c10ed3204c055de8108a4eef3edf12798f3920876b3c1f90d6d78609257838b27ed26db7c35c4553ba7b4c60e1788dcab9fdce9f26abfd0b90e601964f40ebf884fecf77d3b97e9078fa8f2a837542355b17693c1b4da925936b8e4c6e216d1f29e735bc31453c095698dc9602881fabf597290589c296d4b0ba3e5db9c5f8b69716f8af5253663987f04a6425a89a5143d07dcc165e0ef073c7c03591c25f6280564b51893c337f81db68039771a8b974bb5ee16c57d6367a2287152a5d7ffd1efe10faab7ff9dfcc3ded4c87dbef7d04aebc3a7734eaaa20518a8a46ecaefd2a174b765f36d61cf32e061074ae166b62adbca651e17d322016defc7a851fd9c8494cb3abff52cffda266c3ca942e246579f92899d022b42704f7c9d10ebc614797528e4ed988c1d4d1435505c8269dafc067afd4f86b249d2761955c821350089b1dfdee125cec28912a1c131ed617c7549ad543d3350dbb3401351b7389786713e910ce30c9fc9e32b8e0ae6d2ef2522c92c8274a1325707571c54607d881f5b038831fc643ab2c9d24c88fa17ba620c4e38f04ed0f1232affc109abc1a255c89730f78f55091a578e92e4a75891930200fa60c1ff98aca47b9a81c4340318dad9f3ec702bdd02cc08062314109e5e5147321c4b7f2a88da1e45e77de25f1def03b4b28556d91402e24e2f68a0173448e54d77d28d00ff9a2bad94a1d914976c1971e94e8870f8b024b8b2e79b2f1fe4029d8e727e73a60ae83f28eaf05f51a9f51997b713e6fe56075d81227cbdaab93d0edbf416bb5f0c12f484a0f06","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
