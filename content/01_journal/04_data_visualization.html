<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"ba30f74c87e3d00deadb2b392d28db629f594d8df49ddb75f1e8a2c3632061e8be06336999c938cc9696f539b3591c56a9ae98b5d253a904c7d3d068280143c71678dcdc21f6f8fc0d52203ae5831dac354cbb3733fd78867984ec1ddb4fef2b2aeb8550a4fa367fc134ba5fbf11c481cbeee60a5714ec97b87f3b9981e943bba9d4a68fef879375e7c14e9859c9045697e7147b19d2a78e78028964316107e4914de39bb8ceae2eaca62fbc3475b3c29709a045a08a970e2e0b2d4964ad50f4e8f74ce5ab66e399187751e930df557fcd8c9298eda946f70cf86749e40c577e470bf195438629741eec9f871e1fcac5aa9f000f36eae1429cd3fdd9559d2cd70176ef66fcb79ed4d360730b9e7fe0fb8e6defbbce0d2a0c7e3415febf09923239b809a35b15e264e9ef959232cedc57c99828639a15789c00acc7ab36209ddd4f9870c7b5c32340c725dea1940a3f16775f1893d0000d3da2e7a98f90fa63ee03dcf51cac14de71d6bd269e53558bf003aa00c1d2b5a62572816da3403b4889af57cee6950b8412fa23799dc428ccdb5d782103fee0d364be210720369b2a7b09fe4511a2fba72d18b1d6efb0ab067d7b88128f043db6dd5772b3bb28d3b6630f304ded555cb430aa270cee1c159925bd43c12a24717fd8c86b6b05cc22b2a96525c225437b9eaad1e7b027bd25ad098c3056c92c0483be83eaa44e77424e9dad0edfbfcb9c8e1a2e3a68d37843cb7208132d7ed2e2e65277db4e058e45f8cf702e0a9624dce65b35ad8d926f611e30131dc1fe236db67343aeeb704b70c4c11e5393321d09af6989c2e6a1555e84a66d01e3552a266aa8b3d779a7b45ec894caab8779d14b59d9a0c53c52877e7d5004992d36e9fa883845fe2d4a102914dbe9a44bd05d765afe8feb5811811930c82e0aafa76bbb6c0df49cf7ceec7e70e3839762633944e9b031f2dcb7db68345f379194c2ff8a8b2d16995c8f21ee8a1209f10c2abf1018d59bb037dc4e6419ea74da95d95f304f56c56d4eb708208335c498fb6c64864828e5d63654629226375223494a69bef1a426e538ec33c95be7d98721ef74abbde4a8d99222e9887dc38ba29503c544990d31f6aa643048514dde94a388670ba0bd5ff42077b7cc01e4ff57731c302c724d5ac5b80d4f0dcf1fbcdd771f0074d195bd26c41f2a82e9c4bd278588f5880aca4c8daef0a2f0f79cf408652104991bdfca95448b63b6e558723f5001a9a18f839192237453a1db15d9fa6db3bef63aae7849ef90045b2d1be29c98f1b638eaa8f2a70f57c8fd660c07b39a3098d61fbbb9540a18161a8402f4bf9d74b1e644f0d39c5f8e082d97aab234424656ac256cd25db6610e7d05d1f85094049395c20a8f649532a2268c9ac03dff780cfc9722de73d9f67ed1134964c115010ac35a197894708281c2b95ace5fdac77d2c0e019b7164d98b8fc5a33448b5a76cea6cdd4def49206751707f3737e556479658eb723254d3e7ae9760dfb451beb8239b3d3c474d7164580c58b2a6562f09243168b5d8f7ab3750c90d74e8a4cdfb7fd7c8a68546f8283e88f0da3bb7f75ce921552644c077f362d541fe12ca9ccd6944e7a2b3682b9921ac9b5c6fd35cd7cc9cac894f6168f13c0fade166fed3cadbaa0434a181ec046514151e7e18b8f8894acc04e803c61676a29bd5e6e835bc9f836eec69851a5146c832d9d572b5665718da2f9eb30acd9f00dc3479180f4fc8a4ececbccaf27383cf00b52d2edfaae4783a36ba83d00eab3c4b70110ad640d5526225e2a2a0786117ae42d9659f13c2a781366f008b3ec06704f27382c382c4e8083131c6372d29681c3bb8f349419a49908275b107a84201c58c155a44947710024986c4e17d2481fbf31f4bc587c0399bd672b7f2e078555359efc938e7be7293dea09276940ddb6f9fed44283f53e14cdb6545aba25aacc7d7ad8f64628277384faa52b4cf6e4f837c79f8ffc514fac54f43cda08737eae5c93d2a493c3ac85ac97f6ca44319c176e8cb832dd2fba57edc0d217a841af9e54d81f8155dfb7bad2adccc00331ef9f6dcaa5e33fc3eb46fa008944fa53086434d6f91fe9afd32e7d1b2cb405b5f26fc6cd4713e57ae089a6409d0848438ed3d240c7ed24803e371118fd9a390f3371c0ddc8a6c9ef6230b1ea8130a9a71846dd67d6f19b23690b7584b3866e40e838965afe679bab0ba8bc41d3363e8986619ee251ef59177c52207fff0b49c0f67b9b66c45c31b93d80cec1595cdf233fe0465a9bbba79dd1f113357498fd81bc7c43966cb4a861446fdccaea941da399908567511f30e898e219ec727b7b767e707e812a3840c08ee527662cf9950f3dfc0ffb976d0afd400ce65bd1931f3b2730eb0eb5954ae235512e81cec9ab1636d3f9d9ab5c0eadf95dd88a4a4c0150f01f7a9703d48524996a9ac9ae4a44c6b09718d81cf91161e828101b6e104dc5f8289be31bcf48016a4ea5ebd62da5043daef8f534afba2815d1b95632a1e8a98dfc01c29eee19550c16c3aecba7b6bf51449ab5f1bdce9f13329899d45a3f491d4d9c70e4f372a8747e20abaef9d903df2cbbca3eba5e76600786cad19899092d8df90c236ab0c628c249342b88f4478588527ab5e34675c9c13b3c2ccb60b83208c291384365a84a1514ff8a3aa21edfe99b2660a6d3f509b472c9f86036c88cb82fd03d974ef57bec20ce68b49bf951dfbc1a1ef3a5b5604910867ef89a7a2e57151bfb6bddcb86f70af7863044c1eca8cf7f74a3b499bfc3f373725e9df996f7e12f19792fa122795a96cfc605dc3dc4c2f4ec119ff83908255f0374b73d20865f97eae663d5821176fa4950d80459f499135a0ba548b056db118d40c795a94cbd8d7f8e076551dcf965134a9b4742cbd4f14dfcbcd72462eb7d109aa65096eba7e3f4d96136548e25cda61f89d91527a9c62cb09c45769ae2faf9fd4b31869b9ab78bbffad231b58a377d156bb0d328dbd5e344de71cc0e9823ae46f436c7045f76fee9fc3702209ae700f5fe5bd82246f45baa3e351b1efcb963da7748150180ba5bf52901a4973f246b14af2193991e2db04f6bac7bb8273130c3b1f13d785fd04ea81ed551a6622170e6baa4ab1c9c147dcc780d42c5a1d6040238977b68d9247e37f5a61c4cb05168f333a0740c32d6c51d952f6217edb0e8876b7e542555814d2ac589bcbe505213310f50b3e2d8fd0bf3c641ca4dc14e9405a57cbff9a07e7e6854c5a7421db6e8760e6333b0274cfeda3e862187bfc929cf3cc0a2ac024eb9833f8c55ac486628b269e8c65d2db4b4c8c3650ad581ab2928568a14ff4a195feac27ea32417e73bfe5f3d61a5a681868c3308d05d08417ba94e1694cf6dda6ccab5e25ad5b2ca66408ba8909c39fc1d95c063a33235766efc399cfd021ca883ec4ccad8b420f3fbf42203c6583dc40eab00cafac000b6db1269c7b922cb0f64f6ca453138cc0512d63702427a23228a8efb77f72f22156b3128c8ea692f9695e7961d5faad4271b9d0d06e71cc774ba4e3caa268f98e16a0140b5628d785cd249368b0cba8dcc6b689db52b918ad5e60e7d2e722697639d1e9224b71bbcba44dc966e6f33b82d382e5d4125ab2d8fd52f235e074fb6af7f2909a9bb98b6a877b04b35d64a621bd7fe0d727f664de2188945bfc9d49b084eae5622ed1696bd539203604be8b32522e6558aa4902a6d01ea509b96fb97a3387c8d02813928af8d79c9e95667e4ea9dd1e550a53b2bcb75f653e3f46941f0be7a2cd852e5c7dcd7ef49d2f18a164b981e57d4a8835a3f61743cbe446ef9c803a5554eae4a4650a06f90c6c80e50a18b00bf0b603fe025c9eed24afe11a32d18bac0a1d7f34c9413404cb21469d5775229c04e7065dc583b130eba2b55bc5edcbba9573d050bdcc5a91c0e841414d6ae777546cbb3e868a6d8ee980924a94cdcffaa95d12cf23c30a00dfb26f977a232f4e9cb155cd1fbd05ee372177d0e30865fd45ef6fd882bf09cfdbdccfce4658ec3f5af9ef47ebe527201de69d40b3afa0e9d01ef3955bd17e9fe04242d127cc5fdd4e011841027cf92ea26804d2be17e4cf7fce3f8be3ee9967b6b37b805fd04b0ace9bf7060baf51b0f1642be500f36d36af47689435192e58123f355a83cb1b0043126ef3007c8598450eb07360188d55e18c7651aa841be7bf9709cd35d0ed5df896fbf38a131b2193aa58594d21926e34d577aba0ea2fbd9909a208b73a3276ea32cf04af7ec77556959e02a2cc33ca2e6150e21c575c7f9fbadb59e9d5e56e4d9b231d470e6672852e47ba1b33cb28355fc3dd04ef2477a35499f2d5a7f696a168628421b9330c073d41505deb33a5b9dce7af682e2e09c66e28bd4d9523dbc9541c06402b764553ad2206ad5059b558b361ec1dff159ba863eb512dc3d5143573b9dd20b7ffff5f234c8e306165774de278928be9402c81c8e06f3333bc9070b7d37cf00782389a615bac34795c463c826c3d433ed43c408df2b79ef39e8ea373ecef135092341419260a5df55a668d06ea0768cc831d5a698de451f49c6bb579ac401541cb09cf7375f4630369a8ee7c3171ffa510d0d73a1ee1ce9775e7925169cca9661ce00ebb2df5713b596f95c072e80b17e05e1bb55840ab5f22e84d9d84405a6ede7180fe795f0ed14bf3fe10350f695742b3a98b2237287ad7255ec22889be664f99f23f461b19a65c1900039c5f6eecd95c46c8ab135aa49848e97cdd40d2655399d2572140273a3d190bfa104fbf20d2d1a20c539f4f5be2bd904935e4f30eb79edab90d16ec7808c6badb22aa9189c81ac072a4321fb079e1429f85ab0c8def808e47bbf7db3b15861ce5c1f4ab683f8525de48c3503b4d2af587b610642334f58c233272f7e1810190d5982e7ca2bb9dc530fb6e87525ec10e4f5829570d400e793501f26e1e40eca9d52845ad0305d3fb9cd60971893e252b032dd6822fc417b34a2f72c4d05ca9f3f8c572f1396a8776a697f5d881a4e426a9a1744356995312e661702d9c799220fc9b8c13d687959ffcd1948bef0307e26d098ae0343f75f6ecdf1c28bdf4ee8690d1fece7043046b1a481f58221fb468707e575b4b497967652ff7012683c724b41cbe65511670f2dc5297b0b1fa8067eb105d00e48cee82b6384556f0b311b5198092addb10fb48daf3ab85909654b0cc3bebc5d917d0015d18939487a22c859dcde9fcb3fbbf976fe7c34c41fa3bb4ea30d0bbb80d1de34c8c43f1c68b53084fa873c6a47f8f741e4b630e1dd2775bca2b4dd5a26bb6c4975f66993801b81a18bd31ec2eb464841d6b4cbd39533ff7bb10552a051ed9171e9724672cc1ecb5c0c51624f6d07eecce739520ad163443297e5024c8f508794132d1e4bb98cf138a5dc1bda8f47d5bb1a62c023ca5362122f8368c5ea0b81b69042f3456399441d370f5814b4abbe563cadc5ecd729aca9876475c0e3c66ffbc0218e24f41b61925eaac7dab7ded40195d913425bcf0e1d41f4c4b8dd4d002ca09efeb3a6482d5857f4405c8b2730f715d9d738501bf228bf4040767b44ed9ad987b655ceacf47edec94048db1b617498c8d689cebe64d4926fac2f4b6acf12e688ae7d6bab6e3edc9f65ee536358a2dacf2086193b65b65b8d54d85a81f184f3c306d5d01f18bf1a95ae186994ac10fe23070d799f0e8c0e151604ce92d291880a482c648dbc260b3814eb9573f9f26d91827bda4c021da9fb8bb4125ced5f4f6482c06d7a151fc6bdec4858f9bfeaa8e33fcbad6a75f2d0b9035104e04aef0d9500b3329d9ca0a79d60aec270f56c2d92eedf167f19fd8050b1656553eacc9c125bb1f6fe87a08ec485d73c050bbae9850352556e7167f75ea8580736ab67cafc8de381b545f08259387915b870709e1059acfa3f0f69ab45d00e722a2dd1d6c67351380af37b180bb7852edaa34825ef5a9ade4883eccb4b26f85ea234bff00ff92edcf40509b74dba0527af34106b3f15c687bf7182a3c5a066699fff2b806c1b665b47dfc11a07dd30fb4d94db0c2f2b812ba5c5ac5d3fe0b2e085b2e0cac8818e7d49cf261a34972cdc72bcaa50056304665459da30b636c05b0923faa37474f774af4edcbc18d3fefd3cad5f165cb6659fb4504b541fc35927ea9b8d2c16b8ebab28c1350f68dac3a4136f3cb11f26e343df11903c9c3af497b379d37ee34816a7c7a1986a868173748c50ca7533a68d733f3afb9112e4002aaaa1e397267db6281769738835fb0d9cc388e25d4bc274206482cfb45afa04b934d5ad0ff8f9f24e5618222b2a4748295be2218652035adc50eab9d873c0efeb27c8d31d92aeaed9d4088e6e264c07f7f1ab927c7f3d549aafbad7ac8d6d1917b0bb8a3dfc1f374cdffb942f8cf5525b4642f4805861e9492731ade9e7978b01acf0b87574c3a25ae1af3ebf92901ce789371ba232933aeec896ec5170b393a838dee2da5b0c9bedd07fbb86de614ad121df1f51f1ab476e89130e499b8cc64029da5b9c02305fd4ed8cf6870b27482586708f50d643bbf6d5eeee5b083f8ad10e9e6e8ed86cae5cb8c4f133c728e956e67378b990e0e2fe7c9476ebe0b6bf8da43f6684ca0b42c31b9f62b6f02cfb1f7f0708a8a58a6fc5bb215ad1ec6a7b565a987062937549486e70c6c730d188c8654a71145608212ecd3f3765ee8eac44776fc15ca842d55e65b6ad8d7d69e9f3e34afb1fb3338cefd672c66f1a8886f1a58729df8462ed2c71768a7c2099d288ebf491be03fe78c56e7eff240f7bcb7c17835dfb24d5c5ea228999b031378b3e1dfe95a8d2525b05aae130a5c343e9cec93843f6ea642aaccd7af7359d44ac476fae814ed49535996d3e198d3645dc1b02c8abfbaf3f36dae9c7247c62193307b6b32a806beeafc85f791a0c00a34df2a232a0fca39e10bdb6422737a8d4c186189bcd1741f9de95694ca9c6bb84405930046ea858fa344f630aa20ef3ad413d75759bd95ec8197aafb00db5c685c6031ebd752bc03a1a9919d6bfa492000b2589946e6cbe786e89d526ed271575006dc63e83a2ced5dbd01033d06bbe7498f4155e4ca2ea3e9a98e754a06d98506600a2afbac5325098667fdeb2f1d6633f220a676f2dd67b2668084d0ed9fef1d793558022c937efd5a26c7dee93b123db74b294c7384f6f672e15f91d1e6f68d15078131fd020294383b556c828cdb38b0b42a11da1e1add4674702e4060b24521817e9cd9f631271e67eb00f6d64a96a81bd78217f7dcb6f84a7a2781200855de729f12a25d5f9d8f0b3f550fa7a9931e5f52958a06be8b6dfb4d7b099be9643e512b2d9f092e26679086ebd3beae4624a8f32a1de8ad68e13ec9c4bde0d178b2190b72ed0f4093f7b8a267e75abff24535a9bd3fc7af9f56b6e8447896fd1651300bcfe8998f32e38e3e9804b67059db89aeeafc924536cec66ec7f4ef26d564827a3e631c88264fe70973afcc75b9d00570b3a5ffeea60d711a57b74f5988120888e9785fa181a0fc9eb10f225f168e1000ac1b993149ecac2bd4ce4e39c8b9728f292fa3e9166a19dbfefa259b110ed3ecabde219c2e42c48c268910e970fc1a291506986f0109ba962fd57376737ea92da9f4588e4b91a5f2877254061c509625248b739ac853bb60be22a16dcacd0d47b7e48a60409cdbc60041e7216ea9f64872d50e84c6561380b0807f5c73fc9a5e6126b1740701e5afba34e37ef1dab064ae5a4d19ba4e0702ed075476ebe485be0e332077aaa445233d62b2ef983b76383ca2897a78ef69029694ca935e4e20201605e6e618a2321b33572f6cfda79c2a61e7871c7b38de28459500c82e5de089c9832df06899bb1bd9badb92d1dbd5b8e4dc331c3babcf4e8832148979a063744b378098f7b91172d01ea1081e03951bdaee2a887acf9a016c57daf23e1834a952c812e1fb086878d872bafe4bd2e0e50239bd114b25e4102842255194500f7ade946673f0fffd1e1ac9466d4727e4997536a3393e43926ecf8feef036103c5d5d51dd6f47ec352095d688e9c156d7ab078181b078d17bb0d49297ff88748c97668c1e9b03f5ad4bf3441602363e99a9fdffa50088f2b348814ced4d07c0d86e75d7d09c893b71f0e287a5c5744254e6102d4d59487a20b1409fd37ee5aacad07a72a592e2e29078d1f1e82f994171db47e9dce0ca69c0c789b39f1548cdd0a4bc6c11bb967fd60969b626fd90ea44cfdd1e310b9e001f6fe4d36c3859460aab25d9cfd21e03486d8e7ba33b7f06585ead0a348aeacd319295d028b51e3b9d15888152630b32b38836619d5b1c885c40ce3cc2014e07e23e48bdb635794be345857ce31b6a4ce293e343cb6184fd832ab10b82f746f9e3237e92dfecc57cfee9926184e628828060cba97f9f224b3d2efed0eaa50965f4d1b63dee3baf36bdc9ef11a65ab9b68e0d5b46ef4e9158e0b0e4ffd50b16ecf4331cc142e959cff7a01510ed7990c735edfe2f47e8ac399f8ed990f2243a8c01ef1ad8a82f8b64f6dee3e2b6c94e8429ef97d2c81b6d0835358645156ba553484b9138ac6c2d12e19d3b1a485b5bc4324d7a696ce738bd930851cf3c001db64232fbb6b78e18e2e3960c7d02e6b5b6d4f38effc5e9642c2d399f455c30258d9b4fc1d616f5888c9b253cdaa7429baa304437b5c2c33a53fb76580affd26bc91d81d1534501f25f391a6aa5e6f5e5815bb857097fd240c6de6d1afa99d6842a9a872a36822edf36a008d3818aaf82a8fa13393b9fa094129d42fcddc4cee23a4cf2b309e96bcb174e0330788bc3ac4de96dc6b2a12babe68f43febf10b55d5f663dfaf3c6ad94ab9b308a3c312175707b3857b48bc4413ef0603221a9e3a40aef1d7d4199590b9fccc8c097a85692c6beaa83fc65a9ed96a1dea4424ff8ca005cea7526b26c0d504e49bbfa4e68e87b030a3eda3230656876359804e15a7ec01575e25055e8b0ce7e0af98ba01fde859293bdcd8d19a4866ad0ee64082ee19ad87ecd1ca0fad05ea821ef1ee1e90d6f135d1df4a510c75d3a5ea44e56e5c33b97180c8fe301e15b4fca13edc5a239361aefe3aed51d65163d1f7dae85c1f907bfd70447b6a53eb805f812b5b1e024693c82ae099e42242a5cd1e9ff0a5acea9797d637e95d1388f2df19b4047664dabbc1e685ce3e647bab4adb0ed0d4d94085ae769935c972ae95e2b873a298f2dbe98c795e201298555a7935b77d15c852b68fbcd335466a051d1a6cdd4d1a5eb2afdad8836a3c6168de30b66db922065d02b5a18be26961966a6a44b71eb57ecc998d59e57b472a1d0c7bc917c6e05ab6cf7fd2d700ca491d2fe1853007fccd363976f4dbcd7dbe3f1c4bd864b43bf0b23b22500560e616a6279d4dc94b030d5e5b7f4c88e8a1048596a77da765e9100ebd615ca12f78554a8cc44f7a34db8675fece87a1190ffaca1933bd090c32bce85d73c9a2339db9a85b311a7be088a0487f4abad1a8c2e89f5bc9391c2af767aa4cee3dde92fd6966f058cf17b273ffc6d1cc87e750e44bab7d027d5684133a3f17e00181a443234e67f7f5d2a2b708d09ac2bed51a1a981db75cce2bf5e8e5db2e5cbb68c50ee1e964d5199a5c75a904e89b872bfd8ad1f5a0eae82a60696b940cfdf232278fa630bcaa8c98ab78e76c3a8e8007553af161f4dc12dfeddbeeb385079467a18f690a6d352673b737c853c221532c6c9f8f80378a5a26816de653d0b0ab9e35780f8fce2c6de5c6306c04a775207077fa1dffcb0a9cb589f165e46de66ca47e700c35d61af039d2b09d880731fdd96e3dcea46e263421f4c2ee858be8683405d53bbbf9e69e57591a8bca8688fc89289a1c58704ac68ec9a99239799528bf9e2ac55f46768c70815a3681cd002578a3f3a2c42783c9a6daebfa385ec5a0f750f530432f7e346f9ebf5041f8e54bc6b1d1b7f1051681658b440a1233ef519df4cd36f1206e82e6446eafa558d05f353f55c49b8725a15e291acc930d16f085bf9376e2e2d8d9fdbeb321fb38ad45bd64f7e2ce000a63adc8c90f6f558c16d4d445aa1d6775d254e5710892b4cca0fcf71ace7d942a11f71e2f0944c993ee27c4a02e9c4b9d38215abc3de65e802b8b6237053bfc1d8b813fcf6c8809ed749b775133da90a5041c13ca68210d24a8d3a36bf5803f74496b413661ddb96a6ae63d56f650ed090a2ca9246e5056e8b350f0a0cace9183e012b96d33564c70848bcb8c8adad08bf66fa5bd6422c9630a0217167b18aeac9ca1c493cf2f86f9123942dc04244e643896936a81f630a4bb2ae7a80d5f4e8109524820c082bce94f035b88f59595219b019d739b4fb4fef8a8950152c10ac1a39976306cc9ae7ad40bf44ad55467edddd6fb286c6b1695559f20f2472c20d1b497320a452ec159f299d5849880de63e970440d9449ace124da23ada24edca427f06e3db273181f970c2e27a0b39be838af34ed9f2e618a1b6dba397cb14ea950f7c4ab00d3919dc11bd0a0e9a67535df97de4273173120f535f78e7c90aecd04dea41fa9b4e5da62912cb9f6c6f2d040ec6f646414637de37c64d8c4e25bbd814e1f5f67ed0ae250bdf596c71458b26db854ab53743ced0aadff8e671105e331c4d62f50567cca778afb376f8fd899c71a59c0e4269de4d1f3ceb641ec45417d8b689faf2993367b125a5ceee3e4823f2d3e5252775c38f4bbe95532c6beca73fe4534a5dfb1e2348e47365352bc7bbd5bf17f050016dbf83d996e8b0215b5729a09d3fe578788483bb5d03c48d4cf685aed9a357a29a71353726c120c24a1cf1f1d6ecde2013ae1fb29a31f67fc1eae8c306f549817d8eaa07c2fc4eaf4f22019d3c73d2ad24260fbad195f3550c43f850aa0811d012fb973fef409915868309386d05c64cf249e78c092959aecbc2267c81c06213ce863655c60b5b53ddbb3e92cff360daadb6d5062825797fa27facfdc0630bb7955c6d74e883e0c1dbc00b0c33c0df4be7cdffbfcf5b3084f6ff9da23efed61cac7339461b2cac63bb0868073ad8b2c38f47da4d67bff9029c87495749143ed360467db3e57b0b2f5680c8a67c031897e734081cd990830d173dcb0844abb53e99bf1f895198185e00676ec80ebe7bcfa3167eb54b5656d218ba24f4f0e733e67be01415f355b362ed8d350f9fbc6c98706fc9e640498da2be69459678229b69555c6e32cb95c449a33bafda70c402088877fe039c23bdaa5091bad663b4ac8d9c560cd1a2e384fb80f6a618279718a4024aab7ff010a06d042c85aee50f3b1bba6366f863b61fe1a2daa0b5bb650f213b7e60772e7a36b62d23e0cfe7e7432af7a75040b775087a69fe2b6c007fe762f8001d02c135a1eb9939ee45928dbdfa733cfe35db53b603a60e233cc9ede78c0590540d28d1e8283c7dc58a6703a4a422c98b8a3c6117990f3735f3f2c24c13c0334c36f9a75289eff261f5cbb1e8a46c2d239a32389bf2a619b12098bd6b704cd213f8a76f42891a60aad6f28722871b81aed3484ac5535d0d41dd648e3e7762a63676bc7294dd0d44958923303029b0f1a276c825522cd947fe30f82e9d6ca9bfd71a3e296e8233190d2ae363a5d0077ebb6e54329668f1f7976d541f1ed99096fba09986f83efecddfe8a1f05e6f192f96b5c11a78ee28aafe92d4e32d171ee464ef36e63b64a45a9ad5dc3425f3d52f275b572b690998f0ede9b11f89b5feb187f96acea5b3430a5f7f110d104f752346307f427ed213c5ff96a3dfd514f9b94309b9334931eb9129e3263a53e26bdc249907dad0386eedb65744696522e879c3df46a62d90ea1930787eb880d57c1ffaf3cc018bf0db7d22234ec292ec74a5a86f10257c647f3fbd3db8f319ab5a05a090badf74013a3ad07cf3818563c06d660eb0900b7a0d2baf7c9a254261d3e0fb2e4b50f1d9f51fdbef2368aacbe9493e8d035e18b895a0bd0175185a08b41095b7e2b528f06e5d5d2c23e2f606768ed3cf112c190b2f029a215be3da9e32399991be81f99d455609b76c94eb9fb21861835f4ddfd354f0ad67cbf6af4e5db9e13d9d02f057cf640a416702cde4294f49017277b8e2d0fd88820bb1b0d617532c3c795aef39df3953e74a7cd060b11137a879b169896cc4cbf26871ac66a87d20e8798d12d618909657cb97601200bf57f78749b65abdd5c9838e38aacd7a3a97d362721b314001f740cffac3649c93dfa090d9f69d7ae1ec53cf479d587b0bb2f8f0754e9dcf5ec01f072d457d43fb1941116cfe1f33fb20031517e6fcec4edd5123c5440f29f10ae80ff0f99c79a4906dd3c9a9593757a265fc96ee440fdf22c2c63f30b3e39a45a09cd881dbb34de5385b86e7ffd78993378eb77ca04d8dd630fa6f7de6b493b8c1515f341674e563d326b45173c108e59840b8be301a2a71601c471f7ec73db423a122034ba46c0286234d7b4d7234cc011d0d5ea8aa7eed7952357a6c17226f18f2dbb25ac5e39d52eb384b4301f2f5e47fd3aaabdb6a146226ff5d32f03565035c25b43319eae6fc94ad0df8021835ccf1cbcf03f55a1636c24044dab5611d52e56c84e5f82b2140adf58ef9b240e3a6f1bbf04991af4815543fb577d160d25808abb5266b2ddff4477966a53bfe9e1822d994a432dbdbf9bc31c2ae90f7334ccdc27ce0f2c8aa67f1cb7099a1b828f6c26436dd1722fa63a844d14c9fd58d7ed2a2ca883738b657f68f7ef6c7d5aee3819144f6aa36566f5b01770604c0b63de93c43c256af0ea388131c8bff47dddf3635d372ff9f9cab9b72bb0a6b432825ad582d2adb3cfb5b962c138e95545b7fc78d8e634809050fb442132c1636ab47425554c46fd0603986026dd6da299750131b3f139a9f1a6ac0131446823e5d150df0448b5730ef4f6a3d88f7c52439097de0f4de49cc03e2d0623ca5adaceaa94e8c721b992c5503df7b7c74e9cf37a312de3bb4d254448d50c0447ece965460b807bc29172898679437896b71a7e56dd51dc562d6b2089fced25b8eb496f602178d2d4f311bfcfa0facf47c1a8b6ecb39fd4866f70c833acc209cac3447f7c617dfd227134d64e2e937b15396cf05beba9799f04a75e2ba11873f6e1f577dd7343e51496d816cdf5b6941a0313c2da63603165f43d7a07a77460b81b28230350715b7ecb823b628f353743a4576f3817912fc20d93c4c44d760e0ca3b161557c5b999d0fe7953e968f29c095c0df33512e281b8a41793a467919187d8fa66493b6bfcc9c97bb45f4b4fb2a2d1b8ff9059c93c689a4321bddf31b8fc4b66c051cab289000a0bf44b50cd1667656bba7a2c8eb68840f9ab4d3cd0b0f9acc2943fa48d90e81450777144bd2af55d6c2d5c45028716e795a8bf729c20fb75605f68aadf87fc7c8a84a86bc5b327e52d3814519d19ebb91ca885f9cbca169eaf93688cedc2b3c5b505ad6d79055f280a4d41af7efd03b261eec0341721efee95a1c4043f7314dbbf6829a548059a6725d116afdbc0c67d695d4f122e64da740b2f68bdc32f5a42b763ec84cfb366a3ee71a166dd4d10d283fe916523b5c1e6327a798d6f715a8456e56fa4621984e5b4ed6015fe4cee676278b3b28c925623a77ed319ee462cb48b34fabe8b3f56829a75257cb6497eb8a86cc7b3183cbcbbe24f15d8c807c8d6db793ebeec450af20ab2f3b91c3f650244cbc3451d077d32d232cddfd98cdec9caf3f3846005ed19747f1723b6ebddcef0c941bfb89b26593ed2caa6d49315251b4c0e0fb99061c01d28f9193bf031691ac0dd401c4e57f7cd3953dc9a8760192b8f918b3a87fc20a47329dd01f9fd88577722c49f0a3eafd99f8bdc187c79406b66b1ef39226030959e7e8931177bc7ce418d258735c5f92f0263b9a3ded356efa57f3f5c118bb1893d84b36db8826788ef2520e7613a151795c8b95f195064af708063a01db8abd3ab64b60942c7f11e0c85d20ca40965a4c8a28a23fd25490824426b6ec05a3097563b4ee767596022eb3827a9e8a50da81b1e08531687da1a97a15a45b1d09db5d2e42c2a25cfcf6439e4814c439f7cf7ea44a12999cf974ec8e7d83f80172ae6141b3a712ab7ab6d59b8015b0b47ca438b53eea2678d0fa11ee3c225dfadf93a9fc27d63bfbf811f077d112adef533f9ea9cead01596dc73ba77ed5761827c35994a10f430c90ca30b4c5e998ff548450c68873c87b7ef7ef6ec5912b3cf25b036aad232c68384c96290d9e2e553a9e821dd6c570ffb8bb554b6a1038a8d046ac0e8884f5485de5cbcd86152e662fcd6c741b7b613c67f49697c14424ff4833828e32fcd930e4370c2b58ff3903e37b18b600169a0e059f0d246b3e8ec9eef1c424a61cb98795ec323f4984fe469b3e3ceb8ea06c9b60a31677cbd544f0b536289cd4d769f9988e096da57452b11a7ab699d7d582a8716f2abc96e2911ca09263d3fe82e16c0fdc88db60bf0815adffa7731b8d392d4f221cbb8d1ba4cda8e22b00f9d235f34f66789b837e10a3c4574f65b0d037d8f3685a6b5b63b1dfbd8f88895011b078e8ef9d865f986b962e1d1d0331d700cc0858150ce80019d191940fa9a9e0b81bd948532dd3c593afff6d82d77a20deb5a6ee5be6336d5d1f19d0a01faa85e4847b954bc9b1559640285566e04917bdd3e301ac2ebebcebe106ea14e029b3b899e1d8aea9e910893d71ac0645eb52562e723a7f15d6460747dfbe749c3b950260b02474d876907889cdc4eba7aeb72884cd1da3c5736626bc41365c6570dbb3ce7905de1567bd75ee47dde95c18a7b4ac47b151975c5c0a87fd059969c3c500897eee43dedeeba8391f2c58dc5b1e374db31f7f5d677468d73146341f975146f466e7b68cfc458433c76abad2d41884ad44263a8244575fbb549c4287059fac0d41789e6c63c36fd0c54cb3e1be742a6a2d0cb5bf441dc9a175095388340dd3d20f583aaf22300c834157fb5d1f604bfb3c97c4a825bdd8133cb2265cbefa2e8e8a8b77f12b935fb83cb978f93b4f3296584a953f176942ccce73e5fcc3db7f8c8230fd0b4738ca9d6b8950cce4b19369cd2af652963c2498ea3c4954ceb772646c82a3605e018cf7b596fd65ff874d955bd5c796abd6f104637d673d71f5d1eaae1bcf5f4d2ef3f3c2cb514d8bb3ed4b32208508793c087c57c08fcff8e00fdc46c506cdb69949d7e63186599d9af72c07d076dffec478c2fa3e30b4634a28501a782476be864340c8b45f32a54a2c1de8a6d080050b005e1654ee883ef6f681387dcf3b0090ec9096164b460d4d1ce21fdc8f2f51cb3953802d2a3a1aea9b0d0de37ef36fe3c91612e6eb431c67e01c942b1b3c3e73bcb99166d08c8062c4af9aeb4edee57a1e46d9cf9d3b62db3aba2ed1726044a324b303d92298899a020916f47eb4c6229295862f3fa539f7acf7a8a26ff8873326d38910763fa0c0268c2afff6d8634c78729ab464bf98e2a960eb5e17e075cb286900c41a2f716fe7eb8f629a6f021dcf6c2a21f6e2e71852aaebf314c7992f955e37469b9d0401fc27e984aad97837e3ff7b9e5847c7f5ce225e3f7cadc10b4c0e448783010a23ab5823f0a1fbe0511f292a06ca848f82a382eaae08484bb855d3a1d4962a642dc0adc7745b34984bfedbd49f7448782938cfa96617476dae2aa39d31ab249dabc4ba073b70552868638f21754411f0e524e738b566ba5bfca42fe7f49c5dfbfd7417b1d55a7a4f307e21c59d8cfc5e0bd0249fd487c801be7185c06a723a112d85b517f96775aea48014d3d2558672be65792dce62fc9430e45e3d988fad17ddb0c214cb1fef162df44e13127872cedfae852c9d111a451715018d10e957c20d9126bba50282542f8f060bb0ecfe03a79b5b875b15f8106daf10f60486fdca252ad154f9f238759e712850112ed859fafd1f52c04f3d67b13f43791d9b9b541c46aec6b8a6e1817daea5eb995cef1acec07da9e3c98790485ef8c2b5adb80987495b34639ba2c358fda2630ddc30d9631aa2535d1c80277cc3d9b497db09dc12ab6db5c57fd1c2d3b53facdaa3e4da715ef9605c0f89e4fe3592bfd67935c53b00e2066f2387d8b151f5c98fd9601af008adc5301c9b50516bebef4df743a739ecfc0348cd099900fff35d8999896e5f6bff159e328a455324347b483327d67fe5bb3d88db4fda4477bd830f5f3f3a6d73290692f1682c25f178666677b3a13f554e3a718b4b0feb7e160c0cd7165379cfc9ef7e387185b717dd1c6d85fcea37fce3cec58eb64834fd3680daf7c346d2d8b26a0de4e11fa07a7638101863718c847d180fa51c3995f3cc6d7b1f02d509b3dfc50584d5c0daa78e11c2ac79fb8b63ae9f9d8e453a079c150e61c44e9da9d4bf91421b4fd87574367c3acb725dba557832ca1216281e4e0b75829583730ae399f2d1dd2ef72acd5630da748f05f24bd210b45e1e99491502961c862ae30de6dfd4b3b9df773cbddc8cd71132a63e81a22a3b77748a46d6e280a6e18bcbf5cdecb4850ac36415188237cd9a170339ee67a2093633bdf45069272f6f3a3e9e87dca8a9a58faea6d20aaec023328ac7b322b26ef60579e14001b7ccf6ff07489533c45af2a26c2461626cde75a683946952e5e23db7c01541af790abb67119b24bd3997e46bd713595a5c0307e5bd10d1dfea01b02ff61abb5488e15193a4648fa8398a7556145ad2be2a7ffe60f60337358640243df0c0b0289ef3947125de72914a1598a033ba7dc8e46fc21a2a1e5442ff20e2d924f7d81e0debe9613eed6f7953856484e965fbe602386d0eae0c015cbdd79a7f1ca8034ace094314fdd1232912cda5ea49a76a1de1279e579bb3c5e9dc1456e8a4f100897975c30628ba782884a1613de666b8107c3b29d29d1133b7d1b3e345b5d4784f9d43a4e8503085045b56e12aaa3466099a5fd63e995f51fb00e6b92f8a3388a9b64c040636e98a29d6bce9ec8f0c88ffd95100d50e3391584bbcb8e439584725e05b7f3d0e408cb876180b318fac2c491a3b1052d0eb8c71b705093231fb0bbc6f8d76d3dd16801bf0848127d375e900c54a31ef7e033b87edf7810589003dd1a48b79269eecb976bb8bcf8158fe62a6fd513c56ee03afb4362d5ceb546311091afc74d1a8e0a7618bd2c6a68a949bc5bf7e06e63e871c6154d6506ea84e876eb7bae5c10bf8f03c147945ed3ae70c4398939badd0e047de560391f80fee4eec635a9a62ca1fe0819348851326baeb86d31b665cceb1bd0fdeceb7c681687ae08ddf7bc5fc1065ea08d9f281795c655d83ca2efe6c4655df85363e3c6c769f6d2543866734755cdf4b667eb8f84f0f68d3093a0168ff294bd569449f4c753df3fc79e4058fe231ba2a280f7eae91b1629d546559ffb591214a6ce43824c6cdec3e8dd44709c3a173cd074c1a03e29cd46e656643f8c4dfc01f05d9685406d65f5f336155cf33f48f7d7275f189a4c42455c7259c9f7bc0ccf3e1edb4a5c69a649a2370d9a0433210832bae4d23a31da201e1cf1188348870237a1687726089ae7fefeb871473f8b36af2080c76c850026ecfd87bb08fd0d8956f99a83af776ee56c7c912889bd905cfcacd33de1330cf7a42d79f94f37719cc572e913878e5ce6fb9c362c5bb414b474977a0014d228fed6b163ce9a3d12810808b435e40b85039b2bf1282426f8d706b93ae35a768f639f8f16d2d4dd789cb53651e9d13c728deef62bb6ddb263bd2cb174ca15071c13c4884a7d69317e3e3e1be428a0db54295caefb38985a8f7470bb8957cb683e94e744927c2ebd01f53a10a978bee5d9fcfb65f2a35db183b9d1b1c5b803e19b8d0cbd384090abe81e21d696b1b56142a28a7d592f7c95734fc87e4baef445e074121788ba3956255cc5f1441f6ef5e4c3893f9b4c5a233188901c0a4d06b507d591b94456ab686b8d8c485750035a06023499f2e9a1b1b8c14b59727eac73166caf9ff35d7d007f0065f61d3351b410de15e6ecffdfe63069a53156cba8fc4aa92837f0f5f6b1ccb79229e2f8325609d0ce1a19de1c10e8ec83a6abcd8db082e00ccf28ce1ff00db13046935fa9e92ea2ce07d462933d48d2982846f618b9341871e4b991fa4ca89c604393389a679568764cb3b6074c40dc28413c39a7d98cabc2e4329592dda072feac4dbcb54f47873f20893c33ba9d1c93269fe4a47d1e713b6a0b1e00cafd3f7b687de4201f8d096467b3b14cf5300df04ad175c6d7df54176ae4b1fecd0f0a6c4d3e7889e2ae50418c15a32f585ed2ef9de8811e1a69742fa93e222ef6d618774ba480de66aade4b0c640e16c9989c305e5fd23e2e944262b555b3102d367a0774b4751e45952db0d2bc7f0ac282effe16325284d19a9bf622730848b1e7d20e36e2cf5b7475ac52fbd3e15c636c5e9f7ee00044bba7afed85a50feb1766db374f1ce16bd2d6545cb09d55e6f7412c50de68672ba62275335db91e45f4102e5305c59829e7dfc15a2f94d7f051975a3825257623de13453d5f4156609ba52b709d48aec43c6b1c848d942c3b3ee8f6b54a7191ae80c90b05ef75e19f578f6a4805122691831597b90da5e49d60a5652b1b8b29452a6f7205e3437aee3f7ce25504e4cfc47c237baa213dceb0bcc4bb10e98a38a9870c2f45b670c4ea07a44c122f56a4cc4e63dedbda7d315e4b3776e4641b12956b308d670031694b02d800854a05af001dd3c18fac75562729bbcc1940589ff2eda37c4c80177379328e06eaaeae113cefb44cc4178d4f13c410f5ceda5bd634e978384f9896fe421d8a1d7810505f3a9ea9ecb903fae46bc1feec511b243c9d33dc74f87a1e9b2549bc1ac9deb653330a682285c8deb5b7d98734c304ec7a107836ecf437923b7a913dc5bf5119ea151f734ed87dfb5a06bf436dbfaafe0ae9a201f577d2de48bfc45ce299f6b7920c255bb7ca1855fd0f1378dfb660a491c45fcb1abba71859a64c37c20a597b8d06653269a52dca840bceff28365f44a4b9cc07a373064279caea241f65b792aaa0eefdb0a0bea81f26e3fd6e1103a4caee82d03e3410766c129ee8b920f1d643e777794096de68f3248765ed32edc024c333ce9228acb538233e74b5a6a7f0a7491305f01c8bc08b6a12ca92e9fe682d4e317023755be968b51db47320ebd41524b55e24f20c29a02098e30bb7b3b6dbe7f279f072f996dbaacd162a1493fecfcf00da61eecf62d0065c0ffe505442b553878d5f722bcd32c0cc10ccd5679d5098b464572b1df0a7d0b61c079320e68e3c4e8c7f7c9a586e621043037a696d105aa1a40af704501941f60a7497cb5f910aa67e755e3b40496047bdd3662eb75d0f64a9137e2a64606cb319eb8e287c6fc1f433c8fc81d214fd3db0e65974a09fb2a89065da9f85e1c4ab64d99a1565331ef1707e4e222556d56ce315884235f1587909c306696a2d976a6cfa6ce6b42b8d615c1e5645fa6851ab152d25874866de5b21cd7a9afbfdabb8bfd42afe681aa14c3ac97b21e3538405f30f98e1a81a171077c6f551711b8f3dbae0f5db3972e8959732316a1089b15797a95ee99c09edd3ff7063421fa02a1ec87981c3c28537ebb9ce2649410b345d4f9c67969b60a6652be20a38a957f9bee6d8266d15b4f28680b58ed7b1a0c4dfbf7094efc5a74018eb6221418428aad2053f211ed49f83560d55f98bd198e83969ad53aef66eb6497855c465bd41c297883f66c2c4a9d2a702123b7bb4ad4511e52bcad6564b0f8e8af23ba34c431ca43116c2db443d3f160894fa7f0bfa7eedd46f34c5659a407edf458de458fb19d903fbc0d294a907eee0cb4d897e47786c7df7fdd584425d1cb8464dd9fab724e982d778e49b6c3945bdd48c0701d1f16f44e40f4820434ba5a06afa8d0907de3a263ec99942ad409e0e68e733a532a4139eccfa6863646bf8bb0037aae3ccb8b8e6b4c5cc9e20effdd0c7bb92d2c004b2f2c54f53e03c023f0db67a012975bfa2c310e064f830ae79f5bf0fbd574b10716e60c217d474e309ba88886362f75a8e903b24654ad58cade2f075d14ece035cd05774cb457db0ec83d18b194ce06942acf49c9fb599e8dc434aa871e005192d0ed3c84fd0766da6a15a7814a10f6abab16ceb0fcaaa5b70c3907afc37fbb23ac6e06c46ef04befeed7d611d9c4c318a28b51d7423397405357a9e458ccbfce6320a92481c49f207ad50393aabfb5d7364463d8b0f0a786a3d294ebc099547f7f65df91c7f6911582db857df6b137babc532a375db19ba0f8bc6c1cfe482f444c26888b51215bbdddc7e584724fccb05b0f6c3b3ecb36992df623919bf30f2caf57732562625fba49c4c471572fb294acda6e7edf9307f6b35d489906acc8a7f85bf5414454be8a79cbb25918596d9aa864acb16be15b68b5b17cef3ce4a85977abeee72025f368369d3ed5e46f2faded2fd5fbd60063c02851b2c39e43c6bde8bf46b40e19c7d83f4252a4065710a428b706a5303a53ec86c575488794ba81ad8e9089cc4283aa6b4cf16a4aba983ad50cd6d597b6cb8356d21c9414d6688f5c8aa43979d6ae5c491d5dafec9880856b1adfe977c16caebcad4690212880b54e35b5ad4bd7cb44e77557e8e091742ca2841c461547d01aca0044a51d82fc7f43e16373f5e106e69bb46f3b6c9e73e2993db27795c5017c6748cc9bb47e5c9ad72a7552b00749253bbf28090981e0f6f852d94597785d312ad58c154691aaef8a49872dde887e8b9b2747b9259fe15ae1804eedaeceed9dcd652d966d9f08146b443ce0905eb1d16c5d5d0934548def06532877b4c0e2414c0d69fc4bfd31133ccaf67fcb604ed909c09283ce110beb79e487f1cee2db3d4d6763f4b02de056e448518921a94084a7e16f5319c843a007bb1c74a63985f3a718626d2302b771c473a9516b0f28f76979a511c1d718065fc3d6110c8645c35263ed533ba328d34cd0f2e8713ba74d25fdb2064cb231a103c738cfbb0f422aa149afa0030b1e8630c78e2775cef83b3d4935312691d6b4496d22b02a314113ad4225a40b87983e2c2c70206f37d8d9590305978f0a42919c8bf77380f6cf6dfa54ba9d7cd27671c7038b052629258a8f696f0a2e0ce11f03f8763350385b72189679391ddd5835d1cdfcd279b8d36990aba880ce33a59ac7a3f93b701e35622c12ced3ece1c0397fbf3c790e6dc849f50ab9d2c4530dc8c17c9f3810d0ede7c3e7206c89250728149665d7237356925d429e7db1c94fefe2ddd710275cc16638489fbac78e617dc37b52b7f3fee9c063a6161a459c3d24f1c8d872f3778ed37ebb684328096b56653821815817278f58c69b69dd04cc35115f4053bec24c6de4d6af33e8323cd39d5714ff5d2905453780c69a608427a6528894a187cf03faf1b8fb81531b4cd742b66cdd38b969b2e","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
