<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"0e12aa3ca7f34e06901e5680cfa2b2562b182d58dd5e3dd347558cd8c2de52586375735dd35f5d8f30bdc2b8790b1fd83cf37f22afca27686ffd0eafcba158bf45afdf10044e46f609c485828a6e683196a560a643c1e02e9b2796ab7e1b49af44fdd29c83b7a289090b4b7d55d218347a6086072a7486fb2e99463108a4ffad7125e87a6dcdd04ef2314b19e7d65f8113d1d92c8293a271865f0a04812fe0fb0791a31bbcd49f0a33d764faa96709ee86b4ee5a4c3424d92162382e379161cd96a73649e5975972919ae245d6f79db5ba6401368d8db57209296af63aa75c13730d09d006033f1562508bbf2c61169e3b169a2437f64f3ac91e60aea591f7293fe49b3adfeaa935cf4cfef623ce779b5ec958e9808b5ca1085576b14d9db7cde01564e0be7d74657b8014dccfc2be93bca0d1729d2f46d0e611e7f892c1c0632d6c6d166b31bfd3bcb402a85a143c0435212af8329723db3882be75b87a6dbf9f88e940493ade54224153e1635590ad24105eb75d502fc228013d028e7b463edf567c58e0c5ce0a5c370a5dd1cbe9d40eafe3145270b83a4694e8d6208864eafb49fd7f6cec6763043d3c4dad1c8ec5916450c7b3fb10e61c922be5c386e7faef50a68bd03413f4de3924822989c6e661f85061efb43eb013d2a68107d4eebd3c71974c5a218966cdc366f55ebacd9d5676716a7aa5c9793bb1f8989a4d9d66ffa735b8df33c62ce4d40056586e3df6391a01e13938b83085067780262596998fee434dbf1b59c48866e8c57469002f6cc04a6946a323f38577a52004db2c964661e3e8ba8eb0c1a4da828f5bc77b07b6a88560ac9976392108ff6a36fad9bf2820268a3602d696595be91b599a6a54eb92315652060026713b8a4aa784acda564bf14e29a93aba5408166e99ccb927bf4ee421958c33d8b5b2bed9646d008618d9a9498104d6ecc8a7384ceed1f89e8fd1a17b6e9ff9d51651ae8db0b8baa980de530715ed18f17fc3553d3b0a3c5e23b57c455cf1df766ff5999d982cf1d44c66afb6e8be2062811610b79a3bc35a2c07bc49284ecbc31e996956a1666fa5f2d7c7319f25ddc71982dac3042897280ba91e2e098cf79c7c18ad24469a3cdebc05cbc962e87be8e11e2011830c53c6f83d2a661a243acab2b16974c01d9366b957d5a50b1d96d19eddc18faa8a5050c04b587f5583d096881fb9f21a1083d096571d3beb952241db3f914bdd08813d801907ae4cad735082cfdd679aad1420bac9cc251021e925dee5214274ed783fe9a698e66b2b515fb8e1ce9b02fe81370e2d711c9eb67d6793abb66ce1f47e159cbdc1ff12ecd17c8ed0dd66287249ab94dc1a0595ddd645483d16077a163e993336c33f71e537a7ca9b520ea5b6736e6a3660cce50abc21f40c94f50b9bec69124896a197617b81c1264c7b9c9e5aca394a5e485ccfd489b6844d2a10eb3a09b9550bf3faecbcd26c482bddfd758276566b8cde6752005182a8cb3988d723c195006190ba5bf10865eeaf48096729b7fc929acbf1ee8d2737ae08dd1386794719de06d1369c1ac9ee8352ad212112a168f13904051adf77dc2bbf532bfb36fc3f0ec34eb401b57e64e2898282654338a7c3f309775d4bab9b2d0be650fff6c8953cd87fb2643520a59b622f486ab956fc19c279f477055574a5e28e7912562ff36cc0770ca310685a3b2731a7793f4939fd411375d55bea7e0c7a1f44d227ee6b27687ad6a564dcf5dc19d5a6df0de4ce06632107ce9681a9ab101cee6909efdcfdec7f58be7f6b6d1cc006db746f2964c92b4262a3a9d6fc23f261083e63ceb77c54d20a504b7210d099d9807766952ee424ac970ae24cfa5789fcd0ab760d4830ab0e01b2d1c70c09cd8ec17bf44b98f7ab50ec70d4d57a17d194f94425e05e775c51e6e13ba1734b7f9deb1b5e301bc23582c027574c543d16b7017c404a039993a31fc0bad0649b4d2bf5a72978d3a488af6619b322885734ed0f175b8f067adfaf6f474deb8d9490923f477f7186ec6ab2f4e10cf40cc93f29c476389492c1b404f78f2464050378bc10c8527640ab9189f55455eab61fb5cfcc240328e0400ae6fcf151cdbf0f713fafc2da12ac9747ddebe46c27fd0859482497185d6ef85dd968940fd6de808112bf01d13691422444700e789c7bb2f5c0f75d2a799249b0912e5a32adaa64bce6a0e653aacd7bd25b3d28b5a12bb6ca1d03e88560cfd1e074a13ebf75c6857e8bf0c0d416b055e2992b364b04bb21149b13ebacc4ac07fb74ab6b02daacda9d7f05b3dc5a53c3bcb706d07827fd8be886e4a0a2f8bd19004c169ace26a24fbaf376598ee752d723c7d047911c8464e8926974153eb90060d50c42f133d0f8e4e12aa1c1d0e98735f032e5c4ce71b0634764460a816445585671952ffc377251b2a8c698c574356e02ed29e1819e5ef876651788d5740ce854a139c38bcb23c5689e27c1257ed266773315ac86cbfea9dfc1da78e35f76f6155d7ec86217741981f558ba07ca1e2e0094a6b70cb3632c5db5dfe91e29b285f6e015c33cbf924d7c436741840d0106a7ce7ddd81e509699bf298c19e54a8c195e1e23c547d2ec6b1c424a1ac3773c6462db0065808a30cc1cfa76383a6690e66494157ac03ae37c736b394bc38ef53f76c70688fc76bf66f2365159beb69cc34896b64fcdb2b56b07ec763832beda4430b9b8525cb3ee4c5509e567ef508cf0d9aa458b73f967332ae1ee909b71ec4e045e55e2e0791265a55b5b645f07ba79af29725cc0c23c7f4ac6a13edb37f2d236de12224e31384c8c33b1089d9f4de86823f7250a9e2edc912f64d61afc2c90b43d8241e515d636521e2f53fb067cb0c478be4986256ba712a8acec3f387e4700f12d7c229e6f14f75c8353b1304975e1d0992a004d1f65978f6c886c64f06b28f062d3f52c39209f0beb87e196bb5fa12acfefa4514c4f5fa8f9f3dbae57e6ff2e6890eb62c0e8455d71121989bcc1fa56d85fed7cb70aba8870d0325503c6371b6d494ecae300484c1c93303b55d515035b32378000905829c5671760fe0095b5678699d23349b66db82504174bbb2e60e421052693529592b5c29728a2473d2b0daeac4feec6f94759bd8311bbe77ea755ea33990a851afc871c6259a2b032cfbfa9ede0a3a332582e2feaf713eb4f9b16706d97f2585342744950ced892b7353f73377c524eb6b11ea974454870c5148f66eb1277fbb6f327866f36131e031df448db2611ffe61a63fa804f2b47bb6d49975d63cf69fe34a0f386e5498c0975512c2c66db83a0e0ccfeec3e5728eebb15797509a4322007e188c6f05377bf9b2cd12040e7dd9eb37a3f51634d97d50fd3da644c5e5398131b14d2a9abc7ebbabedcf6211e8b07865e5dfad0b9ebb125ceaefa61be94f3e8f0b1ddf795852decbf89d33d9891c064c3fc149f32647e1644c28a4028c67c9151d455b7e6de1e265215add6da691c76631338f8b9d7c1dd051392964762b6aba7bf83f5a36ab9ee874d14cfec0960fe0c5a2f6878e952b21c5e80152e9a3a12566be76a1a47b2d21a446d9047b96178d8deefef8b78ae2f410b71396d2b6e53d6c42ac9c71875bd736f1e7bcb2f5f7a2c1f6bfb379dab014921d3977652d17487edef95f1236957d2842f52c130c7260572257d3c5c2ec04e69121c3d0f68bdfec190a95ea91cbe72b7fdcfe8fe29245a0dcd3bd448c9b3b5c5a32ed2fbad47ea0514a9fb40abfc6fe0998b0aabb2ff47d19023210f15a26e53075edf1d72a07bbe8145a11dced13dee3557bf90083bf6075d3d20503a3f97bb3727a9f658cb44a1c1031ee2b5692f4dd040511885db452610421ceb75a5ffd9ee72d801932ee646814ab3874fad96980318c72cc44afb53601b7e5e6f00fb93713a77f49f5cffec80452604f206c92813e5a7b3ae4314f2a28730fe4e04685bba490ae91e002265e736327a376831417a6fb9d952be652c50a6cec4f996d6dacad21b9de206fef5826e6eee44365b4484266d7f1cd8c4dd027c05c817e1f2ba8f780f63bc8aac19c8ac6eacb08c6d6b8880bbaff256285c12b1c86622bedd762965edf3c2051f4cc6588d7d6f2ca8cc592de3c8b66a6db0eb85d0684a12985d25f113045000e87b73f67aaab551ac6e9edb610626ffb960c3d05ad56f45f2199b1ef5433f7337b46c426248f430f48f98d87c6b9d0999a795b00a861eb0ad62a70a7d5a72f88f175f7d80b9980ac2aaceb87737369cd16aebc526248e92062bb1c875d7949307b2e9c940d57ce020143a52d72715276dfc09967d47f0c62910e2979add717da35273bf38061b20c3ecc76f288e51f78eea72d56b15fea290ae23e86df23463103722e778beca0ddc6c094060e83288400c78fe73caade2f06910a6565f7055a0b0cdc8d12defa07d68ab6665393670c8de01cd0986005c07a928d9fd69e6fcf3d8a436d2e70fec01d90d57c78ac86bf1f5da8364f58ae3425db4191d74f34f014399930ac43e2ed75373bf34e2ccaf186bc5a9c16ded5b4a793732cde4334608b4c6403c97bf397c65df1c973c304d576aaa90f964e6b4de0663383f3d50702e7ece4caa05a99c170b2e804cc1b71d9d14c23950b7b4c8acd49029c904eaa71f2cce323b66825b471a9f7f966b0dd600ecee66f684e33084b94f34e13c1ad7a934be43f92143479e64e4a77709809cdf6036823c2dd7c6690901f021725129e4d17cc6cf2469ffd0141e77c7d9264101ecbbd61e6a1e91df200ed1f2fed761c93f484e93c82b7d54253da45cb0e5a6c98227437afc0dd7cd6ea1591a82e51f483534ed500c4b8f58755fab87b76b1de01ffbd54b971fc038818d18363a28da75eb63d4825def84016cf69be1b900cb1b4c673888505b30a86801be4d248f982300574ab6759da72d4d39f675e01f786a9a17f80f3e7f881866305e547e24601e6907b63d59a1f92654cc282af85a1437f7bbe06493404c2a3044cf23884996eedbf6ad20d044a6529c60e86f7c08fdfb3abbabae546de9a5ccca6ec56a04643ee7d6e48c78c6b9c120e25ec8030877c1485392c04a7a57d0a3ccb232cf809bce59e6a0b2626cb2f6e2980e2e5e7a149b62f6613ef0b48ff9b3545d380c86f55d52560323340a9ff3a56df97de7cda0a326ff166339f60e275488be30bf62bcd22612f9a3ecf17c4c5e3e272057d7dafce8479f30d8b6fad888602e7c2a43b96493ce295ae73c1a4d7c5752d07f7a35889fa0d29acd029a4ca529e09290a71fa9dff58580b4ca8758a37c486afc126c30e237e1001d7eb657ea5ed2936a8675b1eb1a553a49e53acd47995a4aa67c0fb9c978737aa916c73250e06058f63145b64182ffee8602b80698afc2e3d123dac05294d52a9a849d0a51395f9678939dd83d971455acb26b63894290d33421c95fd3834f5bccd88ddfecf8ba77434ad175268dbdd0c881ff960b21d63810061c1cf268ec6d14c7fffef2eb8f80b538954a8abd01b765ab26896934e3e31940e99069465e0623ea3ef33184e12315888aa9ad255a710a18b130f4dadb92ca75c7bc9c1faaed6d362424377b0e98c173433682e605cedb5d43a75a7d45e853d1203637f6f7276e3de27b48d37645cb4286f887f086c34a1c36af39dece12c4f92feaf9d5793f7376d0f7d20d63949fd7e0de20dab26d45754f9a2e355e435791a574270e2b4a72e725bc3fd84af1e0cef577d73847f5f1d81d5f34b08881f2229bbaa0c6643c8ecdd351b6d442f40d29245328aeb52cec6f3dead3dbb56a7bdb231eac32b3a9794a86a98924084bdc2cebeb3ea4113f95c1db4530b0fb991de41a371603001d4fee4443c52912f8425683283d7df23da14007879cfb174fafa4fc07e06385bc3207775a4738f844423ac815c5b30a8f417616171d81fd56e96ae48d20304bce0d7ff4419d3ea9ad76db8065ec501b17554413bf721e6f229d742681615a534a1b7452bef6070d06cf5c3eba5f5b9db2ac80f78b1670cc037266830b72782c3677a2d743cc7a21edb2353b0e4206d8a628887e5343be178eef9f9b6fd767b54520eb403c1d2ef0e2ae82c696a1cfe4570e57d17507d8f7cb41aa8a216cc2cee076849d1d4c964ef6ffe585385af1a057c5a5bfec0a87cc2397f032265f11d0d1482e6905bc8cc1b6354d3bc8fa50b5d2e94685737aff2826b1e6bfdcd8e8b0b746aa67562f50ea25f255e67d25387a1a7cac70c55119f4c73baab9722d6b7be596f427a700926aa3a0dc0101b908329c5a9b1201aa02ed3648f2a59599f4419c10cfa83e8becbc5d03e079767a56976c814fd47d52c265a6a0c5fa97064fabb4a8a42bbfcaac51549aaffa29759a69edbc93d7cd58ee17b2d518fbe043d722a74f70c6429112fd9f257525b9482ffd5e54b88a8a7068bbec1d83fdb3b8ef96430e8348e7b8af1c380cd302d630ffa17c7cde2b1e83976f8b34da8fa962336e2692cbf9b1da4a539ec6ce426ddd3c653de521e2698f672d62d32368ff36d677d275465810ef3e9ec727fe7baeab26e890fcd83fc3b38aa00c109aa1cc7458c5aeec4f8a7ee343c77e1f5813db5b23d6b02ca4355c95a5fd59adb29f0b033ed3b5113ad3e446e211bf0756ddf2b8f83d1059cf74676434073a5a2a242ad6a947643a895102537c9e084401c03c54c898ca5981dcd8c399568e03f0da6a4176086a53d7c19ffa71c3d9ef75c829dd0ae8e4f730b78d52478515ad9e04e3aa7d7328ba7daa4ad716db6353d9286bedf41242c5f74acd7b5eaec231114b7ddaa8e6127bd241f03ba5be0fcebab6fdb026d2d0053b1ea9245da195f3a7ef10875775607693d4d0fd103138579bcca20d9283290dee65817f8854b51c7e278c2d67eed35f36be04d245769d326a4bcff035e0cb67585f68ae113e66d3554117803226f3bded2d20b7a44604e4d328f938e95a011883099e375984da3577fa32aed3bb634816cc576ad18259b37f62ba2cacb789df90fce0c45456cbcdb3d98a3d6e949b36d2b7ea95fbe78ec52156581dc320b4f19c3a3287059ea776b78ffdc4deea0f4bda1fb21e2c651a94e69ad69e5f16f1a845b15f5dd14a81b80d977832f58bc11a907a487735b518720e725abbe498761d32be505900d08c7cebb1b93f29491c315deff60c015efb547ff68df2af8dc5c6d48ee4946f93d85ae9afac1dcc6356b6b66a3948f9061de898fc710e776ab3925ee6c78dcbf23affe97e24b3c627f42144b53c0f8a5bc542d1e1698bf284ea0bcc3326bce44fd206c7ce86e9227fc56e65558a3309dc0da10130b78f78ff2eac71d6f459c8eccc5ca85ba3e4bf54ab11b5f636f9e853b0137fe939f3320f83adf092c8fb7f2d1a2f8b79228ea3dd1479b2be684e91dfa221aefce8cea68d40157679d6412d93fcbc71f4ff82358fdf96a6fb0a5e60388108a6623ff8160a0ccd42e8800c93bbd97b8865f9254c01cffed49e3cad84f3e5450b062e5d0707781513d1cd83a5e8022b7c1ac8db21bec9389514cbd86c7a9744f418a1e0da40b01f8eafb6136fbd1b0208238b45d6b9800a1b7def8826a4c5e5a9869536b698e10905242830fe6fde3272a0da3eb9ac83888a1cf3d261401f745c4d0a6d5354bd85452bd9df971ac5caf11c858b8404703db6d7c127e20d513dc23f0ea05694dfe91ec7b79f8b468c4bb723ca32f0e5f7e352919e4f346b845249236c03de31deda684dc95ebde42209472ec2b147f956501a16dab92b46f7fc798377b90b08185af778ee7dfcb56b00952325ff429503b737ff47369618408adc929b7f5a2186ae11768332bd93f15a7fafe1a95aed41b86c426c9c028f071b33c516ebe06ec8bcf12fa3da887b18171c474fc5ffe3745f7abbf4391b48113b9b2026e1c89bdfa8c1e5f0616436e77d9f12ed6c32d7b8ebedb2214904b2a277dfc5f15bd660423ea5933caebe192a591f3095dfa6f36b500236057f4e58a475749a89a08e0263512ff0c78d92a79b15110b0df5c3a3a09560aa87e5ce2f34a36550943c30bc68da167fa2d7f4f85b1dbafce98040d8c207c51ebcf4fecdd770534fa24fc8caf952904daa87cb81a9d0ffc8369acf009344059b50fce575f7f4c22353bcccd7f54545941773f7cf68698e98a89d21e3d59c5e97b66db167e93d168c57fbe4cd92b7c7b3418bb04cb293a788cadb4958c580d2a9cca73f5c8c9e108525414e3b169aa00c6a549c4e451626cc06878f7ad155920fad5c2765abd79fa5934b1f24934f8f64e968835da4df0752f5ce04e46911c22ce7d84572342defc2583d54f88681ad3716c462a4c58a25399a4e62ce87631678c9f881886f4641c2fabe8207d81f36caa816707e71d4fe2ed29a7fbb871696cd2cec60ca1f07d90562acf00bb7f5b1590be9e8c6d93fe443f01bbccee52e3a75552e092dbdffe6b7cd23894682636d847eb90c209c74ac2a7982ddeb333228dce41cde9c5e858289b05516f90ffad377136cd25ea266959538d2c2e8430c0d45e7eaf61083639522891f7c2709b6e7ac6fc934d5c9283379ccf730cab2f1fa7d49d18b6964bff06016919474c126c01f630db2282573cd7d6f23bf3c8d7355acdbc668a2e84ec47625a77c2c0afeefd4571fe8d77d842989ff1ba822025852d24be9b45cd1bb29ddcaa3507cca91d037e309d4e70ff4d56f279c98e21978a74c5c2e4f687fca3cf5f9f2b6a208108400bd6088a6f0a1282653d10a7f42831951c3b7f2facd24704d4b77e7945e56635a4d88aab0038739ddd95e93ee498b47e6a12e89841190df1e7e79b29c42f7baa8e8eb3b33c6a74a5d9d946c4a52ac1b0443b05b6f8e632858c778700e8dc95e6beb4f7b78f63de7c3c59a0f349ee62bbb1f615194e5733a8579e08b6fc09ba3644c7e2d5add9dc12f465130618dbfece70ae235ba4541ec4b709a74e0f64ac1b401cf3185302624e9e1fd052109ff20fd31df0b5a614eb22ec7d56eb316077c5e576fd4040d4996077170c944e9da0294f724f380006be30d0a1530575e91fc121a382feb3a22bf4245f1da051f5e9ec7bd6e9f1f8aa9243ab140edd5b98fbed0be98922620b0151e1c2f7950d0bfdbff92b3915c9a701bc73335078a02930aaea662ea97d7fcfd23add9ad8a9ab451308fdae963f8cf80c071d24d5223f9d5da2686deaf928834695ca0e68d85f8fb6b6a102a5d1fa504ed41ceafe9f37042a1f2a3b7159286ee129f76d27545807a2e84026f3433964db903f09baf23b9640546b56d3e964023d5ad6e654e4935ca13ecf111848c066accbf616fab161ddd77b96ba03e41157a38cd082f2c5b7ea1bfe779aa4ccac172027300765f488a9944cc48c13b1049be93daefcd51f5204101e09271d70dcc7abf4a67d926a63bc17abcaf686c18acbeb62c5ad5ff5b86d2397d5fafd24c777cc9ba775581db9ec1bcd9e971119a94caac87fb12d6c76108781f56c6c5da4b0395c76bbd9023429f9ee657b533fa808408e93b2a6756230cd8fe65cf9107389952b263cb92775ddb05a0a69c82dd90ee782ac0525eb24b7ed5151a168c2187fba988831638994f44bbe905b049a823487b5210346ca2ff3b0a37ab9328198cba3cc51c77eafc70886f75f43c72a61d6da17b8ac3b72dd3a62929d467da7f61cc797c666df68d2232870a9da7092fa8751b461f3fc8d8f8a74950b1dc8a62ad3ca084652400e670cd9a370e57effc8d9ef3c7ba9b4d7cb9eaf90f3ef0dae04730057c178b4ce7142da3688aeaca69a825e6596190a390144c45ac0d467c32bde7913c8bacd166646b9212ff10c476810b6c1413d086c9d7171348118f8ec88eb599f4d96ed6e408a45beb9b0c6673aa532a56f7391b3fd4aa7f82a222469c23d5214774d56c829eebd1aadd996ae275b45cd8bc26dc9a0c8c4c2febde60c8a6f034b0ea51ba387a45abac955d1734715dc754a63a6fdb0a0487d323b622579ca5fddd54c7a78fcd04cb25129f3f47154624ca27c13eb48095dc0ca05ece3bddcd3479f1772314bdca20a0df95284abb23e7972b437de171d3b9838f6288f8ff665726ed560add9417a1aaa6beb78ca34c624cad2f47c2504cba81cb25d8d020b8d3c6dbce04c645438e187033720dcf7ccae37f0d8f841cb58e30b904156060ad91e66e0511b122c24a25c915e0901ac26c16422289c0d8f7af49456459e59832dd4072649a39117be87d44cb5de23935c3fbd27dc6b3a15a9fbf352f259005499ee9dc095b45108779508a8322807aedc1d87f9f1005e79c87fcec03e5318a1cf66fee38f7fd2ea7f46b24b2c121408262af51bf1158b23bab98eb28df6568ef87f15f368f0a5ccc622ab731fe612b46d82567b77f2f8d08efd2b7b7df80e0ddcb02a84528ca7eee79af0bb204cfb0802b748038cba11db135844e5088f3adbd9dc34f836c2e34563d70908e33a84418d5468d5176a80dda85dc4f55015f5f0a9cda1b3e3db7814cdfaa47882d3dea9ef4df3d35da508e535e581a90499337f0d86314c0cb3689efdae630ad7d4ace146c1fbd77940c7d1aff864bd28c4073abeb1055422cafc11fc3314032fea7d27e90fda645993ef4d1cba8a530bd9b8fd4b83f8333084028026648792e0009769eb587b13afce9c5a1d7970bee86afb51d1e2d3a44e7182b51c31c366b0984c693cdbb58a3beb7a6f6ab5e91ddcc8ba58b302f539fc652e7b8a23b3ad3425ddfdf3a7e68264d2aa9948ad6118417268d7db8973a2f6e24f52ddfdb530d11290a654eb780aab88fb3319aa6fd65e1a40d9314dfce5952914582e9c3925145f51e490adcaba0ef4e5ec52aee86bf1d356921f0c998d8e46c09e9b3c433d0600da159da67bf8528ee645a97c2e10eec57eb1ab20171da6d02f4a18ef9b0c30bf343dbbcfc83fd05e0408072fc31e7525d502b57810c3442a06196878da5cbfe93c0979dbb9335f6c381e0a55bba8b7e8231c2a7efff713aecb5ba4babaf5497d00ae87293b156964a3b257fc539397b9d177f213ffab5141d7a54df0b0680159947281c2e4b2c3adfbcfe85dcb3921aaf740d5426b0f7c8e99a3513d305501b506710b78172afbafa12d8c9625011af9a527dd1c0dbe3c3d409694cf0f0224c0898339e9a2025b3f6ed17ca593fa8998e1c80939daf3856d367779c6c34a46fabd1be77dfa23a504e095dae26757732b4685c4d3aa8de0dd1fc28c47f248c609d604e406029db479e46f64287e911172956e786ca501098f7cb56d8f232e24c0bfd26d4ddcafd757442698cc3c07531f648e0b2b279f00c85cbc2e3ae6cc97c920e3e9b01606d55e6701f01028dd02a08b6e92b55d954eaad1a5de906ea0854f9728f5e31522bcd564615456c1276a0b811b71af7c8257de36922973fb73fc2f420529eaa3b2433f1d5e512ce2511a634d000165431c66ccb8fc000241fe942095b81ebee94590f7560fb9e37d03796f56555ca4ecd7f1e08aa70f865f3d28ad10fb867e1c1d4c4d747ad3b44801132ed315bb342bbb6f5675e28bfda8a6d0895b98d57785d94a3ea8dc743375bb1d3a16c8c4bb9b2b637f4fbb456db14736e8720ddf04b86d30785ab5baadeacc455dfa822dbba87f9d65894cf89b52d9e976621a920f3e8aaecc2e4116331779e4bf860afc646bd0cbb113bd61d6221084cff9a66dfbfc14b559275503738d5a91d6a308c64fc38500a41cf91ce897e7286ef458942c5840c96be94671a5e9d16d43c17af1ed269b19242cc6627650bd862cb731be0edf83fd64eadadd38d2c2d57f345e500a634f6c8263021345c040f7e4c01ddcf211f1ae50108a5d2540f3da01c3b84315d14f441f456ced959c4b682cfd38f13ee146315bf6e1cdf6858e11e47bcfe03e63da62821b4a70b1ce55522e07c4b0882891937268ba2d2bd21e5c5a084acfba1ba21c390b24de23db817fc135a9298c2c192d32e8829916e441f20c4e824488ba115f9f04787e92717c2778705e3642d79ca7269b75ea3c509215735ffa75c27a95924f8d646b3dc4f998b6d28bc7ef5adaf809741e9e5851533cfb93d7ab710a9ae4273ac69f2b4ba5a0f157641875e7928488b2a1a69373df01c9d3b1f823daf36c0b16775ac9c857bfa5d90f8e6b89cc1cb7d58fbe16c46d4f8a29b6aa24504397a3bd2d96d2a36d099d2d8252476374682d33ed87d182e61fa5ae1c9522f0fa8a829bce391c670bfb00ee262c958c775f02d9699a1746752afe765a18161c66a66efce67a7d7d767d9e26f1eb620cb659398f3006c332c1ac35cb39f2bd5415eaa1f91cad7a8b41e55e492441c2359a4692bf50d2f447ab4e72db75f90924247ae05d8dda2409f3b763b95eb6fc01aaa233b41f032ecfa70b1eebb12bc825a95d0a8a632fc7f3d3a161b326e649df6ecd3a1294e98866e26aa47518a4ad134aaa23f22e9f935e84a0f2c664ef8891cdea448bb729d8ce16529150b9a01f792e4c47db72f3a1dbb0feffabbb3678412794591a4b78f48ff7fc70e2891315ef4936c103607b8eae2c8f4523082cbcd145235d02938b7554b8b6dda0c9fd7d599aff2bba4e00cf55137a5bad774d1fc4438930ef0990ac265c065d6f95baf4f7015e09891419a3090c111426e33a40d5cf1b22af5bf2cce56903b6691961a58739a0769877894a78239a1b0f8821c3a56662490821b2764363a6db5a86fb5aad70a3a793a3b2d9d51a518c98f95a846389a76ad22171b5a15fd22a0a213a8fca0335157a13fa598f606f33a073602b6a000aada0ec49223ef11bcf1f58e59538f81da94c3467debaae2451352b205383adabfb1f285fcf21f777683e0ff66fb49560fde8d7f7182ededf10909179e6841cda02dfc163e1a1fe76ebbf65c20f28b7e3e8b38068b934c51d0c51204bbdc62d388916c0102784076ef477f8d890b028ffb896d206952543800126f5ed5d776028360102216814051b411c3106882ca9c241de36b15a9d1542400065ee60c58a5b219c32541ca2a5539219b52c3554c207d17223c14eb89b64b09acdd05a2faea131a87935a07fb858cd766aacb27de3aafade9af1833dba4d1a711f1c4a9b5b6edf3d465e54afc0ebb823ee44428d9c834f5a2b248cf11a9a333db563fab16fb71015ed1aa60783614c78712565a7045d89ccd8e6129a420299c7595be635ce170fc31ee2ddfdc079f8de232f41077676fae2385d90d5e72783a650aee7ec9c96e332db0d07e4dffc710998406f663d5ffc98ad312fad4f367022a06385827ac2b070ad3c67f3cfdb16625517026e92ae34aa619828551d187ad970da489d293f5616d761e76d900f5cd1a7e84ba17da34cbb62189dae658ffa65aa33be010c48b8f5fc50cb4fb44021e49106aae86644fa7a4c6e81053a04d9442955ba2a092aa56d8a4b7bb38e5c4aec2b86e2b513c8d6d3b68c009f4217958ed1fb979e2a2e6b8f6851c41984cf6b2d57280ebdb9fe38d1b35e3b3497845f457b405be66e181e4f90e8d7d8d9931fd326a7dbc9a5b592b28356af31012d1d0cf03bb9362c5f5df75190925a999c30b9e716feb8502362104931c287587407090f3c27c70527321eeec76d7c9b152b1447ab0fdafe9f8203230310400bb3a9dbfc099804f62925db435c42b264aed0663a2419c65e570363d1866d38c0963c304d49cd437f522afee0d635dde50ca3f94a945c133caae82fdbce36e6fc95158d3fa9c0fcd01bd2e1a60707a1c79fcce812a8cfb6a1fbe83180c0b377d671749bd24d953ae9302be5cdeab44a9b5dd9e9a6cb96a42c59a46c3085f5cbab74710bff674b4528e7007fa968c033da22f5473b8e80848378c070b8627a50ea9c5a829fa5c04499aff8b5d41e3a2289c10266fd1296302ffa42d8b23fc6eeec66c039be39a055a5baac4cb4b48f05508ae20aa3b95e27e2e777ecb86bf99c99d4965c51d2b24f1f417e21000f8e2fdce27f6484f68a63f5cfef5c98e0518d50f602fccd753ff51471fa38354dd8a802a6feec9836d20bbae6d8edc0a81096b76b034f250e0129950d71ee4f45d3a581f8f4302abb71bfb0d87377b859b371cfd6187af0322b2a326e59abcc83ddc22b881effd1473526f42167422d102f7be27f2a519d918f75fa65b40697c80eaf5cd5c4681ccfaaa9850263666fc9ee176e54ca79a474406343427dd75712b20982c1e8d6ef46def5c3b9e0b9d06e357964c43fcc9b774b073b56046760099cb83b9e9c28d89eb2f0f6785ad40b40cb015fe58273a1cd2101b18e1da27f298d17f13a46792245192990dd70dcc781c822aa69059160a4b24e6784c7ac4897ce7ea886bf548330a850f7c026b5bfb369a49959714c9fe48c938e0bdb85313fde029984ed953bf2f34107de2bd7e6f33c2513fefe7448bc75c3dee084798288443811c0b415a8f74b7c69f99820266dee39b614396fe760128754bb5724b3c354dd6332146548b0dce39e132d82bc23461901622f3dd0b8df7d122eee4c7ee2d58a18cc542665e3033648406a3a46146d7f204069f0daa0a0b4069151ae70f15236f4cadec1a02c1217940dc197710fef953569c76f8edb2f95626cea55247744f3aff5ae68d64e721ef70627f3322c2d50697385392488959f9c0bcbf58dfef971b7d5f09c3632349bba62eef8b76ea00877f3a8a1bb98d92047be3810e75054132fe44c34bed529fd89a4f999950b5f7692800de8e503cdc3a50c2acb7c85f54fe789ff044ed7a2c3971afdc84e48f7830a85f3f7e699cc7b7d76603dc1d8583c32da6b2b90813e4a67caea615381d674bf3e5c0ea501800d2c3b0cf5ef834949ee9df8cfb3029a05558d08fe7f7b9b596f5cce7b44226eb29e682d620e25b6af64d4d3aedd95216741f1f7aa0bac90f74371fea1d2a29d191779f614147270f59b47a391039e147439e13c00ec44419629b14774e836f1da819b978eba0ca8ce6f0668da32d49c5e5b9aac066aa6e1d670f50d7da6e328cddbd5d9b5f85c4febc34804411712c44d7a4be421d3de740a67e9f99978ee6db8a412156eb4e4a9a88dab11b8180067b1cbdedcfdcee9e319739a268fab2885435876967295f3617623214089e3cf68000bbcc8c5ef68bd6624d97650ad276fc08bc98d8000ee1a59edf5df897f34fc100d4338b7482236bd56b5e84595e7a6c2ffcb87314bfb7a5469a755c029f9e92cee367d20e46bb199ede95bee946b9d9b4914876fb5b00dec9f928c87a7814ec57928a5d7c08ac35e6ae457933b09570d7b8f163a79c7b6dc1ad529534249bcaa320d86ce1dac449d284ca50bf27422a8b8b8e531a0e769e9429e6a9676663eaf3c301cc33d85a4f3d9e443db012cade7cad95a84d553627f7a12d7aeb84a3cb8b191eb965dec9162f49a479720621caed9eab4dcf4f4919e455503eb084c0b51a48b92608eeb0f7141a93dd963735b7a1184981ea7b40863f1d65b5e669a049e01ec6d919b631a6066429bbdb49cdfaab8a7b3b38729fd5f443d32a61cd501872b1e109ee74dc96b5aef24957846c46edfaa09ef6f26e5a1738719df47b50015b29779f6dbd940a83596021ca2cfae86562a2cf67fbccf9b4e7c97a4401d16c0463d53263df348f34437a284cf5960d1547e7019fa738fd82ac981d2caef8533b6f56b6aa6aeb1e534c55c6d45101ba9461ee1afc53ec6704796ea8d6d97673929b5829fe4629c1dce2e225f283865645a0fc1537f67856659c580bbc8804c9ee4200a9587d3698b749b2b13444cbdf463c2c3eaf08a16b0b39c55ea74c513f6da74b56176f5525d28acae16c392d7322e45602ca018cb2e6b32b32d49fca7acf11edf333db44f53549151720452a9d8c58db842ac2063810f0470bf6d38a7bcf9196936a27bfac5b55d2a12522a2c405e4a2eb8d1bcd09961e10196911d6ccc826f3f1a88fff0bfda08ac8b215ba420a6dee39efd1b34b03ede4c5cb6889d315bea69cd8535842fd2a9d1d02c124f1a11d5c91e3fcee5402788ae0e458a14bee5ccba89655a23f3cf4b988c1f942ae197d2ce5f1884ac95134ffb276b964c6d70e97b6a950a27f489db530287ca7eb3f1c480e393c59a9dd3c3e2920a7deb77779879c7e129d39b0c41f38497e61e13b8a9c671391f90d64a6cea9cda4211563384d81e1e19050016a2c1ac83e484743494df7bf0403482fccb280cdb54b9ebfc13d5871a41c61bd77592f33014d77729c7ff63ae328749e3f4495b563d575dad8d8c3dcde9758856d54f38f98d26cfd1f16a3b43d4a95370a54d224ecd144409ffd734b4798711e87c254aa7cbb2ceeca224f3284217988696c8916366483baf44aaa783f3b950c3c454ba40243e5f0c89d2c04843caae0ffbb0196e34bee36cdf9a3bcd6c1c338fb1636a733d8ffe57c98bd3840e7a23453fd451cc6893efb8b4fe129b533eee02d884825066d9fe08d5dc57c743da89f0d55a9e529ccdff95f5724cbf3d92ea860e166156eb83a5030ae6a2693ae930ced301b6d82c94608042574e1f1b30a238325823417a3a39d70712405dc616b08c14dd508a294a451cf3b0eb4f57ba0525ee58e7fddad5e37a0df90bf7ddd4c19541f8d344ecbeda5540ca7535424c19fdde253b52a47e93cd85ebb9ccf8999080930b1ca9f2d23a7681f1e42ae677a9979ad6a1f635b4356c366e752166eb0c67a758e38c0d6a38348939c183acc64b18a220045cd7061f0feeb50cd5f7327920c4fc688ec7f1c36be52e62edcd94c2daa341380ad9d98d8a255ae1480bff81e13f023b7660396ae88400af559f8331b7a52af4520ffdf16306cc522df99945742b1dba5aedadbf333e7a577b7a2d614b5118cb959feeb5fae0fae55eb93158b43b73e7a16aef87d23750126a5374b9e7c21e6a24597d388b69f1ec3eebda834e03f289a652c865a49ac3db0bcfeb90a4b0b0cb7ecc4a066199fcb8acd5347804a6164ada1d9a425df541e6d2206efca0f2cdcd83e3ca9f6a343b5754d408a8c86f0d948d7a9a656998ca252a58470a6e10c6dacba04b3ffab5af2cacedd21c2eed6ab1b054af670bc16e948cbeb57b03390bf4120663ead5af5f6ca85827b708a3f8409d7dee31d38e3bf3587ede6ed1400656e73f42fdb2492c31e1ab8d114c90f5f977d740344ac646bbc73de900aba92af63e33df1cf112a54265ffe392e83194f3df3ca9dc88d55be5de57f42b2baacb5505f379c5fda5a82e5f04ecae9d1c4d3a5b03ca145cbdc61fad98c16491ffd32abfc5bc7e5c1919738325debaf364864451597abe8597e45086fe77ab92bfc78b844b78bbbbe249817178d69b09e83f7d3c1eb08d46df28230e5200945b39b1101190fc426e58e4441e1892ef1bf5a1834890c2eb20c4f7a55418aa4f109871ec52ccc5bd1a7bf5c241d44c26cc0ab961bdfba8f9d40b06335254049ca5b02ae2ae4dccf2ad5307363dc730ba1dda735993d0008113c1f50769fae142def57a5f2fc515dc81562654abc54916be5fd77ba86f0e7a562c2e2e61c94320a3098eedfdd899974846138731c533cd5530888df05c5f3e2ee831c747491c56ed03aae945e77f12079a58f58007fd5625409dc51835970d07e8bbcca8e9fdf84413f6a1bd178c9b0c595ca9bbf7e6f52c5b0afb93636e34db95c68a5bf8b5a7675f901d28be1ec9cded9c3d9412e94a8a02b2a1df21666aaf0cb989e788bce73885059866467c6f58235f663e5125ed40f0c73ab90a91b535a6a20ba03c3baab84e87d2d5221078bd922b136e3ba54d84c12c6481ff495b27c25da3a1d48ec72ada0af4c4377579451ab299488eb11104c210950c1a5c395df7b393a91251b2d78b54cbbf7a7d7f8f0bb79c854995329ca1995465987de2ea3e7474ef1dd2b88cfe3c925c970f3cf5e84bd0ad9adb94bf09851249352d022ad8f871dd57fb2f164199be707687c7887cc36baa520640875d3047cb386d91f2dff8eb4aea9a3c92b36f6a354327879b09d81090811d6e9ac9a121a3e0d111aa68c16d10b43e8bc9f62f7dc95f64a92c35fbee4046f1220383c17dbec988ffbc635c3f8d2c237212a065114be9f25fa72242b9fe3bc9e29237d8747174dc0aca118bbbbe3f71ce37f02c4291481e300a66553d4c818c978afd545f1cfc05a67f47f094d87fd7c744410a52c644fdd2f4995ceb1e52165ecd429a84a20ddbc415e5f027d8575ce043c43addbc2c849cab2ed3ebb913b2af68d5d3a400411c655cdcc50c93c26012976329e5bfe8a1fd3421e9b3cab8396cf8898d0b17759184b45f0a89032bbeacb43aff8e6eece37f5f0418b1c339fa2d67f1f43952569d5d11bf27f925bcfcb6e60d5317629314e0dac5eb90333a1bb21b6075a796017734381e61890fc56cc733c283418f6a9b7fc57c510f677725836763e026441b76f081eade1e417de59eb5cbe2b2927e8f048f5d79968c6d3bc3e3fb3d5aeb4b358dec3f580fbaff3b00e8f56d0329849330ea8938a3a7272d718d88deb2ecc530847b0e6b205b3dc16099fda5c9093cbad2f4cc6a12620845ca68f3b29596f9258e712872572a6bb6c166d7a498661dc060d14af7b54b830c4468a28d1061cb72bbd1954cff062754d4f4bec78334a65659966d23e7ef608b0ed487172063d660692a5cdf095392f208380272649532e22b001455d1040475c315da625707c0512934ca4d42c60cec180b298975d22a49fc1f175f2f0192492950f2615091a6cc1ad1874f9ee288341e9ea0c7b2b3186286c288b423513c100f8ce602db6a63f401ebf46e43bef4fc9947f0615948b61bd8041cb4faeffa8fcb98d584dc072b4f5edb7f412589bde5d46f7e78b7c8dab2b5b8d7e13143691682919b895f9eba1a6c2783853785331d053b07ece95710a87f1d131519e0a2b2f287e784a614604ea10713775036522c427a4f6e28605615ad1e56977bb6d49c24ae625f29517c3e6d1479e3d644a8d9dc7ee979c5893497375514084dec0f46fec87d26ede7290d19d86f9910169946a64c0718848aff3e8cd41cf1c6876a50158c4161a166c23c8314342ae0aad95652066c19299a167325c4e6cdc7061c82e1a0cfa612d4b1bfca8a7926f28fa20d5c9152e1419cac0e3334defeda7ec8ba7f802f801aba68cd116d03949147484f19b7fe14c91d7893ba26f2fcc69dfaa5bf6287a3e42940809df5b07cf4f4fafb7489dbf984a0dd498f69b77e1f8a35932240d6ffef6f70deddbd970a12bce099e9e6acfb263782ba7db1dbc76857c08f6744b95e3b7fe8722a46400ca6b55b754d5279b748be67fc5bb7f7488b6a66e1933559d5f9730f5c44b10a9d787f39a8be25072dcbe5fd2f1ff589f5e8cfb0c392052205892035ae746ef959baad7a83face0e4bf93d195a19906967f007108f877bb4ae1ad7a07a7b36838b58ee5b05ef3c87d0f9d04ac7f9a2d0d4d8b91b7e99e3467fa2968c3b1d70fdfdcf562c7fbd0c864dd828d69e0ac2d451121989da5b27a4037a5efc1a8fa9624f31c92885ad8aaa592574eed92e1acede05d135cb62f983e2cc9e1cb48e13c258fa8ed67f1928c146dabaef3dc85b1ca2ed3b2da35709843cda76f74a91892ee057441be4172c05e140da415c54a4d7f25db3488d4580acd7c8556425be24bd5c8d9e570212aa97808edc45b5ffc76659b969e5166c9d6555131d84cc90cae2a28ebe6e92e9dd30b42747d4a2f4a7265527613bd54eaf67bed46f30125139ec45ef5394411444a7a79fedccb80c92e89a3a0468402348f48f100049366ed67e1df0c3caff99cb95359900308ce175d006782ffb764633a1f8c290bc9ac7fcc412d944088abdc49db0fe41ecd091234c904d6e152742f832cfba346fde749bd6115badfcc569133127b9d40979deeae43e9daa79ee206946a55c5f67e9cf719c712574bd68542eec94322f08ab894c2afca7ef91b5aed673ff5c6dac55c604f5eb8b0ee07a0dd960dcb69a1c45ca47c2c92d1166347abbbcb9fe29897addd57e3294bd5702c0455bffdc131cddc0535e79d25fcf724b66bec2e73d35716e14258423c592cef818c53a2664d026cba9a9f419038a8c8cb19e2d01fe370c2a896cdf4cf7598966127638e05dcaa31b0a45de7c38019ec2cc54855212af24fcbdaebca15075869d66a45fe974d84351dac0b91fd2c40cf058cec8669efa4f6b4fcc472209aa7e33c9e65c7777d39475af5d5e7d4789788cc372d4196f4076dc2d8588ffa1e97e7268cfbcbb6b32b62145ad943661949653cb4e56858b589c7934ff78d0a1512e229f3481bce07ad23dba0a62bfcbebe772f2adc5f4c1f200a22414b0a945ca2349acd4e6b69467f3dc1335c49de31d94c26b6d0d78b3cfe62ea49dccbeeb4287779785e996441b971cae1029f5abf4ba4b4cc6ea0d2bc7b57efd06bc6826ba93c0dfee46b9c4664acc81ebb6ed1bc273fcbc4b37b8d639bb6643f28cb3c8ed736360b44406271f4e606cff01bfea5cdc51303bb64de8b2d10081319ab982f17dd41b32a038694488e6dce6b3e74f9abd08ddbb51d3e8c04ff72157d70e747192e5f743abcb4392dbbbba2bc0efb9d11e2d00c27c74ef57497959c038869ffee90ce309ab2cbbf93d60fd0e3caf00de79d81efbecda6347526df02a21b9232854f8b4b229e0269cf9c4fe669179bb59c224eaa597560bd9ad0c9f9f1bcc4738d25b509e6ea0a87371292f047d86f0834812c0b3b525a800e4d8fe1002a3b7fb0b1e000cb8a818a3508860b5667c6ef1a46b0a9d453c03e3202b0fb51d74ef512cf62796f05fad6cf3e310fbb3198b6b4ded1a587fe6ab547db0beccedd50c55b352b7a453a16116902a2e6a85c127746689a5d5246c8f27350b462d783471c7ae197ae694677e6eeb3cd3c4a240a3d0ba67aa07cea49247a76bc5d0695e0aaf4c3977ad4154f04a13c33c1efebc8f4834efb4e63ffd6be2fff68aaea22adcdef780d89da45d519646f8191bd66a54318499a379731ca957c0068e8e02d5d2ed16a7f4abc3c40a80d05130870a67cbd75373835e7aa4b48beac2968df01bdbce28800b39916afe0921e024a521868a8ac68c79882ab8df9eb0f96cce5ffc8b2193bc286874d82a5f15cdd23ac25f5526cb664f2fbe85069b5ab8734bc55e71bc491ea02e4b9e48c3759e18df807a6cf296334cc6369213f3c8b1467460f839e8192a9b286d32428f46d2be61bc35edde7905670e4139c2a28f704819ee882f6df19235026fba55b9ed1b49e8d94cefb0aa349d4a0d73552f4d792e56fdda1654aec748baad9e94f92a64a97e357326df321eaa1b82d60bb2bc02f27dbccfc20225324a09e7763dfb09fff9ad883a0e0d936a6b3ca3f0edd30c22dea1c01b38855819749705249e380eaa20c53d8b64128687ed7c0100c5132f8f304170a64d11f1a3e9a6bd696e1108caa81c596823e47a20553ec2ddd61ba9c48e47f90164349174e6139c4f8d00dfe383","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
