<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"238df015a88851eec538ca6274df16e810eb485b2981e52caa35911bdb25b33e464415861af7c63c4eadfe594dd26322e3fca2c5d747a40b180bd18b8148266c63be629f5044fcac21e460fc733ae6975e4053bc5087d852f636d2bfe27f9e58e59c75366b0c659942de3a8549af1d59b402343a952d6027f5e024a7f613d3abc548bffa982cfa9f61a59fc07c44f587fcf46350503c2906ce06b45e74f0b2ea3940e85cc9308c75b02efb750c7cd946e2e435e92cf2a533522bede9bb6e541d4638e8e2a6829354cddd655b45aa41f5796fd5b26b466d419d1cb18c719356caa97bb0b0fbb7e48815ea113569a0755f53e07e035d6edd77ecb2dca6138ef29abe8c79be679dd2e61cacb9f76e9c2faff6afe466a66124ef934df5a0ec668cf4f9d682926381642161d700e396ffdbdddcf452a6efd32b1d20e29fc7722ad0a1af1643aa41f1301dd64922fcf666a31ee494e2e7296b3156caf8dc70a29864d09925d7495687df1429081850fe7d1746c7576eed5fc86175155b280c2b64a1bc4ac6bfeb47d3187a35878ebff5b6d30604d58ed426d80196d4ce13bd3e0209f49e792fc8f511d48e80bdbb4a61d55681e90793abaeb7a8f0fa7c9233e665426b6d4573c815b8496ef7527fedb5ef9c71001beaefed99da679c9dcba96880774f4018b97c1015fedc9ee6862106a85c32e4b20e6c8c53217a6599d16306a960d06ec143c1fbaeb0b3cee216980be7c641fbac3cb661c1bce88247534edc4edb4b2db8b3302ba9553028421562670f5b8997a3997b694aaea7a9e3e6e1bbc9cde1c5f2f95e183986c5f80e5551d23d2243b96a295b5471646b933f8b4bcc6d61d920fd852da82836c05523d9a5e44ebc89bfa7ccbd1cb81b6f93f492ea65722bcb1c56640147437e0e73fd2cda97e7ae2e2f866ddeb62780894d31559a5796b2f5e57a8b17a4e82df4899d10773c55e48a00a53d51c01ff7b579286f568bf1ffdaf89d242f9ef90ef38f2f881e21bec0d758d61e5763497ab3e07afc08e562fa9a38e7ee1360a0cf7b80463949e868124ec7186875edb404cbb26e1a84626b10491a48b2eee745ab9ab9493f90ce2caaf96798280bea8fc33397b114b55361d270f4519911448e32107aafdb99600c384f90ba852c7f4420a046b8af520667b481b18be27758ea2c4cb0c9ffeaa78d3ad946de274304d806d7c378ce562f41f415e0526021d8d4c338b9d60077cc3f6e9ca02b528c832fc1eb1b622e173962e02445a3cda2a9b1361983459f1bcb0d9108cd1dbfc4ada8443179ee7ba7b08f8cfd906a7a492025b05649862a1c98b89ae6a17eac62e23eb8716576653ab986eea769e8de4942b13b4e9b416d1d7f978cca5a73612680fa907f8b7234fc47b39a5b29175d91e24690e7185807f3b2aee97f7fc21782e5ce13b97cb2aba6690824407300cf16912c91b03afb8e78462f84d2142dcc109cbd8d474939bbd2cf51ecf5165f61499f4b4b76ad3939be01d16b2fdd7e76824a001eec901e94e36fe7ddd0a2e7c85d2a873b24102518f4c92c838f99946b28320160cdd1cfc4f36c66d05db9e708eabb16affea3bdfe4a6d9ec97b3c3eddc90caa8fbcb3500b8095bb6a8262d0823b947ccef84d8ead82a8691ed0cf9b8f2ac7de25fd725d63a357274ece795848f0db66f8758dd418e338d8b5dbf795879f5843bcc62da349dbfce17ce01650650950fd0933867285b4dd59b743828a584af602a9fa49440e1fb52935b7a003448725642d258b1ffd7740d36c83e790a726a8a29b457b7a512edc21c44515ad3c183e56bd7425c290dd0786bb26d2139c6ca82f4959e0bf754ad4f36a39ac057362ed74a8292f200f3164e57742675d2956fced92e63f394659e0652a3e00dec4cc9aabc249032cc9b4cd06ac606a60e4bd234a97b4f16bde2be9c452e16ee879092d8d262b8ffd5cf3523babd740d054665e1037241bec02c612abca9a9c8e08cfc99d415f1608fa5b88e32a11d88f4e8eddaf285ecc17335f91e97a9824f2c69f26315a0fd211b0ab5af9eff5180d1eb9bc66dc80e10dcd2cc06ea149788efd2b411868dcdf03a346336ef09086d523dff25a424ae4d1e19510315dc2153ff70350334b0dfbff2b4bae9cd61b401938ff6a1baee213a0312c34ea8a78f14cd3d8979e149ccf9482a3b037062426596cc4758093ce619af78c744dbaa24582c8e3054a4c9bc291eb1b683245e8b31fc949a5a8aadfd420f64693229867e9c1412a61fea7b024ccfafd4aad54347228b455b6e82c6425be35312ee7c05280656c6868279125f925295e205bee0d149c1eec5f7312cb9a3fcd43360a547b84d7db5c2eafb63e0d170abe31bfadd4f83d29c1f96370a76a4ebd671e9d0e2341577d0685b2e348239a2d50a4845d6db9377f05674f44206307123c57527ceb36e87a91938b9357d9102f85d76eb92b8d32475700c24f7625d341b25c35bb8128bdbfef1be1d2df261f87575e56f76274dfd34027f29b9285a3bbbbb02325dbf1c3320e8799d8ca46b2732dc20ca5ab205aa265e3dbeffa0bd5ae8696d742cbf82957736e1417885183de0abfe97c5c653b056f695531abbf120c441a23b7e65136e72c932c005d2cfb21531942deb3891b70bca2da337f0ff532f9cb66364a874dea82219795bb8fa6b3a879efcd49423492e2420cb6493bf7f007637a472ac0c6422c259122c142377687898a5f407abf2a62fc3a796da22ef553a2609cbb4b328706dd7f1b916601a33fa7dcbf0fe06b65a4e45b7266737b7bbbf12a3daf143f80d979b33307c2cc36ba9c40fc509cff4dea3a3a8b04705408844464b83defadc04d42fd7ff2f5502efde78cc92e736db720fe61b93dc369232cdedecb797a31a5bb3821dd3a2984d810c514ec3fb06bd58197fa694b783f095e4a38e0d29ee1e52d041893b4dcdf84888d0241cc29f5c8ef427c85a37dd0776dfbbab220fe2e6e2fff931a55476b78d907af001a65c52e86a58d70635b6848fc7d9a7d2b07a8f7d38dd75bca5ab8f9f81911b3e79debf2efd4e8913931dd3a6a47fdfc2e92783ebb8a0f34d4f60a783c7415f1c233f3d611d573d30e8524fe29f8a0c5d150316cb7cdc2affd768c94e87dfbf7ae9884fa0a61e4647f31127e26d649c2d0cc672cef1121af1aee205852f520f880622ff91137d8e08acac44ae34981dc2d98e5b0ae7a589288bfe9b6ee4c54a8d634333b757bc717c535438f1078fb02552cae6aac7dc4837f0c41612b260e8a254c40dfe8e3c3413667bc5cb0e4234e6a93134abf1263150006a9d4091d1e11d30278f083d5fd4a1f5799ffa4d221ff7701313abec44df46763a1dd70a718361908de5c0d9ff86c182e93b2cf1ba37499d9d0893fd8f72a5dd924ec58c7cb11ba90f326e96dd1fd44a57c972284ed5c16a1b153c6371118ee71b520e70daa422feb48e55aa070c660088c1b055f500a0bdf4a1ba5c3a0a605329900c6ce83b4ac1d00db8be405391a69f843cd12018a09e63864da8805bc428bfaf818bf8b7e4ffdfafb24e4f30bb82c796a2a3589e574c1422d8746bb35ddedea95cd979c3ea9bb68ccd087835ada5431eb4ca1d116ceca68cb8c263ca68d8a81df05e4033fb0e7946ab0e94a6697f0266dca34b73fac87708f39e83341f770ae1f6c039722ccac0fc6531fe88b906c76dadb6ae863e9835558dc791603dd7c549c5ab6fa3ee4bdda5eaab69b916c360709a1cfa1e78e6d6f5c19361f40eab2f4906bc64ee3434b2b392cbcb7b3807b273311304c04a89daaeecc9cc63d028648d4bce494181bb137db6b516e314e0b2bfa323f708dbd947cd21f04760a33627908ce63e990c5bf366f302be8f7537eaf0c73f75af791355ec5fdebb4f6dbd8d59c8794a3996a0b07b90c77077cebf32e518a48d9b6e2fc60591d6f1bfe1afb38c89ce716aa3a3a6aa373b41cbccc4727a9a6f5f04f63a078ae9317ada6ef6333520953888d562ec52d7ff2a5d6c87cd8f62868fd6822c6232239000b684e80bfe976cbd17895354962473a4781c9d1295f18dd9a4213cc6d0b71e484f2c2f85e9d3ff82cd63f20730e1c7db8227dbacedc3b4e7de91f0002fb0daa56dc47cd385826a22c3fd88e86af7363bb08385583a98894ff638215a69ae206edfd553206b344150d8bf19b3c84337522f56625ba05211335f9f4365bdaf04596aa860fea02c9bc48a53c20e098796f8bb3f381c51962f0057da41103008945082141bc9b78cec555e056759a169fde2b5e485b6e49fab741f587e64cb78a5d5608e44712c9e8c595db7594cb4ba6faf928b979760b73f697c305efc3ab63a20334fe18423d0c812f4fb15a9fab5cbde2de3fbf051539db609b21acb7538510bc667e220ba2bc4a7043d789c30e2cbfb413ea359f4b2b5639322c34f1b5d8fa34c7ccec2d9bdda8f776b3c5aeefe0c9f353782687076226d3dd32af320f8b43098309f4c5de0c859b90488cece4d2aa3e8075d65dd638303161d9faef27d32b858716d523ea11447a5deaeabedddcbdcfd0bf1baec03e326d8b1019c521e86a7749332eeaecbe05a9521d78451afd031803976b14e381cf0361408562de35a698d78865d241c4a49f3b5888d356246673d416159d021e3e594d3e7091f9f800d4163e172fb6352fcd335c5563a64e6f0d03ecc1405ac72b744cd17c91aaa90f947301db3d3414da0b4a927803188a37f89959da0ec6e10083ce2bd8c4d9860c47177df4dfdc6b9f744328e74aba5c2a4584cea2dcfde2704a056134c8f869cafca29f97a4482ef541600cbd68513b0d537ce6eff8a1d6da32d576ce36bc416cbab399e0e09a91071baebb7b735559c02f2750b420b8946d3261d3e8518a8296865f553203a7102dc6605ce083213bed318a96c59af4d33982f61c1c7dd368ed639cc2bd2f236dd28c053f83888a2e53b792d29b63cfe5d2b1bd3c2b4b43b25f5e7c912a7d45987b5210ee1b60ba1e83dfefb27b47458c9143f76b6422e0c630fc7ff94e5c0d5d108e01416c7c6a6e446c9571e0a4664926764f32420ab8e0a8774b8e13f6ffe1aa5850e884b02c7ebada9e95e4ac3aeebabb26dffa40d30e86747f41e8c80eba767f07ac7302e44f1afda3531cb0eafe2f0d7bd0031fea29b4b11a28cc288e7363fbba0e716ab6c5d7e3c51c4831cd2dd2f94aa8edb21c6b6949de7dedd830db841503e5ec7a752c877df2d4e3c7e1db4a3eeb437b81c9d84b647c6dc9683b995abe557d6b4564222e0d3bfe2dd5169efe4543d636822c6b96b340a3b36db025cb39a3bffd9719a3b2a8c6abfce7846b13825aa61ad70ab3eb3562cc964646baae6181dbfbc31d239cfdbd4a6ca5626cbdf4b60344134b17df8b77e959a2bbdb60cd9339eac6034a4a816dec163d622e0258a7b6a5ab97b558bc4a1975d0766597a421eefb123ebd7136bb74dc3dd487ae7700b54ff0b54277a7fcdc9df9fd9aac8c64135e34d085803e1cd5d3606e425dd20e092e7d508c68c565c3451b3e3067ab7f62ff5616debc841fc0446e658263f8c2eda1fdcbde6788192451ff6dfab3ddd12e4c21893aad6b758e6eadf5f4ddb561d39f0ac9b98a0688068a63f3a3e0a56175c7de879fc3289364efa044ab220e08eb883de7ee30c36c585f948ad763fa03a132669e5cc1844c9cbf2fc531daaf6c898e76bb30f741c1fc55029316485cb63714f5c90976e48d63590622f9a635dbc3e34c9f7cbf5efe4844d8cc678646e8f53f7a4176a709864bb33a153e84789496a62ca7e9e099d15f1713df7eb2a83c4d0fcfa2cb04327befdbd458625f7635a887476ac1d8a364f509cc10e3d1986ab99181262c6c0db10bff0e9cc4324b8ec5ea2d39a93279ef6ad6b0b6c0fe9cf581cce00dba5687a97ef9fab7c98c0aea771fa9a61b7957517f8e791963e44909f82f909479ab43b495aa5c2ce0f466ffe001c83acc4c624fd9dff7e2741b4f5f66012882762395ffd376846ae1b3d226c671c9629bc65d21987d4f8eb5cc720dce48fdd931fa138fa196cd3e0f9d2a88786e342992e449b89506b96bd6b0e884602a4bfc2eb3d2e4114d085a0e04f5bff88649ba54aa01308573d0e29d1201904f3843621ec240870147ba678e5557157412ec8e2f7ba0d7d6f2419bd3d5c452aaddc9a35444f43152885f1acde73c00586c0b5e3b8f2bf8bdaae368b80ee72aee24513380a4b33d6b6379e460808909f3bdca54226975d6f186579127a3cddde5bd814fd98c95f9fe5543621ab6da9d73742dbad9b427b47b193da9c7c59682a5c9335b9b0030403d9a947c78d242bfdbbc7cf6d09b1db8d5fd34d4a5ba8bc77a4e4a2cd01afd42a55ba22373cb6bfdcd826175a5cbba0469638c7745a55acaed0fda6c6e995914b83ef6409dea3a0c5c33a58406676384a9b5894f6e70aed15b2dc96e2d5cf61d7a8b86e403bb58aa484e38a9780c1e887338b9580af10381628b7b4b72d13bb6391b79424fbf0b87ec2d8edb2236bf29eafc3fd432e069671fdcc1ab67bec220052094688aa472f6bfa6888196a33424f4e3893bea4073444bf5736e48d7439e87c211480faf5822aa9e3566b008ed3d82f3a734587e3940b5c7007fa6c47f4da57fb7bdb13f853d5cd7fb511144077b6b754a1150389645a4ef51053c639a40d506f85e85293d7ec1de255360ae441e9bff597ef76cf021042ca7f64066fa98e40e5ea16f193a17ea71bf24bc0cb2bf93b5c62f7e72d762e0ab4746cbcc901852c20ab6746c6cb6f50a2b527a8f2f7a1e6dbd910741863c02d0000340b7402b7a763c740883a23460a78a23f4b58c0b354f031e12b226af527c2655fcd1b06a8fb040b7d1e45955794ca8893a2bb1d86334a3f838455f485ffdc42b32a84a09d0d749e77391e81b935176178b3739f79b90527615bb5df65251e5c9a027110acfe800f747a658efe6ba36166b54a3853a223212461a61eb4215fb6a85035538bf2def118bb9f1e6571c5155d859c81b6cd4fbfbeef4124031da499e22ee8d1b5b5aff37f9bdebcb5cf325cc5e32630ed367c7a9d6c33e63d5063c3f58836d597405f4a7baa5d9c8f1b66ce30908c21c0557edc14b3847fb33850fb45f194e20d9716c8c7adafa30ba13000361e12b50ed0fc92e87fa2757facd6c5f33ac7dc841b118762fa9dd2a97d3ffefc8c0b08ab470f944f802f21b89fac5ffdd0105c45bc2f7de6b7cd88081c7160bbbdf898f1d3f4cb4de281697fa5f6e87d02ee0f6cea897a11e240f0d07300d13e122fd5630bf25c8f77c0e5231d5603b21443ca795a82e3b49c468aeb4e6b7ba7740e90f810c07a8ff780bf2993d8ffcb85ccf967cd417e4eb2a4df78962f731318f8cbc3e152da626f584795df662b5cb88607087d9bfee4546919c0565a3c20832ee4ace68c9af2aee4980520fc4d9855915158ce60dcc1bf9dc61449c22049b8dec4f9272568e2d8714be08bc0565d98fa50f66c10dc9b8c354071f5fd23c66d1501a08d808f9133564a3e53e026d283e8d6fce723a12eac06c29fa4801a7f379ad24accfabbc42786f34dcfe0daa1f9252b8933906040a2282deeed4bec5e1f818ec26cb8c91f6d30f9389a42d6a5b12ecfce36068dc76b9ab3278563756fb9f414b10268695aeb416b82797802012c210416d8e3fbee65abbebd71088831504426aa408f0d8de906f830a268b0c66b987a5a7a991c69139b84d0d1975fa91cc75babc57b2c866ecc1e694a513b799adca28d462972eec2d4acac6588176f8f825b558b2cfb045acd568eb52e8c0be2ce50ba60acf78638e2a1b52e4df6fcbc22d38a5c469b05efe0b5cfcea003cde833d492a94606136230416491dd171c30f571a72a6fb14cdc11cfda4cea3d63eb7fb0ba29e7e3802ea27ba8e2d2f04387e9ae8bfa0d9300bc3ba82ec2a8d8f09fbadbfca11eb9cf6c28db05d59b3a3980730fac34fbbfef21b0d471f7801826bdca1d9d5d986118381f54ebb24029d7e53419b8bd5ef6c9b92436b6f9aaaf39895e4d0ef230582142be312a3aa0a594a6f21000af6939e6b80c0d9f0dab77cc99a4c7ff82bbe1de0638ba8fe99d7863cfdd823fce99deded2d0b1f10436c28587a2b0668a083d7fd933d20bf93541bdb33551fc294b6a4b06ce4cd694ae66f531bc355e2a7123e529c971887ed8885c899f69507c8fff13c2573f3e1b3f8ea06e8a3a2cd5c05e28ecdc8c71779245acc83fcf6ee0461c3f49250e1aed00664865f1156622337b82c3c858111d5ce74f202c9ce3ad74aa74a33f4dda17d446100f91937b66b4839db67cce0698cf73d5ab847f52e46315e3210ec593de974fe106e09bfbc77785c8864f7fc3b2065bbd5522091637be29ab4203b834a50b99e59bc65e303c40ad2c84bb00afdfb9e5390d3d77108142025999b6e1a58256ec18c936c57dc82b671854b9cee18b09317adc41ba4d742d548a83cf76f92a64ff6443deff3cbbcb31a025fbacb45cee94b1052625607f7e43c982be91b912aa88c6b8f7c2d899b459488eb88abb21442b9ce284355a06b262ea0285819ad2eca5b7649aa36af2c859fe1ce5dce89a20bb732f5e0b2c500ca921621f85930e006d727158c9a74a49a5bb43ea937b2c70b95b6839cb1193d8614ca437be90cba919027213d181ccebb2f8fe3a7781197dbca21c96736343c3fa0637a0f50968233a21c9cc70a0c5b13b731cc2226f96a0fd312d6423bfcda1988f64185b918441d0606e1efdfef18e01d89b6e223e513331e695966c983c962e77a2750999a8f02173ca3ebbf8445fc33dcb4cc4b4e62952e7ffd678780bd17cf160c739f67871b6bf8120f44d23fce548b8f40ac34c1188dfd35df64872dbdc7bc22eb4abca072b0f7ed3685f51cf3752c36cde7440f44a5543c142605c04a968fd019b20a46e80018cec7621faaf57f62afa7289bb1415a9ea2e889bd1650d8d9ab898e3e91983802943092d040c738e885f7b61fc790b294d10659087995c7d1f971e7e607dd5b895c8fff0fcf013f118666881bf477a5897bf9a47ae32acb6850c7c43c038aec7bc13ff477f20f7c327d395b432968866813d5676734711b620717a4e471eddf74fae0781853682b2ec0f161faa9dac307f54286d8c0b863c91b4a09bd39309459cbfcd143d2c002c341d8b420970700a3b73197b939f0082d93ae56ac6002aecdb00c9d85d487ca71be097b951172514c8f6f32223b15fc26b1a5961e5c4161eda0856e393ac9212cd91f7920f329b96286b82ea3ddecaed0a84447f4211824b85d59fa0211cbab0491c2b0cdc2d31ce6c9d16e7c37d96925abb4acfc4967122fd3770a542056de24b85b5db95e5dd95988ef1f1216d95658013635c03327720dea89b9b1fc18186d735142506dc1d726aff1d06da642bd3c7e1bb5a657263ec1d1a739338463b13119746a763abc7ee0aa597ae804f21fb119cdd4f22b252ef6423c2adf1cd99ed8c57a7d30d97a7446de2032462868d6eba458d844a118f2886202748188530e698bba6c73f4d7a4cd6b770271a55b7cda2e4b4d2cb0b97ef5f70c87c2d7aa51a47f0443a5ae25fc0c73e3ed04065e5d8d0653a7567894fec980e988f52870965d045655f0b17d9968d37515e277ee9864149581193faf89786500d76192e5d959f0327dbf03d69adba27c94fb9e1175907389b62dbb7a15be270fd647e51e3cd77f9b0f0613d7de6f1d768e5351ca98884223121866934b44c8d0483cfaf90da2875b4f335f1cc9972aab017cd47cda1da0a9275d1eeed0f7b4d41235605c82e6a76e02245902e697829ba5c20348defb1c0bc8949130b36c3752a83111c0b157f3bead0e63b5066ba96da7580ef361699d00f33c6199d2e64396e88c6ae1b6d1b0e416cd39c5167a0f3b5a0de29a309845a72f662408b2b138824c06ee40472f074056c88dd04d74b2c5859a2d28fad64153df22764229873b1f7665a303a52090b20793d76182b9dc9814e820fdb4ab34463b8c1669c53ff9dedc04e0a5ff00301404ba46b5cc60b4fc137cca41d1a11bdf4148e34958ad795c9c662c99d29d14cea9aceda2e9b8ef046c18dd9408b32ed159d6536f9859c77bb43bd63af9b2bd0332149dfeadca35765c841cec8c918ab3ca69ae658ebac6f21ad09c18a4dda7d99d3d7a65e99f9ee338d1cdb83418d3b866a97e69f1c41cd292d65afc90419625f00209f2578f297bdf874a5a5cf3511a926242932b335b7e35aeef8158e2fb0205c00465aee9147340fd17f2d42350d0b5e3603138d9d04cc350b678d557ccd1a21e3b82d6b3eed5f3a798f0e9f3f448a5f6699dbff3227dc39dd6eeeaf8f0977d41462bc0971b23a8d135058f6065df71c186cf07a4dfd69642771443ba639fcb61b3670a339dce525575a867ed7a3f3c177c7a06b34ab5c9bba6632991e9bc004f276ae2da66ae2c98495691bc8b59816aa53aa57965ac38b833f110e24b36e21b221eb833bac4d20cee865f15011c2c4089402dc864149a8b35699d0b8a8eac17ff0949cb37019136766f7f13925ffdefcd9c89dd0ed32f2b123a4aab918917a3ba8e17f3dd9a695dd01db7c13bbf89476ee9ce5f67e40663b26894604b0a0ce9e86058be0bb830090c2f5a3d283daba83b192264431ab8929d68b4e01824695ba23deb529acfcd95b427b429ff11ca67b412e42f819485a8ed35cb259ea56f6c41ded993c6afeb183896427b46edc0d5b328eaaf37df5446446ce48342a49aeb6496dcb6870c5473f7278dc5a794f97d4faa270138101e1e2149181740ddd2c8b2ec933867152d3f63ea64f72ac8d91db17fec9a44e43af7422edacb5be9eb264b5a87427adddd238eb91605d60fe2a4ef4ff0dccf94d6af307793245256a7422009712304664f52b5171fd1e6ebf41c1aa2c3717d76b80e8140e1c9fa940c5eb67a216b6ea781f89a012788c9c7f3bd0eddeb71c7f4006733ecf6caedab92b03d60ee3b73ecc7f1df87c45d341d7a669975515adacb4cbfebbac475ec28d8ed85953a128b5017884319f22031d9193afdbc759a1ab9d4007c179f41132dc530b2d8b8c83ce36a9b7f67e9d9b52834a9f17ce2ff6daa74c07c76ac0dd755adf413de911d4a0bb40064b8cfb8b2b69006a028e2069be775cb3c47c74c2f9e9bffa53d668c69cd12f8c5afd06238888f5c257b07f08abbb3d6d88ce29631aba20abb2543f0abb0a6c6c08f077dfdf25c29343c333e5e41056db9f2f99861f2c8e86f57bff3dd833cd9a3589c0a1a964588764e4e1b302f6ad8f0092e5034971551d430176ed5040b9cb4021b9e7d7522c23dd8b822cd25b2972604e50c0e9c73599c5b8a5c4d5e90cb798215ac658ec6e10eba91c341d2aaae9fefd4ac4c79f9c687280a988654544a08d6f3c3e9b48bb8fff3b7f00785263ba92f3c92c2d7c7ad26c08772e62f923dcb4da953526a96c081a6eb9742c8c685573f3849f40f55b5fd2f1f448f3af9b9a9ae2ed23051ff9b6c523f46d40ae4c2586b5738392cd8714e6ba58a04fc88fda71a2ea9178ab914c574ee0ad9a91b8550f14efa477c59c4745c1bd5919b0a12aaa9ab9410fed5631c73e85afe007069de069ff432cdd542b3d2e83a84b2c4bdc893561bd711dfef031a450ff95a31c734b0e23d9a12bca6c3752aa23dabaa4cd1b8797c3beec5d2b72425f8752001fd8b815ad4669cc000ad32a4d6c7c453ea10763ece2c43568909c8b5051fdb589391f57345073cbbcaaf647c2f1c2136cf4ec223cd4802423f6ddaa9abeb9ea62950d2917e636751bc54c04b2b996b9df7e966e8db3a5f61ce04ff0d4b20ff233cd96f4b5e60998c5de555db0a6eae16316ac0a4815b1cd31ef662fc15aa9d3bf3ca59cbb18f92dffdacec9612e9613f666d1d74ea99965105b564048685f85429d0df6bda253688e3c12ab0072cf5b3dfa0c8c80864863d0e03d3be091b02188ecc6ea66e5ac7814f0b4820be3337de85b4d99a460c687b9aff84e504563d2557ff34567ed974b0a0e9e3acc0170c4b81c0ae720101d11f7cba9a064091d14440bc290564485cec9aad3006421e81ccf2bcb07186af4a4d95736593dcf3f75685b33e6f9f08239d6564cc060737d6657c7e9817cab170b19b54d419d60cea87f4d112a07c46d6c82aac949286bf11f3de81fd7e5d25b01ce525c1fb37d65092abd1da1afe3e253563416f22a3222a0dfe9cbf2f3b193c2ed4688518d8dd035af6b72b2ba9f4b33e035884b3ec9bdee2941c34347562213e5625927c4b421f05544ddb100ae19fb5e1abf4efa303c301870e8f692daaebd357e6532c2fc7b38b8f4464c2b7c5d2944424145d0eede8a33b2abd8897a941c52800248dcc18a183705362b8b6ac856e8e28380acd6c64596798a3c9ac4e1ac84a27f1b16112b8afa808933a66f0f8820c30fb39994281cc08c4efd1727b12f94fed86e78b74ca801a8e384417aa5b891ef4a087b240ca362fc6ddc4f52103f1a587a251ab5e93dc0b19b4b2a4623f69cd1260686bf589ca15cb6dc153809f86d7cd81a6fcf011958b2e0d9a3345db5f2cc5b48e169d0cadd428df148315a5d676e1b5c7ef0d12594384c70813e1f89028ab34567ab885819d184dae58ef8f03e5909126d9c9e734d33462717520a430041e12e8104ef4594a61dee100d77acfab359c7ba762862ce457de16e00a9cf0aa8f14a506671ee293b2bc6809e9e7d77da980ce325e5b5d3ec8063f29be55f84966b8a6eea0a2b28a2f4734ec1887c08e6a3d608dcaf9ebd26f1f3658b8204f9fc4b01df1bf92162bff477dcd2979082f2ae33bc76e23db0314c05f8a25bec5eb437af9058899b90b89ac095e7b80f3d16bb6270b02c1ba08801fe718e6c4ab1dd88e99ce41ab21fe5517c0638f6e83fedc4b392a54aa1443bf854e58aa0ea4a3dfb6949651767e6b8e6420ff313fbf1886f322eb68915a5277712ad8d406de55e27aa342cd7b6564ebf5c1db85d68f5d9515de5c1e5008be102a9526b901a21e22e53d2b7b6e4eeec25bf4652e795e4cbf538487560c92163049d9077d15518df8c63b98e6a1558fba584567412e265a387c7b6adde16499bb96a7fabefde6d672776d8150a953bb75d389734f3646ead9db88178db572ea55c1c052f57f64a3dbb33286233887986f7b3b018a99220c53c99aee8e19d4c229f523326029e8f84fa3acbddc42e7fdb5e58706d8430e13131a4d5ce5e719908883a55a312425f052c44602936c468366eb6450ceabb4bf0fddc31c62acc2e8a1d828d0f6f9b4c219db795b96079441eb1ef5734cc6ca8f57d140fec6509625cbd9b06d7273453e8e10a304592e781c2cf689bce030201ddff8e23bca4e4314a784be052f2d8aa6979c424d659d9cabd9499879bc61479189476bc362613294b2db9b12425db1833b60ee99bf511ba2904c8b80c8b28c0c6056a22f3e326b37fca14a4fe70ca6ad799a9add519790d758750a10496b11c92151a835924fb5dd958b798f59ffd38f8e484e93fbebdd2c1ad49705edc7e47eec7e5b1fa14df75b7aadba33e78141706afa7250074a8b75c337bfa7d39a05a66c5423276d3c1130bee13dfc807e170074208cf88cebdab94e03a82aa3b3d9d0240056e57eba4c69e063c659d78713f470f6f6c7a04871a884a325bc50c2f68e3b0fbecaf91de55cdd4172c35ab50c10c0e50fb0df81f41960f9850e4616b88fbcef025f2441c17f1a0b1733ce6d8cfd8db8a32313f0c90967de855fd952158949ccec5a92d22a42ced8e3a4fe3deaf7b81f7bdd2e44570337050560e18190e614fe1c660b012d02b3fc91c88f403efe0727eb063a32b677ecf9afc4cf62f854066c180fc5e93c663bc94c856fbcf24a0cda6ba64d9f44eb9e1ea5ed3489a09935605afc0c196ab22a1186841377a538a74508bca46fe267aa77a8ab89495275f3fc05b8cc45c86a59347027782c6465bd3709a85e39821fdafb82fbacb928e8da5473ff4f821fb6c58f14e8cb1e1e089a5c0e6fda7536ba021dde054615b6357ff6967bb79e1ddb7c99b47a6b773b1ca76065d5885371674893473942b21733060cd8959a2dd8fbf4ea94e072b61b17bd2eb7744b802139dff5a0777cf3cc7a5ab5aeec45c061dad1a0d97b446001830b2d2c0fb06b038f96d955272f04ad9c316338652fad934afd5a879152145a1da202ad9ad001b63165b291f29c4b29310bd3359d5c263394040c5bd348bfeff6a7fe881b20113c57f777ea2e71cf35888de969d44f99fd5c5d60ec360a02388cad271a76894de3bd2118445eae9a6137bd54038759eba343e585233ac7e4002f4768fec25ec04c6dad045a28fb1bcd392f888bdf6305f6e22c36acf3a4fff8ac3a06914a8c29156ed07475c9b961315d4fb682d4d86136414b87e9a48af59988b859ca12857d59de376a55f9880c1c7c12174bf1993056d8d48b4cd3d1ee3bd4520cfe773e7bb1a9307f00a7930070e3691bbafd432cbe19e8aa92e76872ccb809afad3d0404693e22c62b6cda12b9cec85c06f42c8023e5b53802b474f8e1762ec17bfe3d03a3379e92b0bbafb7ee5ed26dd524db4c78e828cbf61011820a5f973e258a07ceb9bd63ffcb88bc863c5d2d49005d67811419a4171d9a70294f3bfa96481924e7d58a0d0cc2e0795ec89bf594b92e858a68c339da49ad35d234df01b3eecf2263daa6b0a62372d9ac2e30aaec842e5dbc666024722e6a71f3b5335739f81b51a86f24ff61248c71803dee30eaf702fc0cd6f844e9414a6f98c13059151fcaa5bd77fb625641885d09d8df6b448b9c9e74e338505be4b3fe5b6b9af9edc12897b60e3156a9b43eacedb110c2434f3f06d2490451055aacf1871e9353a9139fbcd4bae2f7b05509aeaae1fcd08056bd1c8c2e6bb645cdc0a3c8418e25e39014b5d318d2a415cbf7e81e6a94a26c5d135f8cc91cd1606cee8976e66e99d35e385223112178445bb8b0b66b4ee87679f913ea2be10cf5faa9e77c915311e9a5e5fab142284e6411d012ca55dbc51ca524d3067dd0430be2b5db31c673a97b68dfb7d36800900651b9c728a92c100a9f705e0d54362b871bafa194b6ca0681797b91633aa87ffc55baa6726ac9f0017961b7cd7bcc0faf9b41a28f21a247114e205f28a0b8c42768d57799b432c5806f9b67902871313a1ffdebede729eda73b20ac43dd7d639eed5a5ad6e495aa615d98dc3a637da8b7be6ef6ba8a3caf5415724fa99efab9d189724a82902dfaeb371e6708898166c00e7ef74a3e1ad29ebe236118df9d474fc496f7ab9db8cf740ccc6839eed5658aca9bb209c7933c5bbba16080134c98b0468910b80703c4a721f775d2c6b52cc45ca0b2e6ec406340c7e30bdc7413c34f58fae0c806c92f13e1e7f535f6b93ce349dc4f3bce642fb3119b0e2c91afb00aa2b68e965c6cbb5c9c37b2d24774f8b2da42e4e2aa1bbc1401a543bf26a2c6d6a3a32521654d05068bd436e2c05bff005fdeeb89b455cf9ee2e5a0e66eb8384aa3ef7d5102ba6ac595dc50216d493eb48e4e66dd8e6a11cd307f4a4ea31c368cc37c8646912d11d8b2e7c6d6c77076351ec7f95d995a456fdb1b97235139d806524d3f0a04c25094a6d7569b885a321aac627b43022920c9ea2a2cf1ddddb8d4b02f150be0f47a91c5a9e802b8af125b01f5ac2370cf1619f70c929b6233ca47db14f314d9c851191e26315531364c5a410afb35deb5955a98c6c588f7fde6beb9202a99250a52e5083912962a643db6f58fb409062d7645442bcad1fc0cf912ff317b2c6a6ba86da10ca47d9753a3702df171338845faf7b9f2dd15f23663d2649634216adc682f8910b5a0938923f08ab94f9c6d846b1a4b6da9774e88592e6d9ccb30f32803d099a4bf33feb924836ac7ced9bd90b544340eea7334eb2461b0fd56720d230b7461a6ea6de9b92fe8ce7ec542f9810b8e9636a4da00bb9d13334880cf912c0c50195c20c1da1dead3c6eeead7703373fa1bcc46d006cde518e70553260a250846a603aa73d70014fed58645d374f690ce7ea5ee8e2f4806da20c452cfccb8a70568403279d40fa3f04b64bb7bff52b2ff6a0049da3cf46769422d5049e7f48ab54ef31e2d4273f798596603572b9341e380cb1914ca96866feab66c1fff9abb2768df2593c54038da5c8efeaaef89a4feb5c6a8075d8c12c82c6ff73a383c5bdaaa327b5951320d571c88f1a937d490c77a860a24484bc1bb94722f93053607a845b5acf300f0cc81639c29ceac3d1c478eb6d1a3483064ae0aa012ec5d715211fab6b913b71844f6e794250adb41f5b3a93cb89124e0440178275e192b28e4d9b62a4c679b0f0bd5447657d6f8d6450f2fd239ec5706afa4230b17365ea0c526619b38c034174f41851f3cc525ecdc09b1f7a663128b94e5687a7d6ad481d37893098969ea9e050a472dac83446f5f049445677f5aedaf25250212f8b6e8e89a6eb6b37d9010911737893dd803e290cfebdd11097dcf804b3eb143b69bc0742f727110fc4917ce42bbec86a8285275dfae8fd23efff07e3d9d30f58511285ed3661db0cf43db136d97b053b7d9dd89013b46d5112deb03999578186d1c20a862bd36610b24106dafab6d2b00b4c185041bf310268d877ec9b705d777b9986e59f79699c1d36e94649e857cfacedfaba074742c2c0927905d9d1c03b2e0b4b5192ad78b67e98ca533bb67a193baa9ebd2e4121255a2f6b68a7dbdeb323a0ffdcb1069c0991d7491605efe6feac08d588c225e5cf59b21ecf746adc6294bb39600e47943bddcf1b45979d81c708471fe38d5de6dae2da64f24cb4a0d572d92b69f319ccac7e479c2b1ee3cd565abd7ff1004c1e7742795f8a03eb8ed4f1e9e088c053ad459cc2fd5e7147e9b39f86ff6a831d6091bfb08b115062ffaaa63fb3a92000a9aa07bd1134dbe6579a30c084830b069ce4b1910fc03334b25f1027f0cd4d4529193a2a0a6c481f0550811056321a5fb0e03b713108ce9c47c675fb70ce464a69e7168e86d41a42bf9bf10b164dfd9e1a54a58fd7bbc1811f743c7fd4ad9ef7d7641ae66504a9d46dc2d0017398a5fc62dad5484e0cc5a695396b507b41d3e09cf553b262964ed558b9fbc18555cf33d2321131c982b712df7395727ce7321e2b01f01628cfadd665ba406bcb72423c704f5c85b33f4bf9c13e8ad6ebfb5d4465193a1df428e21f4eb8a0cef21aaf02ef197c44be5dc910dfe219c76e09f9c8cb8e2686845e82a075c94e36ffcfaca33d6df2e35716b6ffc0cc2aff062dc7894eb81d2bb5fab63a042673f49a36bfe4a2b20c27e69b2a9e845224175b8f97c49b0ad119d446c732cbca1c26babb1682ea9743c89ee0d1e7dca85b6258362848e97b9ea4920c47959a0b6d4cefe78551f6d07cdef7d15cd0d2eb4246762835e024068e832f98379eba93b2e993119e81498df97eb684184654788e48188fac903f3c4bfb24dc03251b0a40340b834396b2c51f5663c3ba3f5d976318b988b59968f2c9fcee929257887cf75c42bc03c717197efd73e2233eb5752c850c98fcaf29fe7fd058ab03b3b9bb973fa401a2d810ad60b678deb27df44fc0d4f94fb7e9b1e0ebe35f3a833564d9d8c94fec5b9e35187498ee143862bd9010be4593cf5aa312d2a0994c1cec7747905df49fd318789f6cb4f70646de6c042ff0db9cece583686549f08d30ea745793a01b2187b276b7ca6dcfb1b54bfb7757884b01c00204684f459175928b9e6e4aca91803063e9bec237a05a0646d9fac47a23bd8909e279cc1030d64a2c85dcd1513dad6b5e829358e96c388ab063f89a8236ce8a76bbcd4b164f204daf631df95f44879178dd055d66e63f13c119e3c96a1110dba247c576d34865662a4418d28baa8be4f98d9d4b7067f83abce5cd37d1e38bf37a5757a7b857f0e8e343a10666b4a81921d8721f9cf59b8f29f040e4d0f4f9f1ceeddeb7383980781dcbf47cc529b1c194b73676a240668b8667539200ba6cc7edbeb9dfb105958c12a9bb91dcc453ef9d25ff59ca66cd5a866aa4d0aaa5bb8df5c2e92c3cd974585e9562257684e683c484210d53f0bf8962bef15286094633d85ab683b730a1d43b777d3026d8e4941e59378e4e842ac882b813d73dbb14c000991a8963a048584a4e56c05f81ab72e98d4dfdaad8072a1daa15bdf2fd0df3407513be2c19f7c58d22b0c5b6071c7a5f0d64544251fe7934c13de483a3521676d1133cc2e834346401df6d715f39ab91e1982ccce02bdb7f5b471672d7c53695cae9d822b23ce213101d0a87bedf20e0e84e098e1bd6c77b0f31ef8664264e58803930d1fc05625c5543c3a295f46e878a889e7d9ab8931eda4d660bd572665366e276c9bf401fc7d923cb43e829ca68eb7135678382f97d4cd9535be1e681584c5e0d2ef8e620a7224d00d44a2b8d9a916f22d7b152891081db5e89f97950b5007b7e31d00143bc678bffe60fcf48e3551f927dc6e0fd6af5628b0614462d99a3734ab3e317ff2fc0ab55b8a20415da903571cfa971c23c09aa5f89bca7f49ad9418eb78636388d5a4d904fe92d29215a7e1589584cd7431b959e8cdd88635636fd68875fe767f92f5a75b651edf1f7e904b4df0ac9af5d26e67de7bfa4a0eb339297e706c7209a9e2247ac15e7a0f96198b8e90ebcdb3dbe5fc18b56b6c8b353477adac91bcf33541041e9e93723655ff75f9cef1dec3ab5ccea1fc6521135eee8d5459678a64fb230b9d8469c14cfc0ef98cd5893856c1af23486d3508594dadfdbe661916c4ff293e20f30a0a781892fac59509d46cafd5d3f637799b03f9c74e6f842a51cbd5df203ce16484f93ab7e5002e0514452e56e94ef6a66c08b4d25edef575331daa902ef1bca731bd4ef21355cda265abfa87a6d0c1b29ef2b514ef89ec3d590e6aec411912ff9f4e14e03e980c0d026487430cd125cb688ffeaae2c6eaa73bba50e070d4a6fbd4dd10d15e6dbb3544236665d286636570cc71f46b79100daac23f65ab082001b87eecfdaa902665bcd0fffe934027746e67458d031ccf64499cd0d74bb60767a225e2f9ec57b8a3ecc9aa7d929c9632878802780d38f7a9a6a8ae57b3d752e532f1a9cd11ab1bde09f6c3bbf2463b7c363760343d7b8349f3c4f5feef0b5762f5397cfacd1bd23a6b6144a7c5ec81437413f360ed323bb018b194c6e3353d09947ddf898937d8beae2eb667594b49349b12f18ea393ab68f0ed7c69b05dc2acc6b027af1c6a77427261b17ba277eda43299143dfd37a3357aa4cde139af936127d37b96930788ef5c30f31a5e4966716e6f64d40a67fb68bc43238dfe853c9d66988ce350d353615cbabfc2443028ae5c036871592dd3887f6152655f268409b02a20c0515e1807b1593906282125f22cd2f965fbe6a30454502df84e3c94f9ec241648260c462ab61ba958f67c375fe1e8cd1eb12ad73ed7057c3cea27e584e1ee1e1ee5663c6d0230a498e6a34dbfd37522e18296543a5c4cc2158c415b147165795d7d6abe1415d96cec7553a843b12ee96296b5af257b340dead8f9b1a173c75c50be8bd941d58a2f738f9fd2a35c979ad11bbaf51587fb985034165a3fdab3a080183907821eb4b6b83928097265cbaadf2feec05e9fea45e4ea52d50a5d4efcae09efa7f2a17bf5bfa3631c551c0b6335cc76e4d8ec1975ab0ccde72912ebd90a0384e0afd7ed107b6aa39865f71d85a9b5d7d7797ba8897fa336a9918a34b809ea8989d02f32449bd89a9de6b4287394f07f7dd3780b3722f38749b73c20b41162fd0e5234a6abdc391977e5a2d551c0cca7d1d066221a1a1f86e2ccfda054e6329439a70e42c578f71ededba107a6249e314f2c48ea82156868d0474e109b60aba5a8652a6fd087b53004c87630b8844f4822f6867ee337802978479fd8ef3061984a7d47cbb36ffcb59d0e05906541ce00f85e0f9ab5809a4d6dd1ef6ca7a58fc4dd2a067d2c5d629380ffd698e6d25975582a6e460d67d614437e89b15bf16ea6be5fa714cd1c3bf28a2d5c2b00bc948fb9285109dc367780fe09875994ab2f6847c48d53e2ca294af8e8452867be58b15996cfcba4a40c9418a8ab23ab300eb578387f180dde591c62e1043a20cbe918203abb6f93a3268f9549e07b35429ab8cd2eaf1893215c2bc0b97645decfcd901071e1ac676d043d2cfa23ecce49f77de90daf0df22bf4ddebe79adccc794e63cfcfcb673c06ee7b69b4ceae386c493825e9a63595c5ea497965d5291f478f2a024ef9f957521a0f76ee02a39001d8effe6ade9d7ccf5a20f7c77fbcdc855f305a63d52a64388467a70a29c0bdfced2a78ba6a169505e72ad39fa7f4218694e06dfd7bd044a8acc436b9f91acb3dd882969a3b128c9ce054d06f2ee769c05cb2f8b4634fbf948602e2f459fa3cafe773624059c383d3a38405b6a7a2e2a9d611a4f1cf39db65c6dd4d62ecaf17a78e1c7922c4668b1bdb6f55b33eb7ef893fc4b5f5ec69184df742511fefc777b950c8f840cd2235ae92105242a279a8a49f386efa7e5666cf2ec2994bcf6ca80eea403feb3c2ba61eba4023bd0c4f14a540bd986b7f7b16904fb7487e2a9a3d416083d32b4482a3807802b6bd2a4fb11ed5f64370e88fa242e2ca6b3955af4f46f67b760f270c911d34b4cbf1a8b3c40554bc8f8a3b5e18c140634bd82e9733f4303d44e55c38701bd74abb563d936d4b539bf54a62a0b9a206ddbc7dc78e9b3e550aae4703547887beed8cae035d05dedd68c30869c19e2c02e4fb3d9c73f54200ae8ce874af44644856b11feec5fb7287e6dafda7ba62c4cfcb933b4b3da86de26ab3506d480d40eced7a0899d27eb4f15d684b7cf7ebcbfbcf6baf65c53ac82ea5f91fa0867fb8019a7e7e3768e180fb2d741d8a8c06badd3d5cd95dd18995cd19d5abf1dddb92bb546cd0a564e1c31b717cecd8c1f0400e02c33cf85ba43dd870bc05ca6ee2d4c91cb229a2e869c1a0906b9fdb96cd6f59a83975896b82a4e3073f47f94bc29c44a2ac2275d15778d5528233c7c5f412e3a1c2a0844d668cab9a407810cf1d8233b44ee4353c93cd7322d1440a96ee41c41359a585c251b64c7462051c8dd960d3cef74830648369effa3367380dadf8ba99ab16a01355988b0e044c7e60eff72392942885202874131a8b2af8d5c1f45970caf8e8bdb94df3cb1a145b7202e70d7eb9eb166685248cb8cd2be4d6880e0039aa4d327b7c7689f3fffa96cebbb4268ff106fa60dbddef8f58adb7320ca05734a79c4a65450845e350c462bb68e3709842bafbc5a77e355584db83cb9cb2b2a5e38d8a45f52152db6369047b17a12f3bfb7789b22b97abcc8633f45e23c238215443ee31681a63a1afe8e1057977e1ce9cdbad2e797e7440f481f63c099581b32c62e815df1abff677cd5964e6f539a4fe","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
