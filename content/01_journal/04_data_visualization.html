<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"4ba4ae4437b7b1e0a9c37517e9a016c20f00bfbf008e5d5b5702a0c6cdd417db4498681ff1804d9f6014160a5bd786c7dab608c9cb710760740fef93d69b73e6077eaceaacffd83574f09f0708779bb6393dac2719f653ce8e1489de5b4f7fdc67df1af5611d7d2421a51d4dd9710b474a00f9176938400ad98167b996c08eccf6bd3c04939b709fe2c03aa66570d4216e4158817c9b8d0cf61798085ce629a282a94b4c658726cc63a7390943b357256576786b13437d8c752a22ab48b8396df1f4351e8900518a25a519afc188920fc8404dcbd9aa2ced9f33e27bfee421f75ee2e644c98545a234ef13c8d429c3dde41710f8ce1bed7437bb815e8986b2fdcd09f67f8842f8a0688900f7cd96ed65b1072b0d07ceb21c631793584a3d5173c7d9db18c6f1643cc1c490e2396210ece6a8e497f8e18023c3b71cd9b6a2e96bc8f655d2bec49510fcd0a94c15ff449070e7a600f36f80d1c9936a85ab3b9360a843ba80e7ba4346abe3ed9c6f45c41e8f3989894f16317f433de4b473bafcc3ff6524ff0adfce59152af41ccd277c6027291b66c01e54478ceb005629b446af0f1f458473215893294a2b54694bef4759b4ed5c025203acad3e71c6f03a177a95fb151aea60b1afdd4d90f6a023ff48aacf60fb2ec982049e34cfd84fd348604b7b428f6250fc6e5594e992eee09600aaf4447f8ada91b029b5811fa1f62c96ae5e63b00e78f9ada640102522bafcd84ba754737d38145bb8ec6314c08aabd5feed1ca14c974d4235ff390a8ebe77fd3b146def245baae11499ac8e681702f4f5ad02687a73c050005b0020a477e2b5b1fb9d5018807a38a4810ce0b795122d4bde1cc29e952cdc571d34085a22997a2a1da683394b475ce963825e82127afd9cad0041a2cebf36072b3dcf24b9ec27d4ea7e5a1a70315abe253183b4d2440b1082e0703f6525ffc83db80ca2ba1137b216d4d82e72079bc11d9e9a6fc86ba168e087531813d7a6deb50f3555a0607fdfaad347ded02008fd1832d9490bc601d4beca553528327839d049f25d563a5a8d5fb67ea67b3a169bbfa6a598f9e31c004556e7f266209aaca30387c40b3cea4a163feeace533869c9c61087cbf4047030f6cd0a231083c6baa10d1716108b123f01f1b7e842700dc5693d58e6a922834a635421cd666c18689bbb03f8f570bc17df4dbc1f759af3542e9e9edb223727f30d6f43711e73a180065192fe41f6be353dcc5181f7e4ba9c95f6b43a78e7b340640ad790d6d19df20993b52b1f7645465dbdd836ed02f388f0e4539b8ac94b39116406beaeb66c21a6bea4a0bf3be00dca84cb528ba2e470f976da0ef5f221d645faa9dd687687cb1d80b2085875aef1cfe15536cda7941cf833f35b18a4180984a2c502c0c20173fb1ffe228102d60b2d7fe1e752a7514d0809713a93a384478bd29672e86e47ce12ac8a8846a7cc60a47a11180fb4e2d2e646176d5c25088bd12b5d5ca981c7fcfe309ba3dd0641da1e4a0646bceb1e2b23f624a53217fa800e6186612ff2e0d721d5a7d4a1926c4dda44e5937ff36f140e29081106ed288fc878f86014119375abd1d6b9d5b61650071ac5d28eea52ba07d2fed152b4bb0c7b7db54e19d2196e77eb2b4bf44adc63b54ec4a42173c5e920b5e50fd4b004c1ecf57764567ab327e05ed264f266c231befaa50278987ad2f988e0c8e541b319c7b61d81edcc141065aac2ff1746717645ea8f123ef3c84e3d044317b5e38c032a1f929bf90c40d04c782e68f5a956c9e0e52d68ea8c3c2a1c04742dd7c43ca8300f905842022993dcf26ba927b218ef936be953c6d6865c1fee195e704de61dce44df42183ca1b41b788e84ae8ac253312a3d2bb46f3c9db23b72a3d71179406ca7165b11d255251dd5e06c7fe0233d91c40fbc2789a3230d6fc02f6bc10f289d67bc965579f9f82ae61f6ba99747bdd183542fd48211bea4cf32f231ac471e7db7099226c3d3bdf547a69cedbfedd24b7f7fd2ed8f2832c8daea782e6c42262cefd1c15346328eec0b56e729ac2230bd73c9134a48b9effe401b99c0f2907602b4a7baf4153629fd66be71a116b08f9aeeafdab7734645f9fb53a1c4c1dce3e642968833a5aa99de37eabae2bf5367179701d16a495526589bf1acc48e16e3db6bc2dbd2e38154799152f38ca27f0a729105d50d760ebcb0efa690cac5d1b27264f201fbabdbe1da8d4b5d5e4627332f8dd7e8f8ff23c8feb09198da12d3a5278d1bb92cc15fdb2530d98bd8b1e4fff65d152d5dd1319d315e533b9634b4fe7e8adf44bb4e5267a7a46fcef3c208dcede1a685385acaef0592d8daf14c7d75a40c7c2ddcea004302d6868b35812c1fe25156c8e1e6cb62cbe573763842ba92efd3342e20fc65b336821aa78f92165db90a1783fa2d009be2f97a39c6523a0b6a4d35d6ac556e7a8be2371066ca57443c706dca0a9641a5c6170b7575b07bd30cc3102ddf67741c4a05057b526661d36b7bae532c471e52d0565a419d52be3296c3f1dc423554c2fce66ec7b2a010731a2f517ac1fd6b067beb402c34c6f5252a655a97e67202a612f4121e9fd9873df26b5e04580b0038021af20789dd46d4f1478e94b5d7a11161d855406cb00e50d3fd2b0654c5ff44a5ad5679cdd4d784c0ae16d1871bf8a6e9d52bc16515340ee7fe0bfd28a1e812d4cb11cad81a136d6444c2e75ac13699eb7c63616e244586efd55f2f64f3a716ac774eb189bc0a307a7d5e3646862dd5c10ddc71a3f0a19b6bba718f620d83e398a895ca33663105b2c1c9e243d5d2ccb210b1fad23600f342b45a5d07586971544dac8cfa4c0d5a2447a3af638c9c9b597ce1884d13e348ebdbdc206108d68fb366fe3d1592af26bae665af455d40dd417f69d2129b837035940c0c7d7e36e0b49fe95345ffe34df1bf70c3dffdfb2e870a8dc7bde3517da5ad41a17989c064f17e956e5c290c1ae6327003b41955c074cb7ad8f0b8cbb0716a1d0e051e4340ab97fcc2d97891338f6dac71d66057775f3a08d0c5d419a0f6dd40e6eb0c294c2120b37ce89e4286413eb06fb09baf24914a9499393d8b5efb4c788cad9afdabbc977d32c7ed5dbf6ca47fee5ba438ae57d746cd43f87fb9b9190b7fc507f1b6a17ecccc9bea2c3fc6062d051ceb18a5323aea5f165301bcecc163682d5dd8810c51c33377c5412c00deb2e8ea668c4d32a1edad70fed98277a1561789255851d16ac7dcec0e00af59430de50fa24558ca8fd6d71653a22b0e44ed4363364653523303b113fd49709affdf8c40c279c8a5ca430a3f4a582ac1ca7c128a246c2e714dcb3cd923b01cc417da40e0835037e2dea5d71719156abbb06ec7e9303376e80a4392b58c7ed22365a31d3c9e151ae6eb9ec84c1d869a15db7ce70d97de084b7f54c70bfdf68616f7cd2848c71833be59aab3b776c1705c091585e34b0a08043dc417c2a7e9f1a527f69b0deb682d4cdf007e4954853ce8c5d928b7a33ec6e7d3e5d3b20c801ec25eed2a1f745f84bd507dff37491eb0fef37b1925e5f3a885c793dc9878fd2886c66887e50886124f3ecee1cc8b896911da9d421e425c3ad13c260db67be2e33ebd0b2323ded49f168213d637c45963aa47cc37aeed42d001aa5601785bd942577d7c75df01697e8919f6b9751ccc9563b8c59ae684b132bace9defdbe707ab8c673370f42b895b02daad4aa41851339e2c54aa3d32c67a8dc05b62d9541b25652de42d72450fcd35005da86246010a3abe947f40cac5c3f2aa3c8da6ad58a3e4501b4607e23375c265b4bb15fea1889cb2a43d1f6b15f0e4856e529ac3d7b663d68bb3818f07f08dc40657c6667e64fdb3640ca41c5d2defd94498f61b88583e509f03537ef9f580588e81c6d1e1e7f0d5b2e57d283bc17f6bdc00d5d9d31d1f9d8e1e8100b9519fe6a84327e7542cf4e4e92395b0c988dff65f907a9eda7db466e24ef53fd5fe2725edfa58cb70de358c14937734eb0ccdcda0d6aca479a63c4655b6ebc4269a2e06c6664b905afbaecfe98394ae8102e17517e9f9750b2e277c5f2b01c536774ea666eeca1092929d22ea6738ee60267a38fcc5c6631b62f2dd8d9f414736d36c419ffb61c96f2f4040f4ced1385a7703650737d94414ede86a6de118dec06131638296e55f3a1cfe34e598154022ad4c3237fff1642660ece18774f7ae785a15e589e8187009dfc0ca616b27716db83d9a25677f5c3492159b0834fb4a3c17319b39d0db66334446116fa857e581cec7d2b234ab36dcdce754d96d02098f59cea47dbc53b3fc667eb08c5312e2e6cccc7d52d801a37de5a43218671994aa5c41b9f0714d087fb9ef5856b64454e410fb324fb51cfe07be06e63a6d919b0381fa6451152d0bff128e715a623fac5f0a0c39a9a2b7ba0b8d1c4f66af80a8ddaec957f58ef92bb060015c292563a2cb81b559ec159464dcf1bcccd0593b6d407c34f352d9749277bf6d9b1fcdb6d04a1cfb6f8e8b77248ceaed22b02c602e57994383833bf9899f8a2902f74b2cb0a0957d61ef7dbf28f1cb468c4a545118a161f91d4c1056007c787389267dd7c783bfcb7574304ef7690064b51e97e6b9b92397be237e5fe76c162b2bc3f42dafd102ab81baa3a6ed8051f2f1199805b90ce6300565b968fb0fc5fcd1bcef081c2b431bf35b4d7f3143e477c78f3be02ffa560a6f2636714db224880f959031b593075e526c5c0d0c2042423f3c807ce702e482595fc4d2b5e89f76f77398c88916c81912502d8b441002f1e83f7916951c4f2aef034f94579df2c4d3f4a746bb7adaf4ae202d78b450742d7a5f005c57bee2b4d878a34ddfa76c054ad0b61ac230cad31b5257a940501a63a6a98b0ef1c8524b16090c40eb93f39b5fc264d0e17b2764761fd818b242101e7e98890885b0ab17ca272aa90724a10fef339c8179e43425b7c0fc6fb2362a98f843cb72916830654cf5ab2e90bd13235830be017bb3bd22834b72f26cb28fa5bb8fcd9a4ad9c03d2f362be73e55c9283655abad1f278dbe09712aac2e07d8161ea33969381a0e0e98848d4447bd17a7e8ddead5276832e82ca08a388a890ab2c55c259b874423712bcb7cdf29085f0433eedc74f35c233865a53e4d61a173048adc6f1949fd491545160be987c00c65b1052dc73cdd96d35b2ddd013423103e006986ad2514caa8d03fb9107c2fdc0cd19f63ec8132443b41b4533124727115c331b021006eb1ded4689f901e2a38ec2bd3348f9af06cfcabcf322de7f5b3d057f7bd4653240bcb0cad6ef8ca465830ce2186163ca46112f1e0b020258821d486444393017ad61d1738c38017f6f909ef9a0bad2ddc26ddc3fd0b0d47e805f03683395ade666c3613b4077126c75dab8d7016f2b01c6ee8102e4da781dc7af092ff6cce1641a417fd11a071442574750c2c15259f6f380bae02a6f111f13e115b632353c80450a2d52c26c1e1ad67682f57c4f5793c396f590f0b88ce0e0abb2aa250ed116e91877a0477db6e6ede9b51c75db91288929c7029897d0ade0ad7bee577aa7881aed34e87a7f044a5d340443869b3c5ce1e0c617d82e4db2c8c80848d53583f2a9ac7ef87ebd9dfb74a0c6727874f18573946edabffb99e20596b2b5d44f002e212e88dda27832c47310fc16b223c4b554a2e23d942da564218fb287794d2325c46917e8759dfd3f9cd45dbca80df310daae09af3c88aeac55787bc54f128fc481aa528b46ac85d78a5f32eb295afebbb5352bf73f1a1ba058d78d95429ba7d50e3942e684a28187859379c2b5b51e10c8f19740bcea7f199548905fc951ab6b817eaf4d8b861bb6ac9d62855176f929d8b86cf99d2113e3febc9b8557d1b9b2ba57b8dcb06e6bb836b0c3dac327c41c74010e52122ee54b4d009af4b9261fa37cb610ed490ca58501f96585b1a7a1922d37f030f051faaf8a8a72f75ac876d1c02431adb5f427688ba7187f0f4b3679afb1f8d6a3a927d41591d6b62fd765cac8ea881619dc13eb126209e22162fb0aff133e378ea62186575c2e06c373a95b664dd33068b90bbc129dbcc2276fd810c6e46effd63040caeca10fab9c4a5012d29d55e7f448cb39304585cc2d66ed15725ef3318383fcd7ef07246152040899a6f4076493df1146996850285c45f3fcc5d6890fb63791ac550115a4a547b85aa81bfa5de9a8e076be6158a1a513f054c6ded23c0616860641bfa2ca5576a917e27dbeb08155b2db107749e09230c4802e4ad752a3d6ce6f6182794ac2b2510d14e89cff63a77b4bf4193a8c4bca1c09dedc31774c71a377d82a3bc9c6c8d33e215e31f104d6f3f59e60f757e0f8e603548cd2b3196f231a22147ff4382e3b0163ac88c2c4b3fbcc45553eb0afc7f9c2848573dfaab0b69a6857df095eaf9c49a9fb2a45d73d6385e6db1b649a7d7d5fa3d233d636ffeceb8438bed06cf13aea1badcd5fdc5cfc0555e4f5331aff09f4688c745467dee624473480cb80e89e3bb53cdb9fd824aca37aec95bb60ec24043f5756f5e21b19e22b11383d9abdf151143f0d3ec5326bdd014b2da3049cb7e27cbd82faacd4666fd8808f6a478a1cd75bf9a0dc530d9345c480ff7a51256917a4bf077018d6a6fe15d0e09c630de7e8ea13c3397615c6ea7545e447773a5036425e8ae68a09009820c373c4295089443e9f20975b5f40fd88a4ddc9da67029bfaaf0029c3bea5345298e2b84b84d4d404c70386d072b8ec5eaee37416edc83f0058c21a1d3512f5114ec6fb0634a0cf654d4970c3a190147b43d1891ab06dc9b9d681d23e00781b749597e29abccfd3a24565abf1206e760a7b3ba231bcf883c7b102beea707894f06c49d8480c67ad5a3bab985328b2ccb1e05b43a8df6bbb7886cd55822fe78cc3332e02ccbafd7dcd4b7125b316b7fdf688fc68bd20ad4af6e62976cd39f2796703fddebb185f87e79ec274e48ce3264527e4d52faa8c886d1222d61f68bd5422c8b0486b2564f74ad12730f1110ee2c36ad009edee7a966019679f689bf9adc2b0dc51830d0abf9240b0b8a721705f90f054c4e02fb82aab0ce43c84a964d28bc1fc5c16b3a49c7212fdaf9ce52862852b101f607d8543ef380531b7abaab60fc803d09557edef05f84644faca355fdd03e5a8aae393f15fdb6abbee9b171f278f4ba5f306d2dcc0298acc3f6ad5c87210072043d9ea445509f89b989680a8c977febcc20a57f9bcd10f3836449bae9214da48951609583b0952a33252005a04029ac3eb805844c0e84f7c5db83d91c074a90cf261a3fa55e191a0fe820d2964371815a313a48639178a17680a05864d791b6e93f1bb4aa45feb26e033ded60c2f6221b38bd19ee5eb9d41becc0fc463848b483cea07e3dc25ee0284e1f4fb22285d715e5010e47a75f750c6ec605866a064e02433ac8081a610d6664b714b55e388d20e395d271f068989aad308bc2266b5b3950eda01f70df1adf1cf7c23b249a1c1659a289068483afa426771a86f0f31dcda064bae5c9bab5f1f07ec7a6adad26e7b8fc0de637ae5827d8f043c80d9f81e981ea5578f0f556efed451efab3332fcb832937cf769fdf90fb44803aad3d7647d797eaeec6b5d9043ef663499c3fa786ea43b5247cc33a0a755e1cd37d75f215f7a381fd1cde1f790fdc442f5f58f753d2656b6baf0a887326b6c97419e662b47b173556ed3c8259320f390d00aeff876845b6fb510a8ae5bc4a93a85b2baee9eade9fdce90a58cf1bf8994296165dd25099e2b2e4a714928b83280a00a58f614ab880613a3142cb860baaae09e267a9a14d2ce700e4cbde868cc8053c1c0ba1e36ba71ca03189bb6396426343e0d2eae9cae88ade1c1a762b4adb5954ebd22b335b1547d3f398b744184008fd6b0da7ccc73cc9761c57e8feaa439db85744b8ea9ef58b4cf96650b1f229042697258599af99a6a08b340f0a1ebc1372b51c712fd6581592533e4d46eb0ccb6f5750c877eb824d1cdeee8417a211350c652bc42352e1710a4b967a4c0ad3b6626321245c8c226b4ded3ce3f3a3cc53e1ee4b039e13e71e452bc21c9e12dbb242a31a5b57a248746d486d5becc302aaf25957822ff2aaecbd5ae6216af755e4b9ae8f460fbb9ef4835e73d9743e990a54f8a6ccacd7e18e2a1446d6b8be89b0c719790341087258a938831785c42760606039556779bda9d305a8b219dc19d5c5d866a24c00b81dda02f249efc3db1332f8d395b6bc0fdbd2aa52adbbdb042686c2c871106da49f1c71ca23ebf3eac12262a6547706a1009a3fc43cf95e66833cbaad10d92e600892debb9e4140e9bc3dd759a732eb65d6c108d3adf5405b896677999a663cc52e2178acfd6c1a494373042d416b2fbc24a98ca7a774554a34793252fbd4d63855f2d94e5fde4ab824eaaaebb44e01b89604cec2a4b768e6d804e34bb0a598bff20e5316abb5c3b11b7b8ed10b2c749bdc90e815d12466759204a7c447193b6debf69f962d9f8907918dc52070930459241d9926a481719c60adad34f6743bab4bb6c58091f365e4000181c6268ccbe3766662747d85ba055353d079201e2d2a89e5f5a3a6540f69d12408358b26d955831bb57fe317f5cba851392b41479dc343647c8c6c42df618f888e29f03b2983a1286c6f5e80445dfece218e0fabec7bfaac383582ae7b65f3d86124ca9a8f54883277f280541bc92a056703cd254bb9853035c3b2f59bdddeeb784ef32aa1580bfc3f3cdaae818e02c239fdc0b03278eae85eb5a6260c652b7c4ddbd5edbbfb0a65a2c28c0acce07ea02cff69065cea2fa44d3e30e7169d4285f4cfd71db4354d932b4fe0b7f70d75110cf9d5f3f486821b558f5270a2e0b546fefb3bae3e4780ac4f88fa6cc1da2142ec2aaf4caa90ce508961d89d8a0dcf65de40f6c6dea8225151885b970744fb8f4276f50687029ebf1dd788720c464694d34684bd335737f7c266b7da12976ffebc5b9abd02d8ce77b11979e95d072ae5fcb0ef7b7e0316418d1219827c6a1d5b4774350b1612acb570306233a7e98d89ed717e4b345dbae590739a3bd336a6a0c3cf791bb9d082636a635788948829c1dfbd01631c67d634bae8e497c2aea6d085c00eff7e9f9ecf2a5396c582f4b4c1e2beb84e20ef13f2382cf37f18477a947144d7376f67725b995449ee6874683e6d682824c7f1b1bd09ed503f200e22b5e8f46f964e739e10ee8452897a4b3ab07f27e7bd385e29b73e2ddcd54bd0720493c4a505c862d6a2b80433e68f6929d918494d25b0e30915f4a47d4fb7b1a8183c0b213917d39000c6bacfdde50cabf18cf5d12b3f222b5ef67967b9006d46506ead194a4bb7342b337242ec87003f9e75b43c3c13ad54e5f80163f3d92e6dab311a85c2fabe7db9d292de5c04fbe9b63009b1bcc7f853b8995bb5e0248141d37385997f9f01eeb986c417f5df0989088bc1f13f4c61d11462820245d9bdcfefde189890d650d2e4d309a286d5e7f1572cf51f9e90ef7e14a49141dbb28d3e641acd2b1c861739ff3c8055bd6e019da49613d71961634358717c164a84df25d9ac3319ae0a1e873ba55a69c7a55ccd5ffc28ccb15f8e15aaa8781ac2539bd96345a26bbc79523bcff48f945cecd269a875f20ebab25aa786cda10a2198632bc1f57251a7b815e5d4d6f91e48f0fa8302b889ea58931db009c62304066c4be6ff9db1c10e5084bc1bcf3e88f121e19771588e4e87959ee4c355d5fc314c6e1768ecd5f0c18e4a7938b5abb5dca69c0c1bd06b6ebc919ad65210fc0312135afb1b0e441c46576caae6f2aae199336a23ece61dfacaf19d5020599175b594c96c562c4876581a0b01f462aa8616468fad90ff644aa437d5f0b9d9fcef9bd9df88d3510b7cff19671398bfdd3110a59ffc3b83633ea9088b5d451bd24a20b88b7331bd69d26cd345be51bd4b8c5aebd787ddbda4b3340d90dc0f946d4dafb7bf86b047fb72e88a7b0f6aa6218a7bc22b36fe9e3be2cab3ea65c8f78118fa2df3e2ca20102b120c8c23bd0a4c6c7dd3eedf2312099beba8752ddc6b74e52b95126aefdeb01b853013de0e801cccbb86151dd34ff2cf314e2906cc0ec5ac5d65b23a385f6e7e7bf952b8a19203fe91341ba6397fb40b5dd5e0f58d509c259adc701e3ff94b3bdb80f5fac4f93b17173d56fd538f0680eeef91c86d6b4b479abad6a1e3fdd99c968ca0ee8624b4633cd9a908225fb6e03d323d759ecc2597ceed28c31545e95cd1957c0ab34c6276c2aa77fa7c0df1b3c1576fa06b435757333f455811780e2ff97fa80df334de310095ca5c8af30fb8b041494b9f87a178ad18b0f814c124a766b81770fb6bb963db4c0b7f1ee9e0035f64613caeee1d52dac71267d753cedfc0dd59c8ee7b9c8d1276c789166b29d6fcbbac9c9891379ae9493cd9bfe6012b00d6e04c725054ff8a00f546fe8dc017a9c8115b0063d5bc97296b3773d6c75d87defa15b0601ac496c607d27c89509103c67701d1981e14705e7138360b60734500544aacc43364c8bfdec5f7d19103ad9394e95b26f112adb4ec4f965929fce912719e5d38bebe1047ba85b8cb8e900d4012a9dd0ce3e779466f48cd5afe561d636ab96610a964bff658d4317b4e26cf8afac41b30573d9bdaa19d338319751430c29ff7b239186c633201ce3fc0859f11f92e3edda0f3d82530f8e1da6a984d3dc155cb1f920fa9f2b73ec30f49f5927dd779fe345275185c91e4d1f780224f6b152ee8a6fcf54d44ce277d042424ed5fa09eccd2391737914950aca0c83408f794ad2cb332dd9b50a1bdc9932cf936cf7bcde475b62545ce5fe9b21ee8196c3a38c23f608480a14fd7126fb15136cb609de55de5f756391c3cb8b504bf0971d52099b3ac007809446860fefe36699887b3d188a6464afa126c34bb8b4d0abaf8e59a6c4145240a65bd64b7b6b91bec31430ea900b55dca735338740285b72c84715ab2b6534c7c596a8262dcd7294d39204d4ed960eb443f4cb8a04b8296f390637fcec9995aa20b6681f30e5102bc8093c372e454fd2aa2855561f5661aa0b0b729ad7a1015529e54f58d84a3266df157c76dc2f3517e3214192aba684e6609713da42dc5e13d9e223383a4e7ae738254858df097f2f5899ce2a9f43ebe6b47c0fa5242b462294474c146e9ff60a6c6ef24ba9b8c8f66b71a3e36e5bba38e979ffb68a6134f2f39cf8e8a6bb01f16fd0537860071e69b64bee3985a98f60c5639d2df614b5250f65f8404c60ee4ea9285f44dbf717362e88d0f04e8660c253414bc9289cd96302bb95a6125b3c0e5ff1ab52aebc817d0fab74a4c783d66aeac8b5bdb50aeee6296b410310bd3eb4123c80b58a11a29f0ac79755ea848cc3a7d3f3f9749e3e388036fdb290a6c32ac39dc5371cd719d2e6832a126ac7958537f371a8dfc77dc9dc1867d7fa0ae3352fa87aad1c556db429e323da60923bde30d0e1b807e754010bb64bb0a0d0babea551a4ebc77f293255efb54f063ae2267cf7484f0d9455e0479ce7b061b7b37e952713ff77aad3d6d61364cf07bf05810f90f45c48071ac6bb40d5d419a78682521cbe418b062ed601a6a062eb829872d309a15f9204dd144795ea15da64c688b9c678ceb033fc8a76b1499e3d95d499df60fda35674afc45e4e2fa976b5389a6e122b25aaa3ed5869d128cd83778096aee9a22c197069ac93c742c67ae9396a8486c89f0a847b635896f6e3ae5448bcb8e8dcb1ede0392156bc8deb947b8c9cf012ec4c100e04641060ffcb54d541ba302d4a8caf9bb4ec27c9253417851848a35c4ed7e087fc35cd60ed0fedfcce02eb350c30d7b075b8e453d1ae7e6706b345b6379f65f455bb7e9e9c13b4c027778914c90cded3e36383982c83780d0d298b43455eaf1669a8e01046d2561f29681d8eda57743f6bdc406d25b42927b7f09131faf81a2211ef02c7e805a9991dfcc8816d582fe763bfaf1812c077c151dd9bf9bd94efdfe4520d19270c972c92373f21631e608031dfc00d93937cf22f1912af026ecc86934d1c90000e55ab6709d051c41d4d84f1b534e2740a252362d06f8d5ae499b1cbdbaeb7b6a545f93a58c5262e54b1588a6fd6444bd0157b01080a9293391c615cd6dc3d9d5a9c50ca26b8fc41ca037a0d8b5c982bcc7200993051ec08cdfaf074b92c2b816dafc186b7a2cff88518671d7eb13a59d0035f27e6aaba121103d337f9f22e7950d514e01fb3a5a4cabe19ad96a403faa6628b74bcc9b42aa21b9794c9b41019e1ddfa892a94a2e3daaa64020a0b5d1a8e5181f78ea5de255c1585ab090668dc1605675533c35b65e5704fafb9f11bdd6c390ea6309208af017d926ca234443df55d9fcebbaba3c325aae40ba8f807bcf60d64251f7d76f361e3b79c0224eed4708cdd3013faea960d61957e162d7e6df9c07e60b8d20b71f050abe1434309801c5155fdde98073c09137798d275239153fc2301c6daad9e29c1934551894119b7177c01b0d54bbd028d3bf548a939034e60b139db31c41ff315c23e49d5483ae7fa6375ee46f09fe4619ed981fbb74983abf89327f3b61ba78526a639f67e5737e9d611abf1390ddfd53b105438a2ba7517dff15fb3e1872ab0ff6de875df13370b31f76d1cee774913680da7dace5c29d08b8224ecffa6fb5fd603a96258d04e10492bad24ced8eb976261bb285e6349c80219e47737414586abe20f89ac384e7acaa9fd9dd82f422b40f604afd92c2130c4ae0fd196223d0625701dc5286499f575eee74571517683bd02b33ad66238374d9bb77f79944bd0785f3406461550f4b9a3a590cdf0cdd31912c8a814084cd5cf330596d9d01a2b178a2fc4c05f7026bec0ff8b8611ac071d4d89fa2caebd39a0f53a4e8333e6db15618f31628db82790ba0d182df1ef8c9b390042837548c268c481d1de1394e5359f10f257f9e43ee245a551c5167ffd4cf8debf37236a981358f7c2f2b9a6ff995e1eae203c43b6ab3612b6e3a2696d964c9be682b47ed4c38ddd0dc4d597873b39d41b44b4146deab821475b4530bb294b23bea62774ef765da13a51a5ce8f8b1c4e2402eb9fb734ce13e941c0413e7b18fdc975b46aeb8ef8db2fe4f6d7e1bfcfc23a4d2f9445d49bee1af9ed9f4ed8ae3f302b6ecd6ac139ef5624c4b9cd47dfe965dd225b4d760982c0dc08bbcbff3bb5d79bb951dcfccdd21aa8ac3e68bdb14f461da9115627bbc2cb4fd8e0fb8713d96141dbc95a1267c73dd02a8f758f4e97497e9ab7b2a198045269d062a0007b2e65548fe5b21e16369a10d10aeb292dea45b7af798330b254a7e9a249a9d327fed54bb9383af114b6695f1f454cc71d41fb5194fbe405061fbdeb138a721615c95f1a4ac17420f9ef9b32321bafdc6c024ac046c1280d529109f151370fd2b368a27d83d132255d45bb761f2fd85bf06c4d11c4a93d34a8dd6ffb52d3f4114522c083b8faa927513dbff4a908196ff96ede7f06db3a21143746a4c852c2725692e074af0acd5046eb26d624875a7df84c4e9025dacd6cd4e5946bb84fe04b6e7c03edd2482e3fdec5b61f7f88f2404f821e178030d4c3b81b2cd975669f1829d13a72db4bc1820d4e381928249b5d5150ae3628b71d4d46e430a5c3e61a79dd0046ac058546d7bafe4881d3c7511fdb8c0ff94cdee6bbcb79a1df33de6891ca9ff480409cf001dc801154997ae597b9816f1f35001cc652a1c50168aec5dcb929c5c809546ee6c21f8f81cbdf4268f8d50194cb7bf4f9cf4475ccebf45602108b2b99a0094e99860d57030ba043381cec6ad8a5d43042739cde4e474e40c46349aa03cd95edcf841dfec071c05a3e7a7251ed489732c44540508cb53f0760b6db3bed58bac036c393bd4a0d9452deb6ee710b872a0e5fa77d9491aa1e34b51bce4369a2995c08511a3aee05dc4269fc22ed0d5e88bccff1d15d179a6e464bdfcd7dfb5b2052baed97c03efa17a5612920fab0e646a3c7dd306a89d1d514f7105969b93799521a9e18a246ccd22178c43840ff84b7f5e5bb4f76c5b206cb6dbe7ee5b174df98e81c5ba42f00308ade84824dff724380540c60e7f42e687a954b37165f86284eb35aabaea3b8fc500a01ae3dc9cdd69600421062fa6a19f2c197ead18249385cf471b0347f868c22a53a99512196507ab5166368acefb142f6e24e9f018ea6e68f602323b53ba1d75fdfb3b0290c40136d98bbf648ee43f73850ef642ee7ca9c4539c9989316550aff851eef2d33e213077f79adbf457f4bbd496d252fe33291162c6f3103b2733f9c4800bcd44e02e56b4ce479c27fc360dff4d1ea10a60a3c7b4876181446eac870de3d73a540b169842ab8624df5e1f73ea83dca8812e13457d341342f95065fbf40434bedac2b9449cf22137e0a876d94ac7803ec7d2099ed72fae12af2c481172f6f38f8939ab1350d2f0e34e9ee16abe2232e2a39917a3888468da1ddcba8eb509b2bef19c215bb56ac33366338af75c7c4cdb780b2b5f5b4606bc8ace9e027d33f42f6828b23d5c70d9fec27a16bbd21d6fd85af3d2f31e7de77fd5914217ab3c7c8bdf891ea95fd090ab8be0347c3487993c5d899af5967acbeec904012105a522c3127a403bd3f1c9dbe2f3fe841bfa59c1f6847e1aa2ab9ccc9bd4754ea6c90a2d2a46871a04d9ff9fbfead60ecd5c7628e3e0bf151a5a8a1d2220602e664e5a31221e5a7b15bb4d66143b923469803440780110f490f9da76d35213022991b4f7e2e2169ab3a58bd989400d1b77eca1ca1020c6675ecfd0fcaa58d20da43824ac42ede592d4e6d5210ab5fc2890da9a2fb6f53b916150fc0181788528ae7642ce3aa13eb60b402fb03e353fa28ad592c679e692b690643517c8da41338ea46d9f2c8b7778511391abc44e2ae5bcd796480d28762a7d912fa68db923260121ddb9d02dd07a45c3822249d76d65c92c5da2c096cbb1a642fee007e81bd7c36aaf7d94b434e0658b03a9751563e55b3557aae7b34dff76a7744f05672c26961068dfdb9ac24c6b71e2681900bf0862ba0dca25bc2eb4be16574de7f3cf9dcb8bdc899b4629051a8de7fc4796bb9317c6ea9ffb97f566455fe7cab41ce36aaba760e06be2cd1edf41da23ff266123e3c37aed3199784e8e4c68d242c610a30419a5b4270ec6edb998cf38f313b2d3d122c9a6a066d1b908379f43bcab794313449537560facc78fe62eaa09ee0325e6c8c8ac8aa8e585ba11d48ebc0bdaaa66893060d9494214ca3d31db6e1e5f999744b0796805047fc26d4f7da289965abd353a0e72ac7d8474467852f535b1d9908002affc289a01a346e8b4b379d748c14023e1b19fc57cd26c18e43a69adf5978c9242f12c077ee77dd5a135037b8cabc736fd69882c43fd98a6537f1cc642b8e8b2b726f9821de0d2d6b2356bda9fd40dedd81a99f1ed62ca393f82aca31d9455637c958adf809e0ec389fe2d40cc646218b5be24e6dca7eb04190bd9c320878acd6b4c92664f474821b459574ee108403b08c183a648e4006d30e278bc8840dadfeee9344e1d7f8c412208778616e7836a4fb0b05bb650c6a23f054517a98403bc47469f7accbb894eea2a98acd637e08fd631bcaad3f1e93a43c10d62fb21354b49e15e389f109142d4421d101393601fb36bb131d2421b7ccf4f69428d4a1e3fb19ef6eb397ca40a710b12769646cf9c7b586183b326cd6072c6fdc395ba83870e184cca59a5bd0ec6c9aea3fe92ed46b9cf66242bbf13cdaf454f2f94e75d13b81a184b3fbbf46a77b8d361d8c36a88b2801c1e169577f61e3e9d95e12f778915b78912252bbaa7609b4965c134620764619f1a2a3831ef474bbc51337edc2098b17c2caefe5672118a944fafdd1ff2765cbcf99ec0bfb2f6f81f1b80a2d643f064d841cc9db1a2ea1253e8013880a47db10ebc59d4863a23c3f7d9f391ade0e82a760ff66394d9d8e75c1f19a19aede5427b0a0db76f828120f67ca95c3095fdc8e68bdafecb9d5a23bc923f8bd8dbeafbde19135790a6619e9c8aeb81cbec057f2e75a886757ad6203a3e49420ee8abaa1c2aa49450dff2966ce6b80080e64754a80b5438857a2bf32096b247fd1d77facb49b99ca16f5aad9de8dc67cea8dc177e2b3f0007b151737bf95ebde21efa858381a5fa42e3e7b0f829caba77b4e69c3b7fda2b64c4c297794f4a736e733d0620fe04bfaae201ea6952dfa3a05ceed8393e9af8f40396617bb3a91a19feb59767cb95e780a4ecc68dab4f6f9f159a41d088edab78f7eff24b5e628b90db302164f7d0eabb645a7349d34573cfafa09dac6a435d409ce1d5c989c70b6cee1bfabf0c5cac032a59b2c95f8048f6790261f408d80bc5155563968b3a20fd11ef4ba858daede37b78d61dfc7c45beaad654c04657ad70d6b49407cba5cf8fb01a71a6c203929ef121078e917202a18d9af9aa5eae578b607d87c2526ae32adcb3be6521de80dc8ca8fb53a68bb539e99729df5c85dba5b9a9322f117dcdf11026c52d6b7eb2214478e0b35c982012c5f55665a3ced487beb5b5ad8788cd377f2685ef685cf620ab76208154d595ea7da6701f8d0310be24eda87e85bd9e75ce09641af4d420eb62a8ba23ca853fa04d9c1b3c9af5cddd8912d446cc3c66fdf5123460bad37373e388851c8ddded7603ab2ef4fa5842c7c32bf7a3d72c1b7e3652a3f81b061aa57172afe7db268694e726c030d33bf41f923c03cdeb3ade8a34aa33fd4099ad20622e2d76e88f95c7ca0b9d41403232690022346315056a0e89cd9113140edb7f34d7a8a2d41ab5a64eb74f61b0f6e8bf1b2c7662c086cd50e318ce381703efaa29ebabbfb68479d21189dbb155ca928d1a6fc71a0da0cc68834521e24f7f7598926d1a5a6c673e2ff9211ccc14e22f9648b7c9dedf37099c60fd25854f01109d823727a0b5a5ade530d0d2cdedf6fab2be6ff34340bec54a1d074c3f19894f9ac4117a17ef5da715140ce791dbe774d443a2645594fbcdcd955123bf02309423ab7e60e69c671dddc44e3a86fd4d24e48830ed1b3cc6e75f3a41ba745bba5ac62e3e912f4ece1e350c12d6ce591e04c12a948e515572b9cc3cad63fd533086f765659a6540a4125fcb270a0284aaaa038f4ca567cc78fd39e17fd7cd6d09537756d66b1422c607c33f7c055c8ab23ab90513760cabc90106a89d5cc3d0575e190fafa89847cb8f44bb62f2369548b49ac2e43976c9d5c864a526f650f50f886f39fca4dab92e5208a8f29be4794d36973372935ede84c94548656b38ce3677a309657f1ed89c54d08bf89a3f99ab48f732f39ca725700970a0c53a91b3a73fc1e39beabd9488c42aac393691884c6adfbe5e25226712c9731e7449f30bc6132515ba9eff81d1e76c5286af38dae8f8810b7ade836b81333f7c8d9d0d4ff02a5196b3704646a903281e0f16be57a1725fd4d10f782dccdd4bdd1a542f48674c14030b064b75d254d4a2a79eebd1dcc4e3a38a65f8da01e54412c46dd42b516b4936b3072e31d07cd79071d53aaf34727c6f370373dcf73bec5a6b7bc1f7c1eef37adb0892da0712b7a2733456fa576d73ebab6670f17bf80aef53094d056fd6aefbcca943aa1a91052c9cb39747dec1d320c346b16d4373d91ef723d08c7644c570e2e3e9be0e227dbf04e71c676d7566a1376534edccb11840ab3e21c4e4bdc2abbf2d3d22d790d4ae7f3dcca79cbb31c4c3f93ac8eccef07c99fb3676baab35c61300bd36e159a12c32fb750ebc6efe387a8a56dbc281e417ee7eee04c94c412acc434d9d6910b17fd0c370583e2e7a080f1e8e406eeeacff8a8e3f843917ebeac4de8483a2dfc20edf676070dae56e43e68a4e5ccbbd246b913d70c906b3bf360c70eb450cd9280cc4ae90a32208b676a945f842afddb380b814062de2738acb17d71343533fd644d0a0e9c28eba5f043aa059972c5e3dc556e46db781fc6621bf02db944878042c7a55ca8d521249754f1b943e63d43f0c29348b7d1359e2ea9694048931dd4d053bb39482be28dc01bdb941ae11244667091eb4bd5fe7e0a73125e5bd2216e82861a59da2923897b554a9d84651f997b9db2350162ef4a33313b081276676ed7c5b51bddb79cfae6e1faefb606868a9afa009fae1d3430b8878bfad80e3d8008a874da831328b922f1b05ee87327355555a22fcc0f7da20b306420fa0720b9b86f0211ba038cf6c802d3b7b1a32b51947c965b67db470d6523ef5ca4521c8882ac853a2598a86ce95832ae627fc759024f6b24f284cc78100d6bd9457315e6c8fda4ac03d9eef61838d7b2be5a52fedeef664eef00418ffc7fbb8376a0852cbe6f55773a095e9987cafd34929a9bcadff914eedd3c99d52d0bfbe1ead53ed78d87e311ea55c42e385c639cb610cb3143e53bd206e1e09d372065ea4c81228c51078a7fefec79371c0d17c845e928eb2572a7ba83a1a27f7dbd4d1c657115bf64271deebf59e9e765169a65ed143d10853e3af76cc9997ba1211435a05f96731cd9fe8022d41a7792243e558ffa54d2c9c38587909c2c206e6fcfb324096efb0122654cf049bdd6000ca66224881898fa54b837c92cdc62741a827245893bfc03ecbb62ba4cee2ff4694acafcb97e62849e7cd5fc82debd585492d9062119af69e5a67028ee9beb3ddf4dc9a23e6085df795ac8293634b4e7f46aec31f9a2a49ab67f9e976cc34854b056bf3e3cf67a38b6442e0d8b2fbda6abd3515837a0d4fa17a4c6a57fec7f9b89a692bae74aa17f702fcdc6ce034142add51bc019a9ed6502524ae50d88d8f75024b3bf28ce1a9f0d1bfabbcae4fe46b352f0a11956b73de0e50e0d4def57604682c3516b75aab5c72d240764b1c7ddb67d2769772005016726374a10d4e383003aadd41cba8b7779d3701c0c1d1fdf62e017d3e050d3f641230d4792e9da5c71391c48ae3b05b0902d02f33caaf14c0255acac6c3f129a6cdef5519355714e8d33456cdb5fb095cea11ece4adde922640ea180c5716ae34702c06e82cf1436820bf5aa41f0465d2d725d91ef30c365b2a0998108933356f79f594aaa0c811290c4e7d7115cf753a82ade1db2a5c5f2cd8702635ac22d0542ed194aaa395510e4319fdaf89ea93c885ba98a7bfee21f5c37723fa96b627cf9700b0141caae6b5d4a948ccf606d6b415ff2ec20dcaa29eb41a1fcd7f75a79c9ca4179dc019cdf4ca29ce62be82dbbb98ee8bd35f29407cd0067094202a452e31c69a3148e77731b149a283996ca8fc4a973a755107fc0ed60fdc7048382e19095c61ade81e93ffc35ff50f110fa2e11d15d594926beb2096e143b01e626d93569de2db02672596f9b991ab7b9687d33029cf86596f4c9d30a0987c736b62063f6d63c3101ba82492715fc6377465daa96fb16a0840a332b9d0f71b4b7361c92e0716f51932e51b45b28fe8233a8034ec495f8facdd03cc8523625d3244931fc3c6dc77041b9a996d4157ae06acf9979ab776b19210f219c22f61a6649f982b6452ab40a8a4c388e394a7bf2d0963be9089237622df33ccb22689e4c3646fed67a6639003b54a0b0bacd20f497511de7a57cddd50793285943a3bc2332ee8d206b4fd7ed341f8939e94ab8893ba6a4542497950204bd08da3e01b0acbe3be5ef62d60e06043d335fb89f8c0581707038ec5fca47b277b0fe02b43079cd32e90520a0dc8c9414e9b0f1b4257be541c84331a9806eb9c3ac9b2b68f9c59697b1e3bc75b5df68aba20dd49243f6905c9aeef4704e0aebb900b9594746ed7e6a0e4131ced288e17c1d7722e32558c0b03c560e1aaec2eda8522b89a0839233e613a0c11e666d94b7e36d58a8eb0f5cb30ac82badcfefa440a013c5b4cc45bd95d28b699311ca82ac8650307249c6eb7d57c8ca41bcadc1637b3bd04343d71173dab57558634e259dc4abfcc126298c46288d36db822bd3371713bb264d68d94987d1c32375a45eff16fad5d70980b3ba25235f64873a5e6ca6a695062e3aa9a240e33449625221cd62ce626f5cb18144589d0bad9cb1929b7934874f9624a28f2ea2626fcfca6147be011454988282a1f034268ccc0166fd3d81a45db66f0bf82f2af7222d495188e8134c933a5f01633e874de6312bac10414a393e3bf4e033a11e0550aa2483acae009408dafb6a53e650822b6028a63644417de8b9aba810bd4468537b21f87ca856ba57d53fb3ab8876518311599e35410132d2b4f0125bb59a0ea2fe7591a9928af6467f57d7eec22cf09fc4b78461135bd841d5d07458993b0c2db46931856829894fd8d83881f41553bef86317742955dbc412d5ac3aab72b572b734ec36b1136fef17881fcdb45d5d0f3c35f202bb702436f05f417437136d102b6e1078a59c0587be33a36f95e993b5543f7ccceac0b6c8cdebcb3515e5e3240dff7ceeb2b477c449bfb0aa5204f0f2d807b249a691a70cfc9765107ee58ac5e88e68b309f44e98f4f9073448f759ae6a44a8f98ef886f2e234bfa32a0ed0b9ba60fa1c213db1f4795630ef7710d6ea7ce5b99b619fd3f615f6dda4421b298b12c8bb2d6d9233b698433e28e1d4163fc3c6b2e791ae2230e880a8e468ccbd5bfc90166bbc73dc82de09318dc054cac8a59bdd11f65f9ea9eaadf6e20fff64d0f298f2cafd7652e41145accf8a41f4c5ca4f41046716381210b8e1b21139af4ab7f3c9f2976830df63f8866433d2b6f2b18d205e02a7d4506b8cf742bdad4fa100e945207325b08a1c91e3c9418e6d17510629d5ebe45f2375ccc1cdfb6b52919ec2e825b8966828dee50119c36c421385fe7db24ca5280150931dd0a6058241cf835f81d3ef086c757e02a24f026b36013e09a71ccce58ca4040377bdccb8310f524d3972bb8abfd45735d9b985630a9e19ce3ba2061ff91790b55b4f501821e9053ce9bf15a591b968feef0c132d0c47d43147f5083e8cb3c05cac2118686c48e39ec0d49a8d0980e7e0d3f9a58e38fc6b199e7163f6f301c4706a8db6c0c82ba7c4af4b998d94dda8794d9b17f79f5829918805287b9619997991ffdd4b351ee73ab721c2ce6e5d2d3c79da64802d930067f6dba2fab20a9b670c29fd1792fc88b8545849364b920d321d3460df3e8842f7c045f85e3e55def3b81ec4740622d3418f80fb69da3897740dfe271632d2623d453d2b0c7b97589dd7bc5c278514ad37777c62838a2195b9d84fa233614cf933f3ea8d374793e93c1f3088ce15a588996e3dd77466725f1b7daf0bc9ba7063fbdac378a7b28972a7b20eb91750a26c8f7e30a6150955696cbdf93a3170e84a182c3f0f30786a8c0f82ce92ccd60da56ab4c601f45a79d1effcb7d17b978455f392130f0058e09d7da2610ebb3defe32af6fdfa95e21555e5d67d2a2491149fcaafa857d0609682ce1ccaa7533d","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
