<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"61694cf7597e5c6f166bb5dab12b6e68ca58a6bf2ebd61da3c7ac2b7f029153998d9bf9c6834e27c2472768bf8c49b02705605eef5e0f6813f2897b65e54d1b884fe7c53417dc3cc9e332e0a1776f1fa9f9e96feb34c9453ecdb0ccc51f3b148e0a66b60619eba7e501d77c05499e0f7761e4c0fcf414316b22d8f4da55196dc5d713db13f129a33ffcede1f70145d8634171753bcf1a932eee1da13a044384052b86337ba83179028a21ba085c97339dedc59d6eedf9db10d2f212dd1b437e33fcfd0d005ceb1d37730c86bef6cae8d6177f31138c53cefea459b297b88189291dc6b727953abbd4f2c8fd2cff03f1fdf0f32d93ff3e613625cff4658fb0311cfb275eab2a80a77a161c1cdbf258001857227edce880fe69b2c2c4d65a2d0ebcfce7898c94d192a1641a71e3d9f585ad0ce54afb906b4b2ad3aea2a82eb8302180076052706343e6ba7bf9304700aeffa7b107cfdd4f46fc1394f3e8d2ae335ff324aef9b82bc6cc3e5711bd042ce54c25479fffb4d827bb05c37049d7c55efac115e334b2f24efb359ccab22f655ca6bb09fc6542661cb68ba8b803bc2dd0c78d4334f440972d21a56670230fa5c21350be3232d755fcaf47d1ac4c66f0061602dfcfae4aa3a480eab440a15f32edfa1c98b3f334d4341974391b2718c2836af3c4f3715e9fca51403b9797cd0363ce55477989bd8fa0ef7065db9384159dbeadcd38ea3d293441f996525023169bf84fc49cdd5bd011688dd641a5c3f36c29c50ae767e5ecca80bf6cace3e79309ce1f6900e402853e7e5372e4807679d19728f08160cedd3c6492ff8d47b2dfe8ea5ad273f6353e88d973a215904949ba9f1bd4d785d828193b17a6bff6968bbb59ca546f55b847c555c8a2f2b51dd7ace322250fa36db7a2017699d6d2c94403beaa8d7102701f428bafd294bac2ab905bc19241109008180f7a2e8826e85b8a16a42dd4ec9bb6489e8ae998de1b76e95d9e87cf3e1925236e473eac98fee1f403dc5f683776197f11ec0a37f0c074fb76207ae5751f60f636a97af528615fdd23c71d5729b30a7ee8b88e1a8d25b92f92132d4605fba27e8333aae2f7da3fb82712cf8744d2f4aed4105fa4bec2b0cb40c143c0a2b7c682d37ed6ada628c7c7ca25391532911d19f1e971480866fb7ad9000b7b767628b84369a73a87e03573c3a5fd4dbe8c8ff6433ee468ea4f13294afb35efe1cb935bfe1d037dfef245320bd655aae8437c553c456105687573488139d98274748515d9ad4c034ebb7c3e583f8b88826bde216709002601209647b5e49618a27edb90bc1ad0970abc2fd9fc3799ba4947eb5c7b57670be23a36c3c1c979dde95a750e70fea534c6a70b19a4fe273a1e19b3fbbce09a3640c0a14664d0ebb6e992657d0447f39c7c1bf4cc4203ab3783e0945751a7829347ca3a625d6961f66d107a5f40ffc89b501d28920b7bd27136b43e301d24034f7f30f94e746defdb7de7e0ba1cbd52fafb79d053e060b66d3fa5802d9c4667e45a933a0e779f44f2a99122c2ef265fbba224bac4d09aa0d2c37f576a75131d89437270cc110942938c474a5e219db8cac63fc93f319f4042492b421ed42f0ba266bbf135812af37ab11b18ba0a98f6ee6f16e51f62522e92ffe0db9fbf2845475563c97b39711c91bd167b858c3b82073bc9c37557a06edd5cab770e606d3abb38313953e2873ef30cb012cd8b395f3f9e8aeaf5ae90df53d21d77065988cae828b976eadb18df821a15bf0d4a296898ab1a05c74f4a43b10a0196c692324379fcb67aeaa18f1e3c9ab6e58d2ec5a0472ef4a511cc95c39c250cf725dfc6d8f7d478febe71061967b8bfdf7eccc7022ce6f0e25adb11414221de87840aa1e1928aa34b165134fb6637077997f00ed7638f9499022d6049d379edd803a647a6541947a32efc03413f815e4651ba11af7e01bdf244780ad6bc5c3220f97b68be77837220319b304e088a460af5f25260cc1213a8e995f1b7d8f2fb61a6159d522e3d42cae0ad091dd21a7f32a471642444fee2ebb44afc7627b8c2c93894bc5cc93fef5b6620600034f54a7c52f99de82e1e5bfdf91d9d857872ead1b44a88861ffd12551071972a0652ac0c624d09c040b55c5e5f28fd386c79001550a40cfbe50765adbbe1cabd4faa62d2b080b0f7935b8c0242df165770a27f6f9ed0599344b92ecc42bf44de420d08576a675953ca18e27f8b772ffd4307a74951c4568a671851b3c378d051790c8afe0174cf9614360201fbf9ad6de9a9024e7c1d359c90be14e5a3dbf1c1c46305ba88e6e3d18b714596eb3b87073597558a02f799a82674b200e210ffdde8b5d42088ff1715b31c43248cf844cd3e1d9cbb4c58941e22a34273ff75c0c7172d21bbae01a41a63fbe4fa1c62d3f8a699c7aaab3dc5ce9eb855914770b3890976530bd4176bd7da31487c058f0a3f1fe409f95de63e46b6df41b5b7a8f177e0763ebf18f6e1dffb179c596ac1d8181d295d392f004ca9a4f48cb3c54b1496def15a6ec9253fd12855fb32d88c80320be7001fb144d016f7f74db9d9b401f7ae0c7444ebbee794e5ed7809bdfa9b41998e3acfaf872dd6eb9efd00a2b01fee0ccdba990ffed29f0f6521754b373a1929366ffa21b1f5c60a67aaf19aafe925ae9177ae4873974fcb2037917fd1a9121855c18ca428f57c2aee0c5e6f3a162f15d1388c50318ceb70516af4074728a97da66df7bd55c15082aa05fae30afffd17203830498e31b4f09aecf8ca63fe885a56e3937bc6f675856401905f693e706c4e393f1d8194ea9bfc02edf143020352f523e286ac814c16cb082f5594e9544f5eb94d83da8bc9dadeb586c2943bbf9983b7e94aeb0f01a3d307b2af740ef0735b4166f9641bd69ed4ed1496e493668142974a2c9997cfcdfc6e2d6b56a55a2fb6ff5dc2465305b108f5115a697d381e969ba138d0e68d6028936b8a9474a64ba6048910b0a97cf092f453da1228507a209b11aa6039fc865e34eeb103eed8d26754ff7c8af54e1838aa397349ba6f7e6377442a4674ced21c6a82c24d92b4e8dca9920f7f2fe49f4bdcf4e9250b90457bb7902bbc35cf8123fe8e2629005769053fbdc5793c16e7ca6c95aa6cbfbe5feeb8c55c35dfd894ea341556143979532f39ef6eb86e2dd587c0acd505e57eb82d12eac89006bfd4f6633fd5deebb7eed4796add6a698be62c03908e796cac2fe3424a48e48f3478027abfd36337f2628c5177b69de1c29ad5f66da397f2190abf35dba7a0afbb46dd2b464ae80c803b940289559eaa68bc0f712a0d753e025861163a44c35630945413d2dba9b299ccee2f5da4d0aec8c83bc46a0b9902279bca972e445d6b83b15f6eafd5616c23af59dd21416348bfb0743272ef222ce35dd6a4d34a59033d35e005e608cdfe2c5d3aae28b3467a343f37d7c5e8d5d2f4edcae3826e1cdd88621ecf7db14d7660ea73633e6e576af6da0863e1c227892d0cc28060b01df94650edd419ad103980a37bb93f7c0fa39f6d7f7df0f1a1e067255c247b2e220b2056713678f327d869db05c4256787c6294d5a2ce7c1a23eb5e0e7317eb34fff5506981bceba06d8051fdbe8ef6cc7319607e5ad76a8145f1cd2ed6b5b2e04681e36101b164f172bb611428269c0c7b76770a27fb028f8d51d665259c143df02ad7f8d3483b978d38f71d4558383ff4b5a71158d6e094fcc8283ad1a9eec91c7694509546530438a118268682dad2dbbd62628a5a9c9565907f8f921901b7791b40f881f7d4093b7a2e6c00a6a0a3803543e1200211f780b335264a6dc1b7adb0d20252ffe9b98df49cc94b731e582894300e9e39d34818160390da7a4959cd856a0756a078966746be4f7ed93c992eb96b7250e846e718ad10ceaf694f4f347ddcc19df87253b5de11bc5ff5b87ce843834e22b8b0e949c9d95f9e6ec893cbcdf62a13cdde1b3d54fee0fac35117604401ac475bbcf1c62e6650f47e7a14c0781e68fa53b3479a0191d2f918a865a19ebeea98fb32b5542c063cf99d36f31c971ef01fadebf6f9bc434f2e1e22ccedf1bad8b122c6ff86874485e80daae9db01d643338db3cee190847a40bcd2b950957c7cd51ad13d4e84b9e5b07fb78ef29ae49b57ea5db5d48985dbf1f4c5b04c54441377957629771ded4f6052e1f4139d13ba783e0e9e75c42dd866654ad6dedf38285e257b7c79f1d3d355c16b220acc63814391bdde31a83a2b91a7a9935778764c454082f2ce6b1bd116fbf908d4056b1eacad7cba7f31ba4001d8290d8b68d627a7511da1bd46e86a60e49e48b4ccf2dd0ed54d08318b3a5f56e911789817c5671e692032ec9e9f8264387268cae263e20ad798fb0627af3403b8e10b449f0491355cff6c12a1558ac504ca9a49a5c7466f7ec84adc6c9ce4dba80e1cb3f989a56c2f2972b9aa802cc170368803c4e40df0bdab6ef6d61676bdfd68660b98d0cc6029b63367a33524b9fd6667e699d1b929c2014141a44bf00eb08a216c36faf77feb3c9fa24e01b06c0e173a14c0705374ee7034e5b5f786372724da466151d6050529204d43baea85cff94368e70163f282a4909d77b5fdc189aa9920496be97c11308f9ddb35fccd2878facac3d17d163ec034955999e5012d8ca93054eb20f1d03ac138e7715a4835678b06d5a68a2a44db8b82f7bfaf2b7f7c136103ae714c6603d344a4ebdea2b2458da32e4d9055474897a095628d5b4a9ea9b3e49f8937f64060e075d73fa2b55a2a7f792b48f2f95d8f5c3842ee4ea20e5b0998f6b96aa21aaef47cd0bf5dffeec89c80b8a1eb21065d2615162ae7dbeab8796461e9777d6591e01fc9a93a8e87b2cb2a41381a2e63943e93cfdfed7eb8b2660bc576e1592550becd7c842310569fa486438f998511d1ab5c1d3c46584e698bc125c409db6f7c976cc1b9e6988f3b6b4a447ac5a4f5a67f25d17a2492feb766e28faa816d27dae46982067430d71364935cab8c89b6c987c339a02fdcce04734882f2bc809ac747b2a4c0bbbca045407d7caac891804a55fa3b9b06a3e49465f00ddee9c61fcca8dc4f6f5c9e7416bcb78b73c84cfa1f7ac067daee625d3691a7ecddf2d288c1cb8588410f7c299b8676a9dd2392a9932bc258d11a07f47b4730595e21375a223908cde17f3476df652f735dd00aae8737146143121a2ffb8e52c010f0466427e43c8253e6381d2449b41f2f5c0b17be92ef00c118064d0605c2a3ca043ee3ceff6d8c52e37e59f4544f0d856394a95fda1e4474c224981e8f7889022123e8701c35c6f5a7d032b024d934bc93fb6ef542d66c9a681ed8faba89648af1eaf59bc648b29dedc88d91f7586468ee0d6ed9a2868aaa16f8724499035b911635271bbed6c9411096809be585f3a4676152dde4137b5aa5eb68251f735685f6bb2a6ab2fc570f793808cdcb10a5f82691d728dd7b12baffb24d11e51896805b38f193596d978a2e2a66dd2d37e66536bf5c9efa4759767b1c7070b0e4b91f29c21366cd7d7a3db16503e197a58a1462c504398ac490f9245df5379cf524a810e895011d581a2c7baa079bad755f3122ede4bd8c795bcde802c06bc7f2dcc0e7d47d9080107af6cbd195dbc181412396b2bb6f1ac5e3fe5d064e6bb4157de8fed11d5e41b7a22b89e376720f707f7790a658cf5d70b7c3e02fac630f69905c739e2ce56fd43421ed3d8611bac0d7f67d764d72baef88313bbbc11cdeb8daa6090480bbcfe113faefaba229f145e0d56ccd726f0a08abac30fa618c5bc46360b943bad879fd1e1464f970e11026b3c1a2ef913314a4d128c33e388712ee9cf6fcce5fff1f59f531c479c1ffe12a4d8fd1e2f9225b83498a1dd52cd211a6ed027558124307edf09afe308a46253f118babfe8a36d166bd0d9266847a278b9f61b9fec50d05ebc31c6e15e586cc35ee38c9eac9f75f1f7450a490ec98fb4d1aae2f84eeeefac362a50e2a800c795923541aba6067fc0c32bc35073ef4776536f628f3e57830357adbef14455a26af9ed5bae3f9f94b541c3bc3223f69df2710d016224d885a02f37548cfb3a20df7a2ff26e16c831dcf67e069c51675eaf5a2f2728555c1d717e20a3184aee95734833cde51b5a5e759463355618858f0146b2afa32b7c65f0b2c3c592b007498a72647e2af884fffc852d56f6ebabf28b8300093499335bb77b9a0449aebc6577e4cbb85c7854f11d0914b8f1445c8e79bfceefc2d62214ca88eed1c9a690134640763ad80dd4f231d645998d22403eb717796e1689570230f517dd921228915876bd58385c63039e902ab6af8d96305ff9c7cee46f76da3624189538eafe3fc7ffdc45be595d3ae8a3fde459c7672c7176867f525e87eb5f764767ed2f89c31c2d70b1c557bd0cae98e7c7082efa40e7c8ce693322a48acb1c810e71278442aa7da83e3a9c6bf0e4a3d5b02f1d7fe199e077ba206d831dc771e5b4b9c4e5aa33aa3beb6fafafb4290fc54092919e3f4d5824196d85a51e4e88d7c59d161399219cb8f2b84051db2cae7e5f7927c0d8c72ada8c76258992994cf5c3c38b3d850f8da593f3b5eb3409257a9b4893720e7db062a99a4b5c91a607f9dcd38bfb6d6054a6308e20e2d0a2400807a1008539e761077f1118bc2592961336ece2e1f16facf1be34f50bac7a1abd2c997049e77e588c76b53bf52bd0459e4d9b4780808ab5880f6aa5367aed6deb7373be460f3f9eb73862978e8b39c716620145d668f51b364c1e548c935dc45e2596742d5cb15e0a69c99084d36f50d3b244fd5044d41c4036c06edb71131e704a5c7b17cd9ba661531132a406417b6945edc7f0e4bed4b61bcb617359bb8b355308b8c32862400933843b1244439c19983d95c20ad8eb060e6b8ed056b50ffd5f7b729f1e3875fc5ac7b02f26efd833a9c7d2d192f8e8c4258a26c8b373cf9a41e1422724c1c3698fcf082c452e9cbf768c9860b56c6b8f2e07ad9b3eb58d981ef9d3d50e729164567b98e68de0ed675f7214ed0f60ceba1683b8cffff8b1f7533ab0161fd4951f27c73bb4a47e87a13a2ff9b297b1e5596990b09b8f24b10a646d84380895698d0e57a781d74e25fb7d9e8772ee8bc6a01b752aa458d4210a482cf4e1950f8bce06bd518208fb726a481f1b494e2622b7c5fa5edb7f7b5c37e11580b8c2fb1ac8529b97850e556e0747f907926f210804ab5d04ba9f865c6f7902c7ae1f553548399b52d1c687eea7e9b9f5b9a982dfd0b9e599b8aa2ab5cf4aa5e326ffcdb7fa18d078bbd0e287ae86313efd877a402e09eac5968b7b01eb4c58cfc8bcd406498666cedfba901b466bb98e66016df261ee48dfbf6323342e950d857e93f31605029295d1e049f141c4ed6f2040749cc89f9e14d5f282e09a2f10ab487ad112d084e844ea3d631d725fed12d067eaff1bead86dbad893e61ddcdf69de0ab133b08bd0297791d75c3694434d0afcab18dc60134b4abfbb626f35ee0eb08fa7be8f4ef2e5a892939330bce9c2e75a4dd98287bf6b580b7a9029400c12e7fcd8adb6f84584e3d6f5f96a4002086839c80c3a5eda1497a5921a9273b8652e3186b345536a4c8846213542dd5b3dda411d82e3f8e447bd48de710781ccba4151ec825665d6c7df3afb4b0c178378b98babae12fa16c7a78c875b5f85c74b5d1a6d4b9a16f04b0fcde7e9bf6ce2cd035f2f06af1fef7dc7497b329713946e3eb387312ca6c04149eba24bdd30a4977679367639a7785523c5b0a1924407c335db3509fd31109bcc0e4bc694a99ae8d9a8d911588d9036cc03009753b4a4df6aa535993aba62bbf44133a484ff64aa1a7d5e1156a67aaf84576db32e93911f0e85e6eb5f7af7cdbd5c2220962a129f9f0e966a6c317e9a46fda7041c3c4b8d4619f08b65781e0b2a6929980accbbc5f3ec978204f47734603660d4807f091fe840ffdbd6d7f6cbf7ff3971032ac235c5d0e124ed4c2895265414d68d62f2b308f457b044be95df3bac77f692806245823acf73b9c602e84b167137ca92e238224d9fd76dcfbb60dc58f37217a4bb5c606ccd8cd9c08f2506046198c422ad8f004a14b53038ba177a6310bbcd500575ae66da8b603693abe86993ce0b5b8482496d50f95e5fbc533445e80ebf2449dc0a27d7c9bc7dff46d7bfef834e10ee1c17466f865d92ad554d1ed9bc9f0a8288e607fa9ec3e6606d86fe820ffa7ef5f215872f1c5b0cd6105c588535eba6d7b9dbc8a452636fabb2f1aea2f559242e8569decc1149e0cdc53ea09966f96778ca42d3ab2e649d1ccfa6ba537ce6031fd5912259a24659e4afc30fef9f5dc82369bb0259ae85edff7a74b6d5c59d75bdae09f42d48db7c8ce98683c4b4da4ff04a2858d4fe8238f1a9f7e30390d46b96e7b5f7051ce8b34ab8b8bac54d9f609314798d9dabfd8b17b028f5bb27f18d6209c3646938c41eec580226f5a5d2efed59151ca5da1730f2604984b9177d6d48bf92f81726aad3a56297b0583bf1e2762e1338df585b783bd77b3960f6d86475edbcf20044ba5a4fec943c796ab5283200fe4eaa8a1e22f6b9890243a0f28d89ebcfecd53f7de30c3a3bfb9d0add0e1d4ca8a77185c9160bef21d6e7e84caad7add1c8628baf11452f0c4172200156ff27c56e035123911ba42ef06080a8ba45048cd775e9a3f041fccc7c238f7aa3aaf4a60ab1bd0204abce8b26d6184d86f0834160c25943ba93b925ece13ffdb86d55a4763a93074b838d0181efdf6df6911bd1db298dd245f504b11e28bb452b0c094002ee5dcbd728626176ff978ca3eee0a312ca2ff18d82471deb375abb31603bffa8dbaa8e87728a1a33229ffd1bd15fb815909c6a7d1a3988f8b13c5c5b0de02b1f2ec527d62c29279543273085796f2af3a239c232241421d5ef1ffe6a8e3095ded34d8db050440b76f2e6f6a978f59deb64a9e30a90fb406f610eddace65ca1079879bd5bce191233324288abeb58b9e70bb72f30f610f82d563796ff1f0cb9084b67d00cbe9c489f617cafda1be99e7f2c8efebbe7170d6a49fa2c4b5832bba5a603d010a0ee41d51ac0065cd20f2fa67404bf44b8698742b9aee9b43664a36e7b4b4ee6b85d42e684124e7129083d9e353e2491e44ae00bde8c9c8f4caf1e64ca392a99979b693b87e309c2f3863b964831b578ac8d0b68dc606df9b759891c005a0af8d6b8b26bfbdeced98a1233bc8546ed654b860ed2ce40a266d3e58bb175beb23117ffff51170f616705975326073ffef850ff5456d9a7eead6f7caec1572a0852cf8cb5e2dc3607451cb39510c5bbbc585ae3933893c7fe2bba451b7dea4be1f7e3062309fbea8cd09d02b3af956ec2e5e79d5a52902d34bdb3b50381b06ffda95f0d24dbd32e333b088c1b472a7072bdfdab8b2a3ded734a7e9b042c8ea99d2d80f1eaeab619ded113b4b0d340da16b44e1675f66a00bd1576c9dd2340d7537fd0888cd9b021f7d2eff50adafc66735b1c65c651c8f87523b6bd7b85c8b626ec215a58e246341296d31136e741cee96023a70d1cfedf4e21fdee0bfa53da5e470b665544befb901f016305dc4453a0195f0767402581cb674ed18354a055305cf56ec6e511aefa3ac7cdee85a3f2bbfdd671fb0745e21eac20a8e307e90eff9dba0373603e700dcd9b8741e47629a3c20581518400cb3bf17179eab2cdafa25776e11a3eb21a312d0fb44ed67d1c87d8e99490bbc2bd3d5b77aa4feab043274f8379b5c07a6ae53255bb6877e75dcc5e921af26fc7c938fdadacb5bdf4a78afc6aff3f81cf17466042d53afe07be96981ffc234ac811e590d007294d2ad53f4d3204d8ef699c447afcff47f4ed77fbc6dbbff301c5a3553f985c68428af01aecb4b39a5950e63fe45d7d35aec2147a8b5db66dda211f8c416523ff852783da3fd9536c21d16311c9f2f7f898c2a22849926752ec0e979066f7a4311fa65ad408210d32423f1b99ebc1ac17d94ff2a6a6a0b8bb2ed0088419bcde768220fdb5dd9b317f1e6e5d823670392ebb55bfbcae634055bf92eee6e5e3a41dd1a477618e63c959952d4c349a279a6413fe6a0d240d2ae39d6a3dd9c14cbce20283e4599fc05ce6d0940fe2e3abd4fb8b8ae5dc8ff5a29e9f94318b21e2bc4fedf2bb2832efb4c6e799744276f2f31bc12a62908147374ede353f4048e2bf679213d7879a59bcf7b8d0265f52f0d80b7c1059a51a00b1d961414d6aaabaadca2feae3e37bf95b6a4acd11b1e0289149edad860efdb02e08dfc26c663b6b61f2c8fb2f0e7cad37f3211b07a232605dcd47648c48c7ab54ff2c128fd42b15ed6ee56a31d1d0b1103e412d6f5dbe19d9c0689a341935896469eb49724487432315fbb1c67d73843d812af60591272333cfc4c88cd6c747d1a3dbe79606590347c4522ac72e854051665a5618e6f5db038c20efcd80e877663e901568c0877526d27c573b580048db8721c2a46db3c92499ba44b7995fe8209b4bf9c95ca71e612a466cb60626ab7c24d8ba0d41cc32f83e038b60b1e9ca45643642bf1042f69505d7a356646daf8f8a9b86d5edb392625527b1d8ca99588d8e3edacb5ed051009e8489a412d2e3306e4d850c4d2b12f4d9a37d33e1cae2d89f9d18bf68e13136ca487ae80ad4573266c9db6f1fa49e058d59cdd76506b0151f63f3953a5206f1f58436bd92d7016366abc79ac7dc3618213801a4990cf97910056c5fd7900bbdad6bf751ef6b70b062e0656d9161916cc3187b5b3d43b8a70753f39afc72799ec1010c0bcb5e4be98f70e461dd769e017ab29642495cbce41d6205315cc8743941c1b7f0da8249e6ac763b025127b2b5cc1b7ac0c55d1d128ab976b4a9b779d57a3a23fd565c886da2af7016bcfbdc5910d833d37fcbdf4c3f9b1ffa6d48496a258e8a3e47b9d6bd48169e93c4b0f8f738d4de20c1f0e044d9bd1849fa4b5a84c845bd1465abb057e8d10e58463ed7de3a9cfdca7f782c06537fd9358730abb1ced7481337a30df0d0b2716d8e4b12a5a189b617ef6d12e38cc8efc2dcda64ca531ac84c19d6c8226f3eca76a2007c50f7a73fbe47e56c0423eec34ca0f6d386893693374c5665b9b5e643fbdc43497648ea449dda7b65dc3e3572ebd2dd7fb27ea7bd35e4600402ce5612990364c9e07201f20ebbe5db96481000be21b82987846bfc88ffcb5d5da4d8bbe569b8ca630cf03eb81c6e667a1a3965c8255a0597f8d7f898aaf0264bdd2827058dd4b2ec42d5d87dfbf724549a35f6c0119160fcdd1c40c37f0ba934e339328c4d1e6c59fb867e5adc3de3e1feaa8b70d09b63f4c9904507e5a1456b90f60f3db88a1e74b01ec0b8feae59afde93ea0c02cf72ee0f4d8d5e886c2a6d2a76bb552816a86ea8e1ebbf73941cf98d5e85d39f2741de4378850cca14928ede4edbd06d6986cc50bff3f9f7c2ff2244555586ea129c3f54fdaf8b5759e8cce6e11f643791cc097c3c1c4f559958b7ddac85ca1ce9493b12cf5073ad7d859fcc66b3b0df439ead88bb32d2ce26ff4dc12b988712e48d5d56c4925878cba4646820e1cc1c401e4a5ca4cccadb5bd8c5e1fbe424ecbeb36193e6e1bf5f8f3bc00e6d9b4525e221e3f27ba638f3fb7dacbdf1bbe08e452c929fd5a176298b210de41b43d4f9734f933bc26a83afd6d28699e2c7607f9ba22a90b0b78a1b0c821753d968b37f0841ec3f39fde32e4ee90c2f1b97445edbf5fa2cc6d7da3c214aaa8b0d9a0d5f7d9c8d24a67d129e2b274d65edbb41811b4e9e0bfc697254aeaf6225f73540ad2d6e35d6bb33223fff70f8e96e81368fb48389958bbef4b696f1e9b2b646cb4f7d285e757e85dbf593be108bc981ffe5e2b414c00ab2eb29ed86d8008b2033b977b6b2101dbb2298162e04959c5a3cabc4979ce69b6ba24f0fc1a4d764e16856cf83ac0797f7dba684ed5bd93b927c223d28bb4ee264d00e2b8186597eaf604d7f4dd030b66646f7b1350f8980c60b6e919a7ed90a2d8dcff0552fb6fa9f900fee418367d2b71a484e8b50f28ec29aba335d9d77cbd56c4edbb2b758e398c526d8c0673d333431dcb3c83f004a8ada5cbb18e8a4758094e3b23ca4b060b3c6760005da9570ee7dcae144848b14814b208c4b886b0b412c920a99041f321afc47a9d973d395a0ae06d163f4fa0a442bc16d3925b99d226baf3cef87c8cd623648f1b2130935115b6ab251143590c8681a5b5eae3d3142933247e76ad189b1997c104292f762be19fae3be418ba3df96d228a6228b881b23c5b59de41da2c9cb67c9d1b31f5bb71ae5ff8f8c918efa59bfaaa3a7d9eb490edf193108c1c3e0d211bf399d9d10eb2c0eb8a7486ffbdba630fc04a5249f446d4ffeb82839381138bdf5f361ffcf87292864ad06721e4b6ae93f30a4853383e6e1058a9a881b5b1e7e59642461f65da63484eb2f3ed8bac97b191e0a217a018f5465a25923d67319f5bf3b0be7c281f18219ea7b13578783cb688d72f020127dd7743a7eacf50482710abbc4e110055066ce3542f83aee516f8a7b28b0df7544094851dd26826cd85895532f0071ebf1dcac77e54049907a93684d7b40131325f5f6388fb10676121c8a067e8a4caf5548c2e135e5068813671545c87dbb3361434ed8ac49b9a02414f1a6d31c461b65ff6d23cd1b27d2e105b63232c7d774984f0a6bba6c03607246d25084e90c827cc88fc5b2365c1b3c5e8d1e2148c55f597d3fb9d2d436472379da95a86e99dd8126765c9b2864b6701be7bd4fe1429f1f0276cac7b2c366c66cd53e6ccafc4c4de40629e76cd101856e9da058c82affb42f434cff7a25440f2e0e4c5c8d9aa702a8be3b583de8f0d0ced3c85b7864eb5ae309f44275276e6f4bad4a316d4f87c1256ee65239a9fd6e0f03f028f7c57c710bb733315b8c48581de469b05c62def989c1f4d94c03917606255d6b8c62704721ca46b21dd1c614f11f093f124046a405b9aba190225753a0f2c1014803cd0ec6bfe08f58d90ce70181318732757cea1ebbd5b3c8a0d1b3ed2708dcd87b1202b7b4f87b0a43f38006d434e3a3dac5162511874174f488e76659472d1443df7683bd5222844826e2355fe43684159f82b4b1240e27c5cf4f54cb44d39a0e91bbe0a485d30ea42fbbaaabf9eb9b45ed99bce0d506149a266fc86494e5b816029df50bd2808d16c1b570c318cab004a599e8bff4da6e5fb784aee3bd1fc34e4bae123560a7e2b23332af448a32216449ce1ca5440205a5b258ae7ef74915c5d24235e38ea413e399741df5c20892cf75bd84d20637a74edec8d87f41d0afa06ebd518e4e57164c6b41371576fb57011ceda765605af6dd806cd6c8d536dad5ef09e42e2b5f0ee5953f59e693e71c7d8070067746d6e3fc77e4933ed14bd7277b9b5886c07292a3b8f4100b03a0c7f64e0913966c7693843f2f3168664e338bef8b3ae940dad93c3e106accb0f5ecab1d8f377641bc9b019a5f2649a981ea385e74c95fd9bef0b74c5eb3209def09d01bb018dc82efa78ff732e90df313f84c4140afc898ee7c0c4307afb1214dd605cc60f731dd3f458acd2ad82f053e120030b82cda26e5b667be78e4ee9105cefeed60d07cd806d45070aa9c8c6948b0e37e2bae40c96999b2304e91cface11a3084dab731173cc820cd8abff298fd503b5748f20d68691cdc2e8c9cc603e037994c399a38ca23a6a83a5697b4019af639af37304afdb952d5d793ce44d5d7b3f08cd87f8286e564260d76237718631a9723ebba80684792768ad911298a8dfc3568b9867502baf2dc3d122fe930b9e28313f4aa2e77145865424152dcadd5739985230f80b1322871f0a3dc8ab296fb94a42eff0ef79c6511dc91c95ffcc66ee5a1452e4e3820016427638af74e76c34194e5961b72668ef4c49eeed2b81f651bc3518e7fc7259c923516282646c8e91c17addb83ad4aa1df137bc9e3fc035f58ed498a3045020321941528932fb09d5a18ea64ba53664eb55044bd3af6113068ee57e9b353587d4518f728df32c9e2d7ab7124a5ad8c770501ff10e0a911ca459ba6a12c11aee27d2750f1b4c9687fbbb76592925fd20a5d93a034c1cc2442884e6b323964c8a56cf4c4c592680d0d7af3ae5c96c763ea1b059bc912dfed92fb5411623ecbce77732159cbcecbd99814d7cb24a44beae051cd7740fe3959af94b94bfec0c7eb88cc22b44be63e2fc54b82ad865c0dd7a770141578f3970039ca8f25e7bcfe4a8dc1076f9802cc0ffa6b22de73b6352f74ae811dd4a53416609879e62c1c78687aebde0f81b6a0251da5a42f14b5a40052ab8dac3a2146528a8e3a9f80f37ffde919df08802404180fd6a354fa1fac4f30c26432c1c28876ec8a95704659753cc77137d4e7446fb95ebceeb40f8a86be2da0a917eaa10f8b09570715fe043cfc5e6882e4821c76f342810b2fb3e4b450134437400d9d650f19edb04079de2b5bd7023d588399811c559d1c2e9550ca764e0c1adddd394f6bec91ab322795e3bfe3757fb32b021340d01f8d29ed433e0c51afc8ee4370e85ecd5ef4928e39fb7008f9f306fda88dcfacab82cddcb2971ccef74b71c7729f5963c44fb18a847fd6d43e40e33d057f11dbf980ae96c9b15795ee81a48ceaa73c0a70624f55e338fa1949011a9ca29fd0a2067b96b870bb4683287dff32866efd1801f78948d3ede288cde98b73ec4025cbc554532063e8d8a2ae4b42bb5dd22aea7251cf6f9b89ff07b8172e0d833233ddccc15810592c80799b7436a81ec5b6415354dda6adeaaf9d3b1100ccf8da9064c268ac4d8469b6f3fd3fb6d57dcf4f43d65358f281cceb328418a5803f92b2d04c0ad06b8edc226b81278bbce9d805c05b448106472770fe0a9110d0be6ff9e69294c7a8c12337d8da4f59650807eeb367417258057300954f600fd857f9ef64d75d5ee09a4e2168a7160cdf15928c267c890688ef177c30651770e9bcbf7b5f912f9249c44cc2c5fc37649ebaf332b481c1dcb7c83e3f0c8df09de9ab3cddb50e64e88f18ce6f6172652abef2a733fbe172830cc69d753102a34433c0354032f89c061b337a2a7e6c7b69a6f5e3c0f28ecb4d8894323c37b81f27de97f65bc79a18102dacf60edb865ea3fc97f1f00457bbdd59b6e1351bc08421f1e0e1a684595f7add707ed5a01aedb35bb97b0da21b8bf8fc571075bce28da8a8bb10b3f8a1cdff715de4562b23629872d8d99bd8648b6013d22c1dc21550d6a06b13353ce83d16ff55adfaa5b20866486f892c6d15b9fa9c2772902a75ba851d916eaad6ae7941949aeaf433512f7844961a4c802c0697164b14c1c9cc647f53aa826cefdac6fbc1f1aa4816f2d3aa9e02cdc110781870577c8b84638d06737f7e26737a78f6c275e75249a5be4edd5ead9c28194a7fa0570716a57ed1e21a787a258b2c462c53ed1c2b1f236cc1e2cb1e745050eb011930ab59b366f56f28997231337e08e000f171bbbd1b944176f9bdbd54acb16b2b053b362f095fe4bd400758545ea01b557db1efadad62fae471a803e4652c5950f7fe1be23cb999971371a8996ac90c908f813f50d7504e05ea006273ae8778c4aeac83d431e0eda9ee5137f897445f053916e1d73d6807f9fc69b0a873996438c7e7b13b9a5add4dc384dc1770b6bcf2b38a72c605c96c46c2bf351994f1de1946e39adf2ed3d62afa0cdcbd45bd9e7faf33d0d410f32b1d55aa4a429bee7e1fda6a3f0df2ca2d26df7833618b87713597c086d18329d2b12ff43cb12ed026f4a49fda465cf13f765450a2a5dff2675521afd4e48751977da16eb97840e9b1025907c70ab4e9e89b477db8f23cb5d71d52b10850c81c0a39e2aa85c4575f39772a13950702d7a738dc9b02257d56b6aeb3f6ab5ba7458276ec63316a1548a188b205bc0099e7fcf82fa89e7823b4339c1a357c5b506af5e7a3dfef36a9705bea0cafa3c14362f2aa9560979f37e07cccccee3b7bbcc8042ec370e44d97b6e1d4abc205aaf7f42e107c85828283caf811e6ccfa847ace62e10f2d58c9dcb10f1c483156a7d15b1dbe411675a02b30051e9084a1692a438cb7af5328b74e8ffd8a8467f1b2b3902ba677e98ebe69d2cae578a380dec9241f5b5c9e8bc74655c9bba6120be9873c497e4887ab96824c2e3e09326df7b2ebfe2210cfe122ad02f30c284c9f5f9004fb7465121c2d8b5fb6ff1856f9b252e5d703f1fc42306daa0356d94b6b71740a4c1f52ca316306bc6edea286ec8ff8c7c6bfec96b2a6765e9de875168b668f920d48a091c24a1c7e298213075ad9cc87d47d4570bffa9f7ae2ad18108ff59cc2db001476725274bda50f61ae61f03660666b08281de799cc7d6e39884fa81954857bba88d2870cb9cc604a7874dca3cddcdb2432c351cf53aeb931041c2fc9ba191b3ceba48947abdb59b6f6c923a6969cfe9c61333886cf5d8efe59bd945028625fc59e600dc614c994bf3a90b5a7228a4928438906c9e08f1f56c8cbadeae9623ada18758b49446804d01921e46cc629f584f9af3ca1e6c427a340216ee20fb6427a26bde6b0ae2a3b9b66e86196c4f75259770cf62b7aea994dc358b61e9d96487706acd5bdd7462536f15c8ed3fcf8b630e78422ffbb3893bfbfa437b6046e3651d5fc94b0543e4267452be7baf273866a9810a59b9d449cbc4dcfe4acdaf72e29ff3846fb383e053a9e689ae6741c3ab810aa2cfc2658d8cad0b2cc8ca294dbd11e9b6cd4d6d615a63abcf15109e81aae2eff255857b00b2856b873ce39f29e9f17e52717254ceff564f28347e0453a1ab3c3d59bcd18699c475f1d1f3cda3e617f77425ee9077de7e386e05689b3672796900286a07a547c53c3b088642eff2ca383bb54a23a9d7f937a83da6d5ebe8425591124eed1644d8b8e81a09a1f529136cc836d32ff664740f52fd35825fb48dbfdb199ce105e9afee52830bd82a631ca6c41e3bc92bd4f30360328f6d1d5b3e46ccab13d79e0467bcee6190bf653f33a1799b5a71affd46910a5900f9c33c2fcc8a7675d66edfc99e8ab9e82acb3f49b578726416fb6b87e17066bdb0af0025ab3879ca4f0bf7ac908cd7df0269cdbdba55a73dc1679fe8b881be9f863b1770363bf86d6fb4f8c6e9b52554090eb529e19bb7d7d008cae0cb8b3c59d36e08e5d0a60f0b8b7faf1d5dbca49d9999196e86e00341e12083cbd82e81aa8b57f66b10b87d7b2e35f2d75ca935eb95077723e0d4019dcb26559580c535ec1263c7152bf2ae6299522479f7c881c70136e446d166a01c9386af430c6a4ff8e3933d4e78b184ed9cc563b493568a098e40f12b86beb4f21f35751c503d6fa7e06675806dfff23f08c485752faf6b5b320322a2b4dbc92887690e3d8dfad63e39bb5ba587017fc39ae71b5f1fc27d7c6974afff36a2e4f89c8a34bf66eb19e05a898a541bc16c8a3b4bb2c06ecaa83ddefeb122390bc4b1f17aa19aa8ab91b8632e06f4bff2a39365b6604cbc8778ab4e3bd3d603b4226626d58f3905486a048e8b7273a452bcbf61664a17135d1f62fd4b555e7e66d476fec8328e322aad9910b4beb4dcc43d4b8599a61cdd67a863961a77b0f89e4a6ae8cc85ff18629f2f0c833aa38cf8ad5162b33ac20f0e2e326d5132824f4bcff19cc0905a48627955dd2d229970747eeb8d7b1a7019c9e5b041ca1dc267442f17898003fded23aa1fa11bc16aa6f42914143c63f179a526fc81010196cf449cdaee3d354dd8b03f2287383e70d9807135d989f92cb60d960f882307bd57508158efcbe18b9de664eb422fadff835164fac4d778729743dec328e69ffeac85d95e0cc24df49caea1fde07f6f203b84d2f8b9d12f8d134b28040305fd284552c7dbb69a9a43d302f5e15608f2e9f3bc3cd11dc6482a6c0c843ea0ca161259032156db1d11301445f0b1cc8d023ef7f53936e2653b302841b63d963430c9f5505cefb6ab90c8e1bd73bb5383240b293847116210ed77138f194b976bdc731c6366e85defee9eddb51ead4071660a01ab0d0b80068ef8bd4bd2845924ef68bc4f0100bddc1dd2a77bb15a3c5710ca94de13da7ac63c2b9e7f24625393a1021c7224375f4d49188e780405473092b99c52fc82d24668fd82bf036872deb597b886254a685b8156d0cefd884bca85c4ee1fae92e9d58438f717ecec6f6b230209934e9779504d5e1ef3f6773abadf76b765c7ef1aecaddfb654c13a88b006a87b7401f9d4259f29cd2438a64585f7701f75f37d46a23e462349bac40936ad82401c76c0333b9f6d8542703de54f41f4def50a50fca64987a833eaa352789e94b52aec167b73b237290cf2cb13bba2c66513920ca1c1f5207715b8efb37c252e9dbfb68fcba8f820e978903f838491232753e2348c4a60d1edcb233f4480294c09d31776270cb547843829c9c00f6878ededbd926dcacb08e1c0567e653a65dcd840d64110f5c9502a3ce83fe50ba0a411208f184a7ed85d23526ac952923d93728e5bb20d85492aabf5e6378fd3dd3ad124f24594d888a70468691355943ee9b9c5d72c3762b6cb0804078db167d68577e594505c0f01e8a72f2e1c393e410bc4b69943a851780e7656bfb6d4af89d73fe31f371a168fa3114a70512674bb505423e9b372ccc8bc6edc3cfcf165013918bbe8928c1de799269acd10dccde32716acf3d5faa9d8844559e9a1079195d39da41d5c129cced408ade6abbb06a386e4ce41aeede71968614eb34677cfee4c386ac1dcdbfe3568848ccfaf0dd50c1582a34b0433e5f3d6478b23aee4ca5bf49702ede9291ca22a4f32858182a35e00423971de15776e4407d52d50730fbecfff4a0781b4001b094878c8e70b434bfc48666c2bf61fece6c95bae6b73420e1f067c7e16a1baa402f6054d0daef3a7fb4471e35b41227e531527bc9e741857e9e4823006d7c9781379e5556a0d285af1a50f70ab03bf8179d1de4804f6ee04daea245f3c776205862c050e40edc224a0779a5ad48f773ef5cce0b6040e723c1aa541d61a853450af9a1053c0d80bc10c93665906350ebe1996b3c1c0a5ce0f0e8a7e0593c45bb6e0b6465ae9f6c5e4bb63a0adad604dd487f4b2bfc8afbb155f73bc6f897cbe90c80a533cb90151cb916d5176e803f7dcd3d2bdae9edb519b1223b126e284a9971083cf4c11635be58cacba4164b7f3333c9238609d20e67d9e68b024d53b9d6f59700d8b96ce6fed163ec307d43fe8a287b144de8b08aa52aabf3c081a5771e0d9ab7f24dca3c1f7c027258f0fe858ae9d2f4f086ce87a522e60a34dfa186a3a52cc9c6cf929fab9e72878eed4b1f6305acd72d503c92fdd75c0a46df1ab2312d581a071ebc3a643cba92726f471f5f060979fbc5346b73611364605b8be2734778f123b96bd191538ff0b13f6e299f13f809763a5e432cec99ac3f1ec84851d45b8897911da1e3fa545aaa081a223f0fa384c1c141697ede6a0344ed4c2f57e5a46751c587f26547a1b6aec1595575add38817d010ba239fdad1039ebe4686e2483d2cc968cdcd54d96e9b20e8a3122f5fb7890e683b6ae3210c9298dd59947030cae4a25f5047be902a4d59785ddb424c94c8466fffe65dbd0026a8dcef80d5a03a0f82ea5c3b56dfa0592a9279287bc4b1b83f52ff4a1c79c38a19dbb483f20bacafba8595c1bf5f6ae0e63314df7283b6964c673b9357367361d485f1b806f54261e94e4ceee12d0b63212d756a0d3668ebac688f3cd58db209e0b5a9cf8ce43206d191e5e53512d17dfc465b4a37b0e14638a1d562ec9ee376210a2ab7fd4fbad9a70073574f669c092f01d2bcbaba5bbb41892c323f390e728f3d0ce547875a982659546428d9bd173098587863ff04e4eed28c5e375afe91aeab6b4f990d3dee4442d9c48aa80f62d0a5fd3aa90291dbded5f11cc02baec3aaf1c9f381df3b4c4e4431821c9e61b3f5db89e4d8d865662573edf2843b69aa2ed95294803e8181cf4f58e0a89c8cc9fabee71a3a965abcd1d78ab6c13d0399fa23fde7b96beefb236c0af964ac5a1b73d92ab869c2fc9a1f0d610cd093105e5d93a87d376f3b2f22ebd74067cc41f9c9575def97669fd9630e38146b8940fd905965db94f9984b60d76d8a105403e45572673a70da8b027c01c3d41f9e08cc6ec2f80211206b95432a9ff98811496cfcf77c9d1f669dff6b3057723df453f70e940eae8c27fbf7613aa0902d98abf9c45938b323fd7d346a6d2e2709db7937488880f1794442110752bf543a5d739ae05615c2a4e65a3cf435c3046ac60aec880ab681075ecd7e2d65608ce27aec7aca9ffebb4f991a8bbd7ec7aed003b0ab0fce993f8dc0e82abd198ba7bd3ea0091b31fc2386bfecde6e3148bfbad6e410c97bc8b85e297c2bbe5b2776459c2ba8d214dde97cff683aeef992f271b9c3f484151a7016ffaef270c42190f59ddef83af9fd688be41a330e3514a5b482cb9b2826700a81b668434575435011c87f94d71fb6f6105177ef5db4ca511d33984ea7fd80f17d08abddb9ef4786d184f50c229bdc41b11575212b4638b93d1070bd96fd82ee04927a1016e24155740152d7e6d6713bb3d68b6a5ef86cdc99a41acbc9ccf8cd9afa7ffc7e3c10eed601ea172a4eb8e416c8955cfc5e25b0e0953fc21fc85239c164d79ff8d768465f63d074ca49e206b5997f25fa0767b46ea3cd29878c0f92a946bb80d94c6fb25e2662e56b90e040ae627b20396db737219d7276712b907330fb5616bee833ff24258b5c679385d0223d09daff257974062c38735e91f4209ac585260f4a61b81b3c270fa9141ff765d436c15a02fe203bbf7be193608520e2704ac065c02118c3eaf08020f03627f203df366eb0b81865fe7077b8176ec46485809971628d70c0fee68c07eb15ab2885ce55823bd48118477ac8e255cfc660595ca1f45738c6eab52302f6bbeece6dd951cd3cd7ade9638579c11df39662ac8632085c6c7b00a7748a9bcd8672f405f993e6cc6c6ff7349b30ea4bf7d8654a20756b2658e975a7af6aaac93fa1abc0a5b825fbe68544f3978cfb4378ac03ec5abc656534fc59089d6ee0ddb2f49532b2a1638886613b6f47ca5d0378359bd6f2fe563bcad78745c3c58076a8b4de2f6b8cd9c4492123c6977d17c67d6249a7b18a77ae5575411615671d6f8d0b73ac0e627bc255ff4dfd3d113e26167090b262b0e23307ebe5f86c6ef43252b65ea15c11bcc265c490088b2210a16f6894458094768c719bd98500c28dc2ccd87460704337cb139523102d5e3975cbab8755c08b66f1c057b34b1c2819cd90153b9a9eb3f580c5cce77f9d04ce36a52609c723f52a92b578aaf1ff7daae3fbaeec06bbefb2efc22848161fceadc50a0248e600817d0f2ed53a27a3b6d2fd90888f8686fc81dae931d0996aee85ed792e7e33c979479b2","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
