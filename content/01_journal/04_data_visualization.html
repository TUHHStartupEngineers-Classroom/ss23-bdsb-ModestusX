<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"03b7ae5bba009de99d7caa83b3bcdebfbd7f652010e1719fc1f361cefb76ffdb69cea35d42c4602e8bd71945770a99a34ffe12c23d9b705d4f481ce4d25436468ac096247f318dd95dd774bb5f30338016f30e2247e2298fa153f179540da683d6c35488cca94d467b31eee5775a56c5e42a876f5b6ebfe04a4f9a8c0cca678322eee46cab531544484b460cf022b9a0fa6dc71770bd4f1af2eacfa683fe58c829bd21955fda2c706e90d19199cd39144a5801722860cbbd2e30f4d6e1f3e392d26945e4b8c5d0e11b57d9368937abba318b661b18da0e3f9ef87972ac57fb9dfa10abc7d8ab62702048b7ea6ab4f0afaafc1014f565191000c07e93515739c9a94efb27d6bb6682b7a0bd7c281603501de8cd9b65ee6fc816fd52f44eda36f98db0c63cb77d6f285ca6ce47e66f91ff46121bb6b021202e1afc84845f1dad6d1b765c642e974a41091a5a09e5f8792303cd5573c78efcac9dc81e4792acfe45d8353f1712efd0d97ada2d6b71b724413a19a4176243f59bdcfb7b0253647ede11b6e5540dd80f0d339b25a252c1d964765a84254d6223ec112ba9dbd5c5fab5307bb13f775f9cd40cd6428f7f82b1756ed3f965ce97a6a6691cdd3ff6ed6a1fb5163154499fd1ede686b16191ab033de949d8965612b9b2f84defa9ae7225c46c28dd4f21d7271dd845e532eb9754f3e831fa6ee6972edf677b227419e1705abb1758e7a09ae0c9720c8b0f25f10e9e43fd2a5c33c3cf7527b08cc4a8158dceb84c4a0b4d487d9e5fadd601e30dd91729b1b19f14b60da61162b65eaa6216659b30d5b4efef795f65721eda92be38949e88c264ad146b8cd74a37e89b78acc3fe420b5c5980699d9ec3d9988a640ece827e1b17557c4a4a1b78954880f91065d33c68e6c8bb12b030486b01c01697d7436ce0d66e5553ab1566f4f879a7ce0f05805732a0a784527eb80054fd706860f42eb3d2c0eed349f1f2e1f697959a7700a25ab1fcc4336bb5ad5ddac1ed330b46bb2adef6de928f7cc6414955899b58b7d664b77db6dceec0bef0d204389136f5b07b7a4ddf34a7224735553667cd82316c4cbce1b16bc91e683ed4a905b61f78f43acdf29a94349c4c1f14240d4985dac18d7cb5bafaba0aeca3fe3b643cbf3553a59779bc465999b485f15df3e9602995112880e7b604f23cdfd047294b57730bc6989aa20742a560e60eb3f65c8270e78b53b4a184ef32c2ab0d8cab4dd451277ea6604e97093bc595cfa7532b6d24da70f516800e1866662b8729de8ceccf1e439e7291e3108e0de57a1ec0e9861661f60c456a009d732649110311df9e01bbdbcd308ea90dcbd15a064b4e6c40dfdb4244ab8d97b5c7ac1c4ea8c6e275bf93317c02b8aee1d0ed3e7ee4aa1f3bd9cff4e37722a881f58417f2f285526bb11ec2a41711ee7ba8acccab59bd52ea6bea4f49a7b9c02329e7ae04ca66b0dcdc4b8e9a2acb6835de69f17d2c0c99470f661a65277d1c46be9f19a996ccd129b892fbc5cc62e9b7c96481abd54b04eee3b2305438cd3f6ca55d31081e8ea7811699e9aba2fc92f4aa7a75099abbcc360598ebf2602f5f1a897c898ad69535f904293e3d5bb91d96593f4578ccf667389ab7598df9e0945c8c844a3e67bb247292ddeb70432545c08bc8e3aa3ab338a7909a878d89118f88a121dd4de3a9f78257746ba3b3a207623fcfcc31e08d44c436908fc28e02036b0d680192eaf053a07ef6db333a5b495af5e8b609a5a743e4bb68161ad42c64ebc4f5118c0b743ada33549574fa7eb452e86598eca3008d0ed58da94f5006ddb41e66c34f227a51d4b872dc16ca75990c7c779090dbf8612f6c61fb45aa7983fcd093209ee679fb2ea58a9e652203a242f4e3839712fda8ce1150cc8b3ea4bc3aa9a0e781ee97a7b87b5d0afa427e629abf3b7e85cfd24db57575f3f51b67d334de3edc3f8b3971582e2dbaf60c48b38daf0fd4fbdf64547f5b548a40a46bf2dd99d3a85c309310cf79d1e42b2f01d8ad896ed08777e423bef94d09e42eba0c7f9cd4587e3726f475166209818eb0b5eb00df10759df231948cbccffd967fa8f2063e4ad8e0ad570644db4dae6dc078db338d38bb62c0376260d4f31cfee8a9b8b643d0c79df8a1af90732b5051def4b5bd7525514e0bc45f131c7da7c02d6d24216a054b62b4b4bdaee3f7a41803d207272120fcda058b77de0937597f3a7b1172a949eb752fde859c28fcd219516b9ea1b860bf9065c4db4b837811d55fe59b3e120e752260764c18f90d8b6b74c418433b19dcb3b8a1f4aa3e1a6c1870ae04a5912374b4dac18d18af5b6e52fd3446910088dfcb2ae66c84e9651b4279a199799165086b8e54a2b96708052b4f889b3e6d64598368b0287cc4d645be15b891228734d893f53345a513faef637072df9639c16569b50fa17695b4b20b494add2cf6e1bcdcb4e1b0bbedc7f75063003407fb7c15439b1e081a7f57cf9883c8e5a9d8293538c6f32466fc536e8e1f340b10e21954911af2529b6996635690dda1771cbe87a42ef870f9515c141f4ccf7f8664fb2f7e199b5ab5c626f07404b035dadc313d7fd1646b38d60071ca0b4447f971961272ff49d3ddf8d2e9971820b2cc66b680572887a681afc2cb8a6ea99b10dcb4f553b1345ad4160b44f3579a133cebb7808bf01526db0f26e640d9707bc27540d1ff72266d001c2c2d8cbcc2fbf6252ff53e83ae1e25ea35b07b48dca13b7efec751562fa6e1b15d50d101331fa1b791f2be37f7f79bf689ef0eeabe73f8dd93cb2231f35756c1c18c4cd6c385f3ed76c771ff77a95e01395d25115664b40808a2be43f9b3b3ec558a55390ab84c363e378322d1a459b7252230263bec658f23a9f1a01b0a2a33b1c0cf04a2031f3b5b2d745dc5980b7ef71005543f5989a1f73061a0c9abfe4cede4d90f6278a3b1af0c10c878de296e6de9adf054190e815ffbc61d6bab31f0b2b07a863634c4b253cc9e007d88636e50d2f967948fdfa94d5a771f9dfaaf0d6165860056a6b482dc95cf95fc545eee0fab57f742e7bdb9bdeafa58631b719aed98a38495b14527c178c8926d373f779c6c38f02ae2ba323c14df0c9817d1ae6aa5313d81de66619ae9afccdd676f65d93cd1b1147c2a1a146e9ed2c79568a29444f99a77f4a7c1064b3848e50024590b22dac665d159a8ad9879aa970690145ae1d10d19f557d6dc02ff562156194ecfbf1b8adb6865db44d0c48c47ea7245da11c2ace61c0102258a3911bf72a9805e72a48980c93db9ad7b7897cd9b310cbb1329bd6c7020f28f2c55ee61a0ff751ecf33f3794ace391d81196b5e7a88d7ac91da6935a2a34409a7d991f18cbc20e182d50d99cab7df19a9f9df3aee20cfc5edbcec672ed1c8746df98fca2353af7db7d5321f639e59e59bba3dc03fac1aca9eac08c55e926e3f6ee8c2addfc49002bc8ada7bf012715c41499b11cd001368f94f6898ab069a2d4266da59f584e655e8e16dd13c82aa2254548f26a2dacede0f0beea8fbafa08d706c8b68fff45e941ed2ed1bf78c9c8b0f3b59ecb432a44e5b529c38f8af029f07b7e67c517f1fe61306ea928d664bec061f580419739efb348067965c93d96de6341835b1b72da7230cce226eeab98208745927f40890389bac4203b47bb5b5eabac4d893b2ec70f249556e3b2c029589dc429ea0a24e0707092b77a04416e42e80fa1af4c1de31131d7f878c1a5dfa29913061d9ba78416408f347cbdc0df4abab4cd46427432c4392dd8f86566a06688d6e02dc164a5e9701425297bdc9431a80300cad707b3dd97f00c10ac374b0351b99804a2cd5557646219aa8ea6f077db042c4e3cd86c1d81ebe0a581f975d132ee796c8feae7f67ceb89b689c292940da260b2fd974f08f189f6354348f8f2d44fa5efeb2efa05e93cd39b73b25964f99102a2527ad0cfb80af38fef494c5f9aac8b46e7c05260b4eea9f903a71ac059f4b3061efb61429cd5dec908fb2748e74ab36cf7bddbe3a15158b41cf555840b6da269f8cdabeb2b79d9df245129ebec906ced94551891ad940da261a685dea0f13ddda517fd7525f0b6916c8d959e178b164496a299a35184ebfb59a610b1a502ca7bffee9ea5b442c0e3353250c5929ea191bc0df438a4f09ef8d955e6c14c6bc973fb73701024ac3881f0d479a9088124ee89c5f45b4f0c79f8e1957c949d34f287756e8064761d900bf14095e9c75fd163b321c03e67b1389c77abf3f119c58b59b80195d61145a54e0ab72d544824305c3b94912a65ba010a96f8082c73817422761682428df1ea7dd4a0cc7cdce2dd9f9a1d9577fbefa164df4427a7b3abc933875ef6afb65ca8e935f20c37eb01c9408e75dde5778746e1448db1ed0815b95aaa6b99838d96f8882cb45a2c78d60dae808b20db6121adf3915db3a9cc8a42906444262e490e9b7c9d6fc9a28abfaf0c513c799719eca45af5459978e096d127f2e069b036b0cd826775a95a4423b6aed23353d07ea33d50e4c058f02e50356cf849485870e0c5df679c936c3c635121b93970a819dfb5bf38d74ff7a7a14ac6617e4f7423aaa5bcf39dd404be6d68722adb7e7728f0b379458975bb88b67e8a02efa3e00ea0d9a2d60c817ce07c455e07d8ca3fc09e75ebdc8a9016386c7e60d3b19487b79d67318ccf2824efdb1025774dc5a64f7eac54475da13b99eb398dc87ef4fbe7d0782dc8488f085f2ca2559c194df46037b286832fce8e4e2411dd50ea1ed8242e20f956ecd8e4c0e6bd033f26ab3a820dbcfb12b8b4a579156b671c4a70ebc13698fb4a30aabff42f8a99c7d085a2bd75222218fddd7795c6c8f7e0ba020bcbed358bc3046cdd67e72a4fd6221800da7a248b6051ee9d385baefdd41b1427b5c800dc52d085dad1fc31538079d20326789e85a9bb1275668e673e25dca4604306cad1be3e202365997b3f6b196217f677a3c9c8e90f5239c501dcb69e5e44a3ee51539c84705d1088e50573b316a88df184a1a0688e6956e4253544b5bd19a6510b06afd9f4df3a082d98724f9bd7c74913c2b484d603d93eaaa02ba10955a6277c18e2268c97c44efb99687f195aa6de7bcb59f618e0321abc232271d866221a0fc4012d057969f79da30692196e3d3d9e105bdfc345d381b8df4e46303c64d9befd0ccd7d6f709cdbf293772baf9acf0a31aaa7ee0b4d32529fb3b7bececb8b5acf2790cf1b2dddb366d416c7803f364c2bf61236018c51b0e178a34765da8627b929048d37768d69b27b8d3101d94ff0ada717d5c1f7c05fb468f94d9fbd315be4e89d670f49f42691af2422efa1b949deb389af04d5b4582c8deb43004161d9ec8234be42d969934254e4832e18ac4f45e7b025a95da76be8dc0ca0831c82666169017733b6aeb326fee30fe1405f9c433d83525a1281191c7210b892bcb054b228bd6306669df27f931ae23d97994fad38e58079892d41fe3e17117850201500881cf4aa0824f5a774803dcb13369afec8b129562b4021d757f703d8aefb0029e55cb4fb659cebfd3d40f322c0c280f2bbe66baf0634d87abbd3d7b22099659a8a599cc70d27fd7d45e5d3bcdd04e8f15763665bdf4ef27c5f2fc1dc1e758f5e419b1d2e84fda6be030df9bf76f78737cc28d0611a2b151eb9de2c6ac9548cebadf5de22f4e25b8d56b6d145ad2da88e52d3efac59175a4ac7a797fb3e9e83f5c644aff07231df346a69403d825d326ec6b9ab9c2abce4072fd106b2cacd9845495acc4ce852510531e14c0941d103675bbe76d73bb9561da43cb2c9fbd5f4b49bf4fb53278c8f03e484d0ffc583bfd0718bba8cd9e66902931a091a1a96755aed8c0badd9d43e708d321c3c8d34bd31b803a12af3705987bf668ca268a5ebc31c8e454bc188195423bd00993820c285ef06b0935055ef6c097bbed7109de1da34e3258d9c647a626accc12907bb6354f09647f113864e2cafe0edfb97458220cea8e15e7f5b04346fff32052c8c261ade34eef899734d5a547e4b6668b7a0b92dd59f79178fccd78c58d5aa8f07fd05ecb21f9a0b8f38fa5de63d5dbb782da2c2a9a3b6d192b038483c0e9aeb1f63aff45c89f138f5f626e17f63c046fb85cf26e25837cc03914513a8c1671212e9f4412d5d839b018e1e6ef41fcba3bc4cc9eb780df889ffd29b7d13dce327f905f374c0d2fc32ca8474fd9fd88df9f93f5bb07a3c175b38bd434e0e2873f79669358aa7caae67b3d140c68592c0d73f2a50ed7dae1dde37d03a999ba140d162eddc7cae5786555cf2f3d1655ec6958dcbba1beeb44a6d41a31e78e065a7abaad14e87f92ab7ef4ae958dbb7b3ae3325fdf591c5b436fd797bd9a27b2734f0d713418e08f384cd8d32ddcd09c2b60dba1abd6d15ffb02fb70d81bf3b550e8d36877582aa47e733948c8fa6862bcc1f8d53b2a53e100fc9c25f56dfe7b56b03b29dda7f60006220ad3c8a5a8cd73998d778b49b86efe6a7baec286be8cbea75b2614b107996df398384873b8c13d594115d592deacf0e1a994fd08323e5a4ace1ef43b6548c6cf69f9344c1103fa76cadf83325d0cd005cb1f63987ab7c5d4ba84bce7d37e3ed35d7e1d9092fb35fbeab43be4927e533c200c991c34c839e497824e35a6813b33e912d6793aa596493c831aab13007faddb2bc06805157b73e7b0d83a36f65f2780c6774f0ab227f4aad5b0564d0212a2c0df24ce265005b350a71786e27bee5ea189572b492b97422f568137dedaa994d42a19dc11c3e057ea4db898a82cc568a58f435bd459a7dc4988cf38c8e5fdee3aa26475094fac9e4dd016e0a4777990ea23ec055dc733abee61df47ec594076161cb094ffd17dec63adb8d50fc1069806e3f4c148114f53990c960ad5833f819bd04eb9877f549e48866693e437e8284e358514568243dbdbf70c5488ac2bf4e1dc110e517a5dfa966dbdf2ca4805fc04630efc281440adb466681df49533ec9002fcca168a929998e1f46d173b67dc09105dbb70886faf7d832b9be75da11b2b1660101f30ad4e1c7ad04de49b579aff305558595e9a4bd6bee5ddd5aef12fb013b650660c50faf27b523e0c4336ac21261e9c71529cbb3fc6412b124b69740c209b94552c81ca5aeea7b469ec56f1d1b5492482a5cd352a73653f377c8d74e985fe4f0285fa9930b0f2d0e6942bbb47894dbc150eb08f6104b02b4beaefc264e955cb2038a31c994193b74cdfcf0bfed44603714e1ea52ae047ccb344560999ea53b1675483ef0244fda8920c5fadfdc7023ed1abf23dfa6aa949673b358af0826f15ff87db9bd106a5b6736b1a4ad0fcb4d55d7c70a80bd13b696820a0fc10947bd1e204a9750baf3cfda803f048e7d0606dd7bc4c4717d64297c7887e6773f7e615a87132b01c14ad2548cbc1bd6eb056e2bf3741f9fbee05b3fcd41809dca73f72c86ece5585748f0e3bb838317a20a4af5edf85188a48d3a4bc06a9d06d68a0fa1c51bbf0d32c5e2226511d8aa36391dcf9d089189d04cdb7a579af7dba8d79d1708dbe2a096315259e2466a8cab9dd05ce052e4ce9c0f07061190f6df92d17ad9c407e57d367a41c3168f91e7b5c4f723442573f64e4b37e622d741720045d1bbe0d6710e6ee60b731f8b5c5b574b9a07fa5ffc5830bb58d1b6bf3ed1b49d00fdf3b24d9d25fc61602839e76d204708be68fdb0f4661f860ee77986a68264396091ba7a5eb4a7538276d8ea2528fa391c8ea868b7792abe1c4d0a0d58f99adfe60340688e04cc1f6c1bcc8c6ca1728a27495c6ca488b9d8ec004cce4c7fa5fb03df875f74db4323bfbecbd5e746c753dad00bed2a0da90d83dd03edcf951d9d30f126a917ece892f04af9417cbe3d8bfb14a9d22da6fa4f87675bdbba45fa7fe67205a605fa6ef97e2ba83ef399334a4053ba9d95995ee627cb7fd33ba7b048b9801cb6263ae5a7101233dfa05c7c3d3d8aa7158e8e6ec4798fa5cd228cdd11af614c6c262814427827cade1c2cfe13f0a6cf8eafd12679df38ae7d67a8ca472a494f74a9e7af293cafa66aa1a73ac430da3ebf7e8df90e8379eddeff4cf869de80dc56d719dc95a480327624a93d960890d116761d4a3cdd54b29585124bc6028ff019b84bdfe5ac920e68574944375663d4ac21b845d6f69190456c76d3bed2c5a2a6f68658f9cdc86d0920ad003739464df0ee2533be95dc46c815a8f52a7892d0e6abbf1929844566a5919eaa9e90acc0b53c57501c983556c22a444c08706717594100c2092bd8da7590a7c3fec68d53f2dea7bc756c2393f3ea29ca67cc959e76d848de7fac0265ce6dfa13b2f67f73c673802b60b5eff8f3aedcaad931c022c5c1d098cd8880dffdc4a9798a529dddace7eb4358e1efd0f1ccd57bcab6b57df22b375617d779b7d1a547e90dcd14a8e8f7d2adf0a017333f8c127fb72a093b6837618f619575f00504117738d64ea366d050c0a1b53c4210cb620763a1833a0955adc2d3ffd94edb85823d8efb5e52d5fc1f119eadf370400dcd2a2be1a0deef2b67bbdcb6a0bc30a217677ccda2ccc5cffcc7003c3349432b3225dc650156616f3a930b0eacf1366b68feae526b26f978bdf92c3c94e3eca9df24e17684af5f894bd664137d8fb6302b2b91745580ac5be1dc6fcc5df828712e194f35482bdb4b5dbd4812afdc692f63a57058ab8ed993f53e6239c2344555e6b60a7f6bf4aed8d5b48a7f7b9bc06a15750213cce9b1d2c0277132c0c91565d070227210398f1c3fc0353f49817726f363ed67277abc522468579b3f5e21422df492acd88e763ed74fb60afae69a1d782fdaa577096d416bcffe129e806b5f1c56e2c058183e97be0ec71135e44a45531e8282fa3c9c1fec52660907eabec26c28d11db4e6977c4440da50e259ca2152eeb25e0f7a94725d3a26330ab25c4dcfc034ec582e661d2bf00226970a6359233fa308cb9f23e29e211a1b952e1f6bc5e90cfd7e925998c7cb15d539825849faa5dad2ae0386cac8558367a4dd4834ec6623048ecacfc4cc0af8085c333d2ece81279029a8b4932be81ed3f1b2f96f18f200e4e21a33090e1552b64718da46ca8cfda280f7decb753f86929af2ac0310e04d4cb90bdeec9eafd54f112160ccab1840e4f7584cff9e98df6facb2df0b49334dd6a2688e84d67dc92a8dfa23eafe9d2cb46bc429440916c68de31478c86bf7a830f0661ec310fb4b9e9d02c6669c75e9df4b035c7c77bc69f8b0cec4f665c5c03f84747d9172acf6593701146a8fdfbb2f2c2c7c30bab4ef8a085be2d80a3d7949c06438df3d8d451ebd9969a9141ca9e73cf167c28869c8e07e56f0ec0c67a47223d1637ea78b2aa4d1b6ff656fbea35b0713d6a3d56e78e40e2985af7283dc2e91b8afd414ac0914e9104f2775d481f2c2c6ff8f15e55e16d1fd624d76c99c2a160c9c6c79a1f9964a8036625dbe357b0bcc9f454c9aa72f99638f36140413773efa4158627bc052deb502f14a2018859ace06c0fd3364b8ed3942b835c035690fa650479fcfc91725a94705c3b9fd6194b1a676f3499777f67893ebed53d4cfcebf921e8b9a09e996a70080b36bb54039343f6190425c218a2fa7abba49b349edb3dd68126555daa1e7a03aef96daa605d3bd008fde539a700adfb3d5f2c2090078df7ef76b81dc4c7792922d6db9520a54f680b1eafb9d13f3f9d1bdcf1c2642fdcad8602e8dd4e2fa92f666e15f0670b67f7071d9bf707769d29be01fecc7b9bc4afcfa3893619942566fd8260804923f251ccc222dd3e86a7a15e6e3b4d10add4a5b5772b729f31a9bc440bf39203f3952f61acb43084b077314c22335fd46d081774d6873bcc96b2fe41c25a504a38ef2aca7675ee6bf0256f12f50c4dc3504a5cded8a29974ba491155ae7cef984118f395a6507c9e16d2b439d1e46246154cf347dbb9a7c18203f0c13494a48089058c23403603bcc2af9c5f6e97ffb28310c4443bf06ea789c644478ac6119ceabb71fb8125d82975adc52a58554caf82a82e6b5009f7fb75d82d0e5cb43d2896aecbecad5b4f5d3541eb321367c1c50502a3b8d2ef4f03050b58385bb3666e6bb94d477d1173b6e4300d05e781a5256f65d2d10435e8ac18586f5b46e3eabec5553bebe0d82ce3c4982ad6129787cf37d205d54383621bec8bbcce25c24ce0a2f4c028de8d2e0ca83cc21680c138965dc93020bb50fea0144edf8c71e57ddbba0dbb022c9e9a0f2ca1312f09325a617dec83e1b3f9885678ec9ca854ba07be26fd1bda1934c3f8eae9e9c80a4df55cf1331027580f01a2c15d36b779151d58a3b189f38cfefe4775dbf2f372d03db38a2a152276527131160bed6a2dddef63b97f6af363d7639c72b62ab49f31ed7effccfa75e7e793b095118db4fc0a97f657520f4fcc52f11f062453a5a453f049313cd646321074f418055433ce6770c1d05a915d6734f96fd9c9e812a6a9439492c2c3ac0b830185b5147a9228868f44d645e2c2a83fde55633ed0f67f4e1123ddaed9aa2828f22374a72bab1e7f87dfbce99fea44fdcf4ec9ebd4e11299c2dce1d4981d26a45a67ff21a705b41add879efdced9fd0b4cf34af6db6477887ee924ec9395349e787b50096d9ae9ca05b9eae6677bb5527cbe5bc8329d611a29f8b32d0ec385db4dd129a60fcf5c3d0627a8de75dbeb4cf0256d5337f28766d0a934e8bc3c5cb68d56cac894d860245abe39b56707fbf99967e7c332542f7838d9c9eefd540bf34252edb112f53ed2b511a7362389d5e1aaaa9ac7a431a43ece631022bd5f15b90d2377466b296f9aa88b63aea50361fd9f99eec8a770069398bd7b1411308cc0f477e1eb44b079c74c107f20f2678188db4d247a205912439c088b668f82462c4a768c511f2974bb68a8fd2c6a92802ffb5c407aee8cc427be8cc12e9083f1a6e793cdc4195ca8d25e8ffa7ab8b0e6bd12ca37e1172a68eb4eca5afec626522c0ae28acc39acf57e216ef5963220a73d662fedfac724869dea5b33cdb326c6a4e8628a9311c32dd006094cff2b6220bb577e28608b73ffcaf0a5695bac6efff4bfcfaf32c9b4c4cb18cb6d7758c59594982d7c1ba7d9a171e05d0084d607ba159de1ea13fa651d9a9707844ce1991055651282b99127147a9207d6ca2a4d698c104a93246b71993b308d9581a27d9a1b9b49885c06ab637b1cbefda5195404417b546fcdcbcb0076febfe2befd335c490fd03b6a50da50c4e4702db4fc818d772b9ec11c30fce4445cd8ff27f249c6267ed756f4f96f374c74b47a68044340c862977122040905faea350272c69ceee3728f2dc0d98ac6d424c8ad54e2f1c9341cf02e0cdd5be2015ded6bb2b208df41906aa6397421481b93aff9b8e570d83771e309d49c238358bbd83bed6bd78549b4e1248739138db089558bc4bd35a87d3fae1c2ca0f3404e4a8dec73a75405e008417db767fb8b57bfa1165e0b1461f6da5f114a3996de2b1e10def3447e6c23bc6d34a707f03e55745b2fd0b626521f118d3341bb15a6730dbf21cdbecb96dd640a3b271eeaddbb0663749dbb120560fb79faa7a5a7ff7ef742b20f462b2c1fb82a5747966cf04ff6051582baeca30a56c01a2d073afef77cedae841c48edbde73bfc96b88ec46eb541de352c27700e58f94b2cc3d92f8e954f1f25bab57edecb90c7297616b616c43bb58d657fde0092d3f9f947c7abf832103822548496670e006d6840e308c7f8a3d01f6dd73136339796e7f435160a657c94eb72dcd339f6bcd6b3c02e2c27fb555c42435c098688f9f4c35462f23f19fcb6750bec8bd407d4097b2658e9242eaccc6cbf2cf8ef2874ff47fa87035318c4e6c296dfd7d6066b681c259889fc11c8a3906532742fb4bc43afd6bbbed008d33b34bd5adc1bfd922f0a14be17a20aa23e7a8fd5826528aa008f79849af02dfca18d54efab9a6517d5a08360516d5853673a8ec7f36cca033f39865967af926b071a0f083a5ea5d8d785b37a6fe95d828f1a8c03226874aeafc6f5b92512d12f1c52f1476875d665e8c673652b5491b19d51c9bc63a2f4d93772db15b50a9fd0f36711ea4407a94fde2c8700c16445e601b7ca7b7e8cebd66e7ce07d301c813a78f7874c56e73bc1db3780a1d10374679d31b949e6c330a4f61df448e733d48d7730f36a50178cc98ddd211d0ad04c2bf872b0326fa199dc210820afa869745101552d0a7f4e8bc78db22375a2a7c803487f39bebd12e949a35880037b9a0ea26e393956c3054a6854931bfc51740da9c745ebc08c07e9abb55dcc1cbf0d1f8b30c66fe43b5d83461f2b6768dba604f812eb6c325057022eef440e49d293ec0f0e191432b085b72ba77af7aa0af7b5ef287f4ca1b586b66616f0e6ac2b78f03ccf3747df967b231438ca99fa8b0b4feb53a6ae1733fd1f2ac7bb5d68dffb80a5cbd99a374db060342a64d4605819d0eb4b89d025813e4283092da5e8064a1fd8bf37ff74feec181b2ee0f50036ac3a4d7b9c1b8d1f1d4700288cd09b0e35926e26dab7abd5ac6480faa4f3038c699e9e5e6a6172406b1c0235b2ae2ea7db5024487754366cb246bdfe19893ffa29afb8533e3baf127a883d8dbdda86b5024090face302dcdd508728c493bb82293fd3f6eefd4de968efd7e6f9731eee028f32b9e1b413dbd855028c4b15e6e4a5b1e8f387378de50e20e591bffafc2a039461d5db2089ada79e762e3df890a63b4b4bade214747a7c30f16bf92f83ea06bc7bf72ee3f0bceee7870fe667c10cca4997eca3b61d7ae2e9170333ac14372c9a54ce008090437105236e914eb77c070478046c3b236a88473c492629394dbb17faf0a64ea4d95432be2f80fadcfedcf4790cf3db6a40b34585b4793722af23008904dd054e4a272f2ca9a5aaf13d26193fbca60793fb3a179acbc14ac8962c40e9fd0f8be59bbe7894b97165cc3dd096fcd5e0f2274e6c460e0c0edd5470481c144e83ecccae6c5cb21dbf0f869ba2e591cdcc6b465870974d2c31372061a49388062d744fcd909ab0e5b44cee2e2409659024bc7c7f6ac92d06ec0c0768298c3d7e10756eb7d0284e182a78bfd0c432c49cd1d35a7572d62f5b5c8d041e13e786b73f8a094ae17cdfd89c5f573183783d8f60d5d250ea07ff1998971abfa40d45bd2dcb82cea05928620deb9fd00524e33121fecdfe4d23e0bfbab8097145ff8fecb985c80c64b866f6cbf57655148aaf86c9727385234403ac61b6e54f4fe26cac7aedd673aa3a8f232d5f930b3f0dc5d6ecc2849aca2a3d6b832710e1334e100a0baad41724599177f73b09fff57ddff830d8d32fbb91abe0907dcc752c4910f715da4bf2305463110d8ca3377f70a2787b570da190a8ca01206c139392002cf2e1690566415f5b693a86636109e86d5f545863c629106a08030d94474d305cbe6fabcc8e2bdd432359cc64518f98af3df8a1e106785371d75ae71f49fb18c7a7c9aa853f981446d1269091b4c3f679066fcca3dce2c1ab17d53517386748ed19378da93dcb0e09ad03fd2511935e20e821244f1aa511c130e6206a26bb68e66f314a34f45e09dbbf6bb2aeacb4edbf43b8c70694305bb0dc1282c1eb1e214a7a79b0616b4354f523aaa33ffd83bf0db9fdf1438eb594b1956406b21bbf5d805302aba3135abcb93fa463b0cd6f417d87c0e8d4cdadd7e17f8bd5d4508da5e3cfa3524f43dbe1d55568c5e4a9f2b3b5a86f1ef5df94d21e5c33a0de191a6ac29377eabbbc60c743298de385d6d71444b429074065fa65aefee139bf39b4348c6d935bc1ab36e5430493ee5b7fbaeca6b9e54f61208ae7d676a734c23f695fcf37674a8fbd66b66b84eddec2a9a16cb5bb95165d09fddd0319c81505301eccd5764aca8afba01bd6dddc4e22d96a1b4fd79df6af811c0d72efdf37fa5b1552258e82498b41d8fe1918f5243e27e9ac4ad4dfac12de24402597ec512c0eb1d36dadbcfb0462b4485b1d767f9e7f555795a450ac3600a342660f9a0ab35ec762cabece9a0dabec5a1b17265cc8994d1b80a1274e37baace3db60a900ed3a5448954e0b50cea566c5834d4b3ef4ba7a6787b6995a94660e6ebb364024bbe85adafc91c928f245206fb23b81023716097734e48c7d0c1b73694f6d63a9eb0ce72ba15837fe7606f8182f3ad4dd60730469d3fad2e4e5c2971da920ed2a61ab2c2d8e9150b7b56828577f8006d7fdba3b7ee2e405596893295bc2d2e71df11fb1378bff06a8ca732fa787ae555d3059c45024735cdd61223c663f5d1ed62b1a9def2f7f7f2d367f23ce407840ae0349cbc0678487d283e1f1754a03d8077eeae05fab686d8252a4f89550f536d8b1e521409db744ed9fca6d9e010fd83b50c211b2e574d5da32294d8168c8eeb68c23ac8479acb271cd5a32a5ff6d432a265950838eabb29402d5b049f7e0722ad15cd208f06f2e4b27481779f4d42092ab3610d64b2b2d26c65f99893340299721809eb8f88ea02e85dc3be9381c3ac22d5424c3b0ff92f166df500124ec6ff0f165d4b76755d5641d0862b647009de1d660167e1a8d3dce35dd28109645d8511a3714727216957541779f8a4b1d698db1bcf0bd0e7a39ea95aff3969555ee04cf8f7b80486ce776471e61dcf03b6fe3ebf45342daa6581ea142d8d6d14bf0e4a109ac5d847450fa015485094815d0c1bb9eb81bf65c9860c888f35b109c11eae4e8210bd4be9b855003c6eb38cfc6bdf4076c6d08cf9f216764563ac3f2ae053a012167cad06fcf8c7e3b8b1f00372752cecc170487dac1e7f313c9f583c670d92f8ff46ff07f5c114920ab28b339f9deca4e6d51edb8b4ab62d6bf0cad0d288aa2c28235a97ec880497d4a7a5ca10048e14383a4c2c379870de2f7c7d535c680608fc6d5f41fb9cd045ee370ac168f9a030a8fb2cbb30b614795beb7100da51d0dd8987b95475a0f17de3fba4f951114c889925d90452e5571ff63d1ff8dc5a96da47d837faf9bf596e77c1a6d83a0cff2061461240f591a13785be0f25731d32cb4d2853dae4466b47007f5aa7e7db23ff284759ebb23257c90a3d22a598bcf454ff31ed449ab1260760800500014c9e6a6af903ae5b7027d9161d83ee2d7a1b26f76e5be920c67d1db38ed56f24ad7b52352288fefcf4953882b78155e102b443fa675379d1a3f9f2b8df6c413b917aedb15ace2be4ffabe52d445e5ee2294af9ee22892bfeffff3575e98f7d64043294da89d2d5fbf9b92e1151fe0369f4a229ffbad25d75a91752409dbb563d57343e965538ccd9e061625b59c7e05b0aa6f7a4a0b1160c0723b2f3e9e61c019202529fad6ededdb4872da9d96e91722fc767d9e36c4ee45fb7decd754f57fc488ad33d577839155ca3c8beef532ab081f71ca9fffcb3147417f5994c44f554c81f7e769f0ec6be94a385a2d16332d144a04b3258ab47d71204cc694dae36e6ce780b5ce0e906fc03be2c08ad1c1836aab61f110cb03bed13876bc1b554a5c9c1885a45f0fd377e2deeac0e791870cd7ed8a3aac0f5110f748a9e32078129314c2845086b106b88b14175f59fc6d27cef94f384768923ab398c859d4f3fa4df8019da863086f369c8b29a104a3926500fb226e37c80a9e32539707e98000231ea47ca7b571325179e3a99b505c08a5436fabb0ad8777614c16573af704b903b8ebbc12704f43e4fb20a3e317be0b2d0d6d40310a8c233b4daee71750152cd03cdb459e31264ca966c5fe9b82a41b3b4465296af21ebfe961f5319086cf50b0fe1b32fa86d23d3ef8de9e342476e66f1ec67a694ecb5e3ce06ae0f5ab16c15f0f76e9923ee1acc8b626e1693eff03667bf8b67cab0fca6c0bb70436875bf450fb6897a73760dc865149460459c601bcb433cf3c626ef0fa038d046a4782e7784ce75650eeb9f66243aeeb832ff24a20df535e245200388258f2d44ccec56420556bc4b75275366d21c7b2d103ae74b1a6c66fc4cb4d22998bc40e051fddcb3f6eb4ef416192905528728f0956a48f0ba6f5878c9d36e18dc418e4be4fbacf06cbeec219a71c37aba4f2372b1c7a7cba3a0540d15e8fa5b273ddf0aa3b88f2bdd3a301e1b718f37714824ad205c2d16a082279beded9bb3087b8e9f720ace95366722f6ed7fe9ecdd922577792d4c6638a59842796125391b104a37faef3928043c6aae99aa1222457c0d6739f8536a02ecf9ecca5058624752b407f3f353eb0b971457853082009d15c93ce7de4c80588989a5e3355528ac1bf7017eac15df1baafd413b53f8be7e4f1f4d40f0853e3df7df69689f6d5075c0c66382e53dc40072eeebab9589c71b501a720df72895bbb97e2d8198c415e26bae1251deca20249b40f5d9548e83bb91ab9052dece603d74247a9a07841fd7c64c4bd9c374d6a2da2b9b94a4fac86774f53e0a731602d8b823ea4f8cec851deaddbeb78e1639e39c3a1960d23815970ff269e849f30ce1910d21a1fb447a6c0c148e6e206bb5d06efaefdb6a8d70b58e16ba37409c7d13e7a790e717a620ad18e5ec126f773475766bb668829dd4751b6ed2816bafd39192ad99edcd757fdacee7af1b98bb37189d8e8803721483952bbcd61303f47d1dd90c55ce6b137abe5d6e9969957087009aeaa43bca48124345ea70e739a7d823951f7c25e25edbff4d2fa4af7659e645b98e718992ce51f8087e0ec10db820877120419be64b8cb374b65b996feb6705fe6f18dcf40db23bd456ec9349c95701d3a4e584485f8df94eb8c8847c0fc335d3e8d5cab1f6334aedb0be9900db3d0d65b62eb24844d543b18124002f80cee350f3e2de1bd22ae596ecc3c1d0a825e885f6f941c3e917501b946da312dbe73602ff30929a42e0942501392bb819e0a03549b2736a64a2158a5f4ab72d56b570332d9d24f0066e3282c53c07f6494a02ea424b29a59e24a1a9c1183bc203a391af0640df9ba4aea2b01e702c7ec1e8adb66a565fbb8da3ac2930e19d45f469da6b663b0709beae54a64ceacd18982592c0f587b973532e0892b108c26f7d5b0db2478a50ad341263fca850a3b87ca603983979c3e1a92e98ffd93b1ee5401dada1533152b01faf0e3bbacf2cf41798558bac24be17758827450ee2698e44c5e51b93cc27e22f71402c26ecebdd446e1e5eba0ac52edf3686cb040fde76a7c967a23cb92286a0b9c4a0b7623593ac80231460df9f9bd27899ddd9ba308e0bf0c1b65a6afe82fbc429a9a527b6a17d9ae3dd3e9af312de328e98785a3c5e259f160117494eab753eabd65663648fa3df255017628cd55180f71db55ab8ab8a58d35db9ef144495709decc46634e06ddee1b4b5287681344c3f1bd9a4af1b25d2d4204eed8f49968b01ece239b594dde554627326322a9fde46157147cbd752021a4a775f9c797385ffb4bb793008b424f177ef13b706796438c566683a282a49661144edfce29b7409d091042761f22ec19f57af891c9d6a5896e6546c7edce29a9a1a8ef95f15452252a8821df8626c3ad5c19c864f79cf1b47aff4a11ec6fa69cdba8079b6029c4cf5c74e910897b50f0686dd02b5aed61df1c299acc1d4a9fe98484f7ed99974101d6a512a479247209104f65419430bff269d1e71758782fcf057d4866fb2249c7a0eeb5bf51720ee7f61ce5aad1bec05d499dc5551fe2d90c62f67ab9f9f9d6aa309270869e3740faa1c40e320d8aee686ec04b69937dff034efb1fcc5db7091aa651652bfc33d5b8228b3e28f3614584255b91688ee9c6276f45fe3e1457459f3b83d5a97a0f1192d320f34ddc58dd3c5473b49c03970578e920958dc99e56195d36361ae85e3fd94ee030a2ac49befc020cb0758d52ebe96d41f0ff8e06d5d3c7f7599cb24daa0c4f18050695d3b9536e37fef9a807fdc0ed7682103c80c2553ef81f181e7ad42cd089009a9b72a605689e76f581cc7ec026d879de58cec00b2b844caacefb2ba2ee3711741b95963123a742cb62b702da49c6a01b2e15a864b3ac4cafba113a7967ad006d3404caf2b3185aea3468e6193aa75e95f61e0b3d8e353a134774d0fc6974329ea408dcacdcfc002ba6ae2dfaf5fa0b4e979bae56dacbc71e6a83644446a3e83bd9d1a29d7f6cfbfd3e733f50af6d06ed58770e3e8f0e326a9a209c3a02495eb9df90500ec32fab6f1c89ef9383476be66f011449c77fc59b10f560d4002ba137658722bd409674343d65e6805771130b01bba00313355da347935711711ef95a754a37c45c219b18b3f7145baf36c4bc9f646d1328f90884a2e30be983092f4edebdb99b56f3df77c79a8855074847491e0df55c1415998cada1dac0f2bd1303788fca6a188abf59f3cc160cd1dae1c4439373506ec705a52acf4390a0000dd85388262031f0029a8ae0de1f1b3d7e87f8edefae4a69b5d495412a8ca2f754a721fe708ea8e01d3fe0c4f1f94460ab823fdca8efb3294a4c837781edd6e4116b2a163300eb64576d2b47976a8d57522d3bd1704edcb021126841cb3b07204e0c4a573f1722ae3f026fa7b38e0fa4326f9ed51baaeb331fbbdbf959a8456b595b1aae4c99cc7e729a7a0c9f5fcc90d8ede5510228a89fa67bcd9be7702a2bcacd769ddbb2249ee8715879ab78f30e348a542f0abbd7c824c75057403a1e770f8e9e819fc17edbb4c90aba65f424fb5932fc9b0a3f51a729044f3052733fc9b40326d9a11c648376b21ecd0cf5ac64fade721b38b0d0047043d94ddbe1542b7a28b28cc0e127391c77f30aa1c5c6ea4853c8a644ea94f0d4fc29670ebcb806e93da531fc533d10f4a517f121d01f90764cb70ddc46745120a0aeaf20e3618c9369a1d99f979b0a713d340ca392482335e41e2ebe8ed98afb7fe3ba5b3c4d2d4427ace09d5bb8ad3a58ea4a6a67b0c485a2a42e1f76ce9738865c54236249d33595c35e0c9e82d4051e65df50f51fdddfe5caad5eeefd6b69e5d3ac389537829b2f1d713aa00daa2d5d31cca730d7bf9a6c09609a2eaac9f77277ee9eee7b5f2e2c9f96a568d9b17b1efb4a0b9013bdf523dbbc833db4b340990e8cedfe708fdd039ff4b46ba6534670c18d6ead9a70c724797f08a2174df0ab4bafdd5e12fc0de180cdc70043f0f055d46c78911a25955101081fc61a377f687f1e407bad5af7f19ef1b99ec7c0cea9473504ef00cf20586a609762485dc73d111bf955c945939e59352ae8ef359a445d90a31876289b97b2b88168c411f79a3412a626feda3e6fd86de2f92f3a142f6caaf4a98ca4471f2cf47acfec2165529bebc51ae9c32d76a67e5cca59470f36c84517aa1a7c50a10ca27b77e9466df58834808d20e907fe00aa66b4a204d161c227b563cb6822d587aa644ed4fdeb93c800ade5f35965335aa40260aa7c74cf971e62abe07a684cca4da72aa2711f1c0cb12fa2cf808cfa3b1dbe9cadd931f85f9f30e173d508c58c0bfa5605f003751104239102a1e152df983f122113c8dc4668a96ab933bf1111d306399b86346a9d7542a3513c7686169f905429ae566158f96c2bb6f88786c991d6b9d1040896b0441b2883c69f89dd47560913264fe44ecd3c9b2a405e34c17a9042f2143d3b641f15cc9e85f0cff4714cd5d29d592b30272c9e19d10414e6c980ade8b7c20b9bdc253d3b760ecf443e01c6e30d158b77ec87cf2af9f8d39d1cc56dde9806c7e40888a4c4bfccc1a6c88d3df86ad5c55a9613daa38501db8c6648fbf095156fed3ef3ef1a5ebb3908a21e08f78cb040e671f0af27b4b684bcf245d0307e8fa5b8e4dc87843a7639973b8446f9538a9c496d564a6d43f32eb317c351e4bf05751d7052374d6964fd341d2ca2a82844c2ed9ca12fffbeeeadf04b57fa61609ba4a35008a525748513c0edbdfdae69d66fc41f8bc130d83912547da58c5121942cd67199b7e54fd7eea79c869f2ec870f6423131bfd200c0464f82c71a1fb89bf1e6cd0cf4611a9ba2053c4e144af014ca71a0d7545235c95c49a5ca9882bed0683669b7803fadf6b8a4301e2a59f17810d306c335a73c9523a3a13a8d4c986bc8b5be68cd8524ca11879b33f276af156e2aace7c06863c35ca75c3b72704cfcae1bbc0bc818b1364ce70d16d2f953ac405ab90f8d9e2784471834d4841eaceca68220bff15192556a7d7c86c665b9b3c2d6ea57eb5eab8d1d5674a3cb194fc9491abbad0d14e530104f5a852f2644fc83f14957df2ad19583eb1a5c114768488547627b5c127ddcb92f7fa96a1c3df4d0ad7173a84a62a1d322b4205e089a90f378a8426f16950c025a02a92c9b4edf234224e0382141e9fd057932f7d7fcd3808000890000f3b4f1fbba343b7e19a802cd902773b486a4e9519bf3faeb1e31a49dacb60439dc3b7c5e02ce30853635820850dc603249e308660bcf34a7a71dfe35bf971bc24c0c52f25a1c408961e5374fbd82143506ba3de52e87af44c6adc85875493e00584ed2c9999c8e59b781f13d5b925d246b25fd864343ebf322e28bbae0529ab332dc746009901f09863557dd32666d3b2482249c89c87b246acb12578b3645b69d2d65bf66bb7e97cae362c2b9c205c65dd4d602d222cef9ca0c17d2288e60516c81adfdfaf2a71ac632ff4164c96c3ae4da7e3a762d4a103d4ccbdff482c9918cfb1cde4286bbd8e7eba5d794f4383ffca32b701671579eaff2db49b82e3e2b365de97871c9ca16fd30bebf9c281111e35543922bda39296c2ad8e38a77f7d6f8a5524dad799cb5f41840ee3de6ae95e054dbea19e05c5087c400fab504b277739a93a6d82b1333501774fa85634072502abca35fa4e45ceeab3e4e6d9daa4bf4255b9292d631deb7879bf70ca0dad652580b0fbb8c6cf69c86b3e05a71fee4f9b6f582a1f59c4c61c9afb7c049db49cee4450849817e241789bc45f4da7c79c74f51993f107f7b7007b15697d8f7703f674493c56979eadbfe02d9b26975c5768137939f6fc41bbd2295f8ad16892e6670ed347fb83421bb1cd44df415b11641824aebaf1e284dc1aa37e4447ac9c5d5fcfec08c7bfdd93a4deb65c14f3476695a3d0eda1bf321cc3fa19f2e9a49f305b8d9859e3bda2435487e5bbba26a90727d4ee18ae0ecbbc16945a03a887d9c4fe5ee212f8785c5a97a2c556ea668c73ce6822e8c6d014e63d1827784ab98faa1432d624ba7ba95ef0efe250b6b98644a7a8e49861825a99b5947228098871ff5f8481a07ec191697a63fcdeb1564407fae6aa46147e7b5b22f5f8fd23698fc49b6234ff467d640f0c63869f8f519e72fdc5e89cf16d20aace45071313c88744855282c4d0b863fcc4fb0446fa00f830bc18cc78efbfd974055d3090ea6c7f71e00c2270bd29c7337cef4452beaed57d0f93164b425e1ee869e35ee0761c0e2325b0568dbdbe5f5bb50cd9c6c8a147893acc309268c3a68b6df42b1d1ddeefa9a54901","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
