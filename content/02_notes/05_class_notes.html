<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"18c40df3045a2f17f159c1a4e47d7552f47dd5b5ca0be25db1f0a6255d945769169089500482af66c244f1cf053a1f9a6ebea84d9ea07fc4ffd0b5cfe42223630f189b60b0282df464273da536fc78c55b009c9848c2c33c9c84c58d9a6628e88f98448f3fe1707e42a93317f99ccc2529dbf1acafac39a3e9ffd0c6145f2e8ce06be04af15153c276e6f943d7e90ced977cca88855a539f3cf218afcf05b3c535e4efd3537ca099a1dfdb7787a8336826c3427614b23d07be56f695a1a25b9cc9e3592e853b8de1d430d3baf493a637c9f58af6094fb1298bad08864c18a043f4abff30b8021581678d0d4fa1415ba728fa41b0775775d7f0bd06730f9b6d3c00c356cfeba1833af50252f2e6a008d058532673bb6a1d87ae9c7f5e7423271795c21e02349bdbe835fcac6f843ac61149f64180b52856ad7689fb0d696134d708d898352fce7e67404bf332ef47995e355042a9ff1278e064e2f5efa3ef50b662f84e55d8d507db560ea40859f4ee465a549eb31bfa86fa9fe4cf6c0c29ac5fcbc43fad9b16abf8b5eff888c7e42f720d762a8c75b38427b14a2909615e967f818c889ba4dfcfb45b90dec1057b7c0f85faff3b7ee78f62eff420cc953e44150df75b796b318a1bab666b91a650ce9a08fa7598d8693031196f0071d00af16dd5ea3b73c4870c06c95d1932ec3cd9e4ec9d19f926e8828083513a5afe42f9176e58ab56e89f0141e2e8390ab11e3043ad1a6edd427818a1dcec376b007b37627142e0b1c4b15ba93a4dac56c29eb552a10591129cbeb882c96023e6dced2649e77c4190827c517fcdd1f1087ab0a9d6d6d36365ab54fd0dac31863652172fafe813fcab8c638dba6abc1b83ff6eb88ea625c004a3f97e180237c3421b50e2bc949cdbf5c28a3bf247d97e22c4c111f0c3e917545085f031290e0d41f8b998b821968fd839e43063203a0fb0d03b853a919fe91525a841018eba26ea10f139cb1b8532b4ab32a872c1b7211f2949ebcd9bd099ee67d65e62d8d7dbffdf015b3317b38d1cb161fa00f73f916c6a3e3010de8bcaea4220985bff4a05226027bc7ba8b7b16ec1cb280740e1e8d8dd8a1ad13fdc1b7af4b90f759f961f14b74b672498cc605c14ba406cc6af8abb06d551e55b3d83f361aca93157653c25d72a88ee6f2f2f42ee9e6f32bc18110b8eafc3502af0a3ef3c0692ca63f5cf25935d10cf710a93129c833310a0b3b1de7829efba5e51a6b036fe03d0cd44178daf4dd7dd9efe8d112fc3be71940256d8dc5e2b9a04de4204af70901466521ac0abdaced2bb88662af288e0c0104fe893b24da3c93821b876d6e519e70baea48ff2c136022a9c23d3f4e5c87dc19d41b24460faf5bf6a05e40bd1443f66ed23cd32eae3eedd25aa98058000bdd3ba2b1c270b18a971f811180b83fcb4c916b53b06a4fdf3d664273d0a5c8fff7b27b78a0e1f28ce05eab3e6aa136da4d61b30ef93362da3d9674ab33871474517281d1ae0d68a07c9a7271f43622d99ff25aef9b7ef1a0a11640b2bb378bbda574b3a9b149e00528bdced566525192999a22d8135c7ee8b95dadbe8455bb9d9b532f1cb25ed281922f1b56e5e9bc3c8795c3ed77fd703bf32f1a3999d6cd0dafc5e2770475807c49e4b0892c8a3342e85ed65775d3bf6f1f99f4242a318263d3764212b426e50e40bcc7f416beccec6d0ae9b6be3f1c3a4e1db85a245eda38e81fc7431a9e92a38f0786701a0c4508aaf7ee9c07e15c7d87f96797f3e2f2e2202b059ca91454f51f5b191f76bb9602b3d0d1b865c8a084aa64cdb2b0eaf0fe1dc274aa730e3129646c1b3b2f00dd7121fb79382e3a0ad2c4d9dd1fd378dd5b6308ff8ad7d781eee498e98f0e2d8b1340408f351c642cb1ccd17765769bbeb9bb702805ded5907f75b03e2ec1496db21880d0d1357d6077d005e909e0f3809ed71cfd132112a7527c8b194a097d01edf33c113d92a4b5727aca8dd0dbe82cf547964f9edec6d4d07a5335e9f539b19ec2d3cf1dc6a3a831e6bc7891e82784f4c8d9c38611f8fe4bcbbd194dd2fcb181467821ce215b9f38f0b77d5d8e77cc4e6f7138328abe58f2adbe30b353abab41a84b624dedb95cc5e3879f3b1695dbbfd0965f668f5fadaab4d220592fbca75159026c00df7f148e433f5f3b1ff0c4494367c4609a304656ac341ae4ed24674efd3f8919f6e043e934852c92ed130bd8cc0d121c27b3bfab75db59937cd010fe207b9b5fbc0ee5ab795962c1a5f05d2351eaf3aa37e60ceb8d9fb6e1bb6a81b1b059c96defbab76b67b9655be0e787e1c5159d1a3e0a94f0718475f147e531ca8a9db9ca7eec64ee4b35cebd0447c48c14671782d936da30b65ead9321312c84ce2293fc1138c7cc721ee537cf8c28a842f4b915af6a5840e958007c57fee9b9577e3e60e3f9c302a38967b0b55bac087e36a5eba3e80916c0e9bea1e7735f09caae7d59fe4a4277a023d90b4000e95c202aee21eb4519010e0ddd664242935b1f5d437fe86aca379badc2d8b24739f022b4f7158594298976bbe42030f9e2620b4e2823c1ffc9180b6382df9aec53bd7cc035f92de444edf53a0d8d5d7725c44def04d68e2696f33ac92eb6a268af4cb29cfb67e1f30c6e2e9a7e144acf34ecfe9f1db871bca376d777dd06c1e255c4f8939258814f01ebf8cbda9d69adf1e2bf3ea347dc45d93abd7d1c1789f5750115ef4c60fdbeb6ac3a28677988be198ffa34eef6c4fbc7988d60a72e160e1e1f1e56aa32bebd19772e27fa705a225c0f757423ad651c36dbb3d954830900c1872f8611db11cf3280e0f112aa48acd5b6dad65ebc1c90127861459d115bab300935997d2324e7fcd8db912e2b33e68e0fd8a359b396d7456f5697d15128de316d167dbe0180d4051ba88a3d247a6b55cfd8f9563b326cb2aa45d425f01e52cd683b821f6ceaa9fa6365ea0209e354a92fa13b7f0544a4c84ef8fef18932df4c18e1c32303c28d03676e7a953ef9bc1b3795dbf5ff8838c13356f9f3456969879f90fdaf7c4b35bc7714d77ccd9de4e7ece73255c6b68d4412f5b5e57d1b3fbc7a95842f450c2c816d586d329e12677179bae625eadc8e7284034f34c3adbc4cd659dd95ed20afe75ab8d2f3987fae9755cad843aa09487e1db7916fd8ee2bc0fd18a2a24538466c33da3f0a07c43dd20c03bfff0631599aa772014242fa3305db791b62ae32c28a5dc7c8c5f8986f6174c6fc8b810085a5b2e8f044118f188327f05b1e16ee253f3eb51fbeaeacfc946f3dc9c1bd108aba7f5aac589c5223b59363f3816812e3435d51c06a4977ecf29862f0726b716aebcedd45831dac2359f3c1b5cf4eeaf1ec1476e37b04407a62e9e64dfa4d1dbdcc0227f680ec2eba132433370db330b93396c11bb2ed2967716df0862b0ded2cf2cf4ffcdcfb14710e08c468a3b2c3c628a6636946b92ba78a26e892e0f5b823266302861684860150643a60bf1c61b87d15aed2adc746b1248816f62cb4d84c6c6a22fa3156b97b7e74707ae70ff7b9fdb185d79c1a6538e815343613f14b1935a798fcd8e4952b2b922ae3db1135004fd8ce6bd3bb3c74ae4f126768eceb93b7f6e53fdd51b583ee9e168e22d1c1bb0e64c6ee9e7a8818c6db6efa05d134abd8ab2b953ac08d50c0debda3d73de20c28cac38af933f901978a01eb6e20dc2bdd0bb7fc75060e9c89bda89a0c8aefaaaa73d12480828c57032b6bf3ddc0bf2dc61146a3b94a7d598e5bf7c51d4866c7fa759b7ff9cd3907ed0104b92a9d8397345c9689e797fa0ef1579f0f16c02a940d09be230e26773ec70171326f66b50a40af7710c36fa672129d816d7148b4a002bacc568bde3a28d23d2bb276e8ef84f1507861e28f5b15cd0de1ee4829f881ed9f25846d11e0057f7db245a795a04c54c9878be2e0bbdd52980a5830ee33e5468b0ef63eab72f10c7372d76208b18ac0a34ec15cc502937ecf351c02f397b20ee31beec92b01c11a485147de84ee68cbb65a2834781dab2514209a1d7b2b92c64aec363ce6126e9d571d2ca5190dc3aed1f0cad362e0d9875b5fae0ac9183d5b5eba1561732a345c91de7712cecf7c37ae6b9e83cda6e15a103e600d82a61385f0f1bf5aaf25fae255e7c3719bd69fc0a4e83ef37e20fd1619c20bf562688a3d3a26d27c4234c2b3af9108eb9b9f5379b40bf1177bd6f5e5bad602a82a3cea7b5bc5556e684010e09041292fce4271e04d2a35d4bb18fe175a5843256cddc7b9a739eba0982b4ede8920151d00a31341214193d00b759bdd3f15d9369f405759a9546187b74c0405b855e4bbada6bf3efc1a71d8819bf76fdaa95d59d9fe84e5f361cdd9084bcb2ac21a25f0dd084524d00163a12d388d63c68a75611a78d5a7c9b9f808f1776ca0e0d7fe6f872cba58714144fa2c03f86b51868c18e4fb98d38f8bde496944d6793e90e1a3ccb116ed9459cbebaa01d8d27c294f266bccdbb58ef6fe94bd59ba00073f6cf35e3d7202034d2393fef233ed4d6e3d7aba0fb4f0eba997808ee9889cd8b0a5f4a9c8bf4466b8a8a2b0f3ed9fa2b299c5645220ccd6f809b06f6d72e5fcd010729868f4c26b6323bb4efc029eefb7ff3619ae82bbce9213fee6004bfa4f773573f3b27b6e0a10aa24ba1cc8a7b795e5cf1779627f8c009bbcbc3b0a109e1f87ed35bff0e90529d77e17d76d3707225f726c7facae93aef09b313519d6ef6366da736cfa2677d6b81622fd7f62f2416deb79224b5d5fb949e0e9fe3359d9934f62833b49e8d1c3995161744b513dca696bbabe8da171489609f03a36b76b9d67d76ff861a24fd50c7370825859c31eaaf1ba3617b4147541050fd93ab03f8c186d1c2b21be57e8d27811b8685804231dfa9981d415f3ec5f12ce799615cdcf1f7d2454dddf46d320eee473bddb1342e0d89a2e10cbcbcdaad0ba07f19c183241d8e6d2fe6da461d621468ca2cca79c9efd8717646b2d41955a365bf0ee28ad6b3b223bdb96dd4f25b90247c70eda311c65fad8476d9f7c10186f193147a793360a7f8f2bae65f91904834df060980f96c25d0bb0cab1a8d168b4b5fa99e974d2f4f2bb1857de1cdf7258110d8b72e19d920990398cf1b8b79ce5cc592b74b8340ac7148176f135cf5f8f3b2626e09cb566b1592a264fe0a974f2929d6fa5f8eca8dbc38cfbc005577e50e4a1ecd63d54eee36d786e43c2a0a275e74e58a62ff224168dc0b502649481d7710e306ec9ca7372552ee3bd45fbf97ed16680283f62a6f281a88bf9e0df3ed40217521faee0911f558a1d68203ac25616bc81680d05d24d4180d4644991915e9b385ca3ac471aa16c5dc758aa09d051e985669a0d283ed8ca95c06ad7e6ecd168b7a2fe8bef61ba63dbd8bf79853bb5623152029b721a8b1142b54c1f472061b991def5827ed0ede0884575b045aa8262af96bca67f3454499b3d71d48c61fdcc67bcfd4a9bf424d81e84dae0bd7ca908e851fea9903535d53241f4184342cece6212bff0ea40c4bb5874a9dea2d125c426ff872261136b5ddd5f7d8cd57814ae7fe885ffa46da120b3986732eb8984ae47b379f09d179b20d296bea244865b4bd0d4ddcbdd709d8c520d429bf48cc6256b7fab373df141a332040612392188d52cde2069590b8671888b134e3e232cd2eebbb275623ec831743eb9d2b948b1e5796043b8c2450572f37919ad07f92a4a01cf30e7b533f41723289f0c97c43378c5aadc5c1f24b3d8722ca304bbea4c558af4b51b29198865d98a84910ab484610498279c76cb51ce1f6159926e35e05f0488374f5d0c4a346c1cbd82b2b15cf1eff170d0096ad7703f73847600b4f4c38899ba12c6e3fa7b30145ef1a42a92d5601a2434f60a8cb3a4c5ddb1ab87e8792859a66fccdf7d75e7515b4126d02f44b18d015e9213988048deb2e0f452a26dc95898da418eeb10667113cb553c6270f726c3b30da101f5c316280d34fd9f0fa14d4e9af4c5efe5905574f9119b0df13d1c667c77afe44544ea2a839e1ea28ee89be5441a5f91ae324f29c722001aecb04e337ab7d8823789bfbaa2307b60cf27bd36890c100b718b6dde6060a9f888c0e8a937547e8c0841b220cc77979abf878c610edbab514eacf9f37aa25361b08be2297024aafc5e6f148eeb542da6ef9155958099144ee628a7499b7257733d45119e9ca21a77cb707ef4761f46834f077b3a122bd85f6bafcb4814baf78153ae7a524391c6142c1022fbc00ddca82f5270eaa04d925a09fc0f39faa31d4acb9b7771d3f9fcec7fe0844bca3efa027f1800ad48f69a85a3bad2b3a76a0ecd03bc61f5f8447bcbc3a6bc44493b53a772d232d9be6b56e6b4cd3d054f4e744e8e790994f46d0307437188dc37dfa392cf364f6eb9b13cf8579a0e71bfc6b7e29a007aa266358447a6e89438249616917b52e44c9345106c29a956a15135f1b0e12f9ecb1c78c76c7cd84e353bcebbedc7f0be338cfb096603ad0ddd367fbf84e5cb14133e9b5c764a1799ee20d8829a2bb8906d17fa2b3ac1ed31d10704b3297dcc5a3a42d175f149dcae9a6e97238a1e5cf3093467ca7982ab8c1eba973b206f22b55436f4c7736df9ec1c026f80198a843a603fb5c62b9850ca10e21f35bd4c2b4498e3a5ac48aaa06d77f08a6d4ee70e494d05e303a66ef302848bbbd246d2ee0353fe86755fa7f8b55bffe2a0e5064f59718f88128aa7b63067412e52fb72e63d1c4622793db8ae5cd775742344824791dacc2b4414e110c301081a01177a9f4fb544217b0c0112a846da9c8087af5c23df50e3e27ea5d26d7ff13bb3e9a76d32bb1f9b77c05986d91d7e9b7a5454b40e5d52019a4128e620c99a0adaf95635ba877eec36a6c48386ca7fc36eedef2fc177d28b99452cdc0911b5b05a50bc07928da94c7292b316869e0dae0b1123a288654391c72926647e2d985715220193433e1bf53e030e189bb992a889b6fb76bcf0807fc5a0bb8e1bb1cbbd42ce93f7b0680c2401906dbd8cf881b0aab25f385af4d934f1da18b77b4bc783be6364184b8275ce981e231a05201fc2007059f276445ca6922de442845bbfca1b1e15ba402857c086b759c604908a2da1e479ba3f5bfc7c98b6d3475c3bdca28640cd1b200b1a3ce5c8ab8b46d367dd0ac832a935491ba217fdbedc1d2ebee6b28b53e8f4ea050e19b7173f393c10b544dea4e5f6d6430974aa7849f476925dbe2f97969749a9e1a2d9c2baaae66e8d46f38d943683f82166161a26229452071cbb7161b53834a8eb7144995199d7c9ad8cd415410fe96cb88b709686b9a86900c23577e8e4a7659299892ccf925530612c90b7d0b34ab5950ec818bfa3f749d2e5fbb99056744658a376f2f6fa4824481013eb5b04409ec6410b58e734ec1c6c2624ef306823216d4566596f0e5c83b4cc39e279fb9e7c5e0bf158a593c4dc62057d1410302caa6d0500d569a13e7a033aa3a81ce475bbd922ae13666385d1a59d936bacc582e7d4f64e5d448ce46f47f8c4cbc688bc155c8c84a1404ad2da2299ab07cb3cbc56293eb252f0a31dbfbfe7b6ccaac351542e73afcca3e8843fc7db04ee6e262c3136dffba03e147a0b8413dd24af480c6a6f10d7ff8a6dd9a877a40f0dda0bc157710428922e18b402317175de73e58f6d5e26629b1f4a0295474fc7e8cc88ea3445d97f973c2dd1cd890e28fdd27adb779fd86fbf5219ae4ed991b54896e28c61f7ce2b8c48143753185e0a2e80760438e4ed69796fd0affea09feb8903e50d08ce046563dfe22177606e474ed0135626f7163a6b24c32c5eb090487ca3cd125038dc31c63784903df75f68a7a46e7c220cdc30609ebfca62e23582ee03cb396a8ec1b6c3a8c5b5c7a6056ee6ef1c61e11068aea8e97efc37b159719d14b3122e81a8dcb2a7660e64548dc66e4317f22fce2d5b71a0d670e158941a5f68bf4ada169bf5b271177ca0a6bb896de9529dd58ea29b86f057a8dbb13f6288786dba7fe432d2a0a82f2707a12d11c43fa471b860a561b53f60368c2bcbf985d1d3877a302cbfdffbcb9a656d35bb94e632b031dce0d447fcf6e3b0cfa613ccd28e93aee510e8f90860b5c8b9de28660d4238fef31a1d1377dca5fd563649a968bac85a2df4fbd15b8306ec82bde06cab6594e306c56e71b70cd3a7a226a6b8dad8a3830596fe207e300e317cec7cd39f626efced95a183fe3c6aa39e316180184bffdc2e55f1f9b6f48554a201c5265d64ed2a19b2cfb48e16a33185ae06de401d8855bba4cd9fef2324bd81d8831a986ba4affa6ee36ddfd1ef956e1ca5f0717b22aa6f8e84c5f80d9948ea6d650d4f6dc0be55317a4d2776e75e85c16b92ac8ccd236b7c867142097ae02c51301efeb527cadaae7e1eebeac215a4f7c49ff6469b5947f3f46bf7b0891c1fc39895288f249c93f9c14478dd17142505390838924c82c7bbd01d52f3a490b17c658b0b9aa493b36fd002d77105e23935fa420345fa9e3a77c953b4fdf91031d415377d61aa8262e021ea2cfbc4ae73456030bd03819bc90deb244421dea39e9945180e9972cc5e20b969a66b9a7b7529980c0734d4463964186b2ea35a22a71ac04691cbc19c27076183896277cd26706ef814831bb884c72e16466e9e6ba682cb1a9c2d8755b2149a7618be29f64f552d8b37d6e14a13231552f3ae11da9ebe305b04cc3a4c58f9a3d9934ad83fe1f610ac1c5d126dd75a8e76e3b3b23d10d5b90c02ef3fba2feb18f77ffea7aaaead73269866bf46eeabbf037d9adefcae7b390d0b0ae8d563711961e55ac0e1b79c02fff04e5d9557548798377091a53975c5f7413ece80704c8e7c1109a01c6e5e5a80304c8fd8738ce3a5f449af0dda6743122d9f60f5af579c4432232f27c3785d88ae98e9aeaec9e297efc933f45af4807449e883e80c1d88533b607e7f7c76091d2586b127dc423df2dfa65c5825e953a5fb88d0c4555b3ec1575ac912ea727bc52c3a0d1ac114a2d570ad4b1541e1708287442a552464bd52f39e7a4066df111d0e1e589ecac8033f9572ac1691d9184a2ee38870db68405fb19ec648913506cc7241b5e5f9b11f2139ba31e2136ebdde08804b128cd4ac9831acea6eb98c0f428b9a40cb2d3cd933c628ff835ea583e42f23c28fe30fee14b124568dca242256687c0f2361ecd0e820f5c01764a50a36816ce8dc537c36ac2a4056c4f3eb33ded37e61400165aafe4c5abaff88d251dbadf1b4f8cff60d1da70d521d820d3b9d51cc1ebbf83199627ed03cac87d0588e70695521caed3b3b622c0ef8499315fced3bb51f13e3256a26f7e94d8de6fcb41ddeb03dac6e87082b2480dc904c3d9e8c8d0a0273e1a6b548f8c863bbafc2ded6d7beb2218c139aa44bad019e245f6f842ab1ffdad8c6fe8392004ab2a13b3df360b84e66a4a82b87ec8fe79711a7b999669f3d5808e006f8c12bab9668aac1f65102b842c3dcd9b2451b4dcd628a483b2967f8fd73922bedd3b387bfb76e9062dabe5deaa2c26f1d25db2599277e2f0472b74dcb44bd37b9efc6a46b517a84b942162a8724cbc58df16e4a80ab0033170db2853d5ae281bc839ad4e23aac0c1b901ba33192b22acc76cf0240e5db4563c9579384463410f408a1677eb91d6de36bd8b8f02807c6ad45efa2da794cd266ed5d7a44c3e40117185745677563f009962762391d3c5183304928568a63eb2b0bbea53e95c3529e04237db628acc19bb36f12043720c8ed1585cd4b4ff78558647fbfab2bc9836b757cd9bbbecf0f8d48cc2547b7fb84cff59f3b8a749a6c80aa3d46c4e21a46cd98cbd0ff1cb98f24045b5fdebc372ce862a139106e344ee8f1fbf64e469a02a2a5ccf144f279e4e9395c3a43e67c241f47ae97cca1b978df37e505fd2de8effeb2214f45c11e60f72c476c367f4638923370bc4fed9835a3c534ad3a4c1b50a3fe2e218058e1bad4408404801d9b97877cfce1209414d14fc7c30c12fc8daa9cb3cef30ee93f6c3598cc1e19422aa7c7f6bb424fe73d17e1b82d5eff488ea87db1ab8fa0ce5e8f3dc30ad400d53659886541ab4081557eb9b4c43338d347fec51231afeb7134a7e4a0400c3f75fd7410af564e6292197f88d9c1779a6b89c70b8e187e3142a269374d7651d0e3288c33cfb3348202e2a639bd32acfc2b6a786520a5ab5fe0889645d1200253d39c62048dac33f84b17a195f7a946802fa950c130e78577f899fd19c042f9492017bebd7974c219da63f84b7e58952dde432486bdcf0fa85c10cb93795df4ac74f53423acd72caeda384fb54caab8988d10d49290589523c328b43052aa226551cabe6b5d88eef15a9754563266cbf01a462135b4484710ddaa4bf51b7688d0351938d0c0d0ee83aed8ec9d5960594e288e27f0ad87ae65a60be38957fa85506f4e9a74d02942385d15957b8ba99d2e5ae20070c0f0544f841039596369bdfd30e2ffea9bcd36deddb2e4de3e718e54b5eb6e5d8e732b553e72b1c904f4b34553a999b679abc89fb747ca8a782129f603df84f0721ac4341f485bac73f6bf5b1556cce0b4d7d9c63242bd40166644dd8ef629b2e6d8dd6a1118e62597ff0dd3179f0d0b05933be3db1f22e008d3a18b8b7458f75d05df2d0a207771a7dafd6cf95c5c54a21c43fda202b3f1eed8cc4404bf63da719ec4800022625c74ad5e28b5f3a74dfe01673096a24a48b80aa579c3f15685c3c0c89a9c3a49afc974f514ade906e0067290780a717fae8dcbe155a7d32e84c5aa952cbda958b50109aaab02de5da44aac12d8dc98c4ccfd38e0afe89778300970141f7641305554137178387085bb185c1d90582c65b0f59fa6823eec867b7005174422109499fe3d1558dcbea678cecb2cadcc6508e644dd248db95a6b0c51cf20a90946668913cbb1034d44da8ddf877902ed02f01062ab16b184a0d39ec11fceb4294a1649c628145c5b40b64b500485ab1ab9e12c030e5e3b64a016e7bfc3d2f774b777096933bc8c33ee8ad72591e1ed887b616e9fdf5887e908409dca89594156f8fa0a53d2052c91f7323a4a407162c1673c61eeeabf8d161d27cc051c4287c56c98e4086a56aaefbbc85316cc13dce256366038ba1f1d84d16d41c2aa57ac7250d3a066cf8ed4c9ca14f7fd5ba7e79e476734bb3c4015d2a39d9a23e102b590c0cdc103013ba0d6bfc9f191f8f63afb35889dbc76880ac4fdc77c6c98780863809b00029a598617ff8f685af3052febaa718f638108a6ac8f6a4d9273f6c7a6b9321181ed1e1d95b520d3c23cce93efbad312b963cc89634cc4cfa1ebdeac3a592df1f1ffc354ac84dbc5333106197089db69fed1213dd317ac9fa1a3370973066f48d16befe5c7f8362be2fadc15c9108af22bb5793f118cd3f350623ed183986921159df6e4f7b0602509f1ed08e8021c22fac214010d8c8b1f361c2ab6a06c4cab5f39066b3429fe3d4a2ab1ae590d0f928dc8e267b564ae9cc513d6705adc14d2d206dd18354c15f52749992299e8ffbdf9e38b59d4c986229cd79c53e4ec1cb47ef21b108b5c3f6d1a4d078f9d2325e80e486cea9c1d5aa79d88e537778233ef3ce8446a06bda958e0fc50c5a13241c20d67ddf55733fe4c3672d2be88a6d2900f4a444848685112433b6299c7071c7d1bae18f87f98e86e4077e7392313021323da3011d32ae8cb6696c25b6e4fcdc17c751eadd2a72a297ad6a42b6eea42a112c4d0272667f9eedfa6d713a3ac80a5e7d9f239c5b233a07195dfed9cbb9ecee0e8cfc39bb62d26e587f464329185106b2d1b1c355dc6fd0995b5e5c8efdee1fbf872c580a0b4c54aeb1f7ddc615d27925e663aa36c924ec07db25fde7e104df8e71a8ff5a1c6b7e13481b149fbc308b80d585e6c88f0b6d89afd96f454b876e4ea147c1acb116041bc40280a510542669b18e342e3d62506d755b59c14bcc3650f65c64b69dbdfb6f48f99d66c14d83ac2ea2e75af742832ca3c2dd19af2c7cac0d84b0ea2312e7498edc2ad5bf54d69baf05735b21c6bbd71a7b830775135817d8959aafeb7230721fc227617e664a4261d527bd1e3612a8cea4df680ceca8ea39b161530148040dcff6026a02eff64d760996fd8c1acf49708c75799b13b7640efb452b5584f9349ee6f122eb86e170c0ea3ff3a554bd22153881d9f67367ce6a088afeeeb6054e1b8dbfed801cd8c233d8c91a8f2df8b89764798154e67c185219209ad7b9970290b4a7f8f1804511ecef5a3ac3452af63834f0ee4ff740bcbe4b7179618891ed92887f561b562f56d62c5c8429c76f2a64b987d00e8a32e5945804888a661056a445326fff07fab60b62a61ac6bf196aa15b30b0cab9f25d967700a17cbd951e0a2e65ce356ff73db8e5e30c0dfa7bd693ff90ac069439645d765c506959dccc38fb2d8c80bc4c5b419db6b4556bd62da41b5424be9a8e6716f472086153e759dbd0052c072d603b2e873f2d67750cc3f0321f08c7dc5531f2485e0139258e60add7a41d32e1f9d331b77e8279f75aadaeb51a5f327afdc69bacbb05ef279e17754e3bedb9a604f2b140851ab384bddb91568fd7ca6ded22e6431dcc32b21c47cc7ef6ba7542083b8169431970c2389eb5bd82ead32f26c77a79ab3c5137ca860adbefe5659904c0a9799865b5dee3d4c391a64f4862e578ba2e245c2d5e11c9719796743ec0d15baa8822ae55870e36d46c3cb29600fdb3a3c1c869cbb25e8f246a4473d56e1952563c29d1d817eadb40e2a4f923d071dbccbf0b7235b144fa1e5d45bd1686b19b495f8e079b14150fc7f795853db4a5c5c2ad92dacf1bd9812f683282317d458b63a6adef08af793fdec6a56aa00eb4843bb2c5e6f7180add97392cb7ec8734d4967f4c02a73fa0e826e8a786c2272ad6968ffd927c8cfd8989390971545cca7b6bc27e598fedff9a4e18f73064c3a2974bf6dcaee40b3c185e6b1a46d617b7e5cde383536e1dbb88fff758564280bde56b7500b0dfb6b52e056b3352ee802d2778deaad6faeb5002af206b7afa7c01828180ae3e4ba9f8db78dda2f466f5ed28a4558350ff602cd54647172761b6f34edb3cf8208c98a1f30abc0440cbfbf7e8b353630818d26d6f5fcf79e4c20babf5d31cf8beca946d87be96db626c3a2e562964f6ac39b57278f88097b79973f9bb0ee80dc463411526fd5fc49e70d34db22cb35e2b80ba533a146cb3790f84bdb1c37b94e78429e3efc99187a1002e336219f48776faa2a501410591b4d92508c52853c37a1f32e869b86a0839652b53f95d30b698c0894b393315fcf585a6dce34d21e0ef7c259184a6d3bbb0177bb272eb5b8acc5a23a12b3983a422623428c6a0f370bccc2cec070403f290d21d48073ea32d7a409048aba66b3a3033045f3dee3c7e5668962518365e4592cc55863f04e230cf4d1a37d114dfb0f9544590237bd61ac3b821f3b38729b6aa590824ef0ef8a7f780978938d5e193fee9c9d3cf6c975b7e34480214401df8b41d6bd23470bb0c630e0668883387e166ae9e0587781d109e84ad9951d8ca55c3a4b6285545280fef553a57d1be904f6a77bf044acf96d22b8572d35e69e9b0e5f4514fdd7f31c7712f732c6feb8187d4fb67494ec49c4f3155de856b682ca1de507a6761a50edd182386690f579fd870c37445293669bd376c49496a373329b9876d153722bc56b781d6602a233ed7145172e228a2f5fd78cadc451bbcfda66ce58f87e2db530174266887f8aa6b47db38d731f69f7f01bb98b6ab5d33135898ec87862a0fddabc6f7bcf548b6c34b2e5e00506b2622861e5566a35f7ab7de3b94ee6432e79e711ae33f778640e674a9a7137945b859df4bd2bea3f19cd6c2c66ae415f1cd76cbf15ba9248d72064ad9db02a6e89b5ae375d23a03750d41522b09bbddc11ff16c9059719807b1ccf76d27d7108b4d5d43dd4b13b900653f4b38fef39ae2361aa8f257545ef684db70b37ebfe8f68899ee33cba6570084282aff06806caf9c1f6b78dee3f1031d9fa047ef11759f982284c7f2c8865ad5f01db21834413bc60c5e37fed4245d572ee4a26cd5db49d27806bf46129e5259b2202f87377c52fcaad66793251b834c8dbd6ef621fb353d52a758b4838df269ae01e95e9a8d926d5e8c251e19c09d59a10ed7a40dd6ca6f712dfcf842387784a3169c37b10a6b981a2f6d9265abe740c9b1f72e0b483986174da3d8dfd0e2af24e5abddeb4785021bf85a827142e37ffc45ab49b6c28d8375db4c6c09cdfdfb4db0db583c1bfd5cc1b7962897d9100cd3ab76abf0d9c4aa50059960d75e8b4738fafde56df12da0e88f5678cb192cb6bf3a772b75d1df10ecf420cb6560d9d38f684eeb816bf2b86906af256f2c2d3e057a48fe211e77347d7260f5855ee029bac6315491aef901589c50fab2daa7358529c1c0b47b95c4548efd29400611f9464934dbef18e6c130b8b5fefce95de2e53702b29b8487d80a592c8f183259e85189f3b04b72a7ad3040006a247f73ff8084dcf2508b5a1dd29af41d6a33871ab4050b2f103eda567fe471379e4f7902dc95f3f8ed91f7e2bef2025cd282e80b9a5f4d8635e5e4e69f242b491637674d60cc41ef62e8dbf74fc5e1b6881b6ebbbd90486688524c970140e2258df12bd3fe3d392d4072dad1f4823a69672944471373cfeec73562a74ece04a0d94d7e3566affcd6bb69eccb6afbaf39792a1e9d86e9388390fd4fa8a6a9fa9b25dafe859daa5f87e54beeb28d4c178a76aed113997ad2f52f06ee68681f3c4bf6e9778453c45535e68eed795d6d7f105420aa64edb4e4eec6d0c43fb69edb1ae31c481b76e265a0d4852d7b09fc702aba9e018229448eb1fe61ed6f9af2434c4da6850251449e2b2b0d2526dcd5dd4195bbf2fb70b15a0192a9934eb9cdb5a56d392961db957a2585a08e0e49047db5c4a6a4bcd996bc5e28366627afa0fd3db8579889faaf38b1d2447ae52f7aa8ecba79d9cc129423498cd24d974d9a6222ab1e3cd363b23bedbe6346784cc090a4266f0b6696005fc189ffe352134f6666536bb00ae1f638f12a8b3ff21143c68de2ebac4c79626cf4f6e4462333fe1598da3fa14fec35d2272f40d109ca9c8d6394118fde8eee794f08d3af0d8fcd6562593625a013f3dffd9690600d434482b1ae2764ddef0ff3fe1c8eaced153c896c7d8938ef580a8365184958dba4be7de855cbab234bbbe0b402ea85357a36abc5e4d1884fda2d0611243b47cd2dcece65c0110d917ae3780220f718aaa1d0f252848973d7e9a6835fac40bb9a455c63b264c51d958761d5090678c4cd84b1a1ed3ed10af6231c4c4072ada28277914cefe0fc461512830c26d28caf7f1b5d0018ee77897a7d8cdf6a50ce2e14945f4eb3af15343598b3ebc219b2710a855955fee942d5c95c2754199e63d7282102253002afe7e4358bb588765fcf3f4006a392f31412355d70001fac17de54f940febceee973e6ec95e54c7915d2ee630f2ba9b58932853854f1cf535e5ad1edebadab6d71ca89248aaa57a31438ad4d7435be5d5b420de6aad34c2056bf64d1286e570bf0bc64ab40cf89b532bfdd6e4df9013b8c932010074d0394a4da85bcd782d8acae67ccdb32719a6f03d680a6907c5341f48d0d4bac0091207d87b4cedff908930b310e92542af4ce1309073e49f20e7e03a2efff3946c007a13d4ba2c46129cfe90842e06e2613c89d03e4d4355d1440ca285a9dd751114bee4a652055d0b44d80c769927eaf0a233653c7ae6eba1b3847334a99db1dc37ca752528ff87a10488785c8d67886b379777a891029156e54ae59ae3d73888bc40a2761a5f80cdb1edfa61d787b661c838506b56888c33f9c0efbf75e0f41b621eddc2b15264caa9d3e1fcc0e1aea9ed14421b28a46f344620eef4a0402e47f9253acbe6d804a313c499b38a06387c43da50c98ea051cd7265377a69a0313c52bca709fed9b4b8b1ef09a0f99af19b0b212e868a011c8a7c3a86166c234a22bb390af717fb50b50c23e0da9d9e905dfd6afef16d2a6c229f06905970473d47162431a61768d72883d0d723426e51cc96dd07c24e50d50c165089d27298baa85be93a2a0ed0348057a7b02aca540811fa5f17bc417981c815f7a8d2d8347c4e5022997b52c4e89de0903865293cb72bc0fc1ccbb007bbdaddd1b50d215f620a3e0ead8e823d79b0d13e219787d130eaafbb0b4040528ffb63964c461f5d311adcf0b9cd9edcedd0e348b96e263899d33833ec8cbcbb733c8af705658f4db70472ef8571a13199e4498f10f1702a386656cc9f1655ec53e605a36cc88446fbeda728105236aa42d0da3600c94d2cf4ca61862961dc19431d6eeceffa5c0309397e9cf31527758e6888ea8e535eb8c4b2f28f4ce65a0d878d4f63f6b4561f53308c827f00df3ace0d54db762920966fe0db345c74e3a4d5e6ef3be9767a0f0a4e383b2d45a40a63d89b0d078a1df2a5d6805e7cad14dbe8daae1cb240dac6791dd31a25f56411fa4d8f060b142efe4ae1aba209641b3a98b261f1cf58ca207d9577393e9b058afcb693abbc396621ad32622cf8952eddaa02eea34ba6cc0737ce60c9fb5249db51f55f3d3dae9e07491dc8d35ff418e205fc3339997b597d1cb133a6d01f000dc261c9a79c71170cc30bef5b6c27e686565606872c90a0f0a5f9181322694eeb23f754018d39f3dc525b10c6898da82bd586eca9fe191cdc9e068e4dbf42cc6725f9eb4b0e92732c876fc8bf0c791aad85e995606ddba94a257dc90ad97f3b3e381dd9bdc5768ac85fdc9ec095cff4ffefc20afc63bb7feb2bf9e8bbde1ffcdf9e716b6ad8139c6ceb43b90ae89b4f92b0b9d41aca8da492e3918b5a5ac11219cbfa42e9d878fc23680f7f8a715aa7d84bd961bfa02408ccdd9dd77ae841c533f4ee5778f409957ae6ca518ad7b3c30194fbe737168da2665d3afd83e25201e6295ed624d2493e4c8538b6adbae5d3c3d770b5d0b6f6b0a7b332ca1c63c2c5d15bcdffeb32753e31559dcbf2f27442284bda3535708f7d96aecf38ed693b570bcb46478e518ee8459fbaadc0d6541d7a50f1dd8115dfff591ea9966c077de5b9d7d3d526e7b634e55afcfe807a9f8a36d6d2022a867885f418f2c913ad660780700e20259e97a2470bb98b4c4c549715441eb7557e243dbd3d39391f7eda0f6241614fb219b569ac17ca4a70e24f54f3d496133990a5a2b8578e6f9eacbc5ab97cd2de74b196618c5f1a1ea7509003607aacd155159607bf96d99281c450af37e4337e270f3340533dfdba11fd495cb52c624ad70586e8ad50c7ea52ae8a5518684639ebe39cce7618ec0321a507f94f0f5fef817e963b4a9749645424c57b9f06eb15794163f49263f2c2641b1376d02004d9214fe636f230a8cfde468b0181eeeab425c1b093ca125da5fd5a6db8433667f714b1f815fab74d5686e3e56ac3987b0842eb6d6e3e29bb6717d4a464f90027dbd7e58ccfad9cb11c33fada32b66b93e675f7650a31b1407bda6768a9bc6b0127ea8ad760d58791a824868afd95db332b2a0fcd3be470452241dc30e5eef1515d798e694033f42b19a63f04518d545d39ad8ebcb847d09d44944c6f8fdfb6cc5e9649015bbc59e81acd479cd1f63b63c7cc981343d31f2c43faf4900b38acb4de44afcba990d8d3b1b73466683728173080685fefa558ea00d70abe92b92847d7249033f74c28900339a937426508df57e96dc9151d094f4f05bd96b65d62c908f19c849c8d86399a8096396eb48208baf348a36e8ffbaa152a769e1e98b1b6db9296c1822930eafdec3fdededfaf0b5fe9091d98b08186a1d6f41c71f36a17dea4f43e6faf5c3fc3c50bb73517cebd604488f536e7d471b51b5437772ee17f6eb16bed4100bacf0db1c71fc4b6183e8877141344919fdbe7fb9b2be6e12b8b874df7e7b26216b3963879da1a29c7c9a314392f5bbdac18982fdcb3c6c0d42bbf87842f32b955b34ad24a7887a9e9cc86b83edc4249b67ce0482449ae3364abca59d4563b3e1025d7313aafa544702d9ef9e3b32358c2b13107551af6d1cd4842dd466c860e9849a42f4d2ff315e158f4a66223de0a7de47d08ceb3500ba93f7668b0f5940558edd6bd1e06cc54e2c75e51baf3499f377ccfd6dd96fa522d7f04f07ef6775708fc84a5d353bbad9b324d5410de46d1076655be9455b7990f5f252247f4b2928f3e38a0c7f88a6cd0bf810c97ee4d844cb4f9a67891c16b32de8429ad8a63d6581b462c3f611934ae47f0bab13205defc2d6fcd9ddc817e69884a7b39c186721063bf1c74f56fa51262b0be687de090b090f2a4b29a0cb53c9405d740b860c00848377da32b0b9348fd0892b11e6434c19728d436e1e0b6921192b6126d1b68f17c3fe2fc3cf9e794f1e0ee90e705fc9db88eb2f004379fcf1cb422cbf6eb399c12762bdf23c52cc570c122ed70ed6657e350f30dfeacac896169c2ff00b1c482cd577234e5b2b0105b97ebeb1e82936c8fc5c71439a8459d8ee389f84885cc57d78c4dc431c0b99896a2fa232159cc5f1839170835e991edc073c8f30f3608afe7eba8e8424cae7d5bfc738ea59e4c8fafe44ebc8ae2968d1cdc4db411d52c63409a8f1d326ee751466c0ab6b93392cf5c9f6107f6fdee7e60e6602bddb3f5a400715d2f1fd6747666453583d345a1a8e5caf7172b76a6b89cb7eecfb5095f47e4255978fc00acc2b2fbb36006961c1a7117d8851c388fd7a83aeb78f1be5ea1562d131be202f3e2b9ca01c6ebc25fe9376f1ae561f2ae07116d0ef76a6632724ce694f825ecdf8325286181fb5adc3d7ac26e2f0a72a4181f5bc24d042aa8ccdfdb945b0accadd622db3fd17f18ac7befebf6bab5e88062ae73b5411e17e7038293220371cdbfef19dc060c372a544457b6214b194d52162e635b056f1332592f56c4b494668e9446bd2cc62ff01e2a55f0a3af0b59310f6be5d5018a40028cb0c51f99a7a204ac9cb05cf0a505ad17a5a22cefd78280f5e82ff17ac1121801563de8534e23ea0f2000549cf0e1a612f1370bb3fa1c54172b54e8225762ad928559b2d816a8a07c0cd6bb3bad8625ca85fa27093387526d3648ffdd837acd122ee4cd331259b2faa8c42565f6fcbfcf02411dbd2fa022e2cd40820a704a1b243e2d300126a21274f8b804820e94d2873b5919e091d791418b613ede207d966071f26d6f10ec0182dc6a8c16129b5f5ddc24317c7738083c2b8d81dd077f35fce90e45967e54ff0342e3ac8976d3ef8ea5de19b6fdad7a1a5e741c07209ddc82d69f8fb27182d27d31c9a5e8b112cc1a25876ec6251d7867ee2458ffeda9ce69c5ec16c6b471ac6fa861f23e6811f3570e75530664f2de399a450594299f8dc78c0cc88ac8051fcc3be11d39b2e746c4560cd3e4fb19f6ce70943fcd7c0f996f85a372e9ead5871e4c74075f074a240d56f0668cb91a0b50f65bcbb075cbfe178114e385254d5436ddfdad2837e1c16f01e510bbe3b91e476e8c50b57af3d1b3016bbe66d0b1deb8481191aeb517d48bceae45f63ab20547ab0525dbd49bea99b89ba18799790f956b3cc251385469287120b03cdd41213024b28de980db93ac59dfbf130f8e6803bb82ff34312f7955733898a2565b3cfded74e8ae104c329eff82089bc47943311d9482b14685f0385f65552d56440f56c6837ffec0685aa638e520868033e60ac7edf88e46f2baaa87b1d61b61f01b54da13dc595560d14f897c9d461782731da3b7675b6e74bc745e9ed5b573fe39234cb85fd6719de37eec8f97b2559ad7089ed3690cb19b7915dbfa89ba18703bd25764af12396583f8a4329f1f1464d8f6bc2aff46418f949c36effa4bee9d713c586876923bad5e0360e7cd2d0850f75883c8f95158330428026e90055e05d28d3d632d454d3b33381d83539e2f81bbc622f07efbbec60b55a2b767417270f4321199cdbd2c4d2484ec7dfb6a12f0de78c37963a8bbaa40285e230560da082eb659d82e315e7309845499c5a7cebcb42952e0e10223a3fbe0462017c22f66214a0d1988fc6df4d2a5d549bf451d2e40a4fde32f4bc967ff33024befb30720ed28e22007ddb1b4da5b86146e17ee865bd86c709ec3e28d639d86d2ae35c5e72cecd4bd1db76bfee0113e1b555dee032b559a552b6030c56e938048f38cdd570176beb8bc14f3f9c4af6777bfa11b9cae8559f06acc089b407978839a115ebea49bd38c14e663864b886d8d48663c357e2d110a0e4fd1c056d7a7280a144be712769a34995ae2e8e18b03f6125c854347a1fae1c8eb420ffd6a9e36c15b4a922c7b2b7fd96267780fb2631390663a1633da319433bacdcbf5ead3d38351fb35f1c81a1b353b9f56ea8eecffa78b3195b6f3fbfb0ed622737c362a1c93e15b282e5967a8ff90312c6149d31124f2dcc13cfc1d198f98ef99832d401385ed09bc64c62871afc1913014a7148552cf83c985cfca4ff95f3fd45ed14f530dd71adda6eb041fe73cb1d1fe3f094d9c53293b1d3adb0be835baba37b65e28dd38dcb9d1ea7f64a97489675a2b7a21ccd56ed16be9e8e078142af43318378385b261bcbd50e4ee7d6a407e5f434941a5c9004de9dae755597c03c8dfa207ab604428765db337fed27ed4d91856dcf52ec4592985c7c9604e11534207772e23e9ce7a9754fec0494ed6e723e228d562f60c9b89c78ee772931b2263c7d3e0ab8d541ee1f48e08411ecc7c9055babc4c8bf9f7877481c391de01fb142a2a54e070a970ae6f5c08fd5956e700741d8a9afaf88650601007283329212c91596894737acbfa323a808c4466e84befdca0dd737d07b727a69c68826a48068bf13c1f48fe12bb8b51f117ae9618a5225030de174a82c5944a485a5868169913357e408ea9824ebefc50417797e4ac298e09beaf7c4e9354e07728ea0d2f413afc6c77563a29d6f26104d6d37460f4d54ab0c180a7dc9651b5c45211f06062ae62674819d458f81b969812ebbab1012561867fdaabef6292a959960e32da2d22f8aad2f3fae56e8562988ab7b56c7a2cc1a978e95c4539acf4fa2807cd130fb36c0631deb8bba1f80b0ffbda878bf10c56a3939b39ffdd729f6a18d32a071f39f1f588fe5f86e8663a53aaf80159023991facba6343b3f36e05015f986eef9ae67097598f32f5f03cb213aa92cb5740496a96fe031a5b17d92163369ee6acf3f42fd4ff2745cee50535716baad836479e737522c17937b21fd6b8a61baf4dceb8c63d6f9ced8a781cb89ad99f3603f6f32668d029215743b5cec63d7fd2a43b5e06e862882d1b58a2e4c89be03e64dd437a07273fe9e1ac4231ddeeff7e10621b99b3c916a36cea40ba1c0eb36811daab7882c96e28367309d84383a0a6","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
