<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"92ad6561a6398b80f7052ebd90903b8e7d6a65ef6b99c9fb5c8962d5094725549b1b358b7f3efc52e7f99f5db4859b2105dd0af2340efe72a37e464165c4ffb49e42579c1de6c742b1d46dbe9661614787df1cc10d00e4e55d0a8e72be7489345207e937d6d3f8db8d1f90070570b03eaa791e9e6f9de7754d93d5945bced1e76b38cdeaf33fe3a6caf905dff60788214abcdc306a5d5ecef5a1c9d25cd6cb6ddfdd494572deed31138eb492cac1e6e8e2d1c4526e211529b2d809413663dbd652c4407d8726f892ac80ddbf2570c9c3eb3e873292b94213545e7fad0fbeefb23d4a42075e77839da8ca8b31fddc0c0255dba537b350b48967541613713338fb259a2876399353254dc25282d5c03ac1c3f700922a96380b709a8942ad79b89ec6c9adf778b595780f927ea269e41318f7fb1abc413b9c3bbecf6987036230609f32407ecb461517b2bfc86cf2b6b2ab8ab9c5d4de4b241fc294e7fdf5355a2a05c6b886c1c5afb86c639599a48f2568dfccf8b8d6c6265e384b54b99e5d7c1f861e83e422bfbb81dbe317c9374ff07a704d21304ef3857c63236991adc9495dd500a8fb4353af84eb9bd74ed7e6a2982c9bcc894fa96b8bdd6334c3f265a3ac77d8977f6c7fd03f8e1e1cabb904587b113b701a9ef899da0a844a1efee188622c143420670e67ab51e565935e1385be3b4e3ed63f897f1509c9ca92bc1b489a346a5b5dc0de7844de844b3e724c75f8c5c7d480ddb72551d6e3842738be7b8f86d6f4fc7372e58f9a3b1d80d7c86a3c8a4734d60cb43025ad552e64d5d0479aad311bad9b7505b80214b12a40fff392f918055384c7ed77273fc59b5f96742346953ecf6873a861d244283af7cf145d23a81291b673b88df8649f2db9b092ce4cc785d12c049b7dea36b982f4e4c2efbbdbc9c3500e03e81f70449da445e8cafb7236f15a3e595de2901ce78d262bbe2f1c9f292086560c9caf250072f1abf9ada413feb51b1a4507688dbb9befc30ddca7a43b1bbbe711c201ee300e3958791ffe5a11fd2f53ad120f4d050363cc0612876d27fd777f30cdf44a1e3730008b20107385b0a2e389d019d4f884b727f26e4cdaa9a0da0dbc3ad2d461597b7e2593fcd897c11ba0aef16253724e271ad4c753e0e565c0a18b059c3c8b7ea357bc9b5245251eb92a3c879aa9044aafef4547197478e889718db3080ab8bcbdc410588d1339d960ab33172c6a469f1fbe5180b9a7874ecd5604512aedeb5a5c11583abc810af0b0143cc0fa9cdb1deb0056f4b68adbaeb8781fbda9e4e34811791888e9e972d382d6985c5718244a18989c67e834d78552d2e8be9e77d301df975f8626eab8c14a8b3a7eb7265f9392ac98b3752c882c3e3001c3eeff8b0505ef11379cd4519eb89016420b324653bad0a5573d4e0f67f95f736926b39aa5f1f2b72dbb5af15d89dd88031d2aacd1c96eea481ceacab761d1e53355d85177409557dc68a2c5382a453312a640134b55921b66681d3c0825f35b8feb2e435fa7b09c02865c0654623ad35ab4f72f1d785868346453c88e3be80377488408f6b8363de5e78eb956a903b0c788e8615ca79cb8e1e72bc2d16a4b87b93816405c8cec9650358911febaa13b9ac2d7357a518a587633cfbe2e64f0fde0098bf277b8d0da318e0088db8a019c6362062a93b9c8d275addf3e8033a6b4a47758fe6b4fc838c6227feb87763384f023a1fe3e6c29e0c616ad44b56d475904f9aac5d2dc1d2bcce4c0d22a38fbc4a792c9c06362c6d0e5402a2d4f9298d5c488d9832b1a029e4f7eba3eb9ffa7f3bc751f6365401954114cf3e62633bed6e0ee3f0231206cb2ff803a4256e666fccef56b24a2f5c07a7cdeb16231044474446b04dd8ab6886f7a8c8b20faf8a61eefe0cb3981e72a4cb2dc64d58119b1b2772b0b5b0213947ff08b6407acdabc431de6648dd37f42412d3c465e2acf8532c79a5480b07316c7b5ffe7e135e5a335fce589f3fd2b844c2bfbf45616c66a5f45732fbbbc0ccfb687ead83e9af7fa4c0ef5ec064cee8a3a32a4ff2e9eef8fef93d7cc615e9ac4cfb9371d01b7fb13b7be291e4d9eb4cc9451274c3ee72188a6db189b10d166c44372402faa980208d25e4603776fb391c480b507cd945fbc15c9be35f7cd9d557e9cbf6cecb114fb567368f0605e813e18ebe8448e06adb7680f6b9672a082c5dcef119f1e21e0d44c88d66545c322b618402da55afce65d8a54812dba62c74da081fcca8624c394de2f9156a93d14b3e7694da6acd177d15f1bb36d33a9364fdaa80a90574ddbb59b2d366e5f2ae55296ecfca1adc3024b273d2ae8acbddf52f50ad7418bff002d8cc77e86497f9e47a9f70087af797614683b36d159aae59a4c479a97a234c339d550e6eb86d0a047c892346da56cb0270e6321ceeaaa2abd35daa3ba96845513de4e19e20b068d1a44c07bc0c8702a0bdef182246ccef0f2f9981460fd94d0be9ea9bf78f28a235e8b9f9adc1ae2d7dcb7509cd9fb16ddc43e445d7102168c88325bba6d8e55921667b82420d6b7adbae18889b0fb3ddce55d15cb7bbfd82c4b60e65aaf3708329e844d79b747e1eb9d32c15143f9fcd9ac06947e6e0719dfbb4d4bdc33d25ea27bb16ff5ca478347e8f5a24e6dd06904957466317edf9a9dfa9f125a9548217751f40145fd5a634cc8450da93318aa8fc1057243183f1ee14954b3a5ecfaa5ec24191fbf8a106fa117ea7fbc880c46f2df708f2bb56cd9ba115d9939874e416823f834569d804bf2c6b46b59e81d859f9fd9436d0489a9f8b87e5526dada4504941f9cb2048a2e16727429bad11191df2a8d741807f36cbae695b0f96b870f9dc9fed66bd8a5efaa43a3a962ead995c6ebba4341e182ef26e279a8984971aedba2763bb5d294be2db18345c8312a0b8d8a9be40cb55e6c9c7d4306ddcb0eb2dccd8d3139a2e0491cad9cede99043d2785df7313088246059394e12f0166aa7e2cbf099d8312d4b38f075e0ba1cbcf15a32e255c04d084699ee15dec6ed03d752640f325f780a282f0ab7a1af41090bac858852c1512f1d8948b0ffefd9c59a98ed9a24cc5c60ef15d77d361bf3fe2ec518b31ae80fb673fabdd3a5f277eee1e19c4a4124f4fde6cfaa3e01934f8fabdc4d0cfdba05e99d97c16712bb0994c926a2682ec3f6bf241429084c67d98a38d9d9a42835e54061b8b729ce0d9c892ffc1b4a0fb4e55fe5d46e4c7bba81fa6a5d56507fee89f4d0dc7636acb6fc9b13e76721211a99a6bd12674b2315c9e91cfd51f83caceb7ec8165453bd28f19941cdbe663abb9f4324d6796a2c9d00daba6ddc0ac25d83c1ccb03fe2c84ab0e146ad87ab0f87d98bd53d7fb959f8b5a165239049b1e4e72ae4c2c1f53fd777a97178f52eceef01d31adbf70bde85b6394c0c5dfe27e6f19542d283f9d12d2076e463dd91dd9045431d79923e68f5151f124acb71063828f72262773663217b218b502bd938b14dfdcc792a57f5f140f0f6ca9ee0299e55c702fde259b1ee051d7c87a7b9b0ff084a9514c0521cc85bc86723c3d0a9425c372e2f43614eca95b4d4cdfa652a4c040414008405949c59d842eec2b8c167e1ed0cf6f60d3ba89e789c7bbb1dff20ba9880310742b520218a8d59f5e29b9b62e6ea1d06f09898346a535b60e047a666b643113c24423770146d7995fb37153fda3d34f8816b00fe06095a0e1810da8f7de801a61705d09649cf323b661f03e300e7d8e71e539b01a449a6040135f008540a56e7683db54d51cbba493900da1439c106747a9a0978e084df158991ef04315944f5c5107b7f6b0eeeccd91f6e80b045033d7b6444e03a5066e014605e0af5d09d460bd645d5bc5665dfadad3c653b369ac40389297994238b643798bd62eb23fb3c012de2587ab1445a1c21a61cd4e278d92491101e24c25816edbc3235bebc545c7387a8253dc508b4776080b8bd5a84ea08885eb4049e90a3ea8e81408f5816d3ea6d4b5764d493a15455d25caa9f4874d83d91cffb383a860dba1ab97708c0cae33b7c650659a1ed9bf7356ab568263bfd4740c2be61a406b4c8ba5def7bc7ca39a60091adf1e38531e1a0bb29c221b16757259deef64246d1196bd1e94b0951bb4de4a7915e40a3258c747462a38c9242ad9b7f70eecb771ae458a5d20104c890ad9781334150a4f4fc301e5dccac1de7881488338b005f196a99640bdb473a83827810fa049cfa826c99461b58b1d54fd85fd7228f89e9d36d0eecfc7d980f4bfd80bcce6373f8ae06e13c4704cf3d064e98580aa22c0f620b0fb165fbda92a9e8c385e845fb24698b9b7384837be392826b212d5dae49608130103f9c25a18c1dd006f72c26f1270d83a472f6d052ba621c90fa19e3568bb377471fa6f136f88ebd5826503026a8349cc93a8b1d533cd4c25a97a188e948ecf6c0ca6ab1d599fa0a2002d323317206461120beae5f6976c4b07555f3ff57f4d05d48d952722924d73198b617384163f05eafb0395604a09ac310f7cd980bdb34226a0514d177e246f48ae62d9d63939006609c95f61891ff84ffacf438a7808d56e53f65f5ae86259ce806ef4b957cd6fd5e8447d48c8b3ba0c625e067ce5fd7fdc72f0803ce237d2f139e31b7ba65f64db644e8953c5af836e8967d97d8333d6c573c3804cc12510ee2b694830815fd2c1a174463367b355c66b095f9df10b06a5811fc619bb5cf797216f11e65af329040ee7d52bb6e72bfeee65b4f48206424d73e99df016fa5ff6a2e14db1ad795ec47b9063b63beaa9885cd3c4324891f7d65f211c94fc35823ecc64a821be345512bbe93140cee75c72ab848814d3d8cd1fedd816dae3130e91ab9f9cc67a38c9bf50c3070c85f7ddc66de39953cc1f1bdf0a0b6e9fef60971ff9770fe7754eb09c58fed763e1eb49e6b29a556a4429f3d788702c1dcd63036d0cb1a9bc20b968d8f4fdbd146686078b845ee6dd7f9cef738ff03ffdfcfad2212a43b138048b67dc5572f7ddc5241a802de2ef65b07259ec1bbceb899a5df9e53b7dcf2dc5140111af38043dd1b967b5d1d83e6ffad999bb1d73c56f66615e3b4048a5b75f80226b79187358b5f9daf6677b18fbf17211c2c0e261f47e21f34195713147afbb33f4d01e8348dd6546b39b5036deba62fe2b32708e25d521d79cf2e7377cff063e5e17055a00c13f31cd006cbf63f0f96eb12f625c76cc5c97af859fe9b1685fb6f9fea7493b8d5a2a772fdfa86573c4b3a56fc0d5b91ef2ede9da4ec9506286bdb828443bfea94412f6c76d283fa7c6fa4476056388843b2390756f56fce13d1df9dc4fe103c0895dccb36fc3be165ecfdaec025b435dd2feb56ac7075d8e80e9f3668df123234a850c735912ac84da667320517478a7c0eeb63e25c0ed48e5bd0a4281e308db1a087c94edc9cbeadcdb4b979e8b4f537c9172b19c0cd4ba262979e336d3e00635c299e9d079097a2e53af6aa74299f32f59799d1c6cc96c68eb39804470892d45a66893f43fb97f65acb03446de38a9e305fc9398a566c51b03002f810108f4fc5815f2a152cae46c923c50c37c11e584b34c335f68da478c7379898d0cd2e67eb77fb00056e2f29660a27008131ad14ecdabf3bc6ec46518a0bf4f6dc15391d63c6f85b576661fc66c15645a00fa78766410782355f195f3dfb18b6b08011183386d6bea277faf98fbbea6619b184cd80083376a68391a2aeba9bf9493351e35a077d63c51dcf0844f7b2ba9d1005aa8c82344e2bc9098a379557952e6c805a4f54addf7a21cc599b151a8edb840d0f0be9cc32de1b994113eb813f7fcbb956caad022ec46a3943577469c051ffad9603d6b27b013b14b077201cb0641d18774683cb9525a8faa593c335740826b71865c1ed799e9b17fe9cedae22ff1bd60239aef557d61f4685bf33b5d838fd237828469266db885fad9412d22ee84fc52d9717f8a58179bfd3e6bf95110ddca9e058fe48e66868197a363d516e5d133373118261dba788f6f75778bbe45ee874845eedd627dbf01cedd6b17640629a208df59e64578834a7e542d6cfa8d0b1aeacfe06293a2e98039689b4dead3be1296c21817acef20d64bab73125a66af65509273dcfceb84ee08af35030d3a2d8d5e009efc81c29488189ae711626f6ad586a13fec07db94f9aa940c4d602a17dd045605bd9983b4e39e93db5b6b993dd72ac39f240e039f64c7f623f5f15821d18f0bad9524009c3c8b12bd64bf01baa6f7009e9178b235e7e429c026067baa448f2337cd294f80c656d7c0645da3238a28c457325b72caf702a5e9390ff7c5afb612c8ed148bbaa6ea88fda5e4ceeed337bf5b6b2b1fe82eaa67b74d9b566776768e124cbfbec86237e67e7b109c1b2bb261fca1a710e946218d049e43c7f411c975e5d9afbdcceceec7dffddbdf69e3133e70143fdfdeb69a1f63b988336a120e9aaac8b567050f252175d8671b222f3436baf10c939bfed77e7fb86f065c01b98673067c87ff4901f19bf77a6f0b0318665073efdb0dc781e2fb07ace7e104a8f8c62a01eb8ac9d9859e0117a95681825e3118642821956939d8bdc816edd4561b2a4290eb6dd30cd534dd88e771f3a938627a04399280c808782d62c41955e62e91bd350ede3404cd3b21f62796a7ea1611a9aa396c3218653238bf3c290440910fb36b4750df8a48f6a1dc43c0210b9ce1a16fac21a1a5cea0d2244dbd8ff91512fbe249aa0bf6f319ba7725e0cb00b0afddc7bc7fd57b791a4d788c4bdf56a1a19521004db40a7ec9772e714cdfa6744943d30b0bb2e2adaca14251b27d469fa8d98a28e28c918ef53d090f16bbbae0c0bb9c39f89669533a0a98ff0d59761ae101235400415ce7fe93a9b2574b2208ccaeb4fa6f76a4976c516c9e6e87b71d0a0158bdc624a5815866bdb79c7419db8c5326abab06eaf2e748007f79a6f60e65df3c509848411e6d886706c94a652e703b0c6401f7134bb45b8eefa8a3fcb82fa2263ad6cc2da79b9f137f0abe7c5850b8384ea31104f89588e8b6b0e0661bc752a2f1d3623f0e81c3bc3cd0e8ad59e9c591fad02cb6b89b54740b0b2901143dd635484bd4999ef6f76a2b7d35200732213de62b5f5af977fc8c54d7b8daa927bd774b5d7cd36b52aae93fc994a8618d1d568b9067a8bbf5e71dfe7837fd359917ba30087d81593623f211be27e854790b8757e98087498b6af8d2e4ecbc6cc8cc2f6f364e9558ca8e7f94560f5505e7e9d53aa53350b5903ecd6f14287c9597ebb951d168329846dbc2cbd0198eac12fd0db5332e8969d488f9ed5c9236183c448f88a0e11d2d0912f336a0114ed2ad51f2153bbb440b0acd7d6aca23d1655ab4a3242819679f9fe4e26764398078b9057657ac40f249e026dcfbdc387cf0be0c67ab1c3a2af512196cb2cf1f362144f265e9f3d1a6e0c7ae06ee8b7b6bf925015ffe0fa3b0786c7c42f1195bb04dd6dec4786006fddbb4be9510771c874b8e6b55bac01b63c213eebbfbcfa94f0c1fbec5bd45b319438c41d9f2ad9024e5374d51bd32f8b8324f2877472905ff2de9e545d7352720ce4d9cc022297269f7d1936ac40d40f03883aa9b288dba989907d7ed55ad0a6ee1c2336e06b574a418ef8a7757958b28e4ed5b6a30898b4f858a77228cac2633cf97dfc07f8d408741cb0181392b1022cfeec58cc09f01661048e23addc35d28c6b27be4a694ed1d0208be61d49aa941909a38b16d321ec677bd198db937abc47fc8878a58fa224d9d3d31aa841767b79fbc1083f81610e744361e42a36b0d8c4814cf55c7489af4a2ba0fcf6b09d9101d0dd06c0fc9b15c6507d0dbf488133297145b4a0198fb1fe372874417c106902d062382f414df92506813c0bfdd8ee8e51ad1d77f66017c317218bd096b76b0522cf6654ef729271366fa5eee08209722337e391f33f84c68a3de3fcb2fc65fecdbcd8e8aa2f0703272330e5d4dd64626da90e943b89c635fefee2f4a784b8aaea614faa12fb17461d5a07c2238b7a4e6463eaa8ddd6f4dc1e72c01a86e6d3dbce6fc25af1cba2706d68afbe9a84a540f37f346ad4b1be841c1bfbac530d6eb2d7e904dbde3c02fcbd206b7e671faa3325fbab1e80ee3d648fe40a140df1d4ab7c32917334cd6114cd3b640bb5cf4f43f2f58d1a6b69843e5531d8086131dad65283d14578e17f837150ee2f52c92a9f2e3a166aeeee0c02a0c2be76a256ea3756c943b39aef4c5cbffc327b08e018751f576a0bc4c46fc28025dc6b0f4ca5637584012167e3bacba1d468d77bafb46877a9b08e29df10e792605658fa7affee14c3fe8be787b8dd46047670661295d1f77a3cb2756f5d6cf36615ef3621d07731bc3a85fed7671b15c3c597804594fe9410d15df3ff5a2f3a58702806eeb11c2a9f568a6868c8a93872430421a359b3db3e63e1c1513e10aacb30cf7069a2bd4392bbc727d51419efe103f828f7ec99436179f47548750079b579838cfa66e8b9453e93bb6b34c85ddee9ef70c8513517b27a1f6682a86db0e75074012fbd0252a9ea4047373229923f031d412d8f34980a357aeb126ccf3a2cea9c3fc921a99e64822164bcb031387069ddbfefc6de10ebcb117d053c4b809d79cc2f1e705b43b4b145c1def8f2aa57adcdbfadb63514f6f2c7b837413a6d78398c7c32e93214d5795e510b78cdabe2fd884cb40a898aebc4ea0e493d4ae35c3f0b0e81c9bd565072b518cd190c69b1023ef6f116cc295a1b98d98f435d5df532adaf8fd9e49d3fc2f460282485838116b9c6f3549680a725d7be3118e519d16d4f6995a494c8ad6c91d049d419ec7772814480f0497416c155ce5668cf38985cc7e2a71e06beb37180da1b850148fbda2ab2313862ad7d455aef47e524885cff18f35e2e982dc9a2bb966832cb1117d0e9938d2e70946d01972e8eb7811cabf3a5d095502b262c5a67fc1f159987941d820cb8dacf741ac39fac26fa09a97f63ea383699e0c1b7698a65c85f2663322279a5c303caf44dcb736d5cd465d82f0c5d65cb8a362786169e7da63775390cc89b35080b2d4758c22c34f63c7b023fa4bbd70ef3f995535287d2a6f27f5d02023413e96c894e6d401e1320e996720e194ac6877caeb30ccfcc009e20af33be085c152848e1fff7d81ea4dd8663563a6391ec42cbe09fe9ae603d4a6774e02d31a687e88c6729143405dda4aad46942891509e46990d7ac83a392f5c2c29b0b769c3680deaf4cb44ac067a67c8a6749b8c8cacde152dd2883fb9ea37fe73dc2159e81f98dfac645cf4ad780e09c52c630148e02071125aebb70edb998a174e9a8128bccf4434d48f711a8a25ef6346a22cf2d6a23d96e4beec1be4131b0b49545ed8a1446e8caf3cbb7ae2e5db2be545de4152d9fce0ed402db10246336e11e62a12dc0779a34de032d6e2b1724661cad11160e5e5db143da24e415ee57aaa6234554be16b584c08915e5db0df009e2ad5f76b0da8a3e76b395ae9233081f618907b371b955502caab7ccdf2e45a46026e1eb15529ef3d4883c8a5a247029401857eaf95b80f23dfef60d110160370400341efef48d775c7e9028c09344d01bd009a281364efd328f23bafc078672070551bc845c8fe254ffb4989863dab3afc42905a4407254527acd6daca91c2fba03184bfb71ba78ddc63142b2765287b3503f433df7dd7bd00411db97f349d66b238a374d3fe88ad5b6ce02721a9a14c763aeecfe7489051b96b9e7d5a7d76bd43f1b73e9ff9537a05cc4eac3a54e662dbdbc2aba4fdebead7c35c7c0d271c696761dbf86467430bf7b7a64cc1747cbe9d513f6a156c3bef26ff9d68103cc2b44cd5939400b55c40de83739e0329b5a7867bd695d152f75d01d74bcb53370cb39a0e9e88c8aa525da2c32883a63a58eb5de512badc819501949c40c460f2cd160b8edb0c46a0d1faa839be732b76d09e79775a3a092a6e71712406b100170069a26eb9ccd5a7ab836ab2b2cdd19af6d668929ccad499e8243adf6a0f8c97d74354a42eb3412ad64987bcbff6fa3a5958e26c06bc120fc48ce455c4a14e6124c467d79c0d513293528fe053cdd5daea362242bb20b6059328e045e900133d4e6936eeabcc255390afd1fd0eb7306a6cf8f417b6714facf484f26f9d70b8c58ac775ee3925de5cb7763503523c802abe3ea6698423fb7b50b6b4e62376123c03d30a1eb8fe89e0ce3b809d8cfa0df615c1d70867f092d40de0ddab8ad08262847d6b3570ce0f22806d579b167ad10d24ff1d24a85ffae0d8ef6faa268df0b3eb651f790867c829183d15d1ec45c308d2f5125842ddf6e725fbb3f17c2ec9a91f6af400953d1f7f5632f1e4eab638237789d809b4e6ed800ec2ed64e6ba01f2cc17be097df3ca911b73e030be4df8f2acb5d3b4bc2e6d48d6493d4d6666be6225d33b4eaaf8f6a031642869b07925b799ea610dc658d11ce7ece4f61c4025cb9c0f67011acd194e7537c8cd638e7f6eb115b7a037cff6c0e963d6fe07d2457f3cf9fb41df45e9f6e2d2a05647c6ff2a21814340cc661df1805e7d965985a455236cfbe4220b0edefa7c97e11358058e56d0e57140c75239e23f03146dfaddd39ca396581ace2a3bd5ce5a7a290fae11c3327ceb40bca7ffd630370f68b620b9979193797814daa137dc914b27f4de1d3d8b5fca9a8e70872a2c050d9e7f5fe9da059be41a9046ea0db7b9974613eed42d87a1401e50dc97f26ef69eda9528bae8fae41473c1e9e2a604365d73dc45c26dbcc354ca63d6b297946b990990323bec600541fb6ac98043a5e7e01f0b072209d27291889e3cc0ee198593be8994cc14cba47899bad39b8a05ab024282f1790ac41b7922dcbf31c6f21def6357627b5ed4f57d41045d250b0f45fc2a52d8621d8f9130ebbb8f344f74fc0389d1b33bcdf2da5f608757cf5cfaee2e52d6a7d596501fe48e46c3e588ef9b31bd7d7847e4ba359a52798b13800310cd511d6e6272f6205b63336af4e4b21aceafd6122095df7f741b320475db26be99e421832601f3557abf5c75c87bd5e7c6a2e7c22641a099a5773264d5664f49715bf38645ab5a3b0a03d0427f32d59fa009acda26940a424339c89522d2f7d19ab25175ccc652ce7d6fb1420f242c26632a877bc233f67d6da0144dfa89f8b3c749954a64fa9543afffd01a302a028a8f0eac07ffe16ac5980947799742fc12c9dfb81df21dfa53d6509ec496728ee6a00cb591565b8638cb2219bee467ccb58e7654f29bfcc9308abc38f0341e25a80072f03a5181e890016650c824c3d2bee49776ca58b0f1379385955eaca473b1bd3c2a7cbe72da427a41b278c5847985f4a41223d9cf49b679362500cf4f050c659422f7c638d7cf61722ce08b54b3cb7688d78a8886d9e3b4520087397127124f52877a275999a439fe1cb69de6223397e93bacb76b32b59a8843b67f1af20b3c2d4e6808b9bfdf8fc2af89ed3d56f085669fdbb49e218d5b6eb00e2dd53562a76392b94e63fa4834877a9a61f447d691d4bce62a875b523b7388fe17d3e4ea9f9e17f8cedc4389ffa2a9c846a729cacc019044aa4d63155bfaac4cedf21ee8dcfa94bcce69a91adde1b9e0825d614220173e124f39a2b5c852202573f6b33e19a82bf7f8ebf8665ece55da2c1c0b89b7ec404e0d4967f785591b1e93e4d6d3e71fd459b737fd4ebca2f84020dba087d7893f277caabcdea61ca5f6bdcd44d30b507aed525721c9a11c2d89901a8865e2acf265f5f37304a1cac2b55338929cd8201c91f03fb573712b15aa80bdf777ab21078ccc42de6961e46b3d952f0522ab40300db01d0146c1daa4da275a500f17f348da29c185b8424b94d1d86486270b759459481657a7223727d87bffb3211d15a07e1873a8801d1c37f895d71d42fa113cd2ff2d801d70e1a178f4cdacf5ec8eb300ba6d0d86d9746540dcaf18988af0a5ca69f9a49c186fc35746b0e5c67b0f10fc74e0f492e565348952efb22b0c6b4d077f76d318abcfbb7e173cec73b5f7fcbdec3ddcb3f958a17cc7fbd1b2ec9cdb10ef49398bf875fbda33d5ccf49bb6215cfdf921578c8bed0e434ea8a0842fb1920e5e31f2fdcc14cce3cae20bb5e1d39ca07727c5de3bf1002b8a563414d033e88b82d8d76be533dd96255536214b142b46bd1c96a45e9aadc6af7502425a78d79f2dc9d0c4be773d8764f155a592ef9b8101dd33f79f82d439a30f88fbee320733d287beeb6a7ec1fc9ade3f1362a7c53ed9dafdefba41362ffeda2014a8049c14e119578270d6428403867ddc7b4e49a1386e303aff0963aaa8306d3f45b6d4dcd23bcfa8a12e22e91fd8a5b4db0a0dcbcfe696076321fe089e2fdd2a5b4ba63619619c539beddd72adbbb201703faebd459ece0390a8da308515892d4c3bac7b681f2fc9b222389de898a614e8684da4de223c20210b0b80e1e19260f4f48a0195e0ec4b0800daab8ec0aaef1fa5e06091e7e1af617bb81d07702cc57cfa50ff634749dbbf343183b952b443e91538a477979e0e47eec8bd572687a82b0709bba982bbf3d47756520cb9b5717439b1416a6cb9482d440c60d7c2b8ff17ef734e505db9c7166ff26468526f2790a481aabbbd2c421a525ea835b00ad109967b02e8aa58e84a46ebd99e34276bb17221e27812d191d42a55822a3de6493faaa7ae15867de6f586988a8d29b9bd59e78f8fe997aec9d0085cda6f1699918a121e49f0120949c5a98452052cd902a11aea3c874888b56eedd03a1e2e545fc41b90a73836802c30ff1a1fd395b07c5a4082cc93eeb1d00cd466198ee289c22469e065280fbe3d0761ac276b42b160e88fcbcf0284173d1bcfac3a03ad133632b7f1c142192164a50325dee81717cfbd2c8b09a5737ca759098ab8b2ff64f79d0fc914f8fa46d42e9261b7a532cbbcda1600bfd0e29bc981bf606772c9a3721bee439937614e5893200f2b87e2aa278833381cd141c70c2e94d3030820161d30030e624afe2fa396c8ee36296ae2c68b2a3cbee309dd9c3806e62d636202f4c47a7e3717a8727ffa0bc73e9d6ea89f5435c8f92120bc7ab05b5a577639be5b6a8af88a74ee4b27b1f8d046082a9b7cb49dc311011d0e896bfff1bf8000a8480dd1169f9d1efe5033a695348bed4d8b209d2019e3b1971d4792b3c633b6e62424b784418194084c51b1f3a4a5a410734a340ae429dfc430e757a373fb504ee77bf4894dc9c071c0fa77f9d8e8f7878314ccae54ce7f2c299c6594437cf3c08b3b32276a7c960d30904ae50833a2f4a2a922117599d964c7154bc4cf49a2eea5e59a00a268444f4d67851931e2a362c2d8c83b15128a4b2d1151425665fab9c8f5de87d37f2989d23b733b394e5a002eb99371eceaccefe4de96078a10bfd3a7d1def3330e169ee543fd5fbc2937af5cced3fd061735912b2af723e19eb98ae4bb56de7d5c7ada2fc672745a90111d5f649c0dc53086fbecf036adb3996a8deb9f5a87977ad4dd08b70331c75994114694dc35a6f78dc48953087a2c344c96c47e50348f5f82bcb142a7886194ee90ba69e85a9b24a8af7988a49f99d896ece03a807ecd4b128e8ace4786855ef858953d4ef5f5e87d6ab6276ea85a14a2813f689923e1db015a997745c74ed060db8b1f2b827e1c37faf072430dbf9e9781a1bfcda053ea603f0174feed7fad1ed29c25322789c5ce13908e3a2566472b20a59fed7fecb10434210834188cacb05961c71753e8d7e7d6c1a9d5fc4bbcf330cb22db21de5ab26486f66978c431d3292dfea61f1948bafbbf80a9fef3e2c1a88583e99a8a3b4ac8caf0f44efde7926eec29ea525761eee989371f307805871cdc75a49f3a576fc72fa32941530abe694f443efab1f85c36e3db65c35e9beae5b95b7240be14e20c9dee892c9e5a4d88a6a9a6b8a750ad15caf32d5042b35f9c1b45e864ec4fcdc48b1f84ec4aadedfc71da98754519f5c4f22b80b87430fcd92062205038d2ea260cbf9c10fd49b14d036986889ee693f523deab3692899bdc2699669eec6d43acf1bc814e12e182fa9e1a842d469ab2a00bb197686338263e442bdddd20b2b8c4d91cc24ced4830a81b2ed0a51dddef89bb49bc8011beda0b31d46ff523fad547b6fef22d0a3d475256f81959e230adf635a4a50df615eba032137013e064aea2923d5ca66d39faee55995f964a2bdfaf8098921917d9d0347469f4ab0c76556820387701727c06dbca85c540a63cc33641efe6af17e8a790a60f53b66a330c1ec81a15a2fccec37bfb694714459f5795d8b938e13fc37188994e4f0b7c5de650d6c9c6b2a6ed6b093f9ed811551e0b3a519c88db927627b67cc97997a12891a5a888731e7cecea3aad5bcf623af0144f74860d3e13338e58a2d30e9f8ec03bf393821f433f36aada08dccf52e8fd4044f0c5676f6bd82ae7d5f659bd5f182e1b703a7dabb48ad059f811cba952687f387d0391cc06e32775420abce5f8d3e3e75d56e4328138bac6e6bcf8cdf3622a8911613b317b257efcc33483dcd8b5c006a78897fcaa5edbc6178a32b625cd4cb4e99c43ff854bf6fbb35a59cb70f4dc18599e9993f8560968c4a5b1e0aa25136dca774931e9d3d37cbe206e9d7279bc683837afdde8107fca7bd01722c97e22f2ddca507a230208bfdef687e74df94a1d23351d166e6ebe882641b4cc0cbf20bfb3ab29895014f078d8d1f52dbce72e6b097393b02caadbfb69150c934c7dc0a56de1fb5d2206905bf8d3a9155d91abdd223d46ef65431c4611346cdc6ada5f222215ce9b7c33f18b20fede9da79f7312c43b1bf8dd42de3cf58ec186e4a1a51e03a2202ebaabe5e24b40f186b4f9cf3126296d8d6adb9d67944a681f34ce13e6df8215442171f69ac0ab0225368378a2d9c543cce94e3098d05100bc9a42674077cfeb5cfa024856efc73d71f516d4a857b6fbf3adf472d0970071b2f316767d1473baf1f67b9d6a6cc4a536b15c5fb116359b5fbb3594375cc10ae76680e224ce969e2259121e246ec790fa15575d7ac17a45490a227a1cede3f080e5524bf7bfa92a7ed79420aa23c78fc8b955fc5f0ade81e32ff7afbc795497e284595d9ad58661b8e475394aef131a5ad13894801192ce0feac35e102f56d896ab3c059ab280d1740ebd5fd01881e61e46bea7ea763be6940553048c573bf7e3070986d9ac382fba73120df98108407287aaf2206a502a10a184f23867c0e09c766cc9be849dd39122e89ec10aae77245670177aaa2a11899d22a3bf33d618eeea81493d4b53ca91e9b28828e1d3f12579ebcc6f2abecab9a3ae2ff550601c1e50ffc4a1a11ce6f17a7136ec29646752d7d431265d77d290b830a84d374119c7447a03957c44c5ec619e736e00df302cd33eb0cde06797fd549f15d4e4536d58d201c2488b0b438b1e5cf6b8c8939ad2736bfcca33303977d7aeec5b4eb79d46a59d5cd72909b131ace75c9aecd96b7172b90c02c9f5241937e714c2b7e223c20ba1fba7dfea9de0f2a009ea55188a7d92de59ccf52608381d02455426d90359201b6dac2866e574b45e72de876cf8a6d5a5bbb32b78b93c3ee03402f1b4fc56b299b5e55d2de9d912b713d4d3754560bbbe1cdfa44d597b348f8271b2f16f918f4ec7084f3f5fc7049788ec946526df57f428253698344885a20ec81af343b98145d6b04ccd52679a421f0e0b8d9687d98f38fbe5ac8bc8f2588fdd35c012430cad6a7e9f26ab462ba0fb6fe49a62170734de32c9d68c5a1717cf0aca33d3928204a8e3f355ec2e5485a06a197df73985fa6fcbe8383296c29602e02feb898ff31152859444139da2bf8088c7893fa21dd1a940ae71b5ef7beeb423d1148cfa1661b2468fbf80f8c74572ce6e7666e6a64ca275316e93cd36b9cc1e61240d413d6f3a28e691c030e6bf1088283bbf65f8728e26df43805bd40bce284ecc476b1b79240fc6e47bb9f9dbaad22b903dc584eb65a2b954b9cd0b9cd626fe4fe41302d3826e086c029e1ed18d9e053b23ff3a036af46e1cad2a4db9333c3d74c39b5f30d57a7b959e850e142e4ebc8fb32b32bb9ee60b91a9175c85248b21b4cc78ee8d09c49b5bd7d0337501d80559498cf8cee816ff7a3d46bb7b288f51de4e9d8a1c91242e1e5b2e36cdec50486ac0196c483406618332d93d562f54f552c2de8c737d65f9e4ee8d293e92577779b3adc52299dbe47ba6285b86ffd2312cd1218a84d0f5c09558503a4e8f8c2af8ba3557d318f21e5c89cd2ecdf5a7cc02c9d6ef163ac1e3ef333fab0e3c72a9ed921bed6f0cee4efc2813d8542a6053d22727f22c3be31a2ac5cf9bfa429a826c6178cc70bfcf32c9aa670d2677c0765b079a90735e2fde22cc8289deb7327b610a9b76817c5f4ca8ab635911b9872359513919e9dfe5b98376c1afa3cf8d6c419c9f39980e714ff76a2ab8797217b057135c98110959e1234f38a05b6af2b6f02f6862d982e35da0f43ce075665a69a11b43eabb1e407c11b352fcde84d8c09fd67994fa98eb04c5227b6444708f53f327d7621a6816cbf7148a47e7621493ca70ec5e62cca35d0755f6b2db75bed3181ec4ede20eea7ae6c7b97b12655b034405e1b0ecb749aae6d0a3d2853a54d78bf04fede21e652e6261b47c756f9e212d90e7e7beea81bfbb208595ce2d0359c6d1a715e2bccc70275e0ccdcb5b3c9c18a387ced83968ba2c38717e9b23cc43428ce82622d17a905273986f89cbdd664bf476f827fdbd5b33c523d47712158e0bb0e8597ede506ed3cbc01e1cce573081c52222890334990aa32ef7f6d1da6f03fbbf0320ccdae77322d05818767995f6e8df0a6fc0acfb21a9e8c2f33ca26f5ce66a01fc413f64bd360e4f4c81d297bc97382d34102824c1b9acfd452e7239e167a35bf0fe663c25d976fc4bc1b95e3e8896083584aebfe9457f78589a8fadf8b85501fa18133e1a2a7c4e1677bd58a89e426d7333bed45e4dd6ee5a524a793860699cbeab7dad466cc424c22997dbb3221b3e652258fd377c5b497837b55bc7e03120ff68ef97902e8b2de0cfc1923528ff2b136a6d4fb72b23f5cd399bc30f5d5f43265fe54826b445c23cbaedfca21dc8dfb66a138a4cfd99eb1c0fb3377d64e95d7fe5d450136f3b88289e76211a7caa57916f5af98e6b731f4c518fca9584a1d29257b603fd76f1a435fb58ba23818a666ef65501299107516b4a1a22528eb61ae09911a78f26477c15241417376a65b879c8814bd99f041680bcc4cb0f9277c5b3adf373908af023188b7ecb3c6f8b7f330564c3024663804aafbeb4febd54150225edb65159568395ae23c28834d79e8f32beda9b403aae92db1bf87d0c7bf3a822796839091acfccac7dd720ae688e5be8d39cc7b3dee866a47d6abc9cec0d514b87871de54954fe740900240fe8d0c6c1f5521bb1a07b8689346c373057e6fca254905da1cf3b480a564ae8cbaac16e817d4b8da6f864c1f361ec275a54c4b3cb759cafcde2887f69e3ea969b0f7e2eb5b488c1c103f32fea6d6343646307ee90277cad12431fd2e019de121433d7562a53ffb5b0b6e4cc2a9233c344640f3928744b76e01924276fbe5be4bc5a87b61ee837409976c49e2e325f3956ffeaf226736e56537db8c382725ec305fb82918b7c025cb6958bd76e7d5b9734ece87a37a532bdf8c24efe4181184b5cd9b39eab16055aefac8cb56eadf9f6bc6f0a1cf0640781bde1440ac29ead3cd59d2240d61762276c1cf27724df0b134beea445ca60e3a9ddc4088ff3ad2232f427e3bf70112a8e32fc3422c051451bdeaffc440b480283978ba896db233f9091a3e572a342fa85fff276d085c4f7114a988a96de3a9624916776b1c6dd0b111e780de2c06787e1b0fbd7ea9bb22f63710f4dd64811b6bfbe039bf7514ae324478e87b0944c8d8935a1617f5d3d6f01cbe788d2c8313b358c2b5e51e4445c1b15bd5a1f6a11aa708d170a7f22c22a0d30b22af9516f769fe1980f77f913a06243c1d6c4c2729a0151e1eefcbd214db4d51001521908d9040ab15b3e7178048806ff9278e68d39f785c00980b47752a9cc107b02da1ff45197adc0ed325732689d92cc54b97c20c34207a73ede103983031c5c799305b832528bf0b5c5ad99423f3696fd31a35d4c299fd3b31d61f81cc3a8694ba5ad82dd59f6904b2454e5c63081450d3b1c3680d20aad687310f4c7c694a865f063158d7f2e82d508841a177c373eaf8ca1c5f37db1a4e809ca5a48f4cc904aee70e81b56cb99bea7b1e8fc3bddc1be5985a29856f55afc7750ca6d5f81a22378d76586fe928cd71ab23ef6b27ff63b6e02cb8b97b0463aafa2edf36b8cdf5474cadefe146a3d8bf6b85ac9bc94a5dcd7e1ff97a6a2e9a84da0e49e9732ab769a7be87bbbd0df281ff407778cd98c22a78ec6948f9ba1e96cc1b90d79e21cf9c90832f0ab9e7d47108c8b68ae97815778ca4e56741e6cbeb84fdbd251774ab9ae0620ad924ab3ce294dda33352a7843fd2e26e593ef4d4b1b6a754e186ebd4b20f142248c2c99b54e9cebdbee947733684434ffb612fa914565caaa5765d65d2f5ccb83e4243270e5e085f315466132c5854a0e112d4fff8b80e54785dc53fb7caeff5e66cddc053125bc2642f1a35cfcd723172ed6e34ebc5daf9052130e7f09c162c43a348b5ff20032fe3045f9e3d33a02f402fe2cd895db98793070f3ae65cb11f3979e6f8d0e0e1c1a2b422105ee646ff979407a9c5f3c69342ccf5460df6a92cc9a78be199ada5d41af68a15fb6640267c792ce7d672392c397ab07562c75ff02d8043ed87493348240224bb1143b75dc82943d88340abb603fa42b75ecfcc52e889db9aa6dd3572b4023f2ac617e0ec7a5e5741ec2e484023217c028d68d2348d7275ab5b52e1fb20a1fb766750eba098543a4a188f2eece03a0ce04c75b0e650b56dfcb5d237a252a2c4f9947931b2b40649fb7f568b8ce0ea2bfa751d5a4b3d78b1e631351148aec5c4a2225e12d7ca2c7cfb4bdcb09e83d2801caea435f7d7b0d6f6ecb2eb6fc7df2c57df77a703595af0d7564b715d80488a661c39f60a704a8c90b7e4073a07aabb19a11c49c7533ac780314a743c464900bc8e6c6be542caa351c9557f68911860d049a6e402d7b6eb3fb09cd291dc2ddfd06679f526b678930d4ab31ef5e629378cbec0e870a593851121f16e1e631d23d45f893b53c06fea2c9401f2c844b95d7fcdd0d2b9c76bd34db5b848ec3dac073ae641f9bfdc2e9d560b2ca081140867744b4ffbb4b03884991ad1cad25bacd06a475db0d9f6103410a8a41ab75dc2cf4f3eff90939870cbc11f118cdb943570ff0ee31f29b425a6969cfac679f6f91c1beee564e5aa4cfef647ca29b562b5b5037b0a2529175e3553344b4ff2bd10001ffa547e7580bcca18747fb07ea84f8009ea1355f898aec8a352a3268ecbe4c04589230a4491ce49d1a3b97be5cd87531b03bdd2f0814810b3168ce487a9a80609449383f84679286b00b7eb4ccb357053db0a8a3235c13c912603b1cae5a98074a20996af6bd3a0b2a46b4642a9da4787b0d4d7820841b7d180cd948bedb5ff3cfd3ce84aa4395ff9231d37ca47813a518e4e3e25185464ffa4d559d74da8842f7f302d46a51339eae9c669e1787e2a562cd4b0a9d08dac8fcfe0ed8a10a91c4ca391c420ad50f39ebd42164e769ac2f9024a58cd4ed5e0a07b2911cb343ca377a90132578296ef8e81d444f025cc9d6b8e916b3736e9cd7f13357ed256b7047715dda684c86a4dbbb71397b3917104c8967c92bb6d19614bce9f42b6a5dfd787c44321c806282c5930d4af5232a21c3ccdb8931fc55c384f192d0da0c5d9ea8e0999c015656f9971421134c0d165a0fb937314d4e1b1b932ca2d7fcbfaa9c1baf3d7f8bf1437d68b45f5a092247a96f04384f076759c493538f801ceef62efa76279dd05642e84ea5c07814794abea2f99a8ceb2d9df8d426f62f4d8b64b57615527e249cc3eec7753e009cc6377819d48eff551de94522c270102c18009fd6d745ba4c43db6dea1498af2d8c029e69eb7d2c9c3e74e88c2724d79beeebf21604343118441374c617991b3ed0d49645aa3b74a676b774113ad3f9baf3783568f69b4fdd0da712fcbbc1be40501cd3ee74e02eca2f9e751c055761c6c8384bd110fbe9b3064a733c1ecb113676ac0fed761fd8d669cb4fe76ae2ab970f6acb92aebe00410b724e9e3bac3570e86ec2214e1af3f7deac9b3537d54f6362d2806b4f2bc438d19e198652eb68a98c23ffe94fb4138f844f1f45a9ca22b1ddda5f6a1f2f9589e26e3c0c6691e38c31059e39b09ee729ebfa478d6d6fd1e534158642c159b1799925f93229b32277b1756fd829e79f0bf2043372dfe3f5a56a217f7884874aaaa21ee6fe009075f55c68a4782b6b576d5c05ab9c8488c21ac7eb9d907fe124e34441cab59b73a34e946976b200b29dfa0a43601649cfd174d3c34103d0afba352f95e57ec1db0d4b9bd9429284cc140bdef83ce7b9762085792e57b5ecf1ae5f80295171fa6fb1e2a48ebf0c023663ecd3ac8dcbcb4b9eb9d7a5a0f2bbecf9dbce19e55140d432388516332fd987f5a84a060b44adf77c07e254cc56b3010478515d8100fa1ec3834a629849617f678addebbc952881b68dd06ba96ba3e07ee8a28be2c945a90ceb0807c692ffbd17f41acea1fa328ddff7aa56b312e450504c239610e0075126aae00ab8bcd3ccbfb06b68f267dcc2bbd77c29c8d0b7cee641bead7547dee22f58d09e66c56aa5ab6ba12bf7bd6fa6c51b31161b3109d8595540a5d87fafd96c4d4b641b26e418f29e1226f63ede03cac72c11c5d3c5f8a91bc407768a4c0d6f5bde36cb6630483b6b626ec31e7f3ebe47f880f67e2f7dcee619fb58e6770cc035a9215cf7cf0f900f1a39d0b8cdbaa381ba186caeb837fc1128074c403955afff5f4f23da476bc6b29504eb78d0552279425e20c9337c9705596f80e820ba796132ecd9b9f0a308f72e2ffc2250aa74782c6715ae316c90c5b247b740e962cbae4b45eaf4734d06034858e0b4611101dbd190bee46ccda551cf763d23e86668508e1ee4fd555c3773db907eb5fd6270c391131b4ad3b771a3a78cf53507aeb284be8226ebee593a2291f8b5ab808ba8f0b812f906d28caa9428f95d8ac5a56a103b0fd616fca9fad0ac284828119d2ac5fef867766e9e410c2e1a99c3673bfd16f316370dd527c5e6d39224f9bd664d62aa9e612a6bd04396f44f8c4abea58e21221866c4685570da71abf5ab599e295e930c1ba8d256594d679cc92a5e101b8e46616bcc1958aa486c2a73bee259c804089729b32378f7d3808001417c6a2ef5e86d7ff3bbe25609952e843","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
