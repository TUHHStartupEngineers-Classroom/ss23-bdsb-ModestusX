<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"ea76265a412b72ecb9869b6712781627d853c499af7e5df2460f97a922ba798e131a4c94ed37d4f68d208b85537e738bb0d8b952dbb8edd01d48a5f18ce55721b8b633de68eb5c7e878917c7781f9a72356dfaa15d4398b0dfaebb308b2e641564f6dd12a64f9fbdad1e16ed950c03d04189b0473a7cacad7eaaf0f772eb36770b33fc6165a2705b1f1d3d04922dfe229988d60698de155c3906597f45e6acbecc21ded71a03069201285bfee49010a4faea83c20f22fb89ab43739b264912d663bf1b98cb47fd9215c84992ff94c3b9ff2f268ceed8543cc9d79a80753338d59e16c78ad65b0531f860d413ff557b1b2f555a80289f32dd98c343e265bbac4b67239a3b2a5d2d39fce52fa20bea5fe11436b725facaa26e925d096717eb589157ecca6b213a03d1630138a357938712e918f92e4820774365b9a02a62efeb244f7152ad2e19e945f93b8bdb45e65b5c708cdaa1d147c0f21dc4ec0d419bd00c8109dd505d81b2b66f0417449cb96cedefe7adefb7a3b88cb8264d30acdf2e14eae211a541094bc2960a4d138c0fa4868887289dc2ac0c03ebbb6702603d159d977354ee501561c33c15fce0d3ff254f2d892023793317de4acd70dfa3619e8c6243503629ae331548495a23f6058789ea4035b075255eebeeb7539e2125dcb1a71ac3c90fe635f87aacdc24a14a7f867fe18d02d77b1984eb00040fc6068c80186a9b4f5b26ffd5947c4324c22cb58cfe802c7e88cc648b813e34c06083484f664fc51e035970402a059bb8cd31f23fbd03b95b9a4a4c7066489f974217d37274702add1d6dc70e77c85ae354d05090269d367ee2a79f300ea903f50c70662e863df79b0e51f08b16f5d16f4dba26f3b90957e7309f39105f671f07a705839cef94d57be364381aa0674ac4f3a18eafce5f795b94d5d5d66a370411e964f3b8b08b50292f5bd8f5bffd4a3ae63c38534508f4d2c34d22fc0f0a0184b4d168ca6e84d2eaa37e2a45615453d3c8baa4d9247eb2661fa0ddcaff40dafd8b6ece64eb3c5b7a8e9c6058271a8fbee5aeabe76e767e86c5cb6cb070bdaa53002642bff13e7e91c3016b0d843abb0202d24221691d6051608cdd89b41c8a5df442a35859edb0985260e898f6233144f8bfcb9c0eb9c30695dc7adc2b461577162f617fb0ab3ddd22199f13fbad9eab1517ca2ae2ee9e3d8d434659fb0c154be3c3491cf9646d1c9dd619da2c8e9a534d5d580665348ed4005cb47df632686b07e8c2f71fe3cb48e90ad084a55bbe1fd0012bab4de49842629fae548fd32bdba9786699778a0b343a5c25a4be580a965777a824627e7e12b45e701b339f9829dfe5f745b9f2c6272bce788212b57723e91f9e6e31e1e85c61ae5d71982d9e0b36c231fe2c23441e9c1b87f419bb262ffea4f9f7e84f0d885df59d8ccd32a25e2bf65a1e132b0a59322d6a1b13676582d474dcfce68fb9fc2c63e5f779af4ba3c48f61f841a9f9fd6044bf0380832e8ef4c1591201a2949907734acbfcbc6851e11509928951cb62446e192b2bf5d68c1f89af85b6e2991002adf9eff5b48db3b7a04eb759ade6218ffcad358b16cd6328850909f1a12986f8948572ad664d9c7bd335d6a88d59fb3bad645fd1b9ddc6563a8e6ba1df0813ae6177a1debb15f3ba76cbc3c909a13deb4e31f0c5b617aeca12a621edd376af3f9f6741d6a55fa5eecf8e0a00207765fb04772a88bd561d5d66a46689fc13b9b3230f15f3258cb7e497ee3592ce440ae40c88434bd94e3f18610d22d907833fbde2ccd14d611dd6027e7ad0913016ba448829abb660cd259fe5203edcedec91483add328f6d9fe72b6d3e80031ee3c2d22f262d6b845782c8eeaa4087b60e336bb84f39c3784b8dff846f1be49ddf1df1143290bc88c06d8fd7b59c30cd647208a43ddac7461a9473dfbac50f68bb7dfa535ea61addaa37713b3f619d1d2d0a1d04e04fa6664ad327631d9f1bd2b3ec8be17515faf6e2873abc12af7190d37117bdfeeccf06212603fd7a69a483dff1af1f82c2484219de21e9c74fa3b6c3692914420cf3c0bf9caa3ee77a9f78684a3351e8eddbdd104ff35643cf88acfb27b7fe20f89a18675714c0016b85f4615eff88cc23f07690d7afb04265b35cc0aa2f841a40724d51af9fde6afe2c46db616cca7b48af746c67619f21bb5e785b79993a45ed1ca06efa9abb5f2386f31d604ebc0424656c54f8a03fc190df13f129dc48456426afa291a3eec78fba10f656054a560f04832cdceb9e0d3e5f2ffd8f834928126a5c387d0a73e56fa6b58c5461bb3284263a302d2946828ca3028ca5972c0e967ab8a26a3b6fefd237e1961d3d6dd9926c0316a7b9ff761836fd3640f971c9bf3c29c170a73640e46ea4a0059851f2374c9d11858d9d5fa367126de4b8134e1f2534008f9c40798efcf2f10d61b87f2d75f9015ab1608d2fef0b44d21f32384c68f551d8d76bc4611527cdc9a06cc683be246da6bd67746224ca365513ea4d233354d734d86cb48eda024647959d7a3dd52421f99de8db0f952fbfda98976080ef74d9b7f7d30c3abe1d9ec549037b2591d35b84c3d629a4c93a641e382d3c41ca1b0d28c8a86eee79fc6c6c13b4636831c0f852d90c8b4f42af106700bf2a278b9838438e96913ceee7ee2dd28128b61645ac73d43495da7846cdca1b394669e8edbcbab7672d1f17a517cdfc5ba835e4760c7f186d31276f9ecd50de6bb277c84063da491096876b0a6e80303867df8aa769b93f00de82f2d595d0f9f7a1d98f8bac8d257b07997613774ec9ac013b213ba5c91143f11b3b58c653aa71c4d56629e393f586e9e36e92c41a17771bb944cdc4c1857328962cd162b20aed655731a5df61d7000da817353850ecb8ea1f672f2ab274fcdac16ef99ecbd29961545dde61fbca89fbb9278155d67bb80b52be31e07013c833bb12749a4bd64168966f9212af34de0a7ad2363af172dc1afeea2ec800e0bc90d20f88fafa06dc814db82b60aea09c41fc58dd05c515b23c21f00a23e2eb9237952859f90de21cf3643a59bbc11529f916c61486d5f250413c1879fec2c877663bbe704fa54aaeb5f1e9931a5adfd44619eaafd63f4c37f08a4e4feb350dfe40d5fb2676c51a6de07d29ac80155d5e752e00c93b91d1f097d1fbf3e0948e631cd84ed362d36e592ff944899390e2eb06ea314ddf595d6834f28a937d243980c902d9e565750985d9aa1aa8c407428b8d0eb59a07f2b63fea85ebb5da63d2b2d3b618f03cbe3a5c87065996f088e10b932841d034187c897e9b59ff05db4c0efdaf7a93f42dbcae996fbb3d8da8e26e799e306006990ebd7cc55a3672e8bec3acb14429409c7589a6ed3b3eea03c5b6b4a894a161246d540bb15b2ba8f9eda41897f2a2657ce62f6b8ca4e924c761247bed56a1d5bbc64eed334b19cec6a35adb6883e30c1b8856c012f31031fe2fbd19762d3fef0155bc87092a572d5c9df807a93579d30ffe48e711e9e9d6177a047ff9876d5b17e33418b30ad58ed4cb9c83bbd75873525593e02fb7ab603e876d1c18cb58a9a373807901dda8c43bff2a8882779a6b1659a4c6a8b4c948a8689a3072c039db8a66607e5758b197ea200b3a0d2ef8ebeba718f679912784681dcddce9a817d6518bf3f7db77b50e5f36470f5518bdec04f4fa23246f5b78fd126634e4f3f3887f3c272a719dc64d60748ccf410779a0aeccf8ed57270753b592112ea05f180bf0644667667ca03afa0854e9cd39fa1a77b6aea13d6cd8973544e93ee07a0169193f2b1da9303c47832b8d3b68807eba46e7a605bc1a79ef32cd434debca97aec0e7f1416c8a9af3a2a95ab5bf433704a12a3b6d16a24c285c8c04a408cf739a2c9daea34ee16cfcff5a26b0ad7bd7c7dacb79364db9127e1cd87237a1e2183b374199bd3159e567d85e37e66fc68f9946c8e38e0785044c884b5ce66a77a8da00940d89a4b555ea794cdae2076f88b91dedf3a926d31ebcc77bcd53119bb99a0069d79148f8862e2b4a070fe3adaf74a1620a25d23e24e76e9f4c13ba29d306fc975e88fcc3d59eb8f262f61a995f5272da47cc5f0a773f94f4c636bad261c6304f71cc0e1a308b222a436430684e98ba0fca335386495bfed7de8131acc0c0b05042a6ca61b9e862ab8149c6afcc3bd2bbc08fffd3cf65e40a87f5ead4edde0e554d22a9fd7918d9cb7cfec69cf6c3383a09519f98c0b8b39b306f4c0dd93352377d3b8bcb20397cbe4d66217b1ee7d78af23e2e8d1afb95892ac743d3c169b5d78651e354aeefd9a617032874e0d651e967492c15e0746100cd90e4e45d6386863f7495d6bfd35499fea7fd77188d72e4fc933cb57890773066ee925273c26a1cd8cc3b0d22226c3989bc38c1eee698a1c95addfd53845a5bb3b48e5efcd9e355be57c7863cf1ffaab56ab17604cff912f12ac12c0d918249210c98c91fa4cd403730fe4a2b90b56ac068741084aca76538b54dab45209bbc02883047a6859070a05abaae561d3816d01df1f75558ade398527ad53e5bf9e88df2f620b14789734a7d600a9b64bb5c4a6579853883d1dbfc22d27dc40b81a60040704249b76a2e7d9bccddd7fefbcd9d291f87cfcff3d5ef0ae7ad27abf72bfcb7ba7f4ed7975bd9ecac90b6353c4a57160eadd94fed4db5fd663e2b32fc9daf4626f7a941602f90fe22fa3936b86ca38fe01ef1dbccd8f6f525641ae5f0814bdda43b0e083dc217bccd0ad4e32cb94ee125efaa2d614fed00d707cec07c13f7763815c4ad3308c02db31c6ee3eb05993f2c5f46b61baa8653e8108000327f1117829bf0c39b0cffb9a69234bf066a2f7bab26b23f370f7b30ce1e7eff53c43e0520227ee2cf6f2528ce6020cc2c5755674cb5432677d3d3a4434e049c0c21e89bf4190ad2d52325ff0a77796c1c78fa15420ca61717037aa36659d6d7505d8eee927fdc53e3cfe7c211c937a86376b1f1bf029589f114d346b5344d33b082b64e1d2cfec0453be2cefe89914a6d3bd73955d9ff35c11e09a1415465b10b6e55839b08b2876759e04e4dd9a6acf932153f57634e3c200de886eb19edbaebde2f2f1117afa7e4c95e14ba7f1352e218c109aeff8d1148dadd1b242a401be18ddd8bb2f8077bf962a60781bbce6f61ee692e4f845f89ee1b387b4ca22a6960aea011004f089f01819bf4342a57c8ff1daeb32165b8899d07db9ddd0979886c95667f026ecca74652fd652ed7d6778aca33893a71db96293351ea05aee8a1aaf0b26d6ca73d86dbb6702e1ded423d6848e24587126e63ab8127dfcbe14f080534e1f92c70769913e5d2dd3181674793d9bcefd23cc3610149b9bef4ed1098187867c61928077a4c50b79e0abe0907f352900a3b82d79560a7d6d579f8f8d2b7a59eb2b1bc83d95b173b9e6c88e720d1da42b2056f63b27a294bc6f1812da302a3e6f27187cc133fd7c574f3e747c71b320f1257378fb1912b0bf06b5cb16245b0d95886288c430c738ba82ccfa3816edc3465453f465b5c403e21d9f4da1f7d25f1cee384287f5c05786816fb25e2cd60fb2c81102f96a2f86c4145eef26af7c81dbca9cb3d417645d893b5719e9631db46b987826a4239d43b9b9257be6996d17eb45c16a7e8fd8e7fb61ec16ade513c2c18503caac13fd04843ce2f4aa85dc6eac265ad19845742599bd20ff85fffceea68d72b10714545a0728b2a100abee9bfd96f61a6b2f52231ad6d9c732aaf47bfa106d6a45725376d6131bcfd4b904efff1d1a2c8107416940603559eb4877c01aa31c572765bdddf4a9a5c755d5cf87e5e15d6ef0537f736eda1896451b0ff6f8810cd4109afd1b0ae81d8427be0e924612c73b5bd868954f5cd0a5b22e4f15c820a7505ef33f5c693e1709d58d5c1bb2c0f110e26a2079f3ba8c683a40d00ac73de82101c034d75e8ee918af7e5ee81032b188c88f26089ed88962bdcbfab901ea576577834e5c805723a7ea70403612459d109e36d89fb6958c91983dc31ad1633e66448aabb0508a9c1ed27dfd9fc6cf3b46e4d39325e26df89b0e9292b0d406ce4dac0939b536d0c08ec72a0c98b180b21e803abe125f39053e2ef5419f588d7ff2fe5ea35ebe9d864d8e04cf57a6ee8d9c622f0e5790052dee112b01b9121d699d2ddcb90082208c0efe61db7576de53e3617014268f166d1885894f0d1c1ba196691bcb104bcade37e65d0551b08345690c633655ace8b200bc3ed28e034f43ffbbd4fd294537ca10a8c94132ab941b344273d18e9fa6889d6d810c68c7bf42323a04b4f7f8e3ef618f918e5212c1f2698249b6c1454d4c1d4e3f570737a3f129bafd78c168d13e90c445b7487f26fc5f10603bc624e8a30655a36e8dc721eca4ef4981c20a3412ab4cacbfc260e58dd4a18574f78aae35484c243cfc5a6543a5a9ce09d5b86d49a5281f6b8a799607521adb8047e171099835e6fc13002414a8bf38e9ab401d4c582c804c6618b3eb60b7a2bf264c5885f4931bf8d245672b7389d26040908728c345eea171e2e187c8001f57abab10e78074fabc2caec9b9f62f8d26e47b32b0eed7b515f4a1b87a30d59163df63ce4109aac206a6c2961762800c1c0ef10a80e78aa68cef1b5898967cb8e27c3a72d8b3a20b0a10257498a67fb007466e1ca5c68f2fb87b317f997b13c362cb456c0dde39dba967e25170ba332e3aa171a78b276c598b6a6bf3ff365b802733f86b5cc8996d4d797623f7bc8cbd632a829f8f7ff659d7e5da056d6b71502e2054783ec2d8fd63a2e08d8e9c83f230c3933cadec146f50a1a3bd3515af1f7bf24f65f49e3c6dacef0232d28b433a5b40a4a2635d69e3a9c7573d461b65ed1b007306c05662e9ef9b18f7d5b36bd374ae4226bb49a99f288b66d15840887bfc33d6bd27737a20afd0aa0418ed9e3f1d3d62107ba9a00ab93b9924a6f5152e4d5282a95859e6033835bbece444d3633ae40276c37f774b68414b8efdf7f413f4f2111512be1b98f66c2ee8be102da26473651a434c0a561ef5b7cc62f4a7d0f5f966f7b0c751278603e298fd2deedc4223af686f125dc33c2a6fa2fb070a67d3252a4bbdbde62bc4ab0fb4339a9ffa8bcc1f28b27826ad88fee702dbe19e11f6424af8c6c783a184e16ef319430b09a65b35887b512c07dc9d3e4c260e58881c107a7fc4f334fb89e18cc52050ee52a4ea7aa0a6e4b4c6a6c8c617ba5f8c709f439ea3f0058b592c384dae97aa11760e17b55114fe55563b10e0b9dc4778e0376a9466ac163da901479cfb52d7ef5add6815de36bd62e4dceb220e3aad70098a611b36bc760f0b520800e8d830fc49a58a1d466ef04a86310325fc9350eafe0d7510f673200f4cbd79e32050b1ac202c4aed814d3975832f14205b441e17e499f9648d70e55bbf8ae2c462bcd93bc4bcb3ac8dd61dd3a4727356b4e06b21ff06a648f3858aa47f213039aacb158a1c8ab28f313e12f46654f09290b5c12549d2d0ad7126c86c2d4b081c7952ad99a278b6e2dc0758d15a854c0ae0a9bc33f9b3870346d893a8b5fa5cccd6b7e10ba2f9b13310d05cad4ab4aeb1d7261b49499929694d86b0c53bdd5d7004a0f0c2879aac1efb4e53db569173d683209dd2abf19fc4912f1a68593c7420ecc5c2bfade64faf686e705c6ddd587bfa246551defe870b505ee99147478b54fd79e99c179ba72f9a6898c462b297b5aa19568a4518af932b75d121dcd195b192d59e93ff0d27d0f4782daf864a6aa347a17b5afaf38db82342d7114e8b9eea80dbf11daf989ab53e7262e9d4dd36beb428f7e368047a27b3e8bb82888068ac70dccf91d5a6b4fb159803f39007f69e1e82f2217036cc7a79a2866aa0651c1132add2bdc73efc26890549335cdaadfa1df5fda73dd15401406396ed1cace4f8031359741660ad654cc45eb9c73c593db5e49b5d7ae6003b77a5da83a5f136e47ebb4e8ba388a662ec55f2d247451d3656d5527e80a1e158f49b6b7893aefd642f440c4a0ed9d893f9bd3bb6f6e6ace1fc197ab182404691b26d46feb508652578fd99fe2c5cb1b626fafd0a3bd39f20665623179da7d95be269f0d5b285931d5355802532a04f5a6ab8a91967aaae4a809d337ccfa7cd2a08026d06d122bf40562a898585139190de67d799fb026416956fc1ef16abe5f31a46a2f8879fba423c643920ac4d812e05f7cd79d1d019919df2c134dd49952ef3f1ddffd20caf4be007cc740b0417131112842394c3a91cdbc4c468a7ea24dc285ae9866d266a797eaae797b76fd3c070f912c9540ba1ef763e1de57a30de1c3a0b792ac03ad3810802149e057140db1d5e0170eb2102f574e7b4df697e728eca9005fbc247d2a74c3462754bf770ad1f1012a74e51759f0ec7ecde7e55692a7a4cdfb6e9b4eb69095aecc2366c6c7c759af884b435dceba934c8472c049f1b390ba757a9210459cd0289e671e72a0eda5ce9e5cdfe4aa3e98b7e008c071ded75ecf954dc650abb063ade3cfd8845ea820b6afc6fd9d1e13a0003bc8dc48ac16f57bd86e4509456e06036a46971318888cd43a6f3f7471b582e28943c6aaa2970b617f54a3e4ddcfd2a32a3c99be5d34210ec1d3c3c854a9795b3cc1ed33c66f6d676ccc310f1ec0e2f67c0194f8ca7610f3e1e1b0fc5bc92aaa38be3dcaf438935870a799db4d59ce9fbcdd6b56b845ac85193312f5228d6af607d38fb6d6b90def36bb2451c2749f9682ced2adf08026031392cdad9eb927328670632365ae59bf8a947a19af6aecdbecea34a9eed1d881cc545bb7446c0ccf08b52b71834e7330c39663b124feccde33ed6e6229ee920e938a956242f36f9dffe146cfe0aaf48ad38e60fdae01ef146fc01b9a5c840f2ca9dd86ca6c942a27c700688f586a2763f2a20bd99b77c8d187ac967d941d1c7f199d624cd82da60a8a14abe1b78744ed9446eda3a9a0393379775b773541ebc6efb9dacba3c8cf1aec73944840be1421c1403230fc56f6ff1ac1521b4473092447dfa1cfefa4655387ee67efc6d0556231bb30c7dac54a06a02c3fd211f260141814cd23348534a2602270e055156b4daa4282cc3e1b3e27351675ab9f85b51bf4b47bde71f5e9d7d161ac71f851c0a5a4e63bb28627b52fab41b09f86a41dcd8129ed560ba021b1cc3870dfcb3902efffb3b25e8857b90bb19f904a98d418f5a97ed95fa788e2df552810343be111fb5180f71def0a9d809b04559ee9870d5e6b4e2a5c47735b6d02b89ed264e9fa4d6e7e5754585e6f6fe1efe45b352c9d58d645b07ab51cb298ec2cdc8d5750dca18d0a3730565563396e45e9f037660e3016dc95fa60624fab97f069b2e1aaa898145497dfe0d813233bc3fe0bb44c30d715d93e3eb4d70169369667c621c3aefe9da6cff282e304c9e29d5309bcbf423a56cf614e42c71aa7bd1ff6fe1a0aecd06a855a7baee7c723d7cea2174b3cc590bdd27dddb2f043f6f91a17b541c221ec763e1821053d03332536c8c577ec51cdae53aea5df87a918493d89938033c8ef3a08d99894842fc87d400c4032dfb1ccb7f457445d9fab02bb895204f95d39cd588f1528a504409e936a1d74a44790e9ff6045db8d4c5116721866e8f25c9ed66ccf0a651dd5b14a432d86e934959eade8fc638e53cdf8379c0ce48347c35ff757a1a8d1a14483a1bb6aa5a81b0d4d4643aef16f96e9d690419820fb9bab70ba41c95dacb4b5dfc2a33ac9d38156760560d821bd9260df80727dd7881ff5e702763c48578368751e1443511f7c2af64a25a3e990637707552447597a7343f5e224dc5482bcd1c7d4b96cc9a15e529bce3673a6d27439c8147afe2bea8283f3a3a7a58ead155fd79f39c10b180cb7878a2de39d468494d5c0c4b4370a3b05a7ef9ae8a88d3e3cd495ca82e9f442cf5534f004435ab4335243890d43484f0a54c98818b6717137c3fd6018a5c6dd83e44e2e510e8a8065b7487d021c4e4b843ce8d404c5faff5d4f7a1e602068f6a6472bc2300a27387f5e1c33694ed2d9ee03caf3d0fe44e60ad32ca4c6a1589aea0efd0c736b0c4ed1040746a4957d917030ac2302eaf90daa3ead16287f4ac03c3a7daff0f34dee7922c530c775c98daea0dd0cc236d95c6bdf6c655bced0d95d327f1f00e0eefe436bf7d4a0530e8329611c534ae9e2bd469a9fb821325362effcbd7b36a30b60523a2dc0c7b0b0a601b566f95fe739e16f1e95db175308fcc8736533d472222919011bb25cb332e7efe3784064320439665a39a3b05e57833edea896f1ec1855da1a10053aafba47333749b796b3719d86eefbfd34776df03ab673524dfb57c8200215318feca6c59e11bcf7ea36c83b24281b314714fffbd5d3a996e61ee8d067b4fc85dce9e91d4fb50a12135dd6680c91e532effbc0979379f32b3030c4b8a947d1b412235b77b2dc8b535e93e56ca00ccd8de697756ec536bc967dbca75c1953dc42b8f107dd33713e6a4425e9ddfeda0f57e77c6258210bb7bac06ed57946d679f0bafd2b39bd34e41db76ee40d1ca676a0c193ed6cf5e7acce608087a0d392fa4d6bddb749386525b3d04adf20dc01416ee350260b4d4c8b65b403645961ae639f8e08060dc3427554accaef04a8e7ca6c96fc47d8b3a2360fb7e85fe0629b1a21d7fa73890a5d3d90ff762569f1eaf9572ddddd310d739f578ca4675bafb261f3364e2abbc985bddc2b40fb00007f9720dd41ccc236b1c717be4e765721a17c2610abb35c6e974f718d4f3e7b7eb22bf6ad80a5c9ba9b1fa4574b2191011bb6cc19a09aeb570402153b856738fe0f4671781ec91e38249835eb089b5cae28a509eeff23fceb9e8d3db0269bcb037ff29c40bb9bd595d9177df3c05708158f1a68264a8c1684dd7e42ca97fbad701d1aed3399774d23741ece96235488db6344cec7a623f46de071e5aa94a813da1f505b504fda36e13e29fb85584513a969c23a6407672663e06ee454cc5b267f584fa9e767f5d0c328278552f8e0abdbf71f86d675e4403f2598b5baaca066f9ee8a6a662b825bd60424a9d40f697ac28a6950c89b24b3440070507bbb808e24b85532b3293db3d40bf59d71f71db8be8feea71fbf67574f7b17eb7a7b898c34070b118a57897124e079db5955c3b110fedcb4281e346b58adfa0356b4168ba3b8b85436862a1a1c71aaac18a955913bba450589ee55d78224040840fa908824c914d261677a8b8d5a9b66c35e7093e9f0dc99e03be4f2db43b95c47de95439c95f7461c610bb0ce6280ce0a124501294ec012d4e740920138e18c9269de9dc42e48e185ee30eaca0c403871a993bb0dfab08fdee1a8ab3a31aae9485319e1c48925e09dc7992957846b9576110661d3d9215f000cf23444923a8db86860ed17ae65cfd21630dc8ad76b9bf7741e62466c45de8ca4e798f170fef8b2013a8158a9285bfbea139a4be41db9d1891edd18e3a184eb177a5f4240ce2a8a665f9749f5355da44dc5166b6cd43144a864a73e93ca7f68bd24ce6b264566d5c1273bdb936806faeb8751ed19b51d0590d6d01c84ef4af2c724f4461a0665dd3973cb5ae02eba81427c44386653a71344a30f46e054c4666c3c46a4249718e4e45f7a81b811d2eb8ae8d78423cc66ec5c16b68025e09271e7de417e1218672881ad938127cfe13086c0b130b728f613d55293839c2fcfd5bd53750bb0004f620a0cfe7cd2389e59e6c31306d903ed91f05cf87859a9c48442dcce89e862fbe0b8eb7bb994453ae477b25ef8680c2ace2be9fa23a789dae78e5bd45e62f808151a5c3894ad97d2eac7a5b35ed571494aff29a8efc67da369e2d7f48acdd09b36f19fd8bf02c424c11e28968f1af7558183cfb7c7ae74ceb4aa8ba63403c830847a289118ed654e9624c5498b86b53ee02c778c679177d55b18bd5af0401a67cc555073b01d16f1654cbd7d947408fbb38d8571c26de270e7017396cb79a6eb1b443e30f1ed56ce8a3b5b7b6cef5ea34150979d648cedfed10f9080eecea40f53155c99c981f88f40b0490562458a3c4e623623acd2de11b08425b14b7d4947c9ba40191cd1ef1fbd582a96aa986a39b126034df73a6c584c21eb55d0410b16f71b69f99d311dc90dcb6011836468d498d2f1734b4c596fb9b634dfc5d871b1140bc295c431fb4c2abe10e3895e0538e2ea21278ff242030e53efd1b94cfbd2f489c7772893d56878d1512c861814435598e18eee5c89d952b33aa7f764ac26a686179bd424435637e53a9cb1b6fdb76a4fb34201c257d81430e602e7cd1f496b77d58ffab647cdbdc5e7690ded6b70d607b2369dee4f9ac7bc2085090376e6718786f0315e3d49ce94d4024d6a44e00769be798997c9c9891c05c50cb020a16e5a06c8717bdd5b9477946613950aa00f4e9c1d86d22b5cc2f3de0bbcf71616d59f154bcfa210165c1c686393b0189f706ca693e7c7cb103bb600237de501c67bf6bd4188d1ecd3ddf56fec6f77868608bdbf289666fd3616c83e0e85da4a58a2a62e8f2280fa80d5ebc04f06e3bbf9275f14d6ea417567160e1e4a3fff8ce648b56948f2f64592eab0bdd3c427cf76d98ac2a96b3d93e8b95da7fa9484864e082cfd400d5f1188c352265fe1ccd980ff1d41cd0ee167ef6cd530b702225780bfee96867e874e07802d66401f54bd1196c183f53b07e669ebf53619bc10966088a35bd96f64c0bb3b5a7dd1f5c6fd9da8b5fcebd9648ab094c1c55efd37c51eb305f2319a7bf0baa962426c86d3cb4d530d06687ad244f9285f79b70dce12f5e7ff14e4a88a601d3fb2a3771dc06ad14922e5d6a8683d421ad126c9f5587805a24291c9bd485a8db37ed0c9e1cf8d69fed22ebcceaeec179ff6682465756aaa5ab5434d2ddd6f9d001a8a560ba482f27725ce9bc2a44e3910ddb04552fc8e70e1e77a58d8598b0c6293dddf8196a45deaa1798b15888d24fe8802122510d9c49ceed972e60ebcd3e96162007505169caffa4ea71972178309089ac7941dba16ba9e0a18100cf21de5ed027e169ef9371771f7ddf7b06f223859002f5c311a5eb700d7ad7e7416c55ef606030dd46435d289c041d387102275752a36427ca9f433a36297b2a5c6ba24fd51c8c686f0cc4be272fb01eead180378b2d047b25a858fb26a65b8f52af79368d33246f96077c148fa85b11952067b8945cbe3ca6de0a196e89ebc99f3e489a0f4f5eb9bed5ec7e7c6e189bbc991f1280ddec7a0a6277b20ea0b16cb53ab01454f17179495da895085b7ae5f55783fd093a38c680a73e736fa5a0acd2ee7fb75db73d5b28a9ac7940bcb469356bdf641e3bea3d0b90a4a98a23e84b90b00793efc83f74825870c9de61e9e70c3893f66498e45e0ca8352d9efb6036ccb5cee6f439b241b4947be54b33cad4191679f83ecee73412ee7ef2a7c9182f3d23772bc9c1ad20ea37d3cfaadb6be94841ffe6023e4a3d37aecef43d306021f8bb387ae1a1a29e8f35993a0dab5d133ad3d559c524bdec26c669ac844d5573833a99e15ca4dbc64f4ca3e060c4717be1a6bbb05ee3e5028f42cf6032135f3fe943f197e737b1f430c5b8d457bad23bd97b3a4094011aa39fbed504a3c73515b75a8f4c482b3e44f6b96390cf89295c30010511e783a406b3ebda6397079bfa38eea64acf99188b0331a062d5129abcbfcb62bfe5f712ea745268a600b29b7dcc2e04f05ef3cb77b9b6316787f16ded5c69d5be9c86142d5d18c800ee20f64c6e230c11094897e32490ef4c8ac81751e74d460b51c3326f95dc8714ba8e1647f0301524a2b112a3e0b61c4438062de61d91fdaf33d718b18db4704349b72d2eb580f6cf2a218e8c883898f029053b33ffc50f795a71f78a6829446c2f4613ad44dd53970aec1b8d70ff5c322e0e74102862610bd67a9a9ccc994b90fb0bdb5df7e7cd37a55d7d2b7a24397d4bf046ea40b5006935309e74a4c4731beef8e297665f9420fb1a55208f72c3fe6591620f2345b74826ba0e4be37875786d4343fef691d9dd93a5cca283d21936246c1c1fe9c1a852667710f4f103616c358dd993490c5c61736f4654bfe915134108a6907791a435d2e82547b3ad6900186a53162b548638cebe2a18d694c7e57dd807acb355e594aaa7fb898f0407c9090207f03bae484c8bed82c8fa2e6cc14ca00b1c486b35c1abf90be850348e4f0616935ff39d4d71b16e880d365fec8c40474476efc31433bf0f62189e2fbf89c45fd7eb9ffbcd750a096aa4f73bb002ff98e41e56ce1946ad64403edf9f585dabf78944d5da5d873025c407311b28d3f715aa7d90b68fb19aa0f7e6df911bf6f6ef6ee73dd15fa10487b53db2f985f175b07eff8ffda51ffa4eaf545ba83065d620fc653670697b486976f2ce8e292fb2d3766ab3091e959f867153bb712cca1355e915dcf72a9bed2e142cd481362bd83050f275c7e56430f64ee68803afc328c42ed7f4d686d050408f0ce8e45dd8da6bea0d13aba2136ec9c3e36cbc33963e82dc210bb23a3d97769b47eb6936fa3d95fadf039c26ce2956c84da7059791a4c049e110482ac213d81ca1f4819326fdb94b77a856aef1922b8d60a2745c4877100a041168eee0abd02b6dd2b75925d48251e17579bf8cea0d31dfa6ddd528becdb926ecd6f7dce4148b99952bf670fc81698d2161d911dbf0bd61cc974e53e41fb3c53a49ef8afb65ccb99664ea2dba25dbe978555b41fc3a6d618a0c813e2b9cce7ddb6e80232b6bf0c8b7be5eeb7488bb2e040fef6ca470e9758cb211180b35a990e8a24d8c4a127c03cb06f5562091ae11f0577b3f14fbe82f4962f38830e0df41a4d7d69d213456da42c0daa0ddf98f5c7162483c3e0d19e31c174db0b4e2ab0e6722c10067e8464e1bde18acf0ba0797161f9e189b0fb26e075551ef46da6a88efeae2dfc63141297b0348c5ae9ee679616662efacc4e787e111fe17704b02d0054c8535ca809321279ad40d33e1c45fd042073eaa0e6c625488f8f9642e2224ae62d4ef32375d81e3a9429d62eeedc402bb2cb71bfa90d182ef2f4bda5cc6a1dff817345eb52f54b7a5939a74ebd776fdd8f5c537d69779ee1a3e2fad3d6dc906ff566b0d1faadf8751766313b590e320b9c251a0a4b0b2a36932d7ef7455cbcae87ea2b6d271a8079de0768c93bc26662ea73b154d662bb9a35b4dd74bb0680c88ac0eb174d934ed154118e8b6607cc4ee0b3472dd468c114892614b64c7482e2e68b1ea1e0b75e02209533f8ed0bc619fc9e4bfb4483d6c09bf03b54bb3d4e7cc8f901fe3bb262176885a8ec5da1723ceb276cbb28ff5733e84b25ff6da3f9c4ee573a6817a655feacc5e9934eaf9e0b8c3d44e27cddafa61261fac872fbc391702d89367329bdc3f753aa3a2aaca6a2c550a82df829c8ae4aea3190c36d39a689d33a6d658e7e4fbc713c203dd5adb065c8e75ecfdde25548e7229fa33e27676d32f1389432a3d349916fb156a1c940921ac9fc2932b350a0512909c9d37b2c2028af7b2bf01df9ee1dbef5e19496cfd51a750099d2775cd7cf487563ed470d39cd9eb18494e750857c11bec7620b504da6111fb25002e06ce5afb4943980c7f2f6db468a675514e2f91cac4c6fdffef36c61ee1a6177960454e2f2d81b36a89d1c26cd47ba1fa2f685f029a56bc9b4c35a91bf496cee5d2df1968111f9f9d802e475bd523d3585783373dfd7adf304ee27b8a872da2d69fdd810360ec36038fb11337bc813a00aed3acbcc32e69794544d3323508facfa63726234954802644ef7cdbdbedbd9c5b920023d6d602dba3127822431d2aa9296e3051503fa69ad1c5ae4d207b2df52a2d32828c5ef236cada72d695d6c7de7377ad8a25cf345934ac7332e3e1db66827b3976a4a8d3806bbf4fa70f7cf7a1033da70654efc5b987f2d49609697d24a5586f3d040f33d3f29bfdb55155d0f3b73a64f4bedd579111beba0ec5037e0f01fdeb55d2a6e0fe6a201fc7d3159c16a992c8d1d14f45037ecc610f044f192a68e410707de5de58cee67f66c4a2750a81c1d59f5d17a7c8bbb1fccaf61200a9e7b0a6473d66864cfe87014c94c597c5854906a5a45a3d469b5943baf8601512cf15e03d954a9e0bd700ff24641c762b55e0ff6686863484a6a8d2feac521cd2ff53d7e19a457ca2f05e3a91bf2b165df4820b96d25e36b590e15395cff661e1196af03613ac45a691ed11463aaee33593e9cad0b715556a326a9ca7f31d6ff832558963ad805de6d8747bbf8fb150a081d739b416f1a0ca44c9fb354acc58d27981ab915161b56fe52bc9b79fd7c15aa342856ccb5c5361ee7be9cdbabc1622c8ff04ad1b7e2277011ccf31ae948a0c7a2e0848eaa23ae6c0788f5161e8dc302ae75708c325eb23417551b1d8c17045f7cff3329f15d868ef9c22d919902aa57b75ba1f11c9da5fe6aa177a49a215d394ec0bb9a3dabdef6cebea71085f23f6403ad8ec4c73e808e2401b1bdfeed999a525b1b69d6dcfdf5aedfa9269796bfb9d69f73dceee749b0643a4e5af9c938a736969d31f80b7a69a0dd27b6110a800431ae2e2d9aa1196b46c6db61cb4a3ac65b9fc8bce75b5863fe07640fdcc8333fbf1e7e9913b422b017c1b1fd993fe9a0b91cb71d582cd02877cab8014beb786058a4eb202c0a03f8483af8f8f29f39784fc2f432f970a96334081321c9cab96cde86e06a397a1fe1683156e4b57c0f941aa9b4c37974cf2b7c8acc8f68c86a6657deedfdf3967ad921269d1cb04a81a3014f634ab4464cb5fc94a2e322d4206e36787e89a75dd25ab728bb4c4e74a0c0f96651c86dfaae3ad68c1bf0b1730f5da2965cf1d651af0fdf7a326d74add693aecf8190ba2bff49d5c06f2e47aadbed6746d13837257cde3a762d7788b67ae64c788b72783a6535a28f442c6614d0daec75fcefbe684481022b78783d3fa5a4abc81f932e0ab89b3b6cf3a50f86b79cce2e00c0c5b9c5513ce74a3b847279ff0f686969881dbc0095c45f8813a65a5b89bed9c01b07cc3389c5aea556baeccf975d1c5420552f6224da6159c0673a220b5fa46677c9a114efde34310e8599a889ff73693371d86820e302230d3b033def5922468e082e98463104652476f87302c0965db5ebe8036d0343584c031e29fc3408c18cb9ed17dabdcb24478b13ae90047847c8fbb9579fd6845bd3e8e6a1ec0c8955f2040d7bd34a2a91e5ef1f222c41ab9d5f6b1fa7cde9bb561e63513801744acb6f8a48bbca3695898bd1d6c355afd8507292a3dbe240aaea92be4cf84260eff0f909b8f50252a0fa67553ca5cf0ff944a351fa2e7900e70fcd57c448ea71bc18d19f75d0d3952801afc0ad3e273c14d60e4579db067ba85a6c8aefebc99001883b2039dc1a3865f764759325a0e7a4b71cc83c0638d7f07c6b7dae6ec721dae6c09faa2e5c722dce05929cdd05ce0fa1fec9fb3c0325d5f5805ea9cf288aa3c66ed7eef4a992d315db3c7cabfbf97a37e64efd9eed7a023d9914b4ac7af1f3af97697972ad4e3553b3811a3becf1d557eb785d390efa8fe8d2d81a9ed3255d8ce1be464a361b732ec85ffe878925d78457a2f2a12aefb1482936a18dbfa1fcb83857352ea238e50e9bcaf598050085f0440c2db4341d2ee799dc3e2393149b97c2f68be93b6b6a52f50e0617d5f4a51c68c23895075c383e797d0738a3727121d87bf6656c3481f57140bcd35b755938d204ff8ce53ba847f2c064be17dddc6c2689f68cb709ca858a84a08e8887cb01b4ef5f8704eb4ed7c9d04bfc83005b92fbb18ee8e20174e1263685055cbf837617b679c67380dfd82ae5e3c501d78258d95596352e0c43726bae350f9afc14b6f84bc48491e2bcbf9feb0ef7a04690da8bcb6ef589288f2c5326d4ea91f65822b77fe1220ce7041ed96b201671d3699e98bb8519f25a955d76b1a8a0d31047a76c1eec98270a6dd3b3d151fdd81171aa9948240bcf45b8fffdcfe0cb9799c2567b11c415063d19458c10d148657afa0e464592c9b7c02133cd6c3dc700ab097661463889f1d8fcd8ab2cad9cb00afe06cf8cdc2b5b710e9001bd75a410ac9d9f3928f5bdfc97b2d3b3dc8dd9ef042d83a398988bb61323b9131a8b362807dd75e7287543c796d32b070868c0e7f9bb255b6d3974d0290de2904bb4806835611537156b875e073e7e6fe20a60033468c8f9c71528a6bc5a8223c8c35e3749299c7ad7daed3c673ba395d91fb9b30c8db31b6d9ccf6cb98cc4522115efc837a12e2c9510f4a73630505216021593d7eb645dba823004366155d336235b40432261310367a3d264bb1bcf2dd99c0e9d531f38702fbff0934e590ed4db71d137bed0b56b10a104ad3a6d62daece832fa25aba41dc1b1c1863accc5d4cb7a79297f58532e58537b69b9560d65578afc7dfdaa806056e9a0f53e68381e5a2f721bdfa9e1595d82419463a9e91757f86711e10aea688d8140c634763eb9c52c8e3c762293d62be3d3eff59a0505462253a96c36dec9cc87ab938cf5206284cfc485a5a47934797499f1b42fa2e9630f3fbc9ffe3cbb730ddd25187d2d0b34ac1e19a06fb404daba876cc19d859cb7918422477329b6ae72c1850dc65c32e1d697f21de7db68e371cccf7b253eef31ec93d65ce3e7aa5bb089a937bf824a08eace59e73d33508d3c6d89f26b576c68634bb7bcf6da4b439f64a34676d42aedd3356602a212518f03c1de9da6aa886e68b7f8e46ce2f5c03ff2f32964dee3a2bf05017edce84e4497727f48b216e6a771920665fb8bb6a71ad7dff6f013d68f5b1fb49384c977da880617be869b7f3f53f68316f7aa6b046731863463d31c6ebebf9a29a28e7bf6f8062125b411731c965d425ffe0772045676eae72159441ff68f9c1564b58d84e2e0b41fdf577c402b4104a76fe0fad80d03c5141b4bdbd37f28e9c982d07ead48e626cf2a8bb9346a9cccb144209d097f9ca8503ce06ceadf5d12dedb024d08c11a8eceee5b46483a867e224b3ec7dfa28044df0a21ef97be37b4bc920ae8a49267a041010e9b17ad0d3af63abbf95dbfbb88cb64f53b9fc0f219af9d114b31e90503a98e08445a9ece42873218ae6be5ace5c883a4c00e27657a6d57a57c4f55492135baa425e0031337b18e4a4f4d7742552e2a064f2fa026686393e81761f2db7b1c50719787b7fd89f0da8a0fa99f241583e2a49126b1bc2d42c0072201c9967feab714c1430d25ac12443af5405b1d5c2eaec21ba30c5ccc8070a626e6db3deab0751c3f7c9b03a52c9df994f78cb4405cfaef5c8795af25c64968d310e4af4be9f93a7922c73949cd35e010a445091df46614e845540abe4161de946aeae9ec3adf9fed42c2b00177d1ad52628b988d0c23fdd9ff220e6dc941f76e0ac3ed4a0c3e465fea52996446554e31d414909dc8aae40e189e73dcaae5cbc08415f0b228cbdbc5b09d1956f9af20b2066875eb30e1e09a0c2402368417a0d6eb7af0fd67097e1cb9d3a2a5de017743788d1fbf54a7df544d0f39d20c441c6f4d0f165bf942b9fdcda647d4fe31ffddf4ae879b946616c1397b22735b496edb797ce70c9de3c20e07916e9ed725c616591b8b4be8faf8263691aa546b6c5f0e353ee37ce974c47cf1f6258a946f31b007405233c3184f5d57d23c08b3edc22a3aeb5244b9c1ec48b790351d76c274b9fdc06d2edd97c6d8049759e070b9fdeb8a952fcd7d5dbd2304f33261ffec69269d923a5411c78bd06cbb88e811759792bdd43e2e831dad7905836faced6952942055becf8b42068907ffcd246895a893219fc8e5ee946434b540e423195729c28f910e632bdf96ab53edb6385c9ebe426dcc36a0a55ed21defe58811d37e21d9a5a13a151d558a2d5a10a33f058982c37c7d9c6bf4dfbc75a352ae9cdc101b23e31a164e7b89ab74ad54f0250ff8adce7e1b0ce013829e99ba6c8395608bc8af4596051dd36e03d3ead490583d1aa68f88ce0a7d2c8cb771b5c7243d94835d3f2d68405b566df1c47bb991f08dda7bb8aad3ec61a74ad9b180bb62e5107a88a4403472b174c8090a6621a10e29a31384a5c1c6e3e32586961e75127a726832744d06a7abbd902bc519b1f35d9b0cb874410bf41235e657fffb65fda8d10dd6a1841ed9a0f3888e43e4fb30dddf3117885cb208bb6abba320073607f33561600efbb6c58ab3527ae1c4186cce0dc0214fcf810f38e7faa42929b241f7a8bc9bd33968764df682c86b6c79b0cd9b02317115900ccff15b3cef049a99d729c5952301a6b3690313b052a00ab2a6357e7d0a79065d7ed5ab8227a8ef4eab21ee25e2861b01802eed65a6ab93e5040e8c70330465fa1e26b3976aa0502c18c9f8861c43c6256a77760f9903e8c643e28b81bfe4233844112f83fd1f4ef78d89cd6c8394b28bcb3fdb62c90fcf4345b3fbfe8135c1a7620194ca3718dbefd6406bfe98fdb2183bb8c0dacb1c0cd8536dc2f4ee31ed8bf43e6407608d8aaaa8ce69fcfde0005354ba66dc8ed642cb5b66b3671da7d933d9ffac68c1a619fa96919fb226ad71b34ef4331fae04fd7aa67c78569995083e05e17c2c19c940bb78cc8f5650c114f7ae4398453456d6544a2d2edcd32982b7ee5684bf4bafe2a43c89424089f4c1c688159e0a3bf4ff3e4317244a2a9321d838fdad8ee0d3a3d164ebccd3aeb33fe9808564c78e9fe6ce0c2ea603495738e391c3cde200527d89616c379d6748819a4b9309689872037e557d8692469671fdfc3ad40599df9b2b5b3bb39be74ddc8c0285f659d179efeacfd1f1a20d35b137ac75d926e948ef1edfc5ff03ee738906f1dde683200a1c8558a98fecd5da8a4105b89257ce48cb96b88441b94c3ed8f9156369669ac6723c093789ab954b3648c9035f70cf2502fb2aff6e921caabdaf450a696b8a97ef04305ac455bec7a5074e4bcf914510348fb68d44ebde84e7c087f77934894e51576bbc3be5a68876f87fbc4663a2acb3f49f6122255c5fe97a1d101537f125ab280a4c0b778a7fecc7f63073ff5cc98e74cd58169e72b0f7829fda966d299b369c9d8f9a5e689ae498aa18b9d86b6dbc40eb6392675005e98df1cbf8d2a49bf57a475eaf3b91d6e1aa1bc781a698acc0882659ee840ffc94f4ec5bd9278a10b7d46ad2793dc233a171a78a0371b0adf111bfc28d0edad3d438bd94ef96eeec0ba5f815bf208576b2a119cf00734d46eb1c338f25f8265a27e38e06e9b29860ed680bcb38a511f097c101dcbbe824191fbe54352b3ccde38027825a1577c6b84e0bc3f382be79922bde1f1bdbeb4cbed7f7c91496ed44563f702b11ec4270970cc6a9e351c3a67cc524e33616c0e0005ad881cf7a995175976ac3a50022eff45e903f71883b06f6ed90dc93f1b23f812d760962e03839e3","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
