<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"0850b1fbc9e37822b85af91eb2dcc71da287f40f8f2c46342fd64810c28ccf9f52c43a463de2188b64bed19efa60969b22b7ac6df060b018d4ebb8c10a76d90513ca2065ceee2b62e295b196b5b20fc48572c0b1a60ec1387a11d5ab6e8e26899392280bff09a49b3e92da6174b9fa1cb993b7c142a573f146a7af4e8c1d24914c074aa16dc6f5c45bb9d99b3a3e9cba3b73488a75a60161943196fb7191d1e1ce286e4e8476647e9f129af4d55ec6ffd7e48b3fe130745f419ab33c0fb2ec8aaac3a44c66c13486160ab1456e520a1782d9a4881c094f6b3a4da5a787753bde402d4dfc8fb2a5e3cada7db8a86d22d9e034d70b94516bd3aac8786a7c0ea976abeaeff83c898a29b0a2901ce614858a08b894b823fdbf8d09d0b130078cd5647e602f42d3851fb0822427d84255b459ed7137fde2cb8c8f28952f78b4fc16f3c508f31731e163be4ee13facca0a1af4a7060409a91a7b3ac53e7858fa3adad9a09b038925124da0f90a10edb491cb40e733969a837343d3f6d74b5c3ef06e8dcf4e76db2e5c1559b6f811899ea05f80c270a0a141dd8a52bb983e3e82789a3b927c15b1b290ceed8e9dcb78ad809f9a6649cce50d5270f5d8dea24bb6c01e9b56e8ff87c13ea9339f30aa2735cf8e1e7268d6d4b1f9754f7f4dd473296c8486142d4339b65f831490ca159273cf28a650511bb1485eccd53bfd673d6d62316aceb1668f3cd218992b145a92bb14cbda83f70a18eb1cf7af24e9ca9a80238926f686aed158d68b202cf532f2fa30468249da2df9d6d382b0607f96a540af58484b51a89a15b3e57a9e2a6bfcf2b8d71208954c2c9ba9a583c92c503ec07c46f65e2112b23a9993b68122c12366dbdf9c1a01a65fab3a7bee68e96310f176ebe3147773d6f09a4a7a46aa864a48093d4269a2a119bd16e9171d1e8c98ac226224c86163b08cc362e5ed451eb21afb35b5808015aa561e8ba1fa13778b259f3983bbf87e8c2d1af2b61e88e057294d5193983142387d23bacf57a0c6120ef36afc92c9fc81402b99861a5ede632cedb7765d01664093f08d587ba9dae6aee8a82cedc5e695692920d9f20f655da4a995537e23bbaccb0bafb31b2d282de47e2b30396519cd5f7baecf258a0ec5dbc03b40b0a5c9ee3845826306ee235aaf756f065607f43853c124d0229dbc2596fc39a8d0bb5a45ec8e2754c1a796aeb569d11010df819e8df0a907f8728fb1506526d066c3db2264333f31bda233b92ef8ec0a0518aac36657d44e12d91216a5c63cee27b91b2bf49a400aa8b5ae21e0870d503733674e8c257f86e5f3526f7b869a869f4d955747453c95e31191afff5d37dd6584d62e3ff8e09a5320c5a9e1cdc020585815de620c48d36e602c9a477e867836ce15267607957e37e533fb202d01eb05516606529f0ec3835d7c32a7dd13b82edae64c66dbace446010681edbc4b22bea07f3189edecd0df038679cadc56cde9e9cc173c159733b80037a9145df806269920e5809b187f5a133c613ab682e8b42c9db9ad7051e6ebd766877c731b7e4c5bdfcc484b61a8f9df9573cb14037e9e9ae94b350b252b441efff69873d9bf3d17462a42690615449eddb1616b339f19c771b147e04e2c19ddfb0c7e36eb888a6ae0c6a16ff04c61147a8fa9a5df1f9be1c599b0afaf6daba378e2fb546e0e04a6281402f45f83a41f0879617924638866945868544b57fcd988ce4a2280927655d6d5029510ddb1c2f1f2659d6b21b4761d7ed8e757f3c7f0ff0cddef1338de7dc02c57289d9b7a719e1e6722928af4ec92bda33d67abad7cf21ce4d27e714a95485af4cc1c4b96d757bae263c7d6c20df322e1054ccebaebf7f1c693141a1f00a5ba8f86e1518f2e41606343f18e2acc8a1cbf9709f17e3cc9d96af9daa371fef0269d0210b6a3dae78baec7378712b87a865c25fa83e5031f64b54e1012e1af1d0ec425ba1096506660975147dad0a3813eb5470d6ea790c391442f5967b7f96e62861fe287bdea564285c96419d8b780b7f3ac942344fc4ee72e51789d47ffcc98f723048fff2dcf8a8bb10e19e0b28b655b43a9c4b56b94974cad321d03c725d288ef052ccb9875b4fed8cb1e5e5139c0d37e19cdf2eb53c151d53387d98c70911bad2797c0c7b65c89148ccf6e6e22cb9545246397b76db3ebb9bc439c9659d038cfb3f7b2eff377d68ef2dfaae08f2e78aa2aa8ff98cfd9fdbaa285facdb2d66887bad79c2b9f09feb316ae5af38dfc31976d3817a0753901647f454925d3f8f0506e59e2dd437b9cfcd17cf4639925918858b64d245cf32813f019a76500a88e5f1c8ff52ff0813a5f4955446f0ace623ff1ba831302cb510d2fd8a5dbbb5b35614222c033adecb5dedd62f45504d009e5f3571bf02fc1e1c6d2bf516ac6c472e4b0ccda8cf59c1fb3f834890728d953a3a1bfb529143a8bae5b8c7c986e23dacf6e0936fbf535c726d9ddd8a6d6cb0f01f08c10e6d06324de19e2be9f795f9cc437bda5514db8b31574a1c0369fddcb31390fd9a0785be37e61fc35d37b60f72b85601762a5447312706e92d9518d8e34f56b7838c7b628e3e46e40d6522151ea6b86b14c7f0537dc16818006f874c84743596037a13c9ee4cdf2465654af40124567e0244b2f613f6d9445858e8eba1fbcee620ea60474ff9216dfe16768d937937c1b13b1f524e1e108092b42ec3c9926a36fa5c97ed57eacf964ce10abc2fd5db17b5c69b066c2c8671fd044412f3c5c2c33caa48a8265133874c7586730985ddd6c23685dd711a27ac1d4108173b9c714bf445a26838f376f6268e6f7ef02547ac6fd89d557737fcacc7afc1ebb26a0bf28b1af45112c40e068c1f754a56b1eca347ffb69be9641baaf91f8e4119be5d022ba77f6da1b7bf6a6dfefc4955ad5cd3b9a5732a997228d8401f42c97fbd12c53b46ef3f89d2c9739308ba7ff8449774d306ccd5d9ee96c1ede0d72acd64d98919c799ebc67e3e1d7109fc3b193d249b97469157d1b3f569d5f19a3b3c2817751878154e2c4e67349d871ecedbf85fee838dc19d2defefecc7b978c48ae05d33e17e2e8d449830f24df457cf9817f905aa5727ce60bb5b6e8701f766a9f33d92b58abf457cd9abc9b2f710ddd24b960936923aa0d3199dd71b83030943d2b3c5630b6ab38953d1c38dcfd915442d56c6fb06e97564e9d41c05791451c934e0185d6907d1de496b6c48433a490fa3b60646b2f6001b472eec98618fe7e1c38997dca877246241bfcbca5814de90702a375f78e6b73b1dbcd0486093177a6521ef4bcb3e79f5921cee2e463e1c0a7c3066a1dd3ce42417811015c923ac04e270d1b534444f5e4c7a35cf950fb331cbfffeaa736f4c9c8718589c95068d24ad52d9c05a2e856caaa92d5901b6ac224bc1c174056599949512ecebd72adcc94638d2f229f83181f2b33bb62c6c6686234d5cd5ae8189fb4e5a0b2d87902af60f45d52ab821f94e5c31cd65a800b7bb4336773f9ca841b72336348eec9fb7e8b7d9a6fb051d7576005a28d7401821da5b37e851402b4e68d6bee50ba02d6179019ca3e134a9765cdf17199c931cfd96dd66712b9452d01881a5f3f29cc754993ec692657c10e6543c139df6626cf180082274de3d182f287dd5dd4883939653f090678f7e381cd7db3d162a92b381e31ab758251420ea30ba7c97f02605f9cff8bfb149dd91450ce53bbbb81492f28155ba3a502135eb064b2bae23a3fa6b133d574cad2aff3c75fcb3ebed8a49db8053d98265bacd1ddacf18a25df2e668c58a2fb1f1198a528d512b0d10d83c8af239e682a4c402e6838003ca7d5761a7fa39544d3b721a87f338d86635754b75dab939c977dbc24ba9d3ddb8825a2b13ec7fdb2c5ea0954b6fe83cf5f27948b19bfb69db8ad199a1e474e4504f82a618a1109405de732b7372efc1bf4073cdfb0c53a2a87a18c40b2db887b69f30caa54e0b7bdb82f4f110fdaa42e6eb313270db87e6a59c61fffe3821b520be6022f25a459c8936b5fd2208b1040637d6d6fa11c9359f14d3702c958554328eab328e5a3542ac1e452e1650d1b729bacb1bcc3ed068f9b4d7ffe9cbbd561f0d76a70e69f6b11e252eee825cad2c4b03d20f15b6a54d90a8865548746154ec510da56804985b446d2464cd01fab314be7866346c13750a6b330b886833a75808dd821d2784e8dad8bcc615b8d5b9a92beac09d7125372304c00afe15f08c2391a6e931e593820e3b05e5defb851ac0772e92c93a70cb9acee26650782edf0d7c2ce9767d8ba2007fdaebaf9256e17ebd6b941a60dd399dca873f8114ba7b3eef1346163e311f76c3676c27fc1d9f9387d36ef3003840dd9b1a1869c0c29ca6cec0d86b8ba0abb60b5f5b14dcbf920a259a11e6137bd320afaa36d4f6ae75df5c4bd7a68b1d623b6ba86db050c7ba784e7a9870fe2b110a5de8e8fe9ae63934f5ef313d67efa71f39511d662c0c5ba58874fe089d0f0e2e43f80e38da6ed49d0e520c8979d6de4d1a86acdbe8750f44674b14bbebfa808ea807e0397e6739f28d5b84fc92b9d6bc90d1e29df596733df70ec27b1b86e199e0fd8c29167be430b1697afe301a0bb92634f97fd05d6b5b812b487eaf36b48ca2991279d8d31d893a3a9ea4b4cd0e6471a15addfb6bd17db2cf385d74313e22351590ac80ecc2cd379ba384f4669240f864442c1c75b7cad6a17036bc65d4cd0b892cec7762834e313a92e22fdda46fbc79cb1668524807b89e05354bfd93013c6ad95b996d2bcdeef4a092c5acbd74442c4a5951ce49f32d92ddcd37e52eeba87a6b3c740e4269f9c0e66451d32a4bc86380225b0b35d3de062cbeee0e3911ed6f2b39d55c6095f0e39f4e370743545d76543ff27f1b4b8357ff9dcbbcdcfb613fb94f5d1da6a11bc35ce4ca8c77ad806331fc9c4271a026c8078e7e82703267f86ea036717daa3842a3650b381766b26f61f081d3fdbf78c778349221b8743baa3483d5abf3dfb255ea18db129321bbcb00acd0fb039a4e784c84962e055d65478007133109a5a734ab379809f6b5dfc6c0a52341fb3fbd6365920d327243da50e787c619c6c946dcebc96f2e6b5dba04dfb03ce95f884caa5223cfe24385f87b3755920fa5f96d0fd871b12c84c7dc2e5382f9f78804af2f4eff97ebb0196dba0a3d6ac6f8cee972ac795c234f4f304a5f7cd7648aeef9eb2ecd4e64096155bc11801663b63ee9d2fbd72d8b70e12473a7c08c168c031f5f6480f00292f071d542c50cce01e1c0f42d3ec4660113322c6ec2b7436a9f0b9db40ea7802bbc2dea5d2305797a3b52c7bb254157c88c5c334a50549c1c595ec69cf1ab11dcc2becfaeb312625585dc0facaf65c381341844e5018cc820e266ec3e9031613ea1274af8445a1e3299098ea772792f74b1b61b43a6125688572a20a74bfb647362986df96b5212bfb6910ef0d3f77b5e201d0097f389aa30146531178c8dec80941fa24e8ad9f854c8590ff6228c51f04ce37ed15e6c92e80dda322ad870645894f19ba89335f6d2d47def15e13fc8701c5927af68b86bdc33d8bafa9a87ae3e3b1c856af2feacb3450cd5d2b932764ff366266082e63fc188805a35f3eff0495d58adf9bb15194499c60b6381fe31f344c718e8c86dd04b3ef1457d84eb1b8291a971dd0a40d708a1663befaab13fd3424b1f9cd5395b9c1d74c4a7b062dc8d1a576d72eeebc2fde91421849de768a335ab0c00567fa6595288d50d19edb3682f5886287c45c09eef917bed168a8531b4060fd8e5c69f47a9b9a70825c883a22ac8584417c0edff42d0e28d1d04c5b8cd9e38d44cbeed79f7f04e731c605bfa13133b076a53b3bc4d40434e7be1f972bb69a076e41ab6f6a4240f490f19b819a3113c9182708947a60530a566723949c1711ef1fe0e68bd6c0334070764b6f36b3483670cd8ee4cb69aa2f1e9855230ff99946d883031ca2c05ba4119428cf55955e36611aadc81fb37096dca67db93ead4893aec1a0622a1db6db524edcbd69f3f26399711415be6e53fa653369d3d165d99a86bfa83875f4365d968e1d857efd7c53cba7d0c053b268f0f975878c622efb2b9ea79f7fc140cf6a9c228445278396b400b7f4a6806b54b8871972c882e5bc5c686281d77f36167fa41bf425d3fac140e83a82c0f5a0404af60767b2061200d0dedddec214cc51d2f69eff796c4640f469f27cfdd1ae89a1dee23f4ca1b64d5c9f6cec7426416537ecf40788725fd7d48acd0931d0a27e9e17b1fb529b00169e5fec0376aae06d07dc97690f8807712777889522cbd8e0911a6eab7a1ac79aaeb402f69b415d892b556cfe162c55d968b715a10310b2dc8471e4d32ad36c52073257b13b9f9d280ff0477ff878eeaeca45566fe71b9942a5126a4e8d693b69f74e4f4e7ef81c3fade9a6fdc169c0993a7b349d87f9c6b62ad9beaf2ee2e4eb7d26afdc4ed79548779fdf05080feecde64bd722b82148c3d879133033c1e7156a25b7b6808f1b8b22744a619b17c6e263645054d25b443635fee8996a8580052c041e50c410e501fd1b19dca7598ceb7ae84a11212660a2fdb2eb8a699b4075f228e17a3a9b9521823719fcb6412dea035636906d781a1da0dbc27d74ff2b3a11d4d98dca4d3e6778dbedb9776acca56f30802dcdccaa7b944d2914b8417c2edc975e5a2f22322614ec8d95d2eb4923acbc8f43f11867cbcbe910f2fbe72552a2a7105ac184021a4b4567aae9c3ae8d379fa1916def0f88c6734200782d296591dd85b580fd52fc797751484791a90aa04726be4db088ab9f75a1863118f720566d27eeedac88016853aa12b8e742e5f2bc2ee6f35e924715cf56736129b00f973e89a8090968d6786eb319c48340a1ad202271605b8ec2d92136fff8c092124d94d8319cd9ce9986d633a30e90b934ee72e1100fa02a8ffe7447a5445b1b3ec2f0109a1d363efd2e8767000dee9546e41a2831ccb0c10ac7a36512f6043548b743e3397dfbd11f2efd2cc6e9cdbf1b6a135a84228549941bd575bc5e4899ab6aa6de3c9f56393fab2a8c4247a46547a26d220294218e2c21ab4cd8649caa19464f7c39f25aa422269ebd50ce658d62ab0d5d30bdd3a88b5f6b6987f8a3503eed0f7fdd817222afd068d2833f1d903e9b489d25f737c503203bb27207c5e2a7507e242c4884c28ce1ac9f6eaf0851c078517271a06c8b828d17c430a117b4ee5d32a873bb6d49c030f418a620516f6a12246c2baa03af1dbac468bb46dddf5212e6393435dd1107157517af5a1cd3bce2d91204f58d8b76e40a804ca93cce3c15b6d38437bab2c4475a3a6048359f734c141248ecaef60f6bd1ecd6ad265f6175ed0f9999744975316d77876fb242348b298967e4f06e67d99bc3706a24a56cd3d98e4f3ff237942d13ed30f7607479f793eaee1cdeaf491165e57d059c75f09b235410624916d946bb571c7c629e4c70c7bde433829be3eb623077bfacd43c69a01ee3b0d1a0d4c1f9359a4334ecce8f5a29349c0170054b35ac6d5a734f44dbf366386a61de38f32039db0dfda8d9f0a3d1317bb0ef35818717910f79761160450166af479df0afbb773ae4c3f79b864712ce5c76b7cea478abd654bf5f73a14f2486827443b4674e3ef8e9ef9b5fe2ac8d6867737e2b647bd689659a352d725362a87cb52c0b77ffdae8af59c331e9596d47f7872c8b5b2cfcba8bb11f37105a83fe609021645cb62845ccc90d3e78a0daed9dd5840e7039ab43cc9dec8ed3c24b5821804471440f6af40f726bea5c969ca9545dc398b5b014d96eecaf3f0e57785d96f12bc7c838b75adf6896fda8e4a695295f23aeb366151457999377b9eab782c876c2b09dc8e74ba64da9c5a4bcafa7cde4f0bd6b5fe717b504e4aecab8967296c168378b2edb2c260ba81133ceb33093dde001a24c8ca78f3e89f60d95a592bb1491ad508512d5a6aa4ab18a3c67565a699d3d255aeee8a0eebd38ab4aa8b83063d3aa7b61a09ddc6e9cc82f0f5ce12a474e4c8849efb10c103a6f03630cbdd1978bbeff17fb20b3c1b135976f5219a03e60e30ce695357b7fd5f7df553686bd3e5242ea4833a0a922748b35525f65b98981002a18f9c08c484d71c520550da4b60f53b1d471540bf4ae1b3b0bf2380eda69e5554461859e735e069d8f70204d49f9c8533912c36ee3848b06c46513c7563b086442f62f19341eddceaf5702106fb6e59e41588fb6db8c7565d7ce934613133ae2d85adfcccadf24608355d217b345889e6466ff0a6f2fbc25194a62ae89ed768136d2acba507119b554644652ca944785b1d6937038ed7fb244658bdd852646dfef922837042bd8dae8400092bbfa8d465d2fbb6a1ffdbc515495bb75db0e1f513ed16467828288add1c53ad08bd12d31245f8ce0c91a769bbb67e751c3b347fdcf11ac69dfd0203cf0723e93fa5a51cc263e3f48ad647dcd3be5a7582feef95c77f9ce302df5eaaf797b2b24be8205c87512c7f9d161e91ef2aba0e91f3ef49c676db850f56209b5bd736a11cbcaa128350d6ea8fa01135a01ffbeec7f037af54e50a1a595a7ea6487cffd430e8fb1c8826f24518d0468ebf440d3d1074955f64b7ad2511b20a55f9b372064ca7268f129eb02ce2757a3d885e730130472af1a7e95f1d6c2494f2e8806cbb48df184398861b9561f93c7d98dbe119bba3debeb5a9e3de27fd293fd3d6c201a5d59ec9fadfd8fd70e098c939aaf446cfe1b7a27ed04cd0ebf708ac596947cc4a62f6b37415ca16b2a1097709e6fcddea74b2b764db9b1ce37a0ff5cf45908e429bf4d4b2ad48d235a2155d6eda704103696523f693e908536fe84a8a621ce9630e91b59442b00529e383890b149ace3083598ec21d194c6764856d1b14d5bba0c3cbb9c68ed42b13e726f4f46dba51f89b194d65c14950979527b3df906ff62c45d9e373a04535a1d7a5620b99648d817851ba302467bcb35e277197a8f912bd7fb4946f7bfa2b5fe793a3eccd7ec8b57a5329a9e2fad20218a1c1e6413928b4ca158ba8aa29cc81ccf40de0e325d02257e43a5af42b3d70294cfb88508312adf22bd57a9cc257f928f24688a354d96ebd3c21a4768575bb9718fe75b1bb764953c12b9e94a478b12644a8a9f50acfc81f90f8381dbbfe8053080ddc6ee7c884b55a0f75916bed9521ccadcdf6e05f7e14ce4e83281c95ec112f32a9fdcc89925219884e27270a5eaa27959b33ba4d4b487e318db02c0bcfafb77c92f9eede187e2899f8502e4f63cc685a5c437d5903b8e8fe2f1af38ccef713d8b58f79ab7427c03455a7dc90ff6eabb4a68a7b217a98149b1773bb304db246b30c39400ca18c03333f3ef719205d4c2b07fc49055bd391f79bde7dd9a84af40d19e4507e1b34a4f5c21e8afd4d1fb05977733b498a4c54f323f8ce1b2bb435943170f7229f506d4e5fbeebc4e2d400d26fba9fccb4ddd516d94f2957efde01f275ae36407839a078dcb143ee3c36e6ca431ad37acb1d383b10b9f4f38e45c18c3bf2771d194b7b82919622fadb4b58d2b3de33a698a4c7842fb2ff9373579e25bd325b3bfbc355b8238d541d3c96977c20792046f72a07e4cc8dc7bbd910aba34dd715578079d9260117098941faaa6320877f42110812c19ac13914200e5c52951cb6fe466155497e049cd1d8f701367e6881ca4c217bb55d7f0aa5ac1226fd8f82bc123cdf8af2aaa9c0d9faee1e4b361e649a95ce88bf745c02794aca24f48b32dbe6b56c66aca9e4c7ae6770945f86755d3974e900c35ea20025dd41450e47a6c4da4eeb0db33c44dd491302a6c341475d5b2e6c96e2b8717ac479d6ed5ffbc2ef5250c5b84e99ef174585e8b2bbed27aebcc64aa61f1adf64fa203f65ee6214578c3a3d75a776bd6639d3ddcefeefd745f03839211f9ad1c8bf32199b763941b1a8975cbc658842e1535d9f8eb8ee5dc6df457389d688b09be9a7b875baedb7dc91d0b728212f1397d09c363da97ca4b59753da4fb3af42012d02ab5a5952ba9c2ce1e46dd85de9301565eae9dc5fec629f6d7a5f9086d52d8fc0c68e8a9d2ed05518f3c92ac52eb86c8cbfb4bb0e31aae6e2d40e4f9af52a862a2fdc9585131081fc3ad48ea3746a12ae204227b133e05350f76d2df4ff6e539a09f0946492617e1e9b2cc64019f73b42b5543d77f3a0a8222e2ed2fce2102961f07679585360ba48ab458a37a75fd8f60c61a6a6d50311e06a7627b67d330a29c25c81e778d434938d80292e79f93a00219ee327ccf6c15c4493efc97f527d3c16c534bc6cc50175e77172ebf02594450b5b263281e0668eb8288ef6bc6edc3fe33c18f9dd9d1b6eb37a9d820e7e970d8b3ab14fc9c6443a9f0e2d1dc1366d8796f9cd95ef6ea94757542e166d0abe1e53124b8f6d397bbfa247e72708052e03427d3eb7de042cdcf952715325fbc2257a796b96cc18b2e409557d00ce6efdbabe32915e86cc4ec852da2a648552c2d376a831dc4140cee834fd517f706ee8590412e9b1903708b5a4bbb38f496e9a32aec67f9d041c87b29596eb3d047d444b614d011826b4ab68401c6a28c94748d43e1504673c5f60bcb7d2638d8648e5a8307948c26af755bfbb6b74624acbf10b768a22a1daa9797ebd22a631c208d95f5cba6b7227ae5a49034e28ba043a0687002b7e6ade9092c0adf7c5a40b342fd6d411ece26855422743aafe83fe904997a3df5e19070b75b29c0ca46779b0eef24c670621036e8cca9fcf28cdc209dbdc26c86b733098456506a805c882b80cc5b99c5141d43679e78dcda18e99f69a503de7e928d80e6baeb284142bb09076c3d45a5446978b1f67ebc639e284b00b5e71f96c08843e655c54befe0afd1998359145673defc0a85afd1e4f9813e013bf902133ef13a20e5dee8c76d1001b0f023d2efaf93a153263a70a8c4cb9c2d503984cf81a0abbe8f3f8c7f085f1a5b26c7de6888e11b6fd43a4488aa6272c65d6e90de9706684607ce1f5334051f7161a863c808d8556e6899d95905462cccd887e0900cc7a9b6811027e7d88556319462f4dfb73000462bdb9a86899ab0f8a33c711296370c85d0fd90c093039406cb361b3cac79b8d662bae7d925b1dd0e5cc94351e914671f79c70a3cb4fce7006cf76972e73d0d17ea342267908f709e7bb740104286350958da5de82c2d026d4f2d6506e8b27a7fb6c7dac927ef821d618f28b3852ea11fcef334b500eb4d16797dad9453740e4c5d20d12cec9223c878e1f2a8fb2e7fa82953059ee4d17261aa8941693d2152ed70246bf7fbffa0224737d6054cabaeecbcd7bea78ca4f4f139f97bf6340a4e705fe04a9e3bc5f21389c0b2690469276df338e5144010d3c0707dbbdaba55ddbe9b496fd6bda9f9773f254c076aa641708126056e03192ee3e86fa976173ac41c66c037d29a5ffaae0ff6658e898759b8e814cd699dccd381095d8dfaba91e341f64809b27f62e563edb44e8de0dfab6c405a9e4a33614688a33fd84fd724d18e5baa19b42850c41279ca60007ff6c5aa408f80ec6e60326549f90b33fcda294fd2dfdf82c8bbdfe25e805bd7d3482db01974d1e2cb6ab1d3d4481c387317f2c2a306969250424586a6569e6641deab8a4140b727e5260430b605188b38293eb549ef07b09bcf9b30623daa2429c19bec423abed3967ca5e27756c119865dd54d9c7218e781adc5f832aaca414d9a904d3db50cb87d03362fb5c5252c02af10db35a5663573a11eb50c1db7d3100c15e8d6816c1cce50a475f70734c225c90807f8368871b21b7312ce2ed11f0d7ce3d08495eecad19ae042a74a566884804af2155a81815ab64ba37ba3ccfe8d01dc7d02a5efc85faa7435e554fcfaaf8ba1c97fdf6c73d9c368bb3e17607940e0467b04f415688bb94fe790cefad47af578c4572fee0a05a0248c5de77e9af243f3ec7094f5a8025e7fbb01beac3ac6d64415938cf6f0cc1a79679336df4b952ea1a054715b703e91a6013f7e0d3f2e3a616ac38ad9a55d6e8ced2119b2fd9b90218d10a649f41e2485505214d52f2a0746b9019dea1728ddc02dad8848d565c8721366547f3bea7939a38856d19f9b45de6e8375284c2fa2dd568785a29501050a2352358c4c294851b0f9d0ae2a9d96dcfabccb57d81bfa62ca52fb64a033325db57fb6cc5e4fb0b6916750b74e7261be7df342a5e818cad9b31aa1b79791fb74bfe534cedeff57d446dad8eacf9455bf3065ab78bbce5d48f3d9620c95760693ed1a67d6fa3ed72bbccb575a9fa2a572fa293797717fe3d103e7956ee392aef5cc943446c6a11532fc26f006238058358b03382e4c97585bfeaf2348b8c027b25ca30a008938a0a5a39e70912ce135e5f0a88f3ddbddf85c4449a58e949f4cc73e18054a9ab85eddb5c7870a8f42813a5fa765503509ab0bca65571bf8a846fb1e3a93b6a99f8c42a5a2d87dc37fef13056dbe696f271cbacbd983a90faa2534c999a9f9d5af8ee1ac7c2f063b29980389887dfb5bf717c637f430c8a0d362cfd33e3e97451e3ad8f5bae0e8f8397fe693914fb1d6862982150a106e8beb793c539e8a71d2832ce0542c61d66f94bd6b2f281b26086f4f891099848f16c54e33454e7a061ff4d120b973c6b0ceb09427826801bad7c02251e26068d32a34f2a5ae7826f8c2e8bb062d759126ddb558ace2ef59a76f5f32b3b1282f1447d328eaa1b56990f1c08ced6a8ff1431a5c3584139f1014f3165db3f0090a9c15849f292b2beabe6e150d0ea399a4506406fac3b92a2a112a9e04bd3b5a3e0dbe77e5b00f833ae6e586aded08f1f119841c8c15f73d2c37764f865bbdb49bb056c330077248dbe93ae960f39a8b585fb42b5a600b4e1ac1336ca4e689f220b5db260d2af402cacf11c57e3c659dc998eaeef491248a0734fca25d34d6e434b6273e3f1e8936b9baa08f12ae429202ed138aa29fcfd9750ee42b3fcbab7ae2a7f2c8c77e4c9bf781d560d7df4d63d03b134d9c34b690d58eb25bf3d2ac404571ccd41dc26a8ab05dc89e9aa888baf136c16a6d3f84336893c5da2d8c1e05ec81d80528fb0b69ffd24319b91a6ad02482a2e547e56e2ceb1d6ebbc509ef14da84df7dd400d816e69a525c658ba5eb74e14633c53ab0799f95c38bab0ddd5380b19524faffbcf9b98166ed4f457704d3685a07dd128c56a63196081dd559c67144211fb45bec7c5a4c4d22bc07b02d9556e743cce5150f179a96cd9fa63c4f480aeadd47eceda56625de6ee1e238866514c330faee0f9fd547dc2c6af9ec421ee39ed277b40efa99d4d2ba790747ce85c898b33f116713924ee496758dab1fded2e729a8cf7d296c98c614b3db5172b0ec6a0c7a6980e2d697714fe77c3e1cf985ea82efa0d6ab6e8d773731b29dabf3fa076a190c40424b1397282bde7eabc5d329941559e2ca0fed404cc7ed5c17295345623a90b4ace63a1742f78a2638e8bcc92e8dbbc8cd25f94529f929e16b7b3cd17d6840c7366c5413d0ff08459f4d9247b127c48be78c41e3e4b59b105eaaf6d5a160a2e8a4176d2e38b6190b572fe3bdae903aebeefe0f8d03255d0ce8f26d7e97f0664124df079b0c4bf327a210fffbd1b92d343985371af8e1b221c832e3e48aaf444e14ee7a3c83877d37fc03e7410e86bb1ef2ccc624de0d513a0f794dd7cad2a8ddd579f32dda782ec3f42f47873da6b69d33c3d14e2559171b68f7a47b70677a94296fa27a0532f2db7ac65c9c1fd2d1c4ac490dcc402bccd82e180e7f55144eae5a335bb9e5a12e3e57c95fe1d294786183c1b2a7dcffe53021889ffae33feda0b14cdf0c33b54718e498a011eadf3153c01d0592351898004ea13d9650a5bac65eeed5156699d5884b6704258aada53c0d2216ada0643397f55bb3ed4fb6ff70f097226e6091202b93c66ff6869841d0a545707fe73475871d721a6409f68fe76527168d0674b02e71c22e90b36e5f0a2783e014c3e3baf4934dcc7b9702b961b1d3a60403a680364bf9f3378e356cfbc790b5d8ee5fc26bb13e0e747c6255f1fb23c0d017ef77913d5d59700bf875163912abdf0d6c25ce3d181ab57e4546225aa8bf9e968d19511131c6cda2551bd6cccc336a05974c2ff211d3b2f68a62291d1a07465b8b9abc1e4c16250412b278680d29b5a03df52f735ec2a7d1c7560e456f1de051e921c2d2eaf99a857bb6bc63996531a7d3ad81defeeded35d240df67e3f006b1623b6c7e716bd9a0ae376f3349e5276f31bf797a206e32bcf9ded1dc0ffcfed26c4c215fedba028eb955ce968dd774b853943827bf15517bf63be227407530fd1f99b4e02aae88eddca5a24272dac0247247bf62bd1bb63034906924f7f43247b675699d2618e721787a0bfee6c9c43a075952cf0ecbf18051aaf2659efcef0f79afe96fabb7b4fefe49b96d816214ad9667fdeac824f8b1a87325a4d397d187df185f02187cb540e1d9c648a270cff58d146d415ea9b01584023c8f912a92ea7477be5bbbd3fdf3d58f0f6fba5453dfa0033725347091ef2051c47a3ffac05a6030ffd49e88195259b363cf7bc695b697ff8702f7f12d2e2c58398e4833c8dd6f8cac5e2f2a0245509a1f03fc40ea99fa9fd0b923dedf4110d24ec550251e0c5445bf7b6175562612fdd71d9fecfb3509c2393ff93f50247965c2eede11ad3db5af1544fa1bff96fefe094efefe3e351d8d453ecc220edb7109eedb5e609eba708eb9331b03efadb19f63b3fb7b87822d89d96ca7b48530cc02341e7720399718f7f04972fbcc72ee9f2d628cef8d8b036ee7c7a562f61bee49e7bebbae213d8e32652519ac19c178407f54d28f7e9bb11c3defcef4a894b8171c65774c3e88de13c4f3f06b8a1568b8a92a00e1afa2dc9542885e5a5c5850a0aa9aa3d71a344df61fbbc10a3eb0b29b1188ca1b0c4c006fd4fa9bd601402aaf560efaed5071e9c1fbf047003b50a95513ffc82938877ad6ec357bc695d2730f2de4236b137385c3a0835aecda84d88dc8b3fb09b41c26f4410b2869272c8bfa63293ee28d8fe3efb8946d4bcc7114240b90e06e8118d039756c18d34425ed0e96112bdb613030eee847774db887d08d0e4e40376b1aeaa5c48793a9b0ed62d2b0fd5d19f1e6e3edad0e73ab56d8d407460a1e58eae805f27fdda2316707a5f4a49e2762474bd9d8ddd905f75ccb547bef6cddca604e749f1b79ed73e368d43299413ca87bafe704290b8a52b9852b3beca388d7fc6fc0d59b4915314abb0e4d3dce449bfb56444e00cbee0d6d73ccaf9843c54a94e0e53fd35b42fe9016dff1284ec2396125828987cd42f11bc7647b3fc3857bff0701b480cf61cd594748ca86772235d02413acae4343eec705bfa9da1c488b7c22a84123c66435582cdf42987fd96877d28a8f0bdb0392a626e8555856c92634b34f04955afd4498bec2438fa1f6661c34a352b6c6b28a299a8e61b159bb12d553169b7c559a113a2f4cb4003d1ae0eea6f39373245c674e41d2b1d5dcb0a6a84d4dc814f67cfca6b64dd0d5ed90f3edeca6938ef78a743f00a4c2b24cd15942fec37e4123fd6c5edac5dec27c87bb16ed8761448e8e4dae80bed933870a3b4595b36541e5ba88da35ea7cdea2d8c82d045bbaee6681fea592b12a17ba18a08043e35c3d3c50ba090ef3d4daaa433f9541f90118b292695d199177ae6a3b6742beae39d535f00d072d993bc79fd6f1b33e7a80da7fbece3bed93d82364edf9521765b1e57ad4e9277d223b978bf59057f0e42aeaa75d69a559172b697ef86c95920fc89799b5f3acf3f16d2cafd212ac9bf8d0016300bff48fcf50115950b600b38d16f90c07230a3ce8238b49e5be954a3ea0caad09916c518633e5e2af1f5777ec42e6fda81cf8201327c265dd18c24e79b54dd29ad6bd936dcde4589e28463bec07c8f07d72e2cb09d37e8115eea6e76886c64ef84c4289abed2f96ba80bdcff4619c1b2a21f8c715b131347f3dd80e17b02123ec03f9521cab4067aaef6b1e02b1063354ca30f71fb2a3b1bd6e40077bea4d868c6da7bf4cee77c7e0394ec181fa0c6dcb5c427af0badd077bac8424f58cf2b669dde1b266ec126f791a39510d8d76b55e4c4c9d6f0fe6515a86941f018acee0f44f7b5b1782b9ae41fc95c61a25932253b5ceb1d9a52ba16cf52bd44bd6846da837fdb4346e3dfb541c5fd18b6a31951924b817597b67953911d4d380b1496f80853e964f8d6709e31c9685ac95253dc2b519a650301132f56b3b861d74bfe84e5727258a26ccb3616763965e8cd6d139ff972a22d788d5cab447afb3c8a0c43b18bef4e4b66e7115f8775b4b4e85ff5e1074074b9670f113f17c90960330ae30321eb27420f8b44fa4cd7c406fc6018c9c6aa83f677a9c8e67c0f0a7607ff660e9581a12d507ed65fcecee38f3f435769eadd09fb551b2f651d3715b499611f80a16e2dc5dfc98c1768311af836927ca406d96397b0bd67026dc51a1ecefec9f4d1a21d351aca6895b5e9cc7bf1d92c384e58b9c4cde19796bbbdf63dc13993a0d6491772e73034791090454b3f5c780d51c8c21ba30ce104077ffdba6497408898552341553f519976c8683784d3bcbdaa73258b2d152ca739c4f106e1d253b3a2ed561b97d7dfc3a968bf64b414e74515b1f2039e618911218286567bdb649ac7781aecd0b23431b9be723d9ac85fe9acbd4968727d083113e0cba0098d50cc5ca8d4f295edc05a4d33d29d5c20cd83a9d3aa44794505fe253045ca0012d3bcccd12c116a755aed92854710ca9fd04e161fe650b194ac9f04b13911fb034d722966b2c5ba5ebbffe2ac1a48ed209c6492c5910bfdedd39dace7c38fcbb5794eb9ed0035cd8818d54ed42d49b56aef6e0c76dd14dcca3f44f524d86681d3bceb73035a2603381abb7b4ddd98c21efb22a8c484a417d65399d5e1cd1cd1f136a8fef165acac349b0859aab9c940463dd1ee1f2a67357afd7d772b2800d0252f5c6d01897444c2348b808a2a3bb7cf53bcb390677121a3c9f472407cf80011409527037919e22b6c7e8289144e39cc4a2cbe8a76eb8e6176952d5b86b32eb92acacd925b47d93171c8f4b877897813c93aa18a361486364a6c93d9a207f8a3162ae4541953ab796120854610347de6f28387c4d40ceb9a020b997b311b9b20fa73810a018e1feaff6d5d8e5020351234918b51ab9e51c032d38487db858db77ada7d3b15dcd456a5e5d059802b78de80c00cb61bd8c67e633e88754f2ddb937c2349a41a4e5df974d64dec5d2ddbea3d38ab5419fc267c13b029f512393b9684e9816730a25cee5f8c674f6a702d21bb0ad1bdff6210611f9e1576c776decc24367ef0798f046dc25eef4c1155330c4ce0b0cdf140ef262ec80fbeee06bb2864def3f85843728ea7b93d26f6d67ef706c481cac0bacf3a8f2c159f40ec924d726d55bba37e4fad5a05526d9958430b44b026ea0468891a898de6776945b7d964641e54761429f546a4e722472372c7f6a393b1c9be38a2956154325cc04c3cdfb4b9f534fee11f48b75ff4abeb1785f8249a068b83a21157ba04b84dac1847150a59ff07b00b5a15678ec874606ae015881dce5d166d32bb0107b41515b3e04f9ec7e3e61cc228c0571d5fa859fb835f12c9254b7446f91f7933d367d2a3f079aee8cd18c08840c73fed9ea4223340e4dad9569493f6aa2aa7251c4cc29eae3a984bc5c3f694cd8594d3894b2f7b9017e0a8e056ca8c42e1c75a910a36ad6725e1fcf142d9a447902ddf73b5b0801b6ff9e2c0d3192d914dfb170e567fe76375ef82e9315216001ddfae5d06186bb0c699f703c6fbb3a1a8296d7e6063915e71a8b632ea5f81f0a671922cb63f977c4f97dce5b5b24ca73c8ceb5d70fe9de86853eb62c4a72150be02407e6f091f00cde4ef0b5e59449066a020a785148ba4eaf13c0ea55257b2c6e66ba025204c646e50b70db90ef0638287689cd48a690663c9ab9d46fb09eea962a06d1cfa7254b1a64171869ae02a1163e821aace2e3ea0df379cfd65174ac20197333a8925a32e7dfc65f12aea7c7aa3aaa5883a0962bb8bace184ef3b6efc7d90c742d22b5bbc68f05658b1c35dcc49b0bb153d5144b7706efdeec85947ed8fbb711219c2e5291483aca3b7561e622be24a4d0da642730b0d98742488ce37c98e51a16669098fbd740e4442ca6d18302e9b9734527723394ffada8731d517d852e0dbfe43e4ee6584b6da9510e89fab793333372676befb639322e3fec39cd713fdc48e371b4bdc460b8bb76a06e4ac38d4739a369ded16a38c36511a915d8d5020813e3dd873db8d5e3551f92723ff1d39a35d6beff96fe7a1402642eb0db33ac835d9ca2068866e53d42e55ffcaad2648faf7bc8bf5dbc40d2c831fa4a2085d0a0402f2929b23f1b26a5b4806080a907f9f7c0102f7d18e5b0417418612eac4c99867ead3c986ca657da30ac7882c71cc553459cc6e32e1cb16bb05c24341ad1f905853b955c7fece544b5d0db53b004793f7259097db28eeb59701552fe5984a2d678f6591093dfc56acb9bffea70c5bf599f6a824b81abb97695993233489b83c1e42616971f01b3900b850f2e9dc321e702f3de66cd4aea80d7989af0dcd0f91a266c0a939bce0601ee867af0676098e8318f77fad6d0dc50593e989b60e92eafdb1b2135ce3c609f8dd262e917d72ccb33489a6cdbdce6ca824a693a68d7920fd5c89d94d637b2d1108de48b46e348454748d7349695b4bfc257cd3f736eb1c15c759abd5cb5c50153271fa6c3b0e9eec46519df7ff5ff85b95d3126cd503a6bf26ead2222f6fdb2b9c2afd0afd3e169d37bc841afd146e26753171ac295509e5a25f836f54abda64d18a0e10f8cdda6aed1556678c9717af2aa0c238f8d826e10ccd2b1bba87a454b2c744a86d000055515cd8bad38144de80cee3709af6fefef2f25f4603fa519f5436b6ca7d73ab63afd6ab14f73170a6b55fabe1c936a82edc363f0b5056b415a15520ee0593fd6390fc088963d490bd96bc163256f568b5563f2b24880c7f0e54515680c65503882a8923ac82e0a3d08d6bdab5dc9f530d9db7cf9b4cbdddb5bd76492644ab9c0bdc3dd8b257be09c6227423f90aa47ccd49cb41037a5d35cfcea81d2006b566513af326331b30a05d069c94f7985ce30b50dcf81ae0f1241950165e5d6c269327b1ed31c58792ed2ae246934ec861089590a7ead0df7e3214aedda9cd49876378ec6589dbb15ee2eb4f3acf9c257992f84f9896f53baae254144ea86a526bf0a6c15cb20be74a58ac100da213d54119584c2f4eaaa72a64e8ede251bbf1a654fb91c567312101ed04e831744200e6789850593105b401fd09adaed5984e6811387a9d5af42299de257d08d192e03824ddb8491bef3d456aac282bf3653dadb89b4dceac2beb7f98fb4e9b9b551b56e03e1fa818d11e613d0a1a9fbad2ec6b746c34a40ec08f95d79045f49804cee130d346f76cdefc8714efa1616667b1a469bc0a9a65ae67af4663e60f68cb66369ad37aa1b69cc68491cf046ad10aefbec0576573e76978ac33e5ea0ce92369afabfaab0b468ac1062c7d76b808f3124b683243033750cead24ca3102f8c76cb140f901b936e66d56cbf0daf2dc75fdfdbb6d16b67e4c1433c8c08793f14d1596c87d7a596dcfa5b2c27167940a77905b03468532d98a91ebcced6eb86da2fb2dffe984ac440e7f5f1dbb7ce573bb68bfa8e5e3676af0a68c2dff3bbbbbf7545ee33bfce5bd8254eb43661c05bd469ebe1f77121bbfa998477daff59798ac6b04bf0d523e1bf93a747900fa886670cae46a3fbaa479ccdcdd91b4eaa515d2a1e1033e5495f86805f815956f57264c362af635bc428f1a54d9811cb06e86fa83437463174ca75b9eff69e045eac9aae5aa601dd550c08edd86133c4893fb15e8bef99e057ca71a0f51f766e9e38f4bd88b14abc4402b6c97ca4dcf14838091e155b36f4716053da0d50700164df429397cd4d2cb1bc9688ca64555af3f36d10bc074e934db049f568736bde04e0d2690e377cacb9b5d08e83ec676fd37b10c9c3a41a7830666291f25055394c8b0d00d5ba3b0ec87ffff008419cbcff2bd1d444ee60123ede5c7e202a9dd96b4da17430d88c51eef5f319d04bbdf16f897a99370864323237936acec55aa7081083dcb99f3930ab0f45bba9bccdff65a1ad6882dda973c84254d25cd009c0b7caf48d8c18f4e2f268133787229395e34fe5703e0766a09dfcd9043ad26fc3d3fcd68eea3ee93e4b1f4fa18b168fe695b66f4baaced09c226a6da6b080e1fde6a600a9bd4e33f762cac9d41a59664ed1ec69c202efe9ec7b6f92857c27da975ab20031b5e7805c5390b790afdb5c3cbe72c978100fe6585c049c812522d221729aa8f19a74d4e6dd977e703f298e089afa8a36c0ca32c79d24413540764ad2e74b1e8b926b0314796441d5a3a741684d4187037eecdc543236193c0a010427ecea67661dc27870d58925b9defeaa8df4d5e795386d5cd7174a75cd6c72d25aab78d0072c0760340922fe688fc75b79eacc66c0c18271dea62fc2e4067eb8bc261119fab50b36d7630d1b543fd31f93fd4d18fbf79aa2d2273039f24366fd8552b8bcba4994a2f21f9ebc143bae080cc306fb917450341a98e1bb601bf8f15cf0fd30b06b9bb77f388cf3ec4233f0fb9154bb1d60d6d428aa2b0ebea7c11d4fabe2bcef303f7d340cdde68c42de5eae9227ef7bb9c77716c195cbd042ee11cc3f29f7f2e27f73b15201eb5d9ca5a712a0f5c97059fe722642fbacd5ec234261d58a9680dacd04e3cad93224c51ad98b04cc2d9a2f0b5e2b8a2a1e40db95b9f8ec4062a5b40fca9f4cc93994fd61980179843779ace153ad65e6643e10bd77484699c864e27816b0b357d66fbfeb8045eaaafa55da6b2999c4817844ad124129d33afdac72507776ce04518f9d2b5d662e10447a8cc9862bc434cc8034462d0c9973ab4105201a01218b54479cd98a0e861413e1e37b6659e6e813410d6527e8da5e80fb35d26dcd48c8cc7ef0725d9fb3e69a1ea8ab945f25c74b0bf4fe486f9402ba988f0d549306a35565be403f303aaf3b1d79ded19d9b9f6d72172887970f275faa2a01cfa94bd4ef38fb1639874e86db218c7f312e641c2b7292d8c4a613b2ad43f62eccb4453dfdc98c83a695a22fa389c2982cb80f4914fbe8b98db12212bf446e507dd376ab747a075838a719d0b1af36ade322b865a5308152204bfebf22883fbf26ff456cec68a3c7b21b4ce30799745abe3f878cd23f269fb4e92f2f18ac99e4d55a453307d2cb1fd1a5466bbb86aa0d3ce40035e12d18b7604fc626104cd9b5cf247da146f193aed546efe71b","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
