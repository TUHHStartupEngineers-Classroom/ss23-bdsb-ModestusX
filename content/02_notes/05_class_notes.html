<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"3aaf24c013b26d112611a07be425a3b45c7339b4f6d284f9a4adb51f0b72e775201f1d060e6fdb5d5ff137585992373792d8a353e3fcd1ff41f61b6b9fd26c76fbc4848fb9c6f1e59b80fa65f1ac7e9e26d17fed79aab6b2001203e5a58d4b06c94fc8d112bcb5f1deea510a51d853a3116b4db5e61b66eaa8902eb7a9b93c2cbf33b4bee97b84aeda66e08f800077af34042c816e0632ad946c8f1c09b0a8b171caddabd1271560521772f89514e43638f0456e80ba97930e8e8e9bc7818b1faf3aeb436fe8c9f4059c02c1bfe3d4916a92f10a43f05ffd1b3c7a5a44d92ea2867f88ddc1c6bad0e66c5ecadbc2e329f3163272c650d1062751a01ade0b0b4322c7245e25e5a6054c93bfd5c010c66d0e9ec3dda93d6842be23eefe39db633bdc0b7dc1a817d2e387427789bda80252d62a0afd370c6ba0201c6a5891db5b094f8b232d4547470e5a033966aaa9a8b66d8c7fb6d4137ecbdf66d4ab795b8cb6c8f4782bcfab5c21232a21738186a05109b9ad5dd881699d56f2a204ae1b41b29f63c6786089bd47c74174a5fd6b82f9c9fe083d14723254a9cbdc4e7b4eeea89fd3e35f062ebfdb11477f42e228c563d82804e9925833409dafdd6396f953f137b7677a778db73177848bad4051d7d5bd399a4b42ec4023e2878276b51e3a76b1943266950dd2c090e3a61be87fb07c4f51411ba54ae7d8e1b1afa87b3aae29534ea571d0f3d19acdb9905b553b8144625edf25018d8dca5063886e20b332532870ecf61c92f3cd06e55b59949228c85abf76561dc15001f1b7c22c39146340864818357e09682e94376ce844a838b6aba773fea2022995c58a82d868a9de790fa9907e402ac3972c00c84fcfd932cdb5893b147913dc0248878eeb2052e71437473791a93de2e252266a9829b0f01feb12fb0bd50eefc107abbef241144a0b02609ae35f484d04b0b93fd8456e8e0e36a2aabc47fb5973c50cec3e4f0ddc0d5b1ee3aa0101e78e2231ef1c2232f8eb16d3e030bb5cec98150481eb4c601c8a5776b3403175aadc45bcd3fe3463a045dedb13b97c04ce02c5d35c311edde8f102f3baf26dd08bc276a96d39c731575509c5dd9dfd6d8acb9c329329e041554a426ee93a8dae827bfa686274445662db44b1b13e0c6502ce67792f885e9668547f2fc1ccde3c5144948f054f4c59febe8ac041f339919468fce5c6741d115658e70845f4ca56c6f6484844a386c57c5dbf817044ed8f189cbdf8fde0bcd4d59b504b6b2bd8393746685b32f3f1ce321f43a3c22d6a6a7f642f21f4e0eb84cd113a334f8df9be18c25273f9f738bd545606b230e8e5eea86fdd2f5efd11316fd58c4339bb3f9705a8dd648291a0853ad1bd2be078ed93781eb1726d64e76f10c97075245d016c5437be9be1128336509ce2d65632562b7fa74a2a6ec7ac0c49331960ad1a27386d3faf36ac53300095ec17421af0b24b9adb11580f3d8b89ecad749a40a166f03a9114f5c472adc472cb4b0a3bc2c45c9e070a616941cdff2ebc5fca2cd24026db9fb59be5341929fc315fce5e02017e948d8fc3e8885aef77c5d3990d74c720d1bc84b89d9b74dfc29437f88f83a9e330fae50ee5cb901f3b2ae661c0361947851e72607d2e57c959747fa539088b21a86615a5f5af972c4d02b45d38a75719b4959b332181294cf3ea2f98ec784ab3472e323c6252e668a954b2bf882f614a7da129aa453d8949d8f12f1d5daabe29c93c0526070004a12eb9991fe9a6ec8e93ec3493404cc757b085bbb61dab5b42c2cf3cfd6a058f61279692feb771e96f94a75c3b2c1c7c93bfda4f044b524d09854a54afb1be67a1ea8ddedf2b03ef3e90e2fd57150dbea8097b828063df2d2f5a40ee5834c6dd31f2837ffb8a8a47d6d41b689ef6ffbf6ee2f1cc1d516b61f94891e9360f92d798bab4d7c169728c95607fc1c74dc500828b10044f8214a5fabb870cb5a56477c456efc44a9ba9f5fde6905fe8a787230faeced071edee6786edfccdaece86f63cecde16f2c6b35716d40b851db21f183aad60b47584d2da6c9369e5fdb7900bb353c642d860d30a344f1ec996a07155603b9a244b06fc527c706e8a7c36cf33522f5b8469ddfb672369dcff839dbf334c40c62fbdc26a8da75dd53b0c7c75377dee7539e296fefce9a4c320a47c46dbba579f03544b9ea7dedafb4c76af3c073a10f73cad4ae164701b3465a3b8d44ab80d3d254f96e32f7b865399bc7b6d8c8f3194fd54dcd9168c233b544764a924f56f5ed752a97a4b1dd805e407ea80fb6e3ed60e63567dd1fd72feb629ac724e67d564b2f7e5b4536a891b26d3b3600b1f29bb0bec39caea41a515dfb0f20e60b8a7975cc903059e2e5b6e486d1f38c52642c6bf4b038079871eb73c1aeca34befca89cd38d40443575d14657ba3ab74c108ca240541489b5acfe7f0de70caa7b3c3ce5284cc7fad1192f11f23c3b8b7f9f65c0205e57a10d4ee360645fc9d066c78cbd480e500cec72fffa5b1acd7d7fa7071acf4272d3cd871e750f848524f8da8543f4fcd7416755d21b8139cf0a75b8c25b341d86e0e590435cf92a2ed1cec4064fcdcefec998f9a1dc6c731f286382f0982834c9ca3539abeae4e8d3bd865580f076ce0510c9ebec63654c4bb29f572736b181bcd584484d1f94372efa1b80cb616a8a2071e0546743589db8949cb88a2840c16ae71aa54d12cfe1d48d93830702e4371a342697c33cadc7f159ebf0b4509b12a243b93f78925929379665592c58026328e51dd903363f0bf376872cf11a08ccbeabac11c4c5e3767d5092fad44871f2493b790242c519dc479adfbba999abd84fc6c052dfdfb7bd6f436e7c499386d077dab4debc8901de087f3ca3ad2702fdc79e8cfeec097a8e5d9e552bd194feb154ddd18dd668dda71349df297f51b5a98a8a2e3b641ea428fb8fcf7f6fc41456fcc1c9504a2f04d6058b45f813fa51e9a392c8c57a41413c67257e7e836f551cbcb166ee7fa2e86fea6f24de804b7f97a401604a4c3d6f7eeecc90d9ca8635a23c6944f1222d5db4085e7fd46e33af5a237972343f5d0b8b1bada45122eea9db2227894010ec684fbe9c159f61b4801a39fe2a035f69a8cc60d0f03d84005f80804f610ac1e95dfc1268e31425eba4ece469ff9321f2a6ae0a0bbafbe86488972ee2a403f2a386f158aaf42027955894eea623d138e64918b35c931f6db3621119b15fc39b31ffbe798bc94691845010ceafb2d36d621afae36a748a8a34d80d63d1c2ef008ae61f40a222ca016ca188ea95f4e5ae0d87ec542bb69e929e94e2dd6b0ff0a01fec14ece66741ccd6f34cd4aa2da9757efe686898f7df74e4935f539e8a791977a8b413fd8592fa950f2466433504ffc96ee17eb9cc3485dc994c6ee055064065fd8738f0039570a4de198ae4a1e249d97150ab93a8577b157c8a42bcb9e0fa6b3e7394cbd52d386a63c5c183bcf3943772627ccef7adb307ef31a603971f3e7129ebcbc2fb5edc8987f459e724452c8a85cd15378f5b5ee71739756db65b40747c6172c9140f4f8fe0b2f144df856a7229a091d0f14846732feef44bb7de7c08d4f89ebd5e8ecb864c8f8640f70a658eaa8bb6bab76af134f53fbabe7378c9569881fa3e093435283c1f5da5723e5fe5bb57f475e1b3ddc9a51be6dc38f3d3ed73b45098b907f8fd22f6f493266aab50d9695ade0ff9d6d27af613d03271dbafd8b7fdaf60868103fa8068fca6f57c1a3ca3488a10b3a1537330cb386fe7a48916040b26bced829b971acdbd3f06d22ed32f24d47a6481c31e49970d5221678b528ce27dcf0f9b8dd7d6e433bc427c3afae7e612b0ea853465898b7f76ec6a7d62dd3f3d3a4b4c494746722cc9bf9eb94732a4688dccbd4353e3c6ebb82176023f2ffbbe0ea7a59bb16bcf485e0b802f9bc34093783eb238d0921acfde3ab7a38c7a179932f4d49e71759a1668a56492a3e9f2003e8f89f4bc72713ee70524ab663940032566e9f04b5402c0346a111ca826dde67b706fedca8b0a597bd6adc574cb6ac6361783aa3322132b427588102a0052efa80c88f838cb0a8e50656fe112e7bf072ba6f27b909f67b02498b666f401387dbfe573e9612727161cafec1be5c104f89099fc3db9988429d9dd9d38921217a0b7aeb04b4201f0a4c423ae7956f3a26871d004c555e8939eff0c2f49c74407557852ccede2e0e08d4e5193f2598609edf1709b28765af3bf9450d49ee30692ffb6e86b1f4f986211c1b872eed7f81fd2442fae58684081fa37ac9c88b667e47d3bd4c46ae50eb19c22d7b1dd1dcad9050e6f307da7ec7b79d8f612aba62ee4d71137d416332f5bac1d47e4cf733875a44261e1415f5882a2065f05812d37c0b566475a4022f3dfe8c8640c174f0f483ba91e9ca02867aca7b212f1e663a67a968bdbe9af476d7541423803211d37baca4fa266e29148d4f9d9abf41a3af9c63ba4f8bce85fdeafad4d8c5263c822b2523988c1a43c9268786a184ffcd7a0cd29de2a4b31ea83d8189ed738a4be45c3d9d3aac45d385b130ce7b6f1844ee17428e7406dc1480a781e620b03b8c89cbc4af745c4f3053a6062b6ced7f88a69979f94e0570adbfda99b4d675c2c98873f4f3b632ae63198dc2b29332ee36f47d1cff13001ba7634c02637766de29848799c8b8fdd920058ec7206e9ede8141e39a0f443245bdbecce5635d5a4d2bdeb2b5c8dbedc415860e3460f00abff92393bf6ea9b0a64ca48ffe2347420c6e1677516161fceea5b8204d56d65350b504f3250b5af8eb3e54992636ee34e83c899fcca209a825a326eb074d96611a22d32a56bf3a269c98a09a2eb01cf83294f91052f371c5e7f2ede17b2aacfab3de1cf1c3486a798bda7afe2376e5c2d17db716aeb3d79422fe9b7c04ff88cdf92accad029bf62aeaaba53e58a08d1f6a35c24208b734ca735a15ebd757d872aa8ad05a202097727ff9e3948ede63080d354185b312804ea68cada529f0997a1c6273e12ab48e25e0b5fe21b1ce97a0985a2a48374ef540a4d30bdedcf616789c58c6b88bd71eb1035ba0e23a99fe9eafb8fcfcaa2de5026bf57e39bacaa6a558336cf256a234921ece146bd2accb5ad7fcd1a253e924a893ac30f336f1a3fe013582d18f6382d6a8046e5d774bb805a9e2f2e15e6a70244f94e7ca01c5ebeca9f5404d22cc5a1e29343b26092d2e48ba205ec3247988e1e2b87bff9c810646a1cc73856d318d31c552eaaf09f53e05095d90919c2b6abdeb0b95c80914cca3c6e2cf413e9336d47a169633bb2e2918cc989c11cc9eaee017b91927ba908e1b24da85626e51ce96f9cf00422126d4258f231017913c9527ba539556999e3b1f7a55a37c50072b2bf10bc87993f3f709f843bf0d8317b4eee4b9c2b90430b10fe313051ca90e375bdcbb840ee6efefb875b977639fd5d5a6905086cc0e3fe0f73670c1e2dc331ab76d84176651a4d2f678609f953ed09e235c3e72cece28e2c8c248fea9364671c69229c552600cb3351fa6e1d4755efe97d1d3716bc6cd5d79192dd7f758aa06fb4b7ee23685c57ab77e6f8a9c9ab13fd462797a9512b282b729795a016905e6acfd441919073a3af449da0497f2128d3bb4bca71a11d171fcd3f0305f399d0780cd0a0fa4a2e7a6b988c05473fe7a59c49530771efa979a41dd39a247a8178522e19d3518837de158903483458c5dc26dd5e96becbc1d5922b1e763460e555f54a5c23c74e30799645e86c0550c56f2adddd3b4e6cfb891b602f102b683f546ae61a6adc6ec82df3fc5cb9e972286cf34447c32a1186da6f02c36acbdcc3b2a93ddffa517bb272fba3f26d2b23b2da67cc85c52899f208b3ef6ff3a64eb939ae81e608214cb900e64936e35e0a1cba0e194c54db62da48f25f7bbeaf5c6adfd7707dc141fdb3d374143fc40a924e7b49300760c8035a0b3e719943992782a9edbd5dc789e935746672984b4c98fb186aaa9adf29f21d255a94431aab8f55bc75e103597de27f4d68d189aa0362b6543c936b79860f6c19c51394686b89491431ad23af488944327fd2153d10723ed17ef2f2315032e956c238f2af7e060bc19d8bac296939c7a9b6f0c1502ea902163fbe22a64391d5c346e01ac97f84d30013e1287308149fd41458f3cdf85be73ea1b17f8b0f8d3aa9a9dc862a277e7cdd6847a2c353da547e366dc3b622ee962bb4a4a54b6f49916dd7165d36d5c73ff9fc3657353fdfb5aaf2b1c91adc339f0f88cc6ff3cc07742bf9b5b7572f1ab0413508e58c8c6bf7e868745f1f95eacc0a4f44daa6eb004294186c73b479d0ed623e6f527dd5b1d442db0a4f1e3acc5f6e3c8bdfc7b9532967d6ec8238b16ad31db59e80be51bc2dfc1bbf10f8fe5ba5d7bd708b9a926089843e89ceaf3b0cb0584d339ac7e2fe1325f5adf128f5af53183324e9ade708a7662c629731553e7005238b98992b8093914ad5871eb405eac0a5d6f12034d8bb386776c9b335a6e6caca03f44abf09286f32af16e591962e61ab8997ebd8fafd1cbbc42b44070b0f4af8d0b65c58d4ec7d8d976c0618c2c3020d3f62f08b70c4ec2a16592a84bdc0dc03e9b9fb6edb179868182972187a5f8968bd678760d0fe7e70c430e7e1619dfb04e24efa210a4e7bdb821f057d4eefee2d55d909b8c42db455766be6401175e4d4a6a3e4f454d921491288710a5cc3213f07a19946d21faa6d6f1312cbc2939904f8ceb413f475c60e7f62c1a52f7e1106e015a4c139be218e75bb429bb71b41bde1c8f813b7bab9e6d17dd8ddaff3645e9dd5f7943791b1d8638a99f14923d2be1096fa06b9798a92b594c2dab609b42385f9534905a10ea86104123eb52dc91bda3ceefc634b5b8de3219115238747c7fd67a87afac1bbbf9d236cd586ac26d58eb45c5dfbb3655351fecba78499ddbc200077323b6df456d5c974042551b3fa699ed1d914207fccf4d11d505dc3f07f5344651e1775995542f6aad07d5c9e6fa2c71f0c92d7058007effec58c3b35b730aa1ab98bf543082fe6bcd47889042cfbc0415081101dffe334009c5d05f6fd5566a4f75d35847881fd0438abde9dca586f15aef96f9b98cd1d168ed98002b0516631345415f4cec1a30825ac2e0db327871a6e4ca1e45f403f936fa25ec990d9d0e3931a0b0e98eb8f5a43839b0e8221f343c9796636fec68ce8f66c9343316e138f0ec194a994d26e15b7949e792672288922061a1c8ebe7afe478bcd4fef3af2baab214acfde10c80bd13963d41d9cfd257a3d8e19614108b3486e396e352123d9988241f8487e14f57b62b5d4c91501f1aa083b6b4d16a0d390a467bed31e1a5ed5ac497e0434dc4d01d5329878f8bcbe744fe99b8509e0fc81e9c2b1a9e5eaa0af3b4b7fe285ac10440f220d89f16d1f653189a54ce14ed55bc3e1cf4df432adcc1d08a5ca869803bce4620019e89ffb22f05ab30756976c60252cacedc702efe42aec22db4f05fb7bcec39235a6d3a78764b23393341b4617c975b371b3d106461aa63f84b70600b7be59bc0664a9164bbddf544b1c4694596cf68707a39de20dad8d9d201be4628a4174a7b1cb03981d5b3810c4eb2dda546e9c84fff7e4dccbe3687905c8336868a5d68e1ad7f425653d344417db087dd5db0aaade0fa34773fbe39ba43c4af277c7457f8c1afe7b847723bf6438d58b95316b9d1bf5d2ec217ac8905ad5d744e234a2dddf707b5869ac55ed59c47b99979abc76eb505cd0ad1c4090db669cdb0401316135194376067b29f681ebfdfa79f66a80312a834abcef60f70af8efe4a7a8b04d868b3fa13453079246ec9cad9480ca56eb41c0e78761a6aaf505eeb06cab481c8423565ddad100371421e31545a6d0bb72db4417448d20732567340036779e04e5828a9d45d98cdf741d27411bdffa8688cafde3a98013b3a69d674499e512cb3d7cee742211e52e6ed89c3fed052b1d60fe7b464bee231752652343e763016d7adae8d7990b2cd975c4d572cc97f2430230d5826c12919a7351e9a19fadfcd7956b1acd36a6090421df4e7871573a9294a767379a71657ba90eff1a2e21f7cdfef997a6307dce0524033641fdcdd1b611b8a152e184b6054f5693c1913d7958045784f0d59a6930c2154abdf122c16032e361211bed9483ea61086e51928829b21ac9de17a42930a667f00f8836247d7a3ced480bbf20283d02dc91d323c7e0d031779f206ffcd32518c8074a2be6935a5b220c8f8cf0802d389eacc74f15933051fb2e67d0a743c6b47b0acddb39ef2c002f74b150484e0723e628133a64ca9af51a2247ff9f2cc5a246ed54239ffd85e3802e3fcc7cd31e48bd6073c39bf8f3ea9fca533ba9490f62d2adf2c0998a2bf1a2315fdfa78dd5477ce3796cc55af9773ab6d93830f9aa50d7e2a87171a47d08111ed74ae2a876805b5278508dd2b7b86da4c436a8dba320d11a50cf892a8b2d1cbd7aae55d653dda7e3f8df15bec737ab0106a3abc2b6e07b1b655c32193bdeb1c82a287621d9588a85596c6b4a0b41a29a4162bde452491593ba4f083db3d8c10bf55ed3c571febb501824f7e4f09d0455d10c6caa47c9b33bc5f4589c96a8746527a4375c011e530dc3f578617ba0dbc9490783902bc636cda195ddd93b291f9b935c022ce07419dc37f198ba6cf3dcf7256d2892c573a2f39a3f0876962b1f2eb413d9de7f740d71e9ef0c788745ea53702a167638462e5ac3778ebfd2a088941abab690bc69405ca9ec42b6c138e283088064e0caa99c53afa3734b08afbc2cfdbeae47bde931ff9423d1e94e0d3a282019140addc16741756adcb25a13b7d633b91580f0366bb7c7e095e531c503aeef552be5751c6b9ea7b591b1e4252914b5f3dc0b25bc1725e931eaa9deeefe0b4e2a4456c694db4964e15a2c0e1b0f102d1118a6ea75f0701e7699461d3bc9c750e100bcdecd357d96f5dbf283a813218eb9531f625efc4060043adf9b80c1821fc74586a5493ee1057bf2cbe736f95e21851fe5bdcbc0719fa6b9ef8ebb94aeb8e6431d7d253dd3844f74626ce5a6c830af86fee667349fc8d3326ef6efd119b62902885d3dc3637e433d88144a53cd11c8b6826e960e9938577a3e3b5d206981b421297940b38ae7b3f61aa08e5d80a0eb663f35104317e577812d55b5f6dc27e99ffde85b83f7fbc68d1a4cffa8e3fe5ae39f5a408fb91ec565c15b5c007ee3f841c8accb0bd6140c97562d1869cc9c039b69130249f79c1733c942a68f0a6777822358e2522ff555d4cd27548398d00f88d46035429dfb3aa4fb8282f75b85eab76cd273e997aa70ffd7eab6ced4a0fa55a2a659c21d90e4769ab1a041aa218b9aa8996016230ff8c1142cf5e3c09662a567f441885331c1c77ea775eff517052a2306c7019a39ef8f37a815964ebc9170ca6fb4bde19bf9350112cb1a456f44d2306b4c284eaac05c5a88208ad2a12975970344d8a59491d09cdd7df4b5014e2c10ebedbbc7beaeb68b2127f4fe2f7fbc7985b1d70320e344aa9dfcb8ff6c08d6b0ebe8275623051e4aacc894fa34a3b6ab0c9f743d026a3807e39b2f69ae19979b66dad1d8e19fd1776f14febfe00fe2498622a5dca81da79da437e6f1b57e26c4b0a584d5f055342db20dc9db36745a37bcc38e4e53af5f0f54d04d64d5fe89d1653939b47f8aeab4a64de766ca9d4c8c2f7f96ded0007476fb664810eba9de1459a98ee55123c31914a7b68f897efc9e620e2944edc55a5e6c9110a5e961992a37e54cdd320a1fbf8f1a382baefa229df8f8b2a35b4b1c7832f4ddd5c5478b3292a3a845f24c899d976e606a0ec06c0aa69500e05a598b042991de62ef550705ec5cc0ad183b605f07e739244e623867c487730fd043c7ee8d2cfcbc4e8c4cdfac5b5fd28eb56ddfd6aec236bb3c64f2ad60437404d03e6bda7ed07faec6ccc0bbb8f96de675045d5de489525a61c6c146288ba1afd326bb9d8eefadd23aa852e0e7cc3a4cae4c164f72e28d0adf82ed0fead864d134f40ba0a67a4076867715629dd956113d949f792ceaa9333c738683e087672d4c4a9c1e8bd113f53d5a37a94061aab52689c7e441c387a9c7f3a60092b445913c41d89194607e8ea67dc8de7b9fbbdb6db69a610e0f7312df409371dc745f33d8527c588ba5989869642fa2ae7c68b5d0be83d6dd74a5993b22f6f66d03a13d77a4fc4da17cae42b11a1a2c14ddc9df43a28cd16622795224c88d5f46566a25b637f9f0ee06d00a1a0f0177fb626f6f5d4f2735e752a1aac4aa085b9a8f112680e114d23eb7dedb7b9dbce5939cc932013a1c4060c47b7703c58cc4896ead1495a4813adfc6d48332f0f0b6e82814e65891a1497b27fd5015f519150fad39b68d85d326e699f3fa481710f540e6eea3bf147903dbd539121772e8ea07e638c47570ff2e9f6eaba980a39514b513c57ef808a10464a19170bd48f923fcb6a315e149f99d24f0bd575e52e891b9372c0c4946c3f89fd0a791c40c0cb4d2a52a3019ff083c635f7e476b0b0707b1ef2935a7a722ae23f357fa3ceb28da696811296a6d80e3e624ac0eb3a73a2908ffec88c564724fbf65bea98062935340528b1dea2e42edf26ed08493ea8d08d8b6dc59e0cce9df9e9d5b5d32b53d88001f8fdf9651e5b44eeb903ce3ef94302df095bf7c3a888cb46c78eeaf1bd83bf46bab814559e6b502ef96dde2452f689ac39b19b063068454db943202ef46cbce31f4c4897cd53d04e4335be58aa244f3ba9e51a915115f6d36ffef32f456837f47f2dbfe8bb06f3288eae7a341b66dc2fb80625aefb94cb3da2b35d9126187a86f6acfc3f9aa36cc827c881e9c791f3f9bdf3beb2397ff9abe1f06cdecf393fad28da71d43705ac0610dddd6abad4acce6ffc15e6c5e94421f5aec08d6ea2113361dfde4dd1a48b62b2a50b3e19dd0215f936f797bd71c18bdee81436ba1346aa9dbcc58c86969564ffb9ab4e2ca87e8620e0118604c2ad8909a5d72df22cc0b8e004cc6422f70a223a899c4b4a070c9fe7334c469e54d756d2798a6575c2b2cb70da815d901edabcb592e588064d075b603bb66dc0be0851dc4cbca794f876de9888f8483d1638011f82912827563853ebb261b8c0e5484394b123ca9451ce20e2af576e37b5d71bb5daa344ee5695a269cd282e71efd664104201f63bc6632123aa3cf9f2da01d17f710f4937801dca8ba10a103ededdcb7240b87a969ff528ac7769994cb717bd0cd5787698d1f20791fe52aed1049feafd212d8e5f7676e516ac6be101b1430dbb1d7ee197d98f9c6109a4a51932da67e470cc8ec89bd35bc76a490c4d1336536f4714e75c9e959c9332da8cb558fe54e523eddeb6735c3561189ed1884739a27e6676d40f629056faf2c536feebf6f974e701b7a59c50ac1e9fc4fbca16e0da75a3f9e4c822a71e0e483ca7578b93a44180965709c13fd6dbacdd58d86a8c374822946f91ccd821a6482540cfacdacf3ad6abef7975a54bb9bd1b1a53ac4d6e4a5c9cf6dfacfdb77bf0b89a22244e72558783216722a367fde114c363511ad1a6aada56520c5f9313795444a3b95136396c298119f167e49ed21e906b998d7fc075c901c42fb5cdc12d4cafcfa47881f965fac34de63fb0a1d002667507a8859c2968d4ce73d2ec51f6a1d920324617f7f5f42235acde88ab511108a5a399f954d0cebf9e106279fd4ad6786277be67cb2182df19d745fe049d4aecdf67194a8d17d6290cacf33067684aa1861f3f102b6786b3659a565d9fd928bfa90f530d0c2be03442b597b1f6b7f55dbd1ecaaee1229cc1ea8a1b659bdd9ce4be35413edb3487e44fb8fac4acfea8d614fc4fee69e8e7759db375b18f3e6b8d5df583f437b41e800347588718ee553e683c58077e947d52ea97bab7752e5f1e660a65597c8ead8e982a417420aa25241ffd3a946abf46da77ec11681292568eb1f3b944ccb76dce57624170cde74c93a7021cfee581eb85de9d3f5a47d481e9364a4408bc7452dcdbca4f2bf5bdad76b92518c1d4a8709825a725792d010f483ac9a01ad1d889111b61d98826b0a369b871c2134d9568dd449b473a66ad48c82907e6513cf9ff4d1198e9abdebe4de3b56edb6fcda9e3965e56dc5b09a3c78f9edd5dcc51697b35bc44b75884d47ae61fb69a64bb1e165e2fb0f2e76a0487e912fc8490b772c0ef1d1904c710735454e733b0e628c2ae5240dfecc2f1b6751812891934cf6eacf86a840ad0682b41038730f3304e595b51ca950563cea05f3f44ff5067fade3a297ffd95a45620b792aada016d0f93f9d4ba9c726c96fb81b4a29611af6f1374b4eea0e5281e9a6533c7e93ba05ab2791e2c7b32f7ff8238092cf51ca9d768505967066d28ee2f96c4c8f933b6c246a2410b293c3f66ec1014503888f29d806059777faf783f3e13ab4f5ef041dfb8ffc04c34f92f887304f86c3e03e3abce04c662a4b5886bec4bf9ec50c91df00c54794b50c3276e62f4dc9e060ab24fe8cc5ee463170f020801640d1ce2e925e7ef4323c694a6830dbad984f5b89a1d34959fca84e89af3b7ec8d446f302a6a45cc5d728ac85e3110bfb90265d4fafda37e5a42f1dc8fb30aa1b32f80130849c60b94eaacead77605d8496d351bf903f52cb0163882bf793b84816e8c3907d827c95a511d8cc32ba31aef000ab03b8da1b410367498e1fa4b8d1f13231b0283f709c2251eda0649bee1e8b9adbbf8c446879c854b5055a2bc559f721b381ba9ef764a0618fa8252886e98f457dbb9e1104694a01d29b15bc37a30d5ee1d07459413043d84fe5017417f531bef00a86fca5b1911578d2c427ac85678338b2a9950ad222e07e3436ceeff85a9d28865849bbb523472dab6c10a3f886fde313a882d77b6bc8e1b1de3da0e18ba4ee3bf968eae49f3aebfb8b4d4551243a2f5f21363ba2c1cfb29780d595dd3f56625dc6e0dae5e466edf616300cffb2fb238b7e3d45189965d9c8d1c82d1500ff8a9c6e14a9135b68548d5a89b8893c215c1409fa05a763bd191d91b71daa4030e38db390dd60613423fb8a314519ddfac0c169bf9f9f6ef561ddcd3f6e0c24e3aa84afe7f16fda19d55ba6e1d0abeb0bf6ab5615fd2396a91e9f17352d073de051fb78431035d836ce7b81954fb2e0e4ee356a3c2d2900ceab1cb538aaad236e7330425e89fcc6b7fb0bc6cfd1e37041bf8af089397ade36a80c6cf3fb5da20bf7d72062cb6968eadf8fe606897a01f47bb0e0daac49a23f67d9726e1b2857a7814274947d99616ca76df9c5905d48c8e7a83098448ae02d7cd0d8e1fc9f8fff2983286a519c6a118c065a20bb3aa008a8ce939a02e78a35033c9fb703a6cd1e5d629da09f3ef4bc9a8d216086088ab9872007cd1ba7111253765f59328c516f211522da16b0c2bb6c56d19a55cc1d109662314b2f064a260fb517300e8739226d9cba40d8625dba4190fff3f68c367152f4461dbbae38fc07fdb2e7381681bae3980c83b2bb50b617119f537c8391d0e370a02bad739f3fe2c794948ac9cedcc359e92eb96b6aedf96cf26f834bf83225dbf4b3183c9325c3f18c60b48f1f16d83b6a1d12b4b5dd71ae27b1031263a419d03e7bfbde3d101fd8c149e81e70ec6432e7914dfabbfd86f4724a6d4f314af68db33c3ac69828d4c6f59569c44cc93d658f2ec7a4d92ef253cb8024e75473d66fdc3218d8eceeb65908484c6fc505e49b1f894a0f97b8024f200f87d8cf69146c4b4cac6df087e8a608a57cb63691e73f02aa65dc393b19c65dbaa191d6b728af1d32b24feb80d8d11e272c6a341abba9a14ac61012cd68eb6aa2164679bcd96d90d8e5cb5900a643d7d92b93536309c67981f8ea74abfe8acc3ec1169bdbf8e2dc9614828825403806d68b8e64a511fa1404315d0871453eb569eae3ae0382fa1517f7c3695ec1a8426320d055226de30851d4cb0bc24374e8c35df2c59201ec42eb06fb4c8b10cb38d49de7bf657b89111b286aaa36749056cf7f643a679e4b9d23bad35f542a5b701a6990461ac4d56f72e541b6e4425844c8284ce3fd435da6e767632e07ad254b3da5831897a3ff6a11f233a1a9122049de6f8ab2a934b26c6fbbfe8449b6111118898b7d9ec7d894f353e48b70011d5ea7c5e0ed51d0108b1940cc156fd3db1a0feb0a54a0e303399ec6364ec569a3a84a5829831a1feb77a038e5b0b657100c9e2c1459711f3d4f14cc32e6063219669ffe0c727610c651223dfb6d7ecfc57d5c7033b1032e3760eb04e7bd031fe377d7b53269ae9b595923b9c98e0dba969230e72ce00c611f04ae7c695c11e293a49d9c57a3b72b81018d9e315165abe12f634324cbf6618ce3a9b8ff75e909fe5268fac0f2ad44c4a4105d13962328370f704678c5f0544e27c9d658c7955eb9de1d88e3dcbd92a130ea97f3f730a75b6d0f7d2cdc1acf2d0edc20f4fcd0bc39f746c276663904628f566677c9c09bb976cd864f4a8b224c31da1e96c2ed8ccf11cd98c2fd9480b3491e467d48bfc5dc5bd1ec215e89ecfab7ec957f483ff051d4b4531cff32c04fd33c01abe0046497599e42d7f6d2b8184f8d36509589ffd36f185b2f6b98252303ce3be4fc7fa180b23a669708eabc648be26e1fe8d4b191f8abd092394b7cc1cb7a4534bcb4358b9d1f1f630e5e58b05b0efba4ad93efc832ddcad88c633c3cbbe805c1f8ad695454655ccbf8647b2d906511f190e00c5551a7fc3676aca99a09c0f412102ee7d3d14cde2bbcfaeb4f4ed7b27ac62af314c10ce606912519fa08ce747070ede87f703cb7892fc5e4649ebdc79ceb9ef1a07bd074c8fe8f7a120c7a55983173fbc78856e0f4d2d8f37ce2423b8377b6847a69475e0468b29deb78d87ddf09fffc404259e93d491a2a4eb959dab3d700f12d351cca6d67a103f7457c0aa7bab828f2043f86338493dd79c48aaf0a460e5453f9cec191ba5bae20c507c0fa8dbad53c11b2454e92d72830493b36c7feadb310d962a1fd3d7934f3ffdd2eca37726e264626181229b3972346e4f1d6fdadb59c2db922dec95e0411884a623ac8df4be30e655ae2efef44491ff10e9674d689fd40f7190d8350ce39fb43fdf7b2205a2f760dee97be00e6d89c1937d3f0e8be59cb9d6b24aded7460d69a89c362ab1a8b594386effd5556407bf0890dacf5a75389064f4400a735954bd138a60066e43ee5a42368cd4492facad1f093dcdd9f9fb239adee0536a62fea1df8a16c8b22f29c9a0503e2e4fa0161a6587142e4c91b7d300db536046756460267dfe5f88c58f8b95579e74f5c12cdb78c7f8b585922610d364a272aa81a01547d13e8c1f956b58f97301713ff9cd0e63fe3e5622914fd38ea2ae4d0a12ee6e55d0eac269b77eb01f37fa34d0bb2911c8a3820e51f211e62dd893aadab9bc62a71749f7c9ec88ba75028d5f7e915356980a253c70bc4b78b059df16bdcb44f0b78abb447201268a2cc8f53832439619d9ab54fc2ba77e56f7854dc63b5a53e9775b64159457618bb004cc046bb1d2bdbc8fc3b5e51dbaf2006303632d22eac456955a8fcc9f34b449d8bb2c84eedc252b909e1eff353fcbe8978726994e62c8ec7dee8d2675421909ecb3c2073c22ab62231a9507da35ecd7b7179f9960d70c0bb53e197d8c7ac3b8fcc981c51c9293102764e907b6eafb274a24cb0be34ecc174b14800221a3a07c2c7cdaf4d2dede6de8898898f36db0b21c222b70df7e8fbf8e729aa906a3cb615298ee2a1acc222c17961d1fb2b9f97dfb50da425dd21ab564c786eca0d6bde84d766c344b85d3ca329ac4434448f75153599a27fc7bf08a81389adfadc0f041ab802c42c7f48369351d07c4a81e2e5999be29a82552796d5165f08ae889ee627703f35f02ab0f0bf0e68910e24a363b3b4137d9e284e077a2c22485ab48bfb5dff5a9d9efef6b7066ef3e3afcb64601d921d08f7cae1aa831afdf7cb9743285aa09b8c1cecf0ebab889c77a5b3fc978a6240de7c9359cda1f650d56e0fd8efa4bc8cf245dcd6b184b33c24ff53dfa6cb8db6a5bfd836a27c163e5d8ef5ee54ee836dca4db8915c970f8662b7350670fc92dc3816428427b1ad0bf59047a2da0e959bd512bdb1c28c486fa6732cd61f7b738c7ee3f4dd0f260651c608623cdabe7f020563f72a96fc73b8b2ed5104c9369ad572c1d82aedd8948e1e7af694fd42f445c29abb825dbd23136c555f11aa9294190b5ca90a1a41d7a6d0905dac55815fd63f16ece011ec4ef0af944a672436b3b8f6a066c2f4a53f3b7e54e136dbbf70b64d3f9132386c337c5094ebb662d2124f87db76ebb3cbbe319d22a4a8c44192ca2c8b0c0d3ca8deb4046cdaa7f83f5c7094f216e8931a9d05ade43ace8f66b8486cec0f1a284f5e3284c6f743ba54cc1f35a5261461ba77e905c183fad408759cea8541bf34a55eb33e42a92d1b4163c54b9350024e3cb5834f5465589f9aa1104d8a5ae1d363b4b8b74a4e8637e9d0d93641e5636b8b81b27a2adbdee3876b93f86147dd2002ef3149894d5db813aef650d163321beea16a271d1ec9fe09e5c14c69861a0fb9043a46b15c93d56e562249c0a29560d6ca98e0c570a239d52ff423a795bf5f299268414a32088c631309c16477a035ebbf19b2e4451a75a364ea6ce8dd6071dd3fa31f1a925623e89b4b96398ee0aab886760962c7c52dfc9078ebf05018561f63d96e2648e82c18fbc5542a2fdeadb5c768daa1a190f41e4f7a91c414463cf98430aa5bb2a7077778a7bb78937b39733060fcd6a6b6c3fd5904147f4f352f636cb822952ceea71a5e05960452919a0f335104d65ca7484ab4e154aa3d31ef56d8298436a8f2a4ef4dabff37eb604df723a6b8ef402701d3d2fd21a54e5d29c8b457be286383b691ba9f0b88f3ffb1e373832e664fd44ad096a287901a0ef9aa7781c43d2a173633a521d3f5ea4c45af0a68979acfdd1c595a73b6365ad37ca9587868e031e7bd0a3d651b1114068f897b140a83aeb9df6a671ce17d960fd0776220f3bc8096d71c6944b914f7aaf331d8db1f9698f0306d323d6c15cc0d37d121f7522c1a5ef58c7c60aeca5533159b3149a9514ee7fd5f70c637578a68df769d2d20347100cd029a823e368f6986baee1458d7beb2f7e96ddeea5d3e43791324a74fb7559a6c512b0427a19b76e459cbfc8cff3cfa07dc264fe077eefdbbddc47cb91302eb95a94c9a9ccf3e5818384e6468ebaceabb185d177e9f55dc2d2d63c893c7a623a3178989695e62056c75f9ded0267d3a246767da6496aa46daa18b18b992aec0ff12994fcfe5fd5ca71e98e19e3503bbe09dac5fe6c46c49c14c6fbbb0e99ebf2e46b31f157b482c6076a736127b2770b1a54c10bc2817187395468fc6d2779fbee5f253d22e31b0af526b7ace20ad138ff4180a1d613c939d15bdc1b4a5bc0f04dcd17d95041e7bb28c7915c3e82391c96b99ec3d072eb39ab665029e5e7b42c05b044ebabd0e6eda76c72ba1d230aee08037e793f7644d6791175a4f7beb4dd6334cd6a0b55f10b53157796b1b9016d474c4f358d435d9465ae1ffb772addcfdb1de7b80cc2a5ffd27b0357188299af4306041018c69a37decb3d3e37acdc0e9bf37b97ea786a28eebc258803529ac19466bd38da2cef0db916926f8949b7d7a0d6c3accbef72f5b73eaa62cd334cac9e8292521902a2cfe0bdd5ff132d8c46aa344e0ae087521b86b578c4518b2972c73c03bf378c54d0d7d7aa5e4cd3eba2248e2bffe6f4ec44a4134ec2ea68a06c86344529a548f173e731bd560565a8af132a5ead6032ef3dc7bd2fc2060a5aaa2374777197d341ac2627c369ad4b359518b4885b2c85c47dccfeda6d4f992f1788f412ccf6732738182a4bae49244b43b845d5d851936bd4429eeb909d3a9e51de16ccbcda388a2da2134a8e3d0578207a1fc86046f9207a07f0e69f3f0a39c7298856fbed7ada5a6a065fb3213d4bb1798810a446382409e2e2fa2022e9f75309a821661bd9fb2db84d1f951995348b39b2cfb2cbdf18d78b4460aece63d2a2ce7bd75ab61f32c3b34a3225758741449cbd5327a35900e3d32e310fab0512c3fab178de0c601a0d0e05e134c7a3abb0c2285d46e7013224a0a9138531f1aa833aa748bc6491add00c4ef91fd52fa95364dc08da99a10c1499c285735e1b60a31a2f42c0560a16a7bd2489a139e5cc8c4f4e11e36a5d5c96b94bbe32af82b6554dceeb2487347942f38a693d41422a6a79afb9909e2042703a268a766c8ff59a57c094dd9e927e33e49e92777f0b6e69e01ef3d4ab91fd1a96da6a4f12246a9a8460c994ce47dc5fc1be7f0cde192a61c9d23cfdf9bb0af082f7d7ef61cd3a3a535eb2563271ae4d4f32dd608269e60720c789d13ca70ed7de5dd493cee627f55109039215cc17167d8cf4950b8b8d368a3002dd641c17e67d67728699501715576050320acd3d5f46fd02cd0620ecacad500f1d3fb35e82ced9f4be4122735f79021113fa48c8b7665a8a00db91605d6d6c211f5652ad85cda73d099852bd1d14bdd10922b7c0601f9a713e954e15b081f5394c9038a97b1332004e189858d63f7b490759fe75a99eaa9ff5f2b87dfec603d8a202e8bacb344721daf1e4669b92169a8cb32f001c1b8ecb36e531f9fa752ae11cd787ae7a26de3bb049e404ed6562a76e850de980e8ced7f6bd3f899733c7567d88ca13de83165b6be51ccacd7218f59cacdd77224d9e096104621d6ec0c631f012c389d7a4c2fd7c832a887faaae8dfdf22fb4e2b7c0bf642965e9c1c388600fce42c68471778b50a9b4c6b7d549477c579925034ddd2c63e64367268247d257b783017ecd379801d8196ec1529afd76699bc08ea115609864c18e031c8b490fad003745617f82f65024b7014da376afff5c5af78302c7b57b5fb8eb592907663ab6707732f8b0c8c2638bf6a0ff688c2dc577919ab3dab01d3b67a95d33435be92afe15c6dc2d8567c84eccb8b70d88fec631da698a3666905162418fdbf19d209f8cbbef2b3bffb5b59710cf9fbfe8fc80bda3ca1b0ff980feb92d7995673ff4fb5a78d61dbad1915527011d869cad33cc3e9a7bae3d7d8c34728b7813c95993902303a253a552f109af891b5eb52534e00a1a39a8f241e7b69c0d3395c54b2fe3250cb643de13b8794cd6fa15363a898247774ecee57f8993e77d1c4c06a53978ad591929fa7a931fed26bb4592a147da46e73f6aa2cb36797dba9e5c683e6cfcef93a9515a6049abfa41c0638f1e848b829182e363f8fc84bc44dd078f395002d60b4fe30ae58aa157b4d140edd4b8d7dd24cbc924bc2848e87eb931bc2fd035285f172a6b0b4418b5c97e8963af169ec16cff8a164c00b279d86ac3d54d52b198939c04b585447734ef578aa6cbfbe7dff8d4672ffaaf4a2b8bda11fac10d54a418011b4ad3968958e1013d89d9255da05d45f003196105e73034f0591378a5e3db4414f6b229ffcfa243754c3e296e9f62955269bbdf6102d5ff5f4145f7841828d503a84e905fe803cf786b9ec268cf1850bcc32a25d46de80b2d756afd4ad07d76420adbdf4a6efdfca7c6f10c738d3fefd0afb613e55b73d1219f31a21ad48b7d5666688264b9c9a5103ba129248329873ca26180e5b660046a578f7e51250563e1a27e523cfc34b48f5d692b67b8e198426e61a6e8cc20fe88a17436a3b956442ddefd22f76601cf14a798c65c7897232ca662b185458c2883562887f7f130fb7b815da75ecbf78ae15f604a83aeeba4d3af1f1fb091de86886a167e05b2b4832f8086a2823cca7abecfcf9e0ff225452262d9bf836d6fcbc9473744b282d5d5105835346fbe6d7d529c4900de0fb9323e25997e9824d266e465bd7c999c4ad24e814ff74060f95c348efa660fcc70c05763f7ef1a296b9e57d5954f7bd9bd02d202ae9808eb8040a39234c91ada033a40d54fe99e7cb01331a86163ad54f42f1fe093363bbd28bcc76cec196c57c6cbb01b4f07ea597b0f5718dff4a07c9957baf77b04893635643448598613c87868c78b08e175ad9c87089c07e2a8454f1efa80b684e324cfa46b85ecc739a914731303bd356fb3974f2e17c0c0a09f6b34ef5b7b57e583742b0aafc1e5ecb21637ca6f66a184b9f07887f69385440ddcd09e1594670e633c9dbf5b945e26e560cac66e709e3e6be79f0a82d7cd6c13aae3aac676510629dd9717dedf795ef3b51e0f2eb1eff6a710d4999a245c39ea0ad03ed62347412e4583f5f307f51e5f236cb0e09266446b023ae7d4c9af62d89b702330f05a949d53b632bef9a26a44d8bf45c07503ed7e00f1ddc80b688af9943a4e24d8842739c47d0ecb0e47e99a88b4acced9b9d71598d2af63139a55fe5c4ec73bdd15a591b2e418c628e2560d39a301488a31aea6eb720778a21e41ace4ed84ffdea024150cb2f47cfa2e532cfdc3ac096bae92618c98bbde2328b425777a6b8997b55c7822dbc256293ce191ea6395ea04d73efae4dbdcd5b43d0bd9deab92fe7ac729d096e8b2c0feb9f3280fc663fc7a279d17cebcd387531e5b24c933efdcd6174a857ec244a745cd3455a7fa18418ecf2e3846d495cffdddd9325ad69dcfbbd6fe0630f561cba24c1a837802bb33ec271aaec2af03aad79fe1d3ac9c791577961d594e68a7cb48503d5821a12752de3bcc16eac9ca5fd3f9c0d317b2f7b092826e597d9cd0ae7159c111e2f0bb9451be30582384b6dcc863e829e8389fef22ba700c834d2739f77b60081455980f458dbaf4c0ae498add1667fbfaf13dd1d8a68b490af1d8739d256aaceb37aca1f483b7d7da9bd900f334b5998fc6781ff5708258c718d312785f37828bbab977ee9cfd05fff6abc855fe74824a821f83db822b47a682e20042eeb78bb022397564f4d731e89bb9c2e4e8f62554b735dc7067673d5862672d28277c927a4269eb1f07fd449f343b258f349e01bef7945fae1b843165c0d951b49774fe6e9c50bc0712c4616a405f68801c1b2096b2345b520d77925f14eef776db54e2d3f73e6c8095b8cc686cf62e3739c15742a23f5bb53694aa02c6b3f6ac9789cd40c00fd774c4aa1b5c0ea9c725f9ef846df9187468780174f9801b45ec241ebf199394fd5f897f8ae161daafe5a0982c9fd66ad386f424d913e42a394cf4d13a5b471be5135c5c8ac87eebfa6c952a7c39836ec002b1ea2d4dbcf5c805a43535691d71f93086c6822c2419e58324e39d85106c4bad5d5d7669404c64aa5a97ac8384647ee8cbb03e574391f7d08cc18c076ad8918127787e9c91c1649eae371b2826d783ebf60f0c36004e1a627a562e29c23003f254b6ee3dd741f505c5a4ef19830a573bf598de5477db76da6baf67","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
