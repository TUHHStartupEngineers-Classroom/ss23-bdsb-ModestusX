<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"e8248aa2615d8b9402e1294a7f49b9fe8be518b6a4721ee65e3f19cbdc80f755da0c115253f6eb2be66992b3cc49a0fd239520c951357548ad971de03f0de3a365fb577a4c857fa7210f94ff522b73ae741f04766942b8ef9c5d87892057c5e325f8f8534c8a840b7b9e69f02417e5f55bee3fca44273798199f65c6a396054efb412706ad147bf5afac4d6716c30b96f888e79b604b3c276aefcfe70102e4c3234db6a8b9b48eade9eddd4f2fea5de51e82e52f23710f1ccf59ae656ae760ac19d473a916d4933857d921041afeddbf49b56dd5b967c56d3e25f3f9597b279a16e355b718217d05b9fb81a3135120e1f12a7ca60b695c17bca90991517fb47f2c86fb2895cff584bd07c113eae8d34c467214d4b777e073e33ee005a4b23b33e9ae9e4d5e83d3a82d5629f0911f233bec7bb80f9947c07cbff5eabe420faca19bdf60408756b43428b82a24ea891478d8e44c96a155f91c662a73977233ca7b465e1f8a8addd9cb001db7ebd4fee374667389856e951fbc698b0c3066c9b152d3e225ef36a3e4daedb0d4983c9036c6248899b6c97b17bf750c420b1819a7e8e88d8b637f8af67a0900b559e1c9c36209b9eb83df7baad5e37bdaf4724859f103c7c59808582d193c39574528a6074668e4b3ff075e7260734bf3f0ce86b5cc08f2460ac55785222ca233aa0dd9a0d04f255e0a18059af8e6637b3a42c52460d1615b7783f199ff824fee61e6f7b1d898c30488588d8d3c8fd0cfd4d177dced601439c36725edb43db7127b29dab1a7b955fea524eae9302a0f5f9cb01be9e5c5e420444f20554da9bcacaa3b50a88d3b7a18d2a737258beadaba35bb7409782ad317bb681fd66ecf38aded7eeac37b7cfa55ff0d840d36a65c0b19e03bcc69909081bad5dae3d0cce6adc2d63d2887795ec130539b9a2dcbaa47c9f277100bb24a0e549d52f1274d732317ac0083bb81ce33999b27c65249ce6f3ddc752d5590b8e1004522f378cb0ba7b05ab8258b17f89c179267240b6909321a464f2427b76da8489339e3fda07c8adfc48784c2d16ec0b0eaef94b91103f0ed681641e2be62dae8bc35acb3e2d3bf5a5b2352d2e3708fccc06b1bb7e950efaafddd39acad0b608c2d39fc3d844351d8a576a74fe954caad0e07aea8a8a33231af6e4ca4b049bcfaf85206288f7470557c8472ef4a622c4e68395cd781264fcbab68edc314b8169439cc11d0e8800a9110cd8278dd51c92b24b64eb3027fc740ccbe57a519ace163e36342357d3daada309e3d1f1db150086d2496e904942058a322da2a356dd0573bb268f0f6e77d5811c8bd9baa409212c8838ee2ff4c2fc3cdbe1f7cff4226c2db53cffe90d91993bf9c195977339bf7842153a94bee46bb9ff74aaeb33286d8fa05479720006d66b5a46d92bd333ca3b856ef7c39098ae99e18cd7d20623d93052714542619103eab64ff9c3b0e707ca708b758b11208298dfc225ab9dac94deef2623ce40fbff10144b112362e49a5be0d1034776f5380cc2fac541c8a9d258d4908c933c48587736c5a55f1518bbb544c69668b174502fa88529052655458c9ad0a2215db1d25343c2d0355110edec157a9b866ed944a5d869daeca1d1a8dda5e41749fd948cadfbae6f3fe9d087f9c731ee041ffe56836d14494efd32ff64ad34d76c34d940e4dc67ed36ccb60b109b60d3a9d839bd545846ec7438573f66727d62853826ae2d499b515cbede9368a9431f4a77b0e0d48845ce2682e188c1fcd284d3652edc19a81df93d583e1169b748f33750790b1f02ba9107a299d2edf93ffa19bb048c1bc5c4dcb9f370590936627b3ba08e6e7a6ff2940790b89b2b1dda934cfc886cc64becb1e7507e840b40b00df46e8e44794c8fc1e8b8540911a8e1a6abe2fb47c93c797bd34e923a0ffd4e27cc15adf56857f99e8826b0b7efe0dcbdb589d5bfc937c402dde5e556482cf8f5e186fc5a1bd509ef371e1f72a099e3f8c479729a2e93f4e6235ab4033038a73fe449ae05fb106819ee64ae54751e5fdddc29f7b0aeb8e78a06bfe94b25b109c2b7029fbe03425b4a7846794ac23897de16e24704acf3e910a1512631625cc4f526a03744022cc7ec135791804b63d73be2c52d776b7838c6e13131011e8b9c519d977df1c8fa145371ec250ea6b8780c64993e3d7b09e768bd5a28cf642b08de7aad81506449b12c7c0d58c790a10a225fe1f8d1bc2eb98a94923dd1adfb87869e9e199b9d5ade7bcab61ae76048c6dc2fbd9907428e60e8de83730b5832846968ec52847aecb2746be915cb10621a000db0c0be0dc25ac5bc250bfe9fd31433b19ed435e418aa653c76782ff7a3eb707491a941339d230e836146838e4445910707deecde4730786e1f3ca65ad47d49d67161a9fd364b4d589d28fffbd0220dcd9c6a90d908ed921f5ad0a26de13600f142d5acb2a159b1835afa9bb1332bceefc37b21dcda7619d2514b7f703b11a72fdb90cfb65068bcadd20d520e3623d90d85d2471dedc238d5fd44c4cf31d26148265fd894dbb46b4e8c720baf75dcdaa89c7ae8771e55a0ff05151d94ef8851d46971d61bac4b9aeb0fb39bf6f25c66829ce6f6b8a62c7ea46648057e5de57df8ff859bf92c50f1b751a3258b340b87d92fc84b5536e7f86b307d5f42f2d30fe7d920d9946d479d4161bbc554329af7f89abf61697f79d7b8b166df6314c89b2c978ffc61940230f6b135d553a4552af8890b6f267944074c46cccedfac1760326beb51eeeb8ce999f3846526d1813e4f8d260fc7a6bb7b8a5eefbe8ea3c9de8fa623b49d8e8932bc721f005fa2600ded8bc0df1343cd8ab563ea770fb85f651e5832cdd7c1410cd5afda0899c1bab8be103a8900a77ad89e20886d88a2fc6a83fcba72d86f094a3e3435f5d5514c779568643c675096d1aa7d04a6e60729a90319a00a0e2941298e7514cd3d5fa233e114053c4d48724656f47df2c5b30621b219f185d6274f889c61f14c4f4d574356abf5a3845b7e4dc20b75b45c345e9ee62a39eb57d7d1de469b82afe075389f2304702c22af484998556d9b5bdcd08152361099ab6d3cf0c667b43dea43b27acc6c2932de25107c113feb3082b487843ecb4ef5f5983f16485490c4595fc09653c68dd912692ddfc4858baae6aac8b241e13dba938e4e9e94b1a817e8c8b2d2d05408d6c2168934e1aef6717c7a6d840f833a0df8faa7cc4c2806ec87fa81a2c9aeaae98fcd1175f02c8ef580b1d4a31d174495aeafffde93c79dc5e04782a885a8f39414fc55bdc21b91c67c4ce6647ffeaff5eccf10b19090c75512673666e115e858eb8fcc06bbf8d3c0168e4d3044e40dc107e595a80427e4c868192a1f70bdbaebf6928d7bff4f3a8b6013de5f36fdd1db90a7a2504b9f60ded84f2e0db78c85bd7740e1ade380159fec434d92371a9b0a0517625fb37ac0e1e1946551660f46fc4001c8675570174b9f4b963c4cfccdb9544f0220686fb199fefa35e225891cc23bf4ff05f2c56f65d260f6b9defed878cca0850a87b24e20d31abcd244066611a26bba286d48503f7f330aac18a44e68235b668c721c45adb5da1b5e40eda92475202142d8627728d67c2e357eb24194b8eaf8c3b8727d51466c4a0b4fe73816aacc5eb46b9e0cde8195c4acfa8043d7481c6ab7cf6f5321fb680c2d68e82258a7b25626de88282bf699a8536c75a346450b9e5a73708f8c4e4bd5cef20635d5a40418ee3207cce69c836835e644ad02c8753bac0d6f7faab5b12a0f6ca1ab1e5d6728de5c0834a22e81cfefc77a3776f451e15dc91bc1b07bd2634dadc16224e8dc34b40445a66a0fda1a7f9a46274a5f2e05ac4470ba6b76d19bd3eca4bad6f1f0f2c18a27e8565662347639aaefaaed3698e6ed12e35229f54930448f374b970870c7d4a9179de4c535a5653a1ad27ecec6619e83bd058ea3a1febd7cddefb18bd93a82095b942365435b0f5ab524f5eb274c302f4b50dc0d4a64cff36c153e92299839570aa8aa4188b29b54174573c80923ef11c850d3f2313fcb745c40150344584e2f608c5d33e0d3456fb2d97c222ae1502c5caa2a83d03cfc34aa9e212375a9268e8223ed64a38756d0e053c4b94b5ac3b7519d87dc43e54fac44e7428abaa2e4ccaca597e6a3a38ddb64397c2fbfa0086bb12820d305e30fd86ece484b93d56b5df301c02d0e564d6ee8b0cef0634855ca738240298a7b6eda7aa67796225855a825bb78da5df15476360506f741fbab7d6bedd4a02c7e91b5b8ddfd677ba5d6f5e3550eda77d27d1b42b52e803ff9e6c4d3cab2b56ca6aef01e16f8567f3b3f84aae6cefa6a6474c24f9849bd5665d253f3ad0c14de9c17adb5a0597fa3ed0ab95ff5bde048c1f31775ae2ab0ecdfdce2eb71d9f571da604c7237baad58d747c7e1397db33e8b423d490c24984246f083e5b236aa8096e5711271d73eaa1ec94e1de041aaadb8fc2c5064ff97500ae1b80ea6eab17e22f7712597bddb6c232ca64645b67e2de836faf515ccb42fcaa4e742120552a7272a4ade807527774a1d018679fbe86672635fea4a11a3e9c3ffa56e71d9afa89372d8ea1b0e695a13ca658d6e7b1abf31cdfca6445604a3f4cad99c0cd1cd39f2ba7a6d08387973767c0c8bc334cf4ece5c61cc4eef6f1fbc24045711d38ae408e9820e52fa8b62fe4d93e981aa287aee67fa600fc6e3d62ee47134a72730417bdd0c066967eeb581341a0325cc89728df23698047dcbf549bc577ab21d6686ca0b895ba97e03c7caea6d9625a471e425bb657a642cc2ad3ad5aa32fae4dac1e605b04f9cb387448b0162f3e8083b0aa0c58a3ef1e0af41e7558be9acfd93b1c03f93ba0df60b94c3cbea6ebf098940644e53111a544ef9330ac2e22c388cbb45d62610b8a1350d7b3d4a30eb3239a57169c2aff05c2303c00b9a58aed20a4cfee13266df7cef8a31e30dfcb6fb45b55e6c2051d355ca73faa5428a3caf42ca14f2eec25afffd346b3310132331e3bb590e735f7f685c46b7e8d19967a71069e9f64fc8036979b3467fd791f575e0ed6c1e8864950fc315269fd15c7a6853e3c0a466a9cf0f77f7378fe66dfb3ee814bd78e4cb7777a06d4e2fa22f4ccf8b7fa8c5fee771e3788ac8a6bacfade32e380185441bff358a3b7751238a10fa46e25df75694af8cf97cf854eba2a2f7e3f78e3318db9c781b135a7d24a8c1b90a70e6149f97825eb938f38540f309100e36809148f2d20fd984a3db9fa0b8b28f6685ddd3f35e47acdac9332b4e8853e2ce8de48ad4e4841a5432053eb38761ba32094438b45713e3f59d44932357b5a4f2c024a4d59dd9d41f8db8b1aa7c815b2cfe5c2704274e1af05d84556bd9665a9ea4db5c374ff831c669ddb083eda43e4a63e14474b1f13d31818c651d2a2a655135d5f9d49b773aeb6886f5c2291b89cf986564e2a67db1551912b58d27a483c1761274b4ed1051c85be671cb9f03363f697fa5a08da9a143fb5b4cc6288de0a054712e382cec1e2941861575b576656f7db02e11f4a4ba052fc2fc792baf647a2982393cb7ad8c344bcdca38a49a7af21605f1ab125e051bf3708af27a606c751882f1dfe5cf62a701d79d17a10ab4aa9df225a183e7c1974f8437832352cea8d6ec35165e7ad2542ea7bb2ba7db2f86407ec049205d7e65258bb79ed868d1152e00168aef7b78c45e10e496c176151855524bd18985a7a905f4e1eb5a801149777800788f3b41db72ff1bbbe2036b103e4c5ac1f0bf18c610e74bac577ae39113210aa20c84a478457820e4b7f043918de40b2ac06f9956ec3d56a7aa78efa4d13dd6f3ee3270c30cf1c0a62297bc261aefbf37f0f843e4494a20ce9ac9783017da5ce06afec7676eac77f80c52535b151bb69fa6e82367a49d9e4ddb2cb45ed6b10c4802c262387a1b5516f86cbfb1d817ea4cc79f3abcffb340cbc5311571611ad1bb2092fee138fa014f63f392693a7e8afc0f68a2dccf204610ec997864d9c455df3c82ce65e42021a70bc6189a3027bfff316e8543ab4e6a9f0c172e79598dec1abe843052ff33e4cab65ef2ef31303dbf847e8d80d78ff51cecb2aac12a5b4413e878189ffde33370448c4a5635fa3d1ea4a7a66b09ed07ead324e540ae035abf31580c6788b33508971b0538193af7f7215c7d92909c186e731ba93b2e2a818c05de17f1b0ce200b4f4eeddc0ea288b5c565f4bc9420ddec5a056a6e68b7626dabe56aafd39fb4e58e1e4d57693b10ef56f63291552b30b8bbcca3c96f3cece834d7e6ff52c384b2750cdebc08a831c094ad417cbcc8aef3174511524196825145819bae719eef26f805ec8e546c762550dbe03dfc2142f7c0c8411d36678307318435c0f198210df73380783205a4b2748a9161f87b360009b26cd278d6fefb7e3d9034c18cd9d40ca2ad031c7e7768f5ea53879b32311b61d8df4ca9c1fbf8dcda1865e60abd53f1026380e89c525a8ee9b5467ec8273d1aa4cbab0afa39afea169bb9a06adc698fcf9a85f3f414305e01b844738d8dca59fe27f3631dfafa32ba9b2b04dd773d5502e52b2e999e3f1cd12170b5596c7199d097e31edd3027509e2b4c410b84491f641d04d9b45cc11aa54812470c8beb86256c5a5480a609c84ff03bac93b7904124f9b92fa3dbf50a75b817752454c86bffd49ea5526657b5b199b79a0d07d0338af9f8c872fafaaa6151209bc6665ec9ee8cdad5e146ed6900da0a7dd15ed790f9c222c5e14efc7524f8c5adc59e847d7de7535901d04fee29ecff540960f8e3712732a3805faa34c13b228097dca7d07b0e2778b01573a70788602be18eaeb9d5cd709da72cf1d6b34859bd14061585361ecdf613d414db9852c7436a18ebe1b14a5aafc5cc05140e22907100319f6f43d5b0305d68ac991ef8a1550a0180925c55bfc8901ef453512803a9b142551e9ec668a0f7e157e3729ea62a5aebcd7e37a53cd9dfa1155ae3a35dedae07c25549d3d2f21073407bec50f1f58e6a6be60f36ad43cfa876ba2a144fbc589005617e54e1f4e7f7c3116a18c01110ce22be6e95115caf7d9cb5228243cfb49670f58707cab0dc3d46d044c9a5c31065be73e254b7faf9510a272214818d2dda1ad1902d75498530aab923372fd5b4d8a1ebc53b0995f3fdc5040d895923bbed3a5561b2fac3f4d5faec8d9bc918aa1a81699efd803004e7946c9025b8d62aed53a6d34276b270277a3ceaddbe34a36085cd0d6b78d5247f9f82e2ff0d2ddf5122031f5b85c4a1ddb481c868bb0d3011b8fd526ff0f36ac363cb4aec233bd2517cf64d93aa3cc7567c389410a87d337d6d0eef1e7ab44618f560c08ad9cd9775d4c3517bb5b00a447e6f58e16d935b7f48380bd1b8da2720e4686d68da72d6e183e835884336d0467ed723af2ee93eacb6a703a0040d9a79f8c91195bee94c6db5170cf8aa7a47646feb79c44949e1daa9509471dfb3525bb96cd1eded1514abe3ca1f84642f06de13e91f761c7645d565648a18ca99226701e9c7610d65b64387a00325e86a65b78cba76846b64f786e8e71e311f38116178d2de06f486a9ea2c143b515b4b7963a355e4fba36fd56a619748a05774389562b4c049cf98cdac5e4dc9a5cfb527ed332b625f91aa386f5930e66436e63da340bd6c5c9ab6bb52daa503d81e0433518d112d8c6b0a6927c7878a2879a585408c98babebb4386e99b53af25614b27e1627652c43190534330220fbbace9c9eb848bfc0807962593809039cb9c94376f0c24018dbee65f207aa8e8e1ed06327ec6928296ee1c1f9e19ff5f2c4d79f383c0fe03914648904fa749f4f14d876f2cb64a8dea2841994c5b41cd49a485136c9f316a3bed4ee2da22158b3a78c0a8cec7e0060d6d66b205dce38f0fc8af1e775fec9f0efe02ccf1e52faa247954256962a70057dd577e7b6f360d9dafa99665e69162d4e33302e2c91d820eb51f6b5187be1f068bd8f760e338e03d36b3c83ee5635bd1db8b7e307b56a1fe1a1790250a2493c14cfd8e0cd4f7b3e99baea5fa313ccb981e0ea5cdb9f32331746bdc56084ccb70af788bb2117207482198fa8fe07a5dcba137ebab5b3d1e993ef569744636db6beb2eba4785a658a1b9b2097747faf236c48cae30963a1379a1cb485f3c57d8d9f11f3d7dba258f6be79e5610fca1b098a6b237a0aa1a7e2d4caa5a8c0e40703d99c2e81145c72d620a0a9d8c5a7f2a53badac07637406198b02ca927b58bf18740958b6ef038a639c2d65f64784e9a68c3e956fdc338502ea625993c41afe26f326c5286bced4b317e70684e851609bc2b5f929a469b20ac8989dab47967c7059afc4962b268f09db1bd8f7168292c81167f30732cc021eaacd81ac6c3a7d9db7d911f4861569e060d31bb2694e108b0757feeb6696c18226f6c5b9d632c8458b20785af49ae7e083a04ed4592c3f4fa2d5665c2eefdd0cf904b63fc3a533136110b3c1a1d6150599dbbf9cfc32fa7402f124fad56218a37d27922856d8b16796b0282853a3ede2c86348d967834a071323160d3978e107ea07b4797176baf8d9fea94b819ddd1918036d687c8ebe70a29f80b42c607e3f863bf8311af9582d1050000002c1db891718aeec2282ab3d0acd811a87b74a2aa439a8f6ab5b52b492be104c4097625cd3c197103c5a67665dae249c659ef827de009ff3570f2e376a69c4795e6d1b41cc6a5026bf14e0627618fa8d7b93917e5663aacf7b5b023bd35e86b6563765ee916b776ff7f6155aa11a85689b09b4f95dcb750afbc76ec7fc9fea1f62b4796fa9850257c7491d02ad0cc32fd9c056c7d024d20431e3b77ad5b9e529b96ebfddde2453bc6cc548a14a408c88f501766f1120b2fd0aee6f942925b9b12fbeb6e7177c8665c3b755ae1ab895d3786412a83307daefb647f3ec2743911e5ef77d74227d35b90da6fbe5461343f78b051c62d5ce2524170e899a90fc6fbf25690f2df6076aa2f9900deb451e53ffb6afde7f4cd4240efed58ec6d7def1196f54779b2a6bf791e3a90860f1732116459230d1bb679f76a89f99b2b6b2a8b65b73ae85caf7863b0574eae42649bb109512db8d9e8b223805ec7d3d9394d39616dac04d0973799bd616419e166910b8c22d74e668dfa909bcb7462cad5bb006868332ce7877d6a19106c63d7f5ac75fed969c6268f167a2339af2ba713a45ba2a0c68f7c09bf9fff76bbf0782c134ea416ab1ce0de7fb72f9f66e5aaaa8618c4e6582eb668444f0193b950c078263edfda2e730976fd6e0435eddab3d661adf65b42607fdbab16c15868cd3df216fd069edfd1790e46e2acc41916e860983d546863789cb639c6c622b0ba10cfd0a3b9b269d595aabf33aaf92c4dd3377d91a2cc7d53aa1ef356ac21d73dcd27026bd6f768e5540686eb898c519df2e9e64704386d019dc3fb052c90e660e8ad7a1cf88daedaa8cd5492646d257c407928b8abde4bff0e9caac3ffc82f99abd2e00ae21655e59ed0b8e7503fa7ee6a3ec65e4440d775afe865be4974b429eb3c556af630d5012a52970902e12ef12bd4e701d91c28baca4c4548e0abcaa85f72bef2982f0922684e63c89e93deaa8d2ce8b876d445c9068919dc833cad30f3e5fe7e425821fbc72b73eb8b7fb9dcc807fd29eb34b6ab7c7bc05d31fc708ba60da77a561eac8aca96f3b2b54ccb1308bb70137cb827d975eee362c8306f2551d6c4415035bcffe15fb396550cd1031b3972091ba6e95342a7ca0dd4ad5a643d5be5e36db93c62b5fa3b874df7a7e579e745cf66b58cb5dcd661ae283afb123f185251e34abdcf5d19bd8496ea104ca375bffff941adac87cd2bc6a966eb3caab8ed32e9206de155aa273920427075f9f3f441faa0037ecc7e80ec30868ece421f89e0db7e144da5b54753d412258823f868e7482464bd57d34b09dbc580f27dda7ef1d2bdd10c935f6ed349841d512667d4e7744de6685b04490d90ddd24c1242676ed2c06e137719cb51dee0500ff2d2f34b47d544e24c85dda6f8419feb15d5d342000c649631029703bd46471380bf4807b95ed146059f4090c881dd6023b915673f8d459824bc8b2639c56e1394f817240af2f185d9281689226a905ca3b1e640579f0248bdd2687ca722d7e4453e370a04ec0c06c1b2d6b99e82ffe1c28258896a29a7a1462f2d7d8d13f55415055997bc3c94d9f9e2c8ac4ae1a6a0340d104a474f00266e2c80826df48b2f3e3330b66700ff072c56c524395bf6189d03fdedc5ee1122e0f794bbba621e47c7e45c06de0fd227379eb0bd2380c9d8d50cafa16462e995e2d91bcd92673fc63692f7921858db18e610d45f3aff627625aad6b63490d99ded757d5d6b4e8a79ebff5d8ba9653f25b8b71cc7fe61fd53e4f6aa4b01eedc04b2b4805642bee049e81a52e6034bc180689bc4177be40a6a349e5d6adde940134e6e1e479cc6bbcc8ed3553ccbf00d9d0bfb5a6ff605ac6c4a464e41a9cfbe46ba1c9ff01c1d375e03182cf39d4577102337cf6754e4fb9aea0a342cd107923c5edcfa3014fff12e4128a366c124c20e2116e42aab8c2dc4335f234f698dae5ab926e7821b211c42076f688102ff8d233493cacd62f5ea4b2e32b8519cd9cdbc938e28aff36826d2b4fd98904fe7478c80cf2e6ab74f6647bc96f6057f1cb12307a81f5acb4a5a40542dc00b8dfd208d0d61ae1ffbf7a6b1b58814c682aff1fc646673ac0460b543be0111274c7a99ab4d2f71fe7804d4ed5bea96b087c1f479134ed50358cbb6107158c13c4da0b48f633170a65512df2b7ee1bafb5cf4afd3fdc90e7b211199140717a999150fed776d69774d14d9aad63f5f51c64bfc94c09fee412bcde98453f28805b9f88e340d352be0854c7f3cf6830ec5777facd07196dc5b892435e35ea4f409fbce6232d7b2ab05dc5ccf0b9be7a7202f16f470cc1883235eb0b638c659ab61bd382e21ab09eddc671496b2f192ef53d726295a0d1ef85591dd7b21ebc145608b3a8583972d758113878cea225d46215f6a49b236ec36f4665939cfc9c08d358b19788c7a6245bf9f30e4022b37ad804a2486b88e65ea06eb1b41dcc3f57850bafce476837c6966bdf3dd18e9683da83d3878a3393fed40796e0f56a5efca65ad09309ca451440e117d9f19f751def433de9ef26d39f066619b1be3e3ccbc0cd1868202e69a8c845f620b7646f261b3b171c4cc1b66c4f086829cbbc177f8fb67393b1c6471fe8b257e22fd70bd293ea53b12c8a88c4ef3e7df689040e8dec2be58bc1bf6a27c94edaeb4366026fef4824dcd9e0ec5a48068344a936ef4c836071dcbe992188f2594b1fc387a244db7fe0f03fae50994a537ce389cedfe56344d3679673046b2ad69933891cdbb7e5c9c3ea367a3b215eecc42d1e024628751a29c5c11496dc7c1f2ff274f9c699b798647d6f6e75ef5a618a55262505e60a75c51e34770023a55a43568e4bc299398b1f4bbeb457222e8d67544a91af32803c508298ff36e694da35ad3e0af6658e072daea7f769fb74835249cbe2c59e7d5552fbaa5d4b8c4d7910452261f336d7b207871cc91fa175fd9dfe0fd9d4e615288a17c5058aecdcb2a4ced1a0cdb9d793aed0fc22a4ac6c76804e00ca4943db9d1da4098865e5b87b0dc063790c8c75709a664db255ffde2f847c57bed8936ba4276a8c9e297060ff21c6d09c01ffdb88aa95728ac164c498b67c6ac3589df7258ca6fef119fd334ce721127c6e93f49ece335373d126b38179e7d28ff40460461da3a93b7bce1dfcb4b26dbafb689441ae4dc35119c2e8c9b0e0ac964cd7b2e536382eec93df005f62490bcef0694ef47a05c0f73535b6fcd9c6998c11eafe2baefb3c5be466a07f9d51469be2d0b18e29c8b86b1b9d1e40c9398e627ac533d442d3ff4c9a8476fb74932f9baf91600d93c1d955fb4bf32761fe8ebdde8af9fca7a218bebc9a9f75d807a8a57344cd758f5b84f489fd00d7cfb4c09e6306bf2c6bb1bddb0191afdcc99ea152a396d149b1c24f6ffe5f26559fb9d213a1f507524045980ba7d8a869242a33242d5f4019ba436a25e2d0214778724d4b95b9eaec4939060652a346c1d64bee9ceca2ee48e56f884cc65aa8b9b9ab4210f2d949849cf06852c55d1c5f4303b94fc4b046452e2d2895bfee58ab019d3a5d0c02d6b36bd28e4f505cd558f2fc7d5558703b4106a52a916053827f5e508fc23928de98fd049f486562b805c84ec1ea656653aa6830b7cc8455711e134acc52c7e1f554cfb642a129cb345da09bdde7cf5c3ab65cf100ee33a22c7f854d2a0e7e45a37bd59e53b6c1c2cf7b56e6ed7c216b24af31a8b0c5e3bc6b78b94fda3e4f0888353a89774a39ea5e4b9e0a10398764a2bb03c59f91f73ca6e7d2a02bc79bc6a9bd9d782976d49ff3880f54773747c787c9f08d1be2acaf02288b7cfbb7d0715adbe4536e1e6581b8ee71fd56ff1a728876d377a3fc85dfbee0515ffdedbdde88703c92462e8f0920f6aff64673f5db2ab1b526fd6f87aa4a367115d5b6b1b143c2d2e37d48ba820dd71908f0f1f39f931e853b1d938d981614866e78edac1bf770e50138ad74fcabd054b64c4c3296f9aa4edd305a0aa3f0feecfd3a1089be254785595a272f605d2546156ae5435a2a9cf2db985484c6ce3d50f4978dcf9b274859d4c713899680c5f9c737d98db310d3e791e0298d1d2a706f0384ca868f7b9729866084f3b3bff0f447dccf648f867c050c6ce043f162a9c624d7476c811a9959625b3c178458096850dba4050dcf04dae5a17c4715846b35eb8dce3512c92274652a13906215f3a36117b191b515f596726fe3a0fbe9f04adb6805aebc76bbb83270e3b0962fbd4862f160616040fddc237e7fd15db3210b1979ced4ca529e6c1f7251231148b7ac27ddc87edb9fd8e3aedba82a19d60f30f44cbfccb2df746834fa726feba821f87cc08c52b06313d83ca8a241a6a5b326a180263d74bcdc44661c869716912936e1298e928ff3359afc8871e26fc4738834b73d3e6b1cc61a14ba309d24c6ee9624d21346a40e40d6e51be8f129d2cfb35d17b5ea29e83aebe2f3399377fe90ef52c54cdc6dfafac989a24c7043de3f2390463123464655828202aac4a9189a94281baed359f6d48e2964fe66e31c6856e359e7477d0ddd09b9738c4cbb28088f65cb03db96ce282a9a0126f76db0b0112cda5ed98145d7e2d4cb386d967319ed50c6efc232c06e72fe5511279062362c2a197eb5ccc21eb0f1682157d5d41ecc632061606973347303536940b36b6a47f83826e9b3d4c16e722f3a72e5cc11969df71b85c483f113bc59de24cfbcf996a4a7ead0ab04d42a114707e8b6e40ad0f0730231e3603df51bbc6fbcd2eb468698d3051bca16714ce351abc6b8963b0ff7e3229aa01bcda0fce8529b679fbebb0a9e99b0c9b07d519878ced8f8c739efb0fda3d389b4feff802a4818eaf89d49d2a902ad588396c685f0055f945b336a923c2b4a4c9f5642a3be62e6a4c49caaa02e78b453b50c1710da1fa53626069bd8b45e563fec6952f60f60153286d1572df89e9ad73087d2ef882e0de823aa5ba55f4f770f66a2b182afd8c3ded9cd77ac69b1b336b272f25bf96a73d46b622a1c4f73702461dfb19884c9b857b28ea5aeb966a88477ee307b93e8b3cf7bff8622a11c46525c543237099db030b546b168717ab07e17be8523a59fe50a58ce6c0775e38805780aaa9c59137c42fe0ce5619ebfbdbf2626c1d8c17befbe26dc20d69431691de9493ffe4213a36e02dc514fdc2580b0c4a56f58a5dfcafdf2bb36cf26ac5402ed442ab8eb1bb5358ae70b9ab7f39bb2758a35e3a908adb1790ff889e0259ad8110b6f03fa8e744630a9633730ff5f1cfec46a51423d4e1d60afc0916dedd4518f509ebb2bb6edd17f3c871ab0ae59c4ce479574c5edfd7def6e2f1bc84a6715839d3f7b0f58e9b807c1bf9b8a00c0f62749fabb827382ae83fb32d025627f46ad2d00a4d5593521d402d1448c872739ed2b6f2fb07f4eaa33038e16b3c2cca8d6b3fcccba1e922068afc24b4c312791d6fea2ebf830518095e142321077ae3a7d527e9ab6fd916469dcd0b9b804dd17b52c9e50a76c548f9c5608122b103b304921be4c374b6cd9d9042341c7533ed3af60d689177d36af4de0f352cf3e20454b204023d2d4c071a2e33471b86f8b955287c33609645595b2815ffe6bdea51b10c8e342ae72eb83307bc13c0e14ad8acc064b3c2b3d77127c4888544932051114b96a2a982f31043d55f7d92f67d58cdd6f80d184206f01db67bc31573e9b48ebb369ef5d2b4fb01b4af405062ff250f6b8ced697f510e597f26d1a0bf644bdab45bcdd1dba482c55e6d3d98bcc7799102e4ec7e918793b63c7a6814be93c70127abe9f5ed72f6d8a42fcb6a7b9c63579df4d94ece6865db9ccb1419baca2cfd076063292d5e70f397905f2206c767e4b3e49eddb6564d53e80f98de105eaf11e39c2b97552530dc3096842accd741526eebb1fc79675fb9f5a1a90b05f702cf747c05584b65f77e598f61cf7823f71592aa81cd5006613bcfe3106c4a625da3045d8ea6599a5cf003ce00e0cc3b280fbd21f23a3066166096ce698fba155936ba50b07c9ca2b2a37bfebfbce1ee70f9fd29a58471463fad43b82f462aedba8ee1c1b5eb7c4f45bd594a6645e99d35d96a836515cd20f83506a11f3258e40d94f7e745d60a87ea48872c3b6911b3effeb7c16e0dfe6c9ae13f7a07aa5d0e6d78f5be73ba157b99f6c11261cbe320bebca3af5e5b29a8f1a6686b3249ee8abcf29d2cc98644e83a27268f0ffae39f8138829d315629f691db2982cc53d126b3e89f6d4f6f0d42718f113bcc2826ffc303c0a096d0506b1b0066d09d6cb65edc5d9c7e0a2473cb3b6a8ee50f855c51d2fea1e7cedc6ff28cabc40cd867760278d39edef970ed054a8a1e86331ac25f80f2b66d10f2b4afc3d5a25f2a6223a03cc26b3e1e6e86668b0236564ef573b028dee5b1c0abcb5364865d5808a066bbfcce1b1fcb143fb28184b956afff1e4f6ffb7b73166ee916d1952636b20dadc1075d5479dae904a76b4ab2055122b1de61404fa3397c394f15f4d708ef0d3cba819a1df6473525c8733e806474351047f28bae300ab92cb9bc695fb3b2022be77a9ce4e16628644340437ac2d92e7bd6dd2fd2bf664692dad8cfa9df7d96a59944d41816d89c6a0731be166aeebdcf5d856533cb51c86135c5753a962da376045b40e83b315019814c6c6ea560f7925019aea010c16f85a8dc1b3a269fab43ff6c4c764fd002a36f8629c0583dc4103267996d27a9d2475a53c48a658d83224a744f6e742ba163c69d0fb42e62d5905fdb00634c72d35ec8c714c5e4a19fbe8a52f9bf612d81a04062bf1ad5a87dba2fc8445424d9d469229de64a5e70b00eeb3662974bf1cbf1ebd14b9a054aea4790d3784e7348d69fd924190d1bee316a9c06c0aaaca0c9e6e81a6a1786d102de0f1c86a5173074a22372a7dff466104a558ad3e48f51df960a6226bf447d4df0b98cab53d26c6bda2c00a667bbaad47146a110568732ad7322af79620cafd3c9e86a3dc0f2d1aaf5ee294a2f585f71c84e795199fea980260655d1e3391c5d95202ca9f1ec5b54d9bc82e4a6b007e2c467e6252cb709b8c0ec5a5bb41144eee797fc3f6f4ad16f29b3320f447ae97d8f4e2721bccbebc9ae7e52b8ea51da29cb3de1cc5f6a1265b3dadfb54bc4e7b67e8370b283adf17e52e3f112164920d71532678a459144442ad074f5cb275cb92f22e6a5353786ac6b2938c03af940e4e6dcc306886250b6ce3eb113c4ba77755926ec149823ae1bf60d454389aab00a73fc8be5132aeae1a356bd37b40d3b43ffdc5a91c09503a8d63ace6a5ae9254333a90569d3bca4d7f932537e65a57c6bf894513b365454c6bec0d4b42ede45daab0baa80f458bc09e2d2df8ae447ea0ba1d07abea63f89f00251f5f47252001c36cd0358362a434de16547c4daffa4063bd97d6aa6da7396cfa13ae12bc693e84bc110616dc860a1c89a96eb807d549949c8bd35e01618fc8e14ce63b7bca4251c5925c454e7de219ba6ec522c2d10671dda73ea92656edb4d3a84a09448da35438bb5045f76b03025480da5062ec469858747adec4732ba3f22f9baba5d7b911b557472c390cc58a08359ce6812ce7219aae4dbf9faddb67fb3bb646dd8ecd7d2d8656d02014064bb2139c7dad73fff932295b6baa26d2d7f51887c320bd06944fd2ffa794c0786becdda953443662f054d292d4cf0608e69ea8fac42337c3104230ba84acd03996951074e0719d8a2b01cbd1b689da7a72babb4eb892f0477cef002f90340f1ec4ac8f8082d9de16a93fee4bc016a5ebb2e538bb632a91712bc598675b62a4f28fe3239d7ecc622cbacd211aa6224ee58125b79098c0289f005ea588b3af338dcec8ae15ef685f23e091c82c9ce572417901e09b43b510cf974a374ee28c9118fa40e49930e628eef890268125bf8988a3da90dd639c3a42b6f9264658d4f37fecd3c6796dbba58c7be73ef7462c3456dfe6cc4b694f4caecea9bc4a876cd3397dff483fd3da8281a68697dd7e50f4e26294c33556be86570c5910e8ce39174826241fd3652c81809044c321c8a70225d281cd2f0ad6bbc64e9eb5435412847b06e051f07fe266f04fee09096b656a85bf400dd8ffbf7f71fb46a68d77e014355952fcdc4efbadbaad8acc5fc4c93ac336581b922715c8e99d5deb834eea47d0eaff975515075726579d245dff5c0f96f0b813ea9eb374a26eb832d84a77bfdb0a3c0011e49e42e20c8d799f1e18c6bafbb50d2bb7dac1a3283d899f6e747a6217e92b3a04192a0cd136fc5a4831f5059d7b58a336284554a8a1496e957f590785bcb1486537db4c4c7eb2c6c3f5fa87db4d2e7c9e2065c9545b784341b0a2d1ce1c7dd1bc2694622c2c0b69b82d6091756a03f71c6183a719a42f216db828da7480fc1df95823a107d4b1441e2cd852b31b5f53155b01e307fc5d1d572061d4a94815d8e0a25d9ee93d53150d58cb7c6500b78e770fcec9408208f927a7a8d3293457830f286d4cbb95463342eb5207cbe88f230bbf2087e4f1f640bb390c8552d1110f22dabac338855872ab0490a8d6383954a7d1b75833ab3a7e592f9149e95f1ce1a0677f0fd52bb04974caa0578f310cedc9b21a13fb2ead59d067dd54e56a491bc7629eac8ed7ddb38ad8a8c7388d924ca4db961a294a3e66673da321edf0a8c3b0f193535aada0bb09b1034b9a66f7b425d6bfee03d1fe28a6fad9c62abf631710f8cd1f170378af23571dd709bf63d75c0019046ff533d282130dd083597c59393ba8c8d3cccae0ac7543a0bed24b737161bd2e0161f778c37a452b9294540780bf56f8e917a4455ec222aa53907b80f2e4f7d9b6c178ea4a73f2e45d937294c4e6785ae41f4c50fc7b843962f38afacf5cde6ffe23d39d870d4ba7161ec1d6b5ba201736b5e8a677611f07dafd2687424966461b2acb3a4d447fd2b6d8c7ae0eb69e140abcffc9fb1152ba418fc7ba72a0857b300abd9099593fabeefff8f378ff485e4c821f18683fcbee8455faf461a5ec72f64d09ff2a0dd63169afc940fa9fc1e7e9a5398a4887ef98387c66db56cd91606559753ed04929deb9c2feb66b63b6133ae804ff30b6e41a64d1ab6c0cea8bb3507f484fff2e926dc0d82c1caaa0e10b2dcb25a804fc36355a887c7263042a66979e570a34adb6041f2c31c15c2390de00a5d815b83cbbe8c7da1ed041d8e0d35f8dd396f12b703c1958ee80ed089f7df0fe2a64b655f51687c5d11e4c8dff63d9c07722ffb979db6918f30491a36f1f7d1c56fe13da767a4517615f85fe1178264c67953df457b28abf712ecbd7aa0eb582038bb4e468f3d06a1a7e8fa5f576522221e7596691c7578edbe36bed689dfbc56f1cf47ba343ecc618d1e992517bb5afd5c8a326e1f5410b667fec93ee873befbe85c9f3b06ddd586a7fa7a85472c8d975928b083d773d16495c4bc69b38617078bfe0311062950f097a7621d0701b7221a6e763ad669d602c2bc992d962a10c4f9fbe9fa807179778e31c63f157258bec4b2b712ee1fafe9cf8f49762087d4463ca055a6236a0fb985309c977d9944df1775a7c1c9c4bfc6325c15492ddb28bb8cfe4477ab8c546892e4d3cd327231245508fa6122371455c4510553497708ef3fa8fa574660bb4192419df7a773c20fddb8e1d260c498edcef6e671ba6c010dcacc1060853025cf723fb877ac9d10f508231fd2a3bef6719ca5e601884beea1ed4fd0b76d4460e94a394034cc8b09b06f76fe4069ef59ea8eb22f82cb8ff3ffc89cfe97eabf798578c6d8ad1d5cd7b6aec3f2851878b755ab3c02738f5222f79d6bbaf87d206da656916514911657fb94f5954bba94102c0ce02fd15b8dd6c1cd9778c3aa848f2beec34915514b9badf83b71c5f459c7e362f8b4a5ba23fd7dc644814e581a8d465173a7a24899e3d72352da66f0ef952aa7fcf534de1a2a5e693b2168c9d95aac9cf0da421a10a30be0dca48131622474b5defad38da48ea7ec76dba2108dd7f92f27168d836fe80843595852e5171cfc6c29d97d452622a53004aaf556dc8a1c52e1b7377f39ca612edeb3975b13bad67f7d7b88709d9e9b3908bfd9925b837043897f32ab02eb0d13ee7c750104898a3afaa0df1989f6a1fa682816e0c8ed635df6a74676ca6b9642e8cc2d0992beb0926c75b84c3c293ca9c6e003e1d72a1312a6fe10841570e10b3d86ce2ec303042ea40648c12db8cc603e8848b8ba7cece3683baae3459954b7bc6a34860bea5ab569068ded9be37b9295c00f7168baf2b81e2fa5080b478815a67549188bbf895154f1e4356c36f80362d9684d56b479ea52957684e46d2184d2a10e91638ecbafdd292df218a3d37c8058470735bd18b92d2d213592c309e3a188db08755d61859645439db364f6aa66d718292aca6c338c1d8e55f54ab7c4b73be405fceaa209aa6e1651266ccd74582ba1a9cb436db06f35fd9368aea5e612f73aca9336a44ee0ad46bc334bc7f57981ffd14eef29abe133a7deb2292bc134e2c6e678b4e972239dfaf3535edbb12ed965a654ad7d9e77c0b3161f3a94c492ff0a8c032122a05e2c3cca0db159e63dee5faf43f5270a30d8d03a86c266a8d115abdef0ec8dc0f17f353b7d948dc9d98d16d4514906d97c5b5ee412d4275986ecc800c82f0d8a3ba8750b6f20956d800767aa2b0b29a694c0e5c363d78b1c3136261c335abc80c7a2d5d3509c17ec3be8aaf1c0be1913b260ee0adf9e8c4fc5275a422c764c5889264b119adba09cd7afe266710f37d5043c43927d9d1f9a49e0f19971ab80c9d74075936e992d2dea5cbfd0d9db2b9e447108c261722b5624a7e3b5729a7429d6c7215108b8293c8caecedc2efb059c03eeb2fb5f245f824df2bb6dfa977230e116c50bcec26bb443fe894e26ce227974648010d8bf17cce04bcc5b4fa738e05404d32e07134d1869dc73c4e4d1db54a1ee7259fd89c408d391d10e899cec5614bf461cac425c3e2c85ae421f976cfa2cb4b2c51da804e2422d4e92c8af4d497c467c13a9bf400b19523bdb4faecde496a95ef915a8e52bf53ed2a05740fd1eabd38b06f075b82859800d3491a7c26b83f20b03392255094c832ef835d6ed9642782239ef4be79ee9e58d5d0afa48e6010f62ef321291dd28deb3708c08db6480524c07e1c1075391b9c34f759dc6ef6ea90ae6035f33eca303085cc80ad85cd2ec6cb57e884cc63bb8d596a48bf8b688073efcafbcf9425bedddbadbc50ac8f3815aecb31b6b7f97153f58c47f06095583e0cb753cbad1b56f6cbc4ec9dea555d74f8729f6531dab36e0a70016d18dc73838fd876cb9798cd51b983ec0a65bc6d857c33ad4e23eb70b4e732eefab9126bee4702780ef81fe5c730e98eb69b5b2917ef40c1c8a1c41e799981ac45effc2e881e6078a26460b8a75480a98fcbc928218a07bfc0b4496e28c9e8a7d6e5a8c043f712982a9b126034a582537262b4c62d9b5f9242544e2be3cbcfd2e92d74194c868c252f85ad0b24019fa500416b4423f5d28293674d6af6e7579c73ff19ebe8b3972667d54a8a99a51d06d00a4695b8e710c37526b1a1b96c180fa31fa5dfc35a93587d55701e0e629d066caadb80d9e67b1c944c3ddab0c13513640f74612a8800d6302521cb06fe055a7b4e1e16429ca53015bf95ceead885e1bbdd2220000ff1c3787259b566b8edfdd8add54dcab4b139a2e44f212d34299830aaae9f9290da5d6f2a6c8e6253684812610e0fb25bf654a55c3979d9a87ea89c0bb11c892cbbc666bf3687da5e57c12a86b39b850fdf26f8cb66a643368016e26b442491ecee2ead1e91f0318e44b04f61f3a59ea379dac82c8e9ee43d5c58b70a717199dfe204611ad32b00ccae4c43c7fde349fd71f6fa2d663e6f0d919fadb1b6c61b6411b4f51f1e1515979e2c1e851bab2f0216606271ef79a470e2b67615ae7187b92b4bdf3207ce7d39800971e60ace88f9f4f91d73b4f1d0d192352cb7fe6c39124e158c448240c6b972ce4d8bdef03b3bb894e79c375ed79b3e3227e04f18a4e805eea9c46dedae989b3a7f23e6be231f89e2b82e7d3228c5a49d8faf2d786c6eaa6d03b1ea20371bdb9d747628e15aa5b30367406f38bf7bc95156634ca78437c03cde2f57ab1464ab1a1f5690cf5234cf808d73c73a93acb71a043963cfbebf553e18a05046ada70f71ddbcdbf0e3214b149bf6bcf58fd5b5452d490761efadd1f59e0956279d8d3bd24f1cc588d03e7772680c8a1bbacf1b8dbdc50efcee48826e7c0e992e26ffaa69591abb8567d35bd347f333410a7cf279e0242e407a5535fdec6391b268f64f3aea2cdb69f99307aa068a738781a984a1a08527cc127aef63724d007744caaa8ea850bc7892009393204a77a1f35b77313ecb2a9c7f412768823c685be817410b487a2715efd54da76a7087cf46a2b6113e9f91587775d58104c607307945d937068cde5781080b01082e7c88d402959f6633ae2f009c66773c1264eab1e368313c3eec32be591c673aa296c3bb9597d3994b734c4b91df8ad32cdb9e8e0e71faa765205d57c224213a39b670f0a3a261d2e4b710ecdb6e92c90014613d0ebed6b158221f90654404f74194b78fcf9b56e260c84786191e880aaa1e206215e059a9cdad970c8c308b0a1377ec35150591bc8aa399ca3f117b1c8a573f9a5fecc8b0423c976d6ff2028ed709af990c39406a99a2d9af779dd7088f02813aa36154706435a8c999dd702532a83bdc7011f9a21050ae766a71e34f89b40cb0","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
