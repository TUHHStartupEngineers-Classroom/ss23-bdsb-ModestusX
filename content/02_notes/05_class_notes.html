<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"7a99bb5aecaf5d553c9005f14287381b019966f4f05a348f624d2aa066374b674ee086ed48dfa790d459f7e2990ac569f637c57861b02990b489cb8e423cb061e90a083fc19415c6b9b8e9b5c3beda79bdfc90bc679870dfe2cfaaff5932de7e31e65442a9cbeda351ce68d557fa928d276f7845168f01bed9fef3a5f0ed61aca68cafe476156941c57ba8d3d4479e0b9b6495fe04c1347375041125dac2ab0d9e56aff1ab87e943e361ce38552ec205daa425d8c245059265b401ca812ef6bdaf754c756610e61d621c248d1dfae452edc1d0003607050ddb4fcc5d3bf08d609625e153dd308607a7ef94c0631d531f7c7c73d586bb731140ed4f3d2b6a75bff19974d96f3f0c5f6ad0c13f73e2d59068d9781fbc3cc41e67d390deb01415471a64e11b461c7cf0b96a42446db24a188dae9fa51f679d86375ea34414472d13eb2ad93fdbc5c318c4fe7ff096735972a91112340b5ccabed6511e058857694118cf74c2123b6eb4884d518235825e48d6326cad7b943892eb4cbb846f807cdd24d4597dd04be2148aa183d71464ff792e6b8763e093c3afcdb858df3f317b20a6767625444361e5878f592b145a7fe0c6713dd26bfa60891aa6a1bf6211f5a7271b6632d1b9a78ed63bb7721c79e111760886a7ae52f0cd600d7dcc689cd59a87327bbf6c60ef94abc7e7952084aface81475ec5ee619a62b87884e4de415dd7ac920a99602f3ceec43cc9c66298a5303e9c97673efaa8a11cb315d5d3ab5738d663d171e27fafa223e081bc7e5cc0694b47e2c86c24e96bc942705aa477cc186a02be2aaf08a039da1d57f1cf98dc56e2faf4543b44f2782a6a26973145b7c67c1f499e5ad401d360190568d8c954cea435b908ad4140fd65665dc71f34cde7e6622426973ce104f71659b57b45a1eef343b529a3242abeb9c9f4b041cb4af746870cdeb69846bff7c48a4d17e0eb1b3db18d6ab01ae46dd6975628975001bbbab943054543eedf71237912542e9109170ea63013cca88cd32f50b6cbfa4881eb66991fbabcb8732587bf6ad37f01b33f26afe8a7a9fc251ae5d96c75ab055085fdb313cc75aad03d08a706cdb2e5ee6f0cb4d390eb281ed164f60cac848620929db67d8078fc7096db782ac8071cbc8545510454f87c87aa72733985bf470be619c177b8a3ed9fef9b0d7a39320e618b1634ca1b9ffc8adf5df4bf23e6f19df071eb0b82bd5087768c7b0b7adfd1ab9080b27c492ba946abcc2b1e00868bc78f2705e451ebcc29e2d199fd7337a50558ab1e365b9a66d03f1f338db7fe2b93396ca5bcd796bcf4960ce64baf3c0ddbeb662f1c579cae9a79a29abeefe9d46d24efd8aa725275648133c900681d9c90c7dc1edf1f1e1e1d0134a091516d457a86c498a58c6df83cc36f2160dd82d8c992ccb2cc437ed96b05afed985918fedf624e716d913d041ecd46a851ae7b83cd9b085c780b398e83e8e57e6cbd5de1103b463860c79bb21c7eb211eecaee7382d9e8f1fdf9921f93a415b346760cef0066bb9c3ff10fcd03ad8d37582cf77d0fd527edcf8720bf8c4113fc9e50d3929a5e78f31138f9a501a97d92148b7c1725281de96c3509c8331a7b736437ae84c76d148c0b000da08e31a0fa6a363dbaa99ad41557c3c21174d3d5f1ab82697621f1c0fee24926178391a40de98d6f5b92eea48b9521fd71578032fe2922fd1846a23a62911c4eafb5247f9a583f1ddb3d2806dad65e158a5d77c744982e496e2c1f96033b57bc4bd020baae267546bb95779061a2b3137868bc6566797a54a439d8d5af43e463c5ca589a6cd94ba3126da43b6ee10dacf1afdea5094769bb28913b48286aae069d1b468faaf438d44dd5d0207216cac220e2d873b0b57db9b3975e4eed4b37900dae98dda97c0239ea0c33a22a3a4be9768b46379c3b811398199ae37fa334fcd44e9f45c80587414329dfc6574e342ee9d2342b9eae3d9f3f1272c857fc6a3b18be553026bb5863029a6019ebf42fee81044113a69facb6c8bcced3a714deb2c0cd5f19bf06f04b270f119afeca83857b71e2c56f0c21351abf233c26377aece6ea94d612a2bedb9b80b5f0bc2afe6ed99a35d3c1a83865205c9158ea328f4fec3c736c99ef22e34c2d04b6dc650050f4ffbf2dac52abdc00bebd7cd242a1e0ebf657c68a91f44e9a78390c890d8f74c1406c0ea79bc18e12ea648ffa8fa6fde6f8093ee155c2a64892df7f119de140db4dc4c9f6b3770fce34066339991f10c5ec7e45cd831b48bda7ef5381be828a189ab30f2decbca74f5dd32da0a9d34ab3db5540ff242c3e4951304d99551379f331fdaacaeedb3cfcc24c9bc843411645e7741e8bdae449bfacaea1e63296978029cf2c60017f9c58e9e371fe7a4fe3c2c108af049882766018f0a4ee1217727b710f47cab58b3c68119a2799638554f999bc0a519679b368fb483c16530bf9c7237e0e0be0998bd538ac271d85b9223fb6bbaa6ab1d11184e308c3b98f8221ccd3bd2c640f9a8a7229515f11ccb2bd7581d0b7d45b5a43a9374ee663d80195090597bfa0c2a49d7c708bf6eff94e32c7d358ade9a806bb8963b945f756549550b172224111b96484843c672902ea979c4e2a2ff9132a5652d4badcadde4c21520486bc80ed1f8524cf5e57f4120fbe99162366e32a1ab624d4664357686bca2a4681844fcdfaae3b985587367fadb3bedbce1ef0e2f16900a19a6718f31d48ca22aa0422468a3bffee80aac3257aabeac44fe7cf6023f57e0876d6ee1f515d45cc6893ca1350c38f18192eba03c1e13bdfaff37a7807a2e33bc7cc5edee59db07269c14dd40516b137ec751f21326d63740a5fe1aff18cd11a8b87800478b3fa0b7e54d9cf631bc3941dc7674eba8e8c837cf0d1210d02e5b4c13ab5a5e2a513c75114ee1cf1f647366896af9b1d79c5f0a1d9f9c71cddde21c721d6382e67c990f946f742f28fde9c91cca0116da6ecf3bebd2cf7c36ba091b5ea57f68b226977f2b00a90b98a5f36af278d6f24b1f55790cbed7b4e2bb77ffa38047dac827ffecf781181b114914c8c45a8bfb3e021068dcbb004922b26f0e97e9682ad46f4825cc14bdd04c58eee77d311804dcd239ea26bbce7f762bda411142d562368f76a6d831ce2f842842c6ef7f01d0597e1808f4734d2e117888e8a0d3e386bf491f968886582404df98b39f46dd4d1b4f224678399ed668d4e59f158151f39882028d3ef009889e69981ba64f6129c3ff0fd5a914c64315a0ec33e8578601c80201861dca6e7c2125aa251d074f73e0f10c744eeecc551b03d08721b85d0e874a532a723bf48250756627c0aaf6f4821da7719c4c7aa512c6fe12df5ad31318b1fb05cefd95a385e74b096aec3eb02335753f1ae3aa6e12c1878a805cae924ba3a86f231589551baf5a5876119294ddb5e2c33a41e22016e97facfffc802ff4c0062615118b27e247fca5751276d5f20dd643c13536a1ebd42e33eccea45bc10f68214bb85be9c38347bf29b5bc16e7e5164d91d8dec62261da6560237757e50dc61ea9dffd538d1f43685eee9bd39db0d601f18a9aaac29328b1095e7bfd23ad5348f4eaaaac6520df1e1de3ab61a2bbdf1cfba1eb3ea3efce3d50370e95a731cd2679e1d41792a31a17fee0018e9b80c555c2317fe37b0fe7fe5996c2d173904744bb7c11e421545620b2d0674a7d57ce69c2105fda25f2052d2e7535ddb08ccbf472e3e3333e5ff89d1a41ea84256a4f43b882d43ed74ef5dadb62317c1bd4137e24908152e5f203f8e98f0038aeb2558fb9c05f4fe442a42623c9959ce98c7da22baf562a923594a59c6bf0aebcc7a4ca2429fe8253684177ee574762b03e476e12c7454dcb38494406aeeb8bdb8b0e15d2d73c28c0b76c93ff08761268947339ff63999fda03eb0dba24b9050b6efdcae26bb2d27c5cefc5ab39cca999a157eb156327479023b03bc81941563fd27766fc04d3b97d7be050e9fafca57a7f37b23df240c80ffe6a60c4764a8657093c38402a8c81445936711d426e3a110a5bcddcb12f50c43dee78c2be846aefb6233c12be454e44dc64364f61e2902e44175abb43b1421921b8ba7c4dc3733be05ca2eba61e99916bba4573e40cf3ee2b741a9c4e33637f8044099d7e80e99eb15fa51e0bac64a7f2a40c02115ca9e541285bc5862e7679e24c4033301ecb87245d31dbe5f9684d36b7d8946d8cfdf95a6a083e6e3c9a73967ae3fd76fbcc294a33241b75fc487561543d78dba02f989a9f05da919622c476785c841e64c4a483d7d0aa1f483968f87443a3fbcbd84e0838d8bfea2cdede47728f4d0d6b2ff12a70672a7b3ac1bfcb6519c4330608a883768e630038c887d816c2950172875c5dbe06fede3fcc53b1ebe56530ecb3b3d7dee7cdce0e8c00ab9cb914a374e3c9bed1e1675f04b5eb2c485973a18be7c21fbbff921ae12cc5b3cc2437dcdc3d8fe97415e01a95a42dd0b40a20b5f221b5aaa0620306beb6aae6f1a443bb6d2cc22df11395b7e4c8e5e0a88173490c548366b6ff6dee762131090eb9d41b0c2a60c8adea90d8626f5a0a2611ba8319e21afd0e68ee5ce9e2a27cb595ec8356d58c29871d7865da3cce9c7fce3e9126bfecdf10a67763f722b47d7c2790a7f52d11e5a4e4d0f915ffa3ce4d6d94e23730ee6781762fb2f1a25b16c674e70f20deffd88df5dac8e84d1df8db91f44d6bb36beab4eb31c8a18135b45d87e7f82ac260cbf6487921dda9897d6cbb4c2f38b514e3033b08a8ef65c50974444e0c06e8d73b60301c0a9191626a14e39dea2dce4556715adaa029466df4eee2a8525871f623c5e60c1909a31d8b3929e68dd28e59085ec756a414e1d04cf4f6fe0b06d19811a2503851232f291f51b309ce6b8ca0ae1f066de0323abae2645e19fb1e3a4ecd948608d8b0208b735ef33581333143a25bc5fbf03c190e386261bc83decb6080869005559ad0662363a0bfcaa993eaa840ad5f0cba69e13ffcde45ab1ab9020f1ba1b778eb03ba88f7bdf39bf9517e69e3e7938fdf3bb87caf9bfa98e1c313fe11c345342428731d53a7cc9cdbdd7e4aa05eb685166394dd84da4b3f482947bf17fc25a73acf249952ad613b284913806b46ba876bd128e553f7ac5dd7da185698a9bca143f17877f2d98c8fd15dc4db6c2e1cb064c8af3b238a8c5d4a723e7a078c1c9bab35eb3ae03c072b5fba71ab83c54c91efc47ad715b8eb7df10b9172a6da36224c37a27f746abe57773cecfa5f5b059f85f160bf4a075127192f93376c879f1912346694c76149771fb82c34ec0eb24fcb1dc01c64ca0c6a00dfa653c138c44e50cd288d5345950066755b49f75ff3ea6d5a6ed3aef07ee8fbb379bd05bf80c29f1567e76f5e47e9a43f97a992f8820eb46db2367957092c916728efebe6c35663504128a80644432892314a6efecbbdfc0476797630b6267ade3c6ba5c9ce6e35634cb60f54b714ebf79829f20e1b2b502ac1202ac83109d54a09d532d587692b8397a6d45c484b37f969d7ee6583ba3bb84c0e7809ea494c8d5c815beb975c956c4a9be02e9be5f9fc09349baa8f9e68a06e73674969bdeaa4cc5c282f386864094072108503f544f3f0e81c0e254300e675ae3211207f616455082807a3c988d8a3224a535e371c95ff7ccb0fc93949d87fdcb1eba36377be335cff63a5389c357671ebe1dfae3ff38883a3d3a59939d4a0ecea722915d976567b4392d481ffa190c6623a1e5bc4e8c1321d577c2b5f4b0155092b3605d7d3e4ec3dd069c773ab5cb0c83d24af700304185f7eeb5c5baf52a1bfcbe7db8e7db7de62c8d180aacad9b1ef1607629e73f3e5059505b8b7ea51d2dc840a5ac651a5878d4d1db441873229b128c7b71a15e63a0aaf62ff6b6c4f51f6bf3ee4ebe09a6149db538adf03aac966ae1d8c88c33017498579609b26b76689ba832218e54fd20c5a681c320a22a0cbb530f80e15b598bb3d23acb2a566728f8e873ccc65df59b88b0a2aab05fb8cb496e9dbbabe83ec6ca0c9df8dd11531d77011a07f770ba9f04a394bc383c511f04ad996fc9f2c97b7482089032e213a7bd8316f1e5a43dda932c921055663639dc4b5224aa6e40756c62e0a58496cf3d3d487dc71cc387fd44e4179e2433b65b6634399745e308a1e62688fe70514ef2bec0d73ec155cc1fa9104978cceb8ebd1dad2594faedfdfe4a17e01fae8f0918a2ab9e34bc788a40867606d718bdf4f88f64d373db807d554dee505a3906114e354668b83f1c0691db3bd84cbe5fe1465dae30c5df14ee16c65d0152c220fcc51806fcdca434913e51a0517fadf543384717745cb2968cb3dbf2ad44c43e3fcabbb855fe58ad9f2e481349e0c853ac91f72d2e33b519ef623781ac81f7d9c355ba2886f6a04b89b5b786c3ac8274aa9f65eeacfcfd2babf52ae974f36e9dc16523f86343493184d053d262fdcb8cb72c0d8cb84c5eeaca3c6fe5761043eff1ba388765b5ffb221dca2d74f3328a22821614e9415cc932583042ad2409dada04eb0bbe2a953a6f0c3f4338b0a9362e32cc98fe6f5190bcc2325cf1520af4ba3dc0ddc5b3af8302bed8dae9f458c2cc0f0dfd40fdbb4cb155c5b3e7094a72319c63e515b3f988f0712ce2ee62a4563a0fc638f1003dc3dfb139e53dad5985a5e89a1e3fb4da49122ba0abeedf5fdf739861aaf6a957365104c06035624bd46e043d09f46341a14e29fbf8736e9e64b01cfbe7ed0230e2cdf2ad3ecd882763be0c37d2b96861e4427893367e218a3141557ddc5a402071519cfd890cbf3516490333c7a2aa8478fdf3350042dc56b11f1cea2bf002c0959b33c905a01948d118c4930a40560e6c161fc509799d8aa45bef76bd83d1790ce3a2d98a8572c2b420f85ccf542c23cf052d6290d6e9c67d92123d704a55fedce58e3ec81ab482a30bf599a651105657b9da3159ea9a53265fd087a8444f4faee6636e112fc7394116bc586d1c825d63adf7c46a27e8542982b35ea3b27cbb271314c95959908b31fdacee374f0908042ffe02bf89a4a78c070777a828eff2dfdbb1b36e5025608731c697130daa2005f4ac0ee2c5733ced8d859cba9f0cf4b4e67036ab4a80dfd4e1c3927e9e3756b661c1f978fc36f1095ad9893e021f01cd8e5e5579f2ef6f55bd65d5d666461f8f8c3584885ca400354e26e7a803590ccd75d9a398eb2b8c168ae21cc05b7029c022d921d71703fa990ffa455847510295887e0f6145945f98072aafe235a09e1e031b17ccec1f95bb4c3032755a7fb9b92a1ef40ae8899537a1c9bae6429f8f7fc4beedb01dde330258443d2f02c6d0695a931ba2ef4654ea68fc44819bfd76a78e2cc94e4abbc3a0c53169c377a4769f03060c444a5136686d7dcb3a565d666263a2291b52df1f48b81d3110fd55019132ea25f3c99f200fff7237ae1e43e769707fe735ca4cfefede12b6bfdca59ee06a0a40672263ca752829ff96fadee5aff58445aa50d7435959bb260bcf1440bbcfb50646f7386f664caca88c69b9e3622de6db0e0f0a6557892aa546b419507beef0a8436a7c1504250072cd26ef3a680511038432730670cd190f2d32608ef76b0095b5c83255b22add4138b7d6ec15cf54f418860b4dcce5e1bfd7a56d3fd94a2d3a01f38ca5dca287bec9fe82531ef4e014cd684f7eb5f03a1f6a1d7c067e1eaf6e8183a0ed8742309712a91b8439cff4f7b176b9625aaed5f8c369ee196c5eb6de4526a2b972f061bcd1d326512a84e95e30e9e1b9b67c8bf58aa12ac429d1da3bf0093ac31e85db5aa91e4d148805dea057c153afdda35820a41882b169f2c2a02e3d9c77b8c7c74156fdaa60b4eafca1f99b0f527cd4d5e7f801fa7a7d902b6ca5c4d36cc28a5daba41b560a7b2696cc5824dc6657d884afae37c3b3ff070dc6be25042ce790aea9ec08ac998d82dff19c8475b4160222d8a4647c5c481c7c67c044be73bd33383931b2233defcabb1db237373170e76771b556021a06a84ca56388fdbf058ab2def3a101a452bc7275997919ee35e86b1782d97173e5a8d3b878df9b63381caae45d2b471b5c75c7d392efcc7cd2f6d4542c25119cd88a8807090404c7595d7b51de1cda462b916ead28808df8207843fa5fb2c42d3d57f790a92af3a7913354a9e3b4d22bc108f675dd9e49fb0be2a2b57a4c10ed6cab541d862c90674acee6b5370380024d6287c8cfa02cacc95abf9fc2fc83892d441c4c80a3d271ed0ee1dcfd3d8a447be5c7f67a8165c0234677eeabcf18f0bcf9e0ccf87f45340e45005bdc3012eab3f998120af152e14e266d3438a0bb49f37ee3e97c40e51e109defb61d3a650fb9f9bfe7a4f77603f72fba7e9d9586a63197e97cf842cbc9992b172e09494a00ba46c05823d40f3c526f12a6f2f475e96c2279546524fa08858a77bfd9a02d56f24bd87f0d586efda2138efbbc2bf390f283d2e462af53c69c8c608390171ca0320cc66b7f9170a979f5a16242da10890162c11c020fa0c70332c01df5ba7bcb7c8d56955831e70e9ac4a6e49049ec45a140448685762d20cc7ea0773d44f3278a9f19a90fc33761b7c39d8b5401cd2d6838bc935ec2e94d03d46bcfb65e7b3ceff2a73869d5ec329c9293f920fc7d7fd610e9a9d8e2af8b7e9d23b4cfbd2d484be3509cc958c0c77008e7713f24314717c46a8e4f82450eaef70c4beea248974c81ae4229f1875b5ce9d1b9c3c49856c00ccda4dc9cd3f6a6939d95da8b279ed47cd0eb717740d2e9638af987bb2b477f2976c350c18177137192e3c54ac2c47422b97e8efa31f7a6c96f23851bb31095a2b4d733590c0e8d03d744093dc8261f10df77d7c1d7341af2a24a9072280d3ecebc88b622014d6865287ad16434d336b59e13f5407dfd1b671256430ce9574e304153899b7cdebd03f7944925cb74a6167b92b6a928dc77fdc4ae4c2828b44cfef279c86a9c351ab2a6dd2f05de508ad0c459ac71c8e4b619c3bdfe8871b03cade9214d8eee2b43a7933f545825f94fdd816d9f19f58548d866ce3f81880fd4c83c0789cbd128085bec01739cdfbedfab2cfcd2b2c1840ab0768361fd9ec057226443430ae846791fe0435586ff2f28f9d92fdbcc4e6a769709ce5f222baf098024b309a03b5e2166bdb2e4b01a2e87cfa2809ff2f95c6f739c785e457b4190678d542df995db194099d21a963993c8da339d4d27bbc0a9715872a17579f70af1794bcc2c72078fc7dadd809425493b2fb7ab3fc88b657f3ce39fe7236fb8d5a71a2ed4c1d663730964bd7de86792c0b64ef768bceb48f38f5e851e0259a7365464e23ca95a7759de723e87621f165fd9c1c372b35ca77341c729b06fc2151a6891ef4f9e975a6b1e4d09f16358d8de091e34ccc881e2f6fb6447586488518e8f6041d970c7b39124ee66f2de420b32a70f27e8082beb73dda24d95ca0b06c1e2eb46953f4847f0693d94a53342d8ce51f9f582427201eaa73a05568eefa184587e0c3f70381e382021545270a30b9b99f4733709d9c287970122e1d84c0a7076eec1fe6afc46feeb67cf5a35ab61f2c9f5620c675cff8f94f143ec95cb25a20a0acd4c3aaae5c601ac1131c9bf0f825d8e58219d545401f312c7a5bf3fb9c2209917ac165e746d34abbd92610428b830bd09e0d4441810d32db93bd0ae491be7816e3c2370d08e0b42596670a9eb72fa8caa40418e250db305aa3f612d03cf120e50f4eda6aaaa91273805948f610d6af6b3dfaa860ce84286ab7b5c19e2b720e67d826cbda3b9e7e1cc64759927a6d73867cd1f175b8f8de152f268a47e3951a4535c1cedb7c4dfe24f61a849f77e65aef3c658443650abc0ce331abe8d866aaff02d4a4a6f249bdf252d3388a0dd97675662647d7ee76a0a137e54ad6b369dbde2c2e0a54f3a8405b033ba9582e0fe39e3009620a973a4e59758b9b7f97b5d82311e3d1f26e506a468b4c85dc8d85766fb79b8a08a65aefce98338b70a97eb50e1ce89429361e70bdcf510cf78827ebc13b1eac5c944becb3bd75059aef857ac2a2be37c5a1a0cee31cd1c9ab758d9bc97b48f6a72a496aada6d2b9c963c67112d2ae2902680d6850ffe49d446aa470b31f458f926f95ae9ad2a74461933d5fd09dc4159c3006350dd3286463c17727c538ddaf20557b2566e07979370385a5f23f2cd978169e920562d305876893524837fc3bef81ec4e91349dbd5cf56efa4da048a8df70592a8a6eb006c07c734dbbb0eb2099e1bdd55e46318f481416f36b1f5608c4c623c027a3aa8b1faf3aed035a2fef89d5ce73c1979c7a01938cbda3fab27a88eb480dd09e9d84d2e5d714ff2bddf0c07e92051e58fe940128a1a325db4f5df55a15a62e30ecca4010195c9a6a7bc73f5434ce647edb65c9c23e052c4640fa020b23ac26fddbd3700806c9837514f8d9696ed9fd1a5d6a52be46ab18cd0e2d8854d1a12330c09f6156f85c665c9344df527bef22be14ef3bcb240ed9c1ee63978a1391139d7a13c4b8d87c6472a51976f6447c4f4d887d20e4e7514d905e755079973589cbdbe35f794ae130d5aa80869149436e40f5bb60414ef867f635ad8e639505842b1fef3bc280e93227ab86b81bbd1c46a8f201903746024b0cca4ddf5d0397c6eb1cec95a6918610d40b1ac30bc0496a47f88879aca387371d64c80711d8498982fefb8c08669575c4648a9933d24c258be6d0bc43677e1e0165eda2b27018c3c564df84504d7a142ce561b4b96c63a314682e5c23db1a33c10a44179e39637d5e71e6136b9b44a84b40c8369e7c483d2deda948672252aef9118346366349ea2929cdff58a84d2d349e99662101c4e62327fd1e4cf0d479d176e76845edd4867ce68741ffae881c5b3de25a6ee66726903c5933e14b23d43cd05a2808c6ab121b091f722e0e02e759e102ed28a316380e1850f1e9686aecba0e103a4c2e55e2ff5197a76ea3ce2d14f2e277a49b8828fea4aee98722e014a3ef42228f37c68621944a67a68aad6e8539f527b284b45ef461a9be93d55021286448bbc082b1b4c1e92e136cd157b6ff0cc65cf687faf7549d38af92a95e80dc3b87c04b9b5eececfc9b19721190faa39f5c4c8757f8a100fcd7a0eef2c6d8d302b61c9cfbd6cecaceb96d0d05675439bdad10164bdce77fd3ff5c8aa22f6a04dcc1fb478dd093e8c61a396e8324a101cef2b8dc4deaf584518919a628699d8462b9702d2b95468720439bdf89fae822d83f4422139dcf717e51cd1569b6a304d0c670e4fdd7e85223df05aeeb22a065549a3b531ad5492cbe422f796652d64e6a230861e99cc3a24b79d86af681cbc2a33c315bb969dac11f9e23c2c9fb6c86e4cc0c29cc4e8daf1243abfd18a5b149dfc6f342f1bc25fe591378a10200459bf48d7fcdbc41bf7965c76e814826e1aa04fbd8dc90d1b0ae70f1c78445e1a94c01fe67697f906730ac6b30cfe537f723e3171cc052e4b0a1e2f8899f096024b4c7d92844fd2cf12570d8d8cc89a57be2a893365e7d463d7e9653ad0f27450c41cc08464bf82a3e6af2f816efe2bb0252857f01524eb57f83111b69c09e5b5f97b43141d518be0bcc8227c8017bc2fe6936391974713402ffb6dcda1ae9022630cb06d278e3496395399fa08a4753f21143d798cef3f38fb5235311ec8a3b6c55f169ce41deb33ff99d05c9ae88012293407167e6ed9177909f3d1e2d099b201c5f5b9766aa17e5f74c26929a6bc7f6971b7513799de05305690a06bb3ca4570887e8f169e4a203a2af02f642c307d8bae8083bab4f138dc6c20c8ada2f889838bdaaf2451fd1bd64b616de3545dc8b717d9906ca09901a188086dcfc787642c30955dce39b9048b9035fcd976e617111d3d79a3a0d32746c82cf63e2c863832b5cff2f3868602fc747612f6a90c2e71e5e9ce942b5047ed19366958e06d9556ee39bfd530609276f064b8f8f32d1d4bf64ab288cb7cb3444e709f2dd74bd2009a90fae3617bee758191bf5691f2b0d554b198b1a210d183163c6100ef6df22ff875657d689e79f5c4303e8c68759946272de48c186754f32693ecad2963db4f9b42cc0deaf10709c25cde7bd10896d7b505a4f449be2acd0f6fe1d0e947b18b431a8c8de5de9cb0779c5955c4c590602ff970d901a74e7c1ace9917ad82683c9c776f8c0dde0f66e37b8712f1a379351110b617c51b2cab833dc09d468c796e30eec3459388ba870b343205f5443ae3f5529bebf35692e95938540b491f29debbc1d56b60c333098d192223a988653523fb297d9a284822952c5c5b3abcee3353cc3a460cdc6676995879904c94dfa14865a2aa4c4062f97de166aa4e52885fdb56a04f429984f51c1c1eb2a83f3251883bea07d049bd073e7082fd665650e8af4e4f6d699b14f403663a30696b03572bd0d6a73ce13c8bc89f2045074c798e3279a8ad4cd3ac4993f96a3295f584cdcac3fb5cccac0f867b5b5c1b9104bda49a78ac00a203ab0482609c6cdf7c295c32365c13ee8a6344802d8f0fd350101185bc0fa09bdf6485487976995fbf883d64bad5c04478f0021893bf83efc0b9cb70d45c263d4af9791e028a39c2c3ff661de027bbee80ce197d7c2e99111dddfd5faa62ab6d75212d440292d725199b5d90fdf2af7ba867523fb7f61ecac09f712e47f34b00ef32271ceff33970aa9fff10782422f61a15490741e20367f330c8966c186160845fadf56161584dc8af219faf230f32ccccc63c41a73941f3fb4fdea198977f70c4803bc8f9057ed86ef8de6e26e2bb81771409bacb9490c1876f3c6352848a7894c74cd802dbc4007507f7a111339e6de21d1139d097ae30285a1084711a7bb49b58a1ee72a3b098e216c7b08c1efdb73dd8dd5db95a4711e9febb6e9690fb7c091a11a611a96a82b3caf51c0e9fde3840860799d7af51b37e74377ad36083ff85bcab27df130becc4791eda7d62c6054f1262a84984d83aee5f394fa73aafed2c42dc76fb6ed321e41136c099668d4b237a9255d2c54d0ec710c4b4711a09001c2d1b20a64626f7971f3ce671bef1fd5bd2056d7a4f8cb4393f412593156e08c0af8a02b7ca7097258041b870ab4747fff8f41e36214a143797bc44452c0feefc10a965c6630b3a3df33913c4f820ce77bee4c77668253c5f41ef9e55efaad57bdf29b4849cc538fabd034f912420c9d2121e96134c1c944e08af9cc6f94c35b76a2a8ed3e4575ec7a3e5e1975be32b7a6ceda5a8055ff0eff1f2dbb597261356c2b65bd1d220d8ee75d170c7d18e43183849b05822b0bb1b646bdbf262bf761d9301683f2f6d27cc3ef16bab2bd84a3d1d57af63f7c62d7ab2c83a2da0dc9da460cf583ed455a8202a169b5ccff0011503543c07a1dba8fc282a42346c4f36bfecb53f4c5849567fc9866876224e32e86043a17c93ab3adee42e5491ce38e96e23e6b6f0243a380f3c7c2e492d264d5dd9d43e9424deceea2675b950e03f84409f04086290c089726766499295e6f893b860ea0eb23e90526791b8a035983d54804ebeb26e5d409c073f9fc4e91a5c6580771ecc08dc7867ab7c7d90df9688b3cc6a4713b91f220892c2ddff360103b9b52d6fcbf3deb8f024078c9d0ae5dc979d565133c55392d54405e920093caa4d745238e7f4cb81f8b3ef785518ca7d2db7d3abed9e14f5c301cb66a884c3ca0624fcd9e7b6944614d2447f114501f653d6ccf6e6cffdcfd70f7439df0e247a147f2521ea67e8606ee0759a715c62526a82b2c87c719690faf075e47f6d479c5c0e440eafa73812272971d7b5efdc033345ade0c4c8a76304682ed3ca5d1d958b27a064e56aa86c8c94cf4f9472761e1d6bcac35d46dfdbc66ff5d167d3a1a3759e6d71aac8d5db660a2f0fcad859563fb421ccc041005f3527bf5e45d197792ea9ceb4623333f88fa2997b0b0bdbdcdcc8d1cfffe38a45199b0fc47b4b62f95820caa1f2e02898b3e06074aab42fb029eac95f5017a88309fbb2a843780d0df8eae0fb06c84de52887b9be3084b7733a8206424d3998653bb13c7e1d78b04f4dcf8d54fc3fd663ece229f3f2c3ebeafb96d902a6d1b780f456fa1b7a9d90365587f44c7abbb16cb37f67d5a1b4e110e2295bb16d26840594fe944e959321c6c73d5e88f4d7eb4fe619c2ca535db7a8532cd63ad1cf95754cafcb1dfecd4b34ce6a9c45a95f6963ef4d54dcab00301033c3b9baa3a3689bfb1d76975864546a0a735274eeb6e6feb1e91df6754e4b8c0fa3708706f1d9ae3f405602b7b2a643d19262b1cc382ea93939886462060d7a5960067068cb6cf22ee28a427a1bc573c5725d637a78bc0cfd2a9ce0545e4d000ad0ba4f547f146e784bc3e87b24dde67f7549cc7139ec8e86a85ffa25db5c51b11ffb50d1437cc1cd2bc0b640f518fded911e541d9983e8d2d09ab1cddcf65b9d662e2f8a2cd86b8eb2bcb1c1800e239e4bfcad6b3d3bbfa450d58637053f3cc457e196b627ab63304510b3f92aaa8d87f1e343bb5f625753763d3980314b527479353a294492586dfe4c9d1b29ce6cca7a5df228bae9ee9e607c2a5859572f7fbd1ec1ad50271f00ffee83ad7d20a51f3ed88da1b263d5d8a8345b33f92e52b79d70c885ee235046f72a50cb029189cb04465c6b4a9f0c8f2eb854c4a016d78172d9e4833254a009124ef41f3dc677c03556eec31bb1933df0259d28ffca1a991b4ae1b8c06c38e7c7ac7d7104b3ae91e3acfe89b5b15dd1ec8f6f0b323639d235d7afa63fca2727be09b36961a6be91aff1fe4895c7dec93d28681fd3c35d35a16d9ca9899c603c5d1df6bdb1ea2629fda91ce67b9962062a3f34562076f312e71ef170c8dee540d7bb03f581a7884e84856ae842c42227e1fa2e3c37244c396b03486e9cb487ec73f40caeacef18b3653c4f655087258a43d6cb686e2506275eecbc8fb1caf7928c8b8fc83da5b7833abfe545158360587d65ccb12cf24339bea3b6f2917daec326afe4a1b8d975f4fc74be99ddc7253c9dd5c9b7209caf4ac84ee5867cb9411fb292b1e4a724d5fdeee1e31f64622d82bdc02dc3a6f74d7c131da25bd520ed1f46cb58374c36e1e8955c48f82ba83161ab87e8cf864f42f7a66910708430968807015da0a398928c5d8aadc49df2f7531932d171a39e57dc15a17d2b02aee97e743d33562c0b848eee826ce32e78703a23deba984c003766664cb2043b51ade7bb381dcb8ba96801db75a95abec14683c45f90c248bd6849c95f336e56b89ee0f374d8ddcfb4e0ded1981cedcfd86bd94aa35792ca1b7fe16439dba9f61b9a2754b5726a1a9cc27ad58d0fa4f53d1b754b1c669922b524c2bf176d5dd62eb65e6b6ae2765890dec587fa92e0b39759bbdad61cc14b6f35352c2c2211ffc9578f54a74b056cff399e31dc1b0bce120a1638c4ef567b6f0b91067bbfe37908931f32c02c5f575e3f485aad1aeb51419c4f2f734535733896477c2418ca2f40c86452328a5fb6e6a1617556498818c3f0aa765130b9034451f79f99087083b12c16e82056593e0da2abf41ad29115e756b7b7e9e532b40c48d12971826b1dc01e4a1168bb9305d69df5ada3c29a8eca9d85095ff4421f01d037607bbae2ed122d2dad0a970d0ca2a1f1651b02897cad53263e0a6b01bf727a9984be82f2d7aa27545bbef700c2f38cef181194695876f6e990cdcebdae4ec55dca0e62657393a305da4a15631829b59172c21433deefcbc879e25733f16d7e28a33f7f2c68811a63f46630a87e914580627c5cee3ce928ea6ab6416a9b287b6c9aa2cb1fbed005ad517b4a17d6b1c7945c3c4391fa6c029acc8f866083ac7360c8d0ce0431dd5b209d94fbccabe7b5413f032e9401dcb81487be4f5a60f9ec3f842963ed29e35632ac99b7b53ee7047b9dc86971685e6fb7b0190ac9b652737a41d2484a08feb5be91f7eeb2f849428dfbb9b5c44e453dd4bf73d10133ea0925f5c13c18794c6feece265a7b53468464b4c28422e45f8d08ec37e8c3fc81e4ec588514c6a2ce0c588b1b082fdd132ea61e5ddb1534aa6ed6dc20bd6f5a57acaaac49b138ecf32953bffca417518c6aea3a2f6b0a0dcb16ca16f7e9fd052fd4252c5c8a785a7e004bcedb85a9085672f5d426abdd3cbc900ca4c03b070ebc702bc4373b34013a0dc22c64639e8d0ef07e3d47c7e2f6243f09107a62a2631a2626e1967ca82e706a9c732ee57f23ff5852f696814504e9d3068cfc3afcb461ea67d8f316b26c9b854572d95d9eceaac5327231fcd8ae0c2d9c90847e503d1de6f6b9eb07694f92cab58db86657e3ba5d8b9c915f398c0ed3550be2cb765285e263a8ee69db7f516ac85942566cd003da49d4b0a1d7f9ebb9c79e41d9ec0afa7cf41968dd8ae10de2c761fb53169e30472bb45ae4710e79f79777dff755898e62ede83d6c83f1a47f7d307ce6b0e1ca93f2a8e37de48ab0bc4d68091509a98608a4ba7a34cd66d7cc5e7719ea3dd03c273aa31e487003e950d11d68a8d4f67e56bccc4e6cc3cf05c401171d1a9b19dae8ed7e6f8c3bfccef848b8def7dae13cbb1a934b1f74f62960f0246b24e81c161952c4af8c31bc9e27960d2f17e96c2d0816b5edd54eff5f7fa6787b0381ed019e0cdaa8b94d2dd41802901eab7ddf87f82bdbd69cb724c4a965f799982f0e4d4928c3e8ab6f183ced4ea967df3470e41a6a13190de97a749e715ed353f397a499af0f044c850fe3b5c00058c172c835d139e9a68a517f0a340b5d061617c65d57f9f751893067ba9dbdeec4185c37e5e9e59f4ede981958438190d56c27279a5affb6e86e9de9ef16e38baf62a79912a8e6c8067ad28b8dbd75fd652f4ce697a4e93d5fed5bdb363a1b54973e81079c19ab8bd448fc68ed85f28f11495b38bc73323d6d3032581420ff533383e278c95291b88b841aec0d4a26a345b1369e38280de5ad9c0c2fca38dc90cbb812bd4adf8c3e0fa0f10d15fbf7bb650abdc8aad5cd212538aed809943f02e709b051c874f1b8987c1150baedcbd30e169a86cd371c748da9f6e4efc7f819361bb92ed2413603f779bdc0d07c417c8067e495b94dbd060c0d9f39a82d170f6cb86f34a26b283a859954d0dfc7a3a43fb449a65712dca150a8ce89ea9b8a72e234512361dbe4af70df738164b3a3b0817bf5ea39798694dc702b4919f451ff0e8368c7ecb16f09e529d8f5781d6e6fcb7d43b9ac3c0c941910887313c69bc57aa28f22c9ae07edfc30dfc0a16fa302e9d3a585c3712bbbb68bc3ecf6585836cf9106f0e1bfff9c794b045498f947f3afeabf9108abce8da6c5c6a500ba93314d04e9c896e0691016db4baa8492974c11b4fe1ece4a123f43bef96622d642cd62ce37e8bd8c6eaa7c91a03df07d1859b46c8135c6ca919a518847de6761e24a0e3a3e40fe42e3a43b0293e2cadff4a86d81061fb163654320a8ef983a2881427aa58ea0ded6033bb04efb9ecc8a464262a71270e6c44d9a504ee35bc81f28c7f8f26de08dc37781bf6c5b5550d2a3a2c06977c177d4affcd02691c9ef2b3ff6f0d2ee51f27186904c85486b9ea0550c5a687afbc77d4bc525318e433f89f45103aa6c5d65e0acc10ec42180b5c0e351c16a648dbdbf83e888edd59f1c8745708c9f50343da64a320e97672a24f7e5d867fc53878da601d9b225e664945de005a95b24a73080f1123f66fa5b6d35aae8b55d8ed09098af943d39ac02318925122708b00090ed522074779297683b58a5feedffafca1cc4a8ff12df0a5899147858514ab7e58f98196ea8e12cf4f00eaf672f9d82bbed8ce6c121006320b7036d07482a6a92ee36e2fb58b71e1f9a3cf0046b8b283157a30e4fba34792c4b24812b7f44f0aa6ee76c86869d1550207d0c673e4d715772822da15fe3436558ed6f7f5f23b2b0f4f08e75520dccb888ccb65eb6034d46cf3e99687ad41863e85c380a3346426fa5c5b482560ee1075718616d6cf3d9a8eb0f777505b5bc4e9a045ba124a61a0b935393929ef5286043007000e236a118551b6cfd0246a1a4547a6cb4a76f30df391fb4ed1da08240339655d9336311b4818c821e5204bcdc84e1a78830eb0784aeaf6f7a19185920b95b73c9b8309a0d483f49101584f518dd18ce3b459ce9828975ac4b56787e9eedd4eb8c76ad34eeabd5cc86e779e1d65bac4b9cd5e3fdff8d15fbcfcba57703eb332378c67419148dcf9673611653fb33359e84cc4892aa849ba03322fcdad3136c9c510471ce26e667ee493cb3fa30a17408ae67cb4304bc2900aa6db6d2a78758b98aa1b8db2e60188ca492ea32c39acac2a2892938a053cee2e4cb0eee9079739d060cb2199cbc84c8e803ce66a6b2483db4303904326d7b5dfc8a941c8165eed68e1f3e5cb4de39e355e684892f55b936f620eccf95a899829d2b8c4b97c065d36c0fe384c9bac70dddbcf41056d271126db276a6d8bf748d368f20f49887faa356ce6868444f97ff9cfa4095274769a43d628e8e186ab864ac9a8d6df0b678eca31d4768b654b671c28f2046476ee6598be83ba6b3ef9b27899decd31611f318134b20108b88c21c02ee5ccd671a02b013852a3b10768b4d24950520d191e49c586c9ef06373e553a6fb8a202b83aceab6b841123edc0ab1ced6add8c58b17a690f73dec00250b4cb9b1b687446be77d1e0cddf4cb45781052f2f97691e0140389397fc56eca860922dada8dbc372c4bad65fa8eb3099c7bd5a72fbe2ffe814e93637b997e90769abd9c54d2ee1248735215cd08a641da555bf4cec191c5d3b18485f955006111213d1524e09ce90ebe0be924f0e310444923c284b0a0506e5506c04b36eb119e65ec5f71f6aee8c198cfaaccbe741d0cb47345cc1b603506ae2dfabbef72fa94e2cc7875abc685515e6002f4a3c1108ed98b43ec435f252e987d6d3553f29147cfc6fe68428c11b5b7fccaa3036d4db43c66c4b42d3a0291dc4233ff402b7d2e1bc6c59fa8534a9520b892ba2dd01660b1fa4ab27cef37fe4ed16c108dac54f996eae4fc5c5d0b52466cab4fb80f7af460c471f029d9a89df46fa6ebf21793b182868de57e41aaac5dd801b648ba66d0bfa01a35a1367df586525e171b23efc63189dd43a6fb83aef5993761a6a861aac514be48800558c18fdfc714fba86b880d714dd45349961289c5a2c2006655eb4c75e645707c709905664a6db51facf4e12de3b0ac31bb65e02ac6aa795bfc8d5bc53b6b6392e49d3d85f2056d6d0f1dc90853e4f4ad4da2d0cd33b74f50d06d503f610da43247a0936897b3ba0827219f95986164c7eaeada4cd93c3acc941603c53e178e5a6622de5c7d1bf6faf40cbc6a8833b87706d47944a1f01076b827eeb9f442c7132fbdf5376d468d4e185be3ac76a6c00cf470757cef207fd10ea966266f49bdbc99db61ad6b86509337a3b2880edafbe93bcf3f1fcb45dca08eac995377d9c6a0944319e4bad7353131832353eb2cd8e1df47be08cd2d932a5e3827de82c43d04fa336cdd1fe87bde46a4b81d1c7de23dd4a8075b0cdfb48251f7781dbfd550eb830287f2493f0ac8b91a3a9ff13529ac6738ff2dda731ce7d6e705a0f6bad3517a6a64be0925fb099508844714fa4fecf4a088b392f9f860ac8f41f83882503204d3a447179763be4d824d352654ad850c2a470aaccae942863815a3bb781f50f6b4268e21f9ca23ae903ac4893d0d58b9d116faa4a9acbb0b0f46a0992bf2b03c61c93bf1567aa5a5d279b65f951b9f7a13ce8b9ab9916a3d703ad68a11af8aef77e3cd8395e1076cea2fe2fba47ac2443068cc20593e29ec75dc1bb43a14a5e27eeffc6e3d8f41eb32ca3957c68becff3aa11b13c19214135053722db1cde07a99f378bcd7a3574d12676a776bf539d1bd49e60214436a8f3a4e3a35b32746d0095164af8ed2c43352b9d3129d2e2a6510b0cca7d408aa9b02f67aa7b53a4e86ac9e59c6552992b0350685b63e9d52a61f1ce3f77b5b967f6732078e816c60ecdb26f851d173ab15bb9fc933b937841904af1ac51d38ff563e7d18b4e31efcdf92172b82bb87b6a9c98c98d83952765ccd9c6b6160a4eba605ee8e15346951f39f68c3aed5210077e6d16b41ca511183161ec85878276f7e374a37be79b16730060e98bc04adfb15a539e0a04980e6eaae3527c29fa770461aeb745189d5a0e6cc6173b3e0538e956de04cb7cea24e0e2859f07174eb74a57f7d6f1a43500814a807701ed3884f57830725fef961934385cf453fe07eb84f3bfc81bcb55d0a0ea4b27941cf7a9413fc281468dc3fc320d4d37825dcf6fb1bde4cad1ee55352919482c5446abe1e4058f9138d6a066292607ad06f0a4d41456d8a1ec4eca865aba96a3a7c146c029998129a821e96e455073f22f4fe7581b941d523469e532ae5b69c77651dd95f535dd5bab2efbbcca317bc9353e29f44b15d74b61c9cc1fa3c799df3378ced465886b427781496d1a1ec7e984f582a5706a689435af100826c7a4110646ca5a2abecddbc25b6d762410288a474add1bf09eba3daefc0572f6e6df212b9dcd92d7404ae88f0c90af5aab93b452f1d0244b6c37097bd1a4e42f1575cac8ce0e7be082506fa25bad1c75a1dc768fa4bbc09d056817548fe302b3e7eb56d9a6dcda804baf11c8320d725ae28570f9c4133f42d2af455389b4ea4e2bc241b99f774c221db125c658af10992fa006f6009445efb137ee18b2f06baa1b41387b8075f8ab5c56fc03eb4b5b6a4f3e052e657b70065187902540e67cf28af92a0afba3ad533fe9f174bc80bc2b0b78ac81181e49e89e13bc9b3f990fe7b71e962c9c22d020dd35f54b9ecfc6912194e8611658b3d2747e306567f4bcb9d231c72c7e42f7bd6f61a6113dab5e283817e26ed8283889c50bd5831d09f52c1bca40d807afbf47b8601f21a1fd9dbea00be11391b1ec5154175a16c2df12887d63dbf76c400c85a04e0036ba1e012159550f07a6a479da1ce6f53d2a1da47a7d74c31e6fcd7ab612a03a3ea1fd352dfdbfedf46ea11215c089fb6533536f020f3611a9b495d5ef6fbd79b03738f8c08b41dbdd9f80710ce1a323a396417dc51d1262e21b5fe085c70f1480f3de8e5016fc63c34dcb84c07ef81fa71ed00b567a13855a3f9f4536e78d075f74dc2b4af9f6be7ef8f417779bc59aec1ba7cd64d5a7d18f754e26f11bd7d3de163fa202022fbfbb54b1069ba7e6c8cdd6eca3a9fd2d4fab055fa7353961012c3d5987e04d1e737a7fc9444480b775c64d2ce78f040ec77be3b089bc92a73d155b4545cfff56be57613ccfcfe0fc6662a6624c5ccdf5b96e5dd05ae0d163312bf19f4b9826186f0265deb42a4f48f6e0771f804528230f09b258ba976f195fa79286ba0f54e2734e8478211bdcdc4","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
