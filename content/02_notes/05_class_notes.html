<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"f3779e985b08efa11f43c9234e814e77a8ae46f140bce07c0b525de37a65c2d9d2b7977e4247d9c6b49d62e6eb584827ec5ea90efc3cbcd87bfe90942d9c63a90dc1b642a609ac5f2e5391c7ae104af4b749371e5a7a7be48c2b93ffd2e723c5d359d6c249c3a22b7f7e70a1ebe002080943d8777f9b02ef489163c84ff654f9d5cb68d41a872e9583cdd6c3e9e69cc6dc2075ed5c81fcfb48f26d6124c8d5dc60bffb51a305d14eebfdd7c5baf0d469924e97b7248482c1da729cbc44fc7b614b0211ad4937c789fa7e9cd2db01cc28a8c2751e02b296ae1eec95cf2498f8fe8698fb5a80c81f50900258e0d1a668459732a4f3a6b2750f756c48b2fc10400656ebc0e726d51f7f7cdc866cac6c2ab2adafa4bcb1fcca7b71433fabe3acddb156a155f35f42ea45aee481fca74fc9da216930bdcb15f474dc19a3f3b47fe55b44eb4aec1bce14474d0fd40eab5827cc0aae04526089afcb26c6bf98024c1338ae7ea82189260bed9214731349e7ad1f6dd35576e5b898d69cf30592747888749440d36d617198a3ded5134ca2cdfbf70456c11aeaf9ff6182516b3dca78f367cadd55219e7ddc82e4e2a85300d55b3125f0b68ed42419605405205c1bbe1ccc5ea9df0ea4574ebce0ad3d692b9564d6eb3b33a093a86792709f60c2bead81d80d13a8f74b3a778bd10797a504f931dcc81c4591404b6deb81fcaab8388975d550a5ff0597c3a6a43e0619ffc6408ec180739b4584c7a2d9a44bed60b0d665da590cbbcfaeec8b9b5db9bb524d4ce8a48d9348af442a7aaa40d9efe16d351f01c45f73215080f12c60e10903a5d7bdef53c9e8ec257e83cdb379b750bb2349b7fe0dbbd9e1e1d668df9ed0303fa5b41b60186eca0fcc9a3aa84939fef6654340b77c97a281b968f507126e2d526320225b9287fa1f6ef8d9027abb7fdd9824a7f0bf01921781fb799d7faebab423f4d5d00ba2a1c1a779b74d9dc8da2ea596da66f82235338e485b6fcdd9734843f42d045a591f25dea44bf54bdbcd6a14b07dff8c19c5b0b3080c54782ef750f2e0d4a92c3817d5c4614e371714508b9bba5eee91f04334cb45aeddd760524846c426226f14100e7217c78c3b579aa9a0a2f3b2faa92af2492e179f72e65b8b31b85cfc8e129a8dd78ba8db61a4a946021cf3e8f913a5d5bcf8feb31d065f9d8a0d5c0d322e6cd5e76e4416e5a91e2795ce0718011e8ec5b0627c2fc25891af23f9a21c21a3ad69c49422b8d472171921b4c31341d6e4fea29275cfa9d16bee8633e0d61ec9061cb79296311892ca14ca7412d1384b903e9838d6a12f9c5361f94fe5c9458a03d6975a9a4995359b604dd5867cbc23641357b7932d872d74a3a6c89bac0efd28e0feb3319607ad80c55ee903329acfdae2ac61230692e505612b38ddb7e7449b7bda2fff492e5d6e1ca68d227cf08527990ef99710af2892a66da88d33328a0fa14113cf698f83ff6e2a2c2191a61f1701edf0ffa77a3f53322520c59190fff1d8214764c28d488742e80201ac41516fdc6a04b636b7d0c3f4e6e3b1a4a3d2552cd3c844e94579201e597300757a759c3b992a06fceaf80e7ddcba08cdb64efdd2203d49dbab8b9740e60f0074d2eccec0bf4bb15db5703ecef2b30fd334110daf73c658043cff3d9452c68fd14f89f60c245300f4f90a2ad18351f85fd55b828c452cedc3ee3b8b6a812753da5ffc4d3190f8ff0c4aaf3335e3a5fc7b7c2fc9f3c6ca63e003c73eae9b909d32640803260b84305be9e995cbdd6638e51adf6a4b091d1b0a9b7dcfe308763af58c106e27780275dce07f2b871675fdd7a106d216a11d2a190e67cd37ac284f53e77f66cb660c958c2878a4454a8243e9f7817f01a8c27f772a74ca8894cbd840ae18d5cebaa93909c6409f0bc317e61a430b37f134007a119e35151331a9931c1b8295476bc063dea60dbd4297c9c5c27a61513ae60d53404f2b7e840bcb42cd624187fe6903989c926c58d99a00670a561057f42c48402295466f2773019a6562f4135dded8729e3cbb6059c91896c45c51b1b59b05dd826fa4679425f1db67746db1d84d94136e63492a88538dc4c31ac281e8cf353a897a5bffdcd168caeacb9a864e0f2be73e805d153af24e8551e5068d4900450735938452577731aca6121726c03d2580b61bae9aaa5f6869b3d3446a3237b9308254fa55c40e35f4a8357209af3ac5a83a0de5b13eac7825daf27bbe32e2f63535f075f14d25171b0f1628bfd84351bafcdc2df476a8ffc0fac6a6ad38a351f829e8daac80ce020f2f747707911fb91e2abbf8abcb4d7660ff4e515724a01cc96d3143b8344fc3089dd0adad640fd271ad5c8725c70052d3bccb45d2ae27f591b6d72e428866c0168193bba881db070ddc1cb03277838ca3dfb43fc9b23f327e657def1815534fb4a3cc2223124e22dddd6851bc82819f541d6cbd9da4c05dea1c080f9d5d23059322f396dd06e369de55fdd2a76e38b3af0bee3c1fbddf2a07f62593c08e50c9fde68b42d0bbd85db03e1698ea4d0281ef545757619f37a15f9f926511c0154f13272e6c783fe57431dd9401fa6e8fc990155e66466033ff81a489e4054720bf49fff4744deb81f2ed33c666d8380b65bd717531128ce11b1b53a28359c994b3a64ce7a84a9e1fa9cc70327b8cc457da433c85b47cae93bc0c3fcd61bad0bf8e896a1478ac8585ce134e601d2b03868beca38ebdf0b0a98cbe414c9c0b13c4843f2500c540d366ec7937fa7aedffa0cb450de6261918b2b77abf96ddf99b8021d380a3ee9ba675b9369eb8fc5925f67aaf5816a39ef8bb8a3fe9bf532562ae7c8613db0acabce4e8d1c1cea8fb436da47f594d677915a6937d93db21c6a402b35ecbaf9c9821865c2af72622fb857e6c9c8b696462af56b926e9b7958a09988b859bebaa15f24be959adbb9e635fd70ef5b773bd4135869fe08f33d0ad3f73ee40e1ff0c86f175536ff7b091ad35b535d34da42c7f8e7497346e34c2f44b43b6acd51f0d4dc6aeba3faf916c45b1d03aa2af05b79048f2b644256a4d584580868f5239e150d24a1b84eb1b878a22d0072251320f721aee91dcdce393de356af7376b788c52d32aa0d817d681ecef7d47b3c5635dba81a6f197da7d2b723c0a2d3bc9750e3c1e1a8a032702ab8394424b76949f99ae38ebaffb5b94b863c47c1836097626b76dad3ecb33268bf2297d4a2b28cdff1f953692e51f77f360ce50e8ac4ecbb41165e9565402cbf4af2acd4d63e11ea9dfa7ab6686fb29cda4d5b4daa860204ec7ee0299ca62ac70348668f858fd9cff025a2fd01b089a2f649300497cbda115f9e29aac9aa8adc825c9b2b3c849ab19e9c7e8eeffaa907d6bcd6bb02af78b4ebf3367600ed54886de247c65d03b76b46fcfea1cb7b13a5804f9076a6d9b34ad6e1009596aa22ceb7c98e2de4b0043e6e388e677cb9293918ed7b968db9a648b8e01363b465891a94438efe753dbc7ab3569a06621ec90a32ed7acf220520ce50f659df0aead44a710cd20fbc4e5529d03746e13609adf8d1e6054da0c69640c2128a555e72865363912c4dec36d7bb11cabf24baade56296ae3f8d50c9693d16b5976dd3da5606ae89851cd26f4c2f73e8586cceb7508e7351ccd93987a52cadb1ddbc2602bcf83033706936ee5e3c86d07e6067f21797c7760f827828c7c9a330c5a14346c1d3dcdf9ace0a030bffb0d968c93b0d0605d793f058c23602077959157a6dafb54beac3bfd9b5b228ffdad563a4d938ee75c1f766337f48aee71a76b991c1c8556140047db99adfb304b10b53dde5b690fd4062d9655825d32f253400eda4ac1c985a99d9473ff0c6f0f5a6f1a500cd18fefe1fa65ee80a0f82a21e691dd84b9617a28c7fccde831cbeebcd543e12b4a638bbb752629ab37547df0daf0d8f9b7057a699c53f785578fbe5b3e68e50d8ac3de3682ccbf2791f9ca0c850d77a5cd295f56f4023f4244c20093f95d334418ce4c2e635a9937dfa018c3fbbc93b4f437dc24d73344291c7d83a6a464ffc534bc21830d97e5534428f976a8c4c5b4cfdd4b4be8b37d1983f8f6c8dbfca7548d4ba634da1fa1c0e06e871f47253a50fe873cf8ad64e27889416ae808b6da6e033a4c3b41485a7b4e342c4d060e94038469a4b7876d6a389b0a1910d0aab8ac8a6f39dc2c9f8e3bb7d513a22ef3e2afda5e7b518b488559e148d7c19f98eb505ea47a9056be37c565b88f4d82892786890c57000c35e65833738399cbc9e74ecfc5821c2ef9683d2984060b2c1eca7260c9c81fb589f1e2c0fe1368550b5a3dff8cc6d1367e45478f9c67f1eeafee1b282a4631573fb8c25bff1a0871f10dd296ea2f10ca1cf4ad0c777716d403c78456b1024d2e87f15c03bcf79d153815d2b9bc84310c2a245c0fba9d06e8ccd4b74be01c05cb6e3e439edc9d577f9a998a39fb1777fa163c2cdbe9d800d7e45cb74d03b1fc050263260d240632490895ff02483eb1209d3e5c3e9a0c90d212590aef3a2b282a66bc89acb7e3ad6a831aa050ac852c7076424138a440e055153ea42e279617c505924c55ccd9d50771d3ef0d64ac4a467186e64b8812c6fc8af52e40ea39ab38e71724e6bd0e5d6683fc217e2ab6ebfcc5cc5586b04332ebaa7de37ed543fda4171345964eb81a3b18b208d72ab3a82091105f07b9ff85644d26c5d73947ded48befbcbf426b0be6799522fb66d4f7bf7d679154a869745d294dc6ade3956faf0996ab83dc17b351dc85ae8326337aeb349571da006d6fd5a8486be054b6db9c0fe5b2732d9f7c9ca3b1803fee05302fa052eca54d3b010c0cb44ba59d10859bfd779304ed0602fe09bafe508b5e5d7bf73b4461afcec655ee35f96e61b49ca99aec49ddb3c636d7dfd65a8f86fffd31ccc4bb0d8a1fc2fc435a8f1ab78b0ee0313e78bfd0a49047449a2ced60edbe1967d1b872fafc82d3d94ec0424195bd932a7398a18601b7d62845b29e4f2c5ce89534a72cd644330ccd7f352a754ba1ee67e8a2a2b29ef827bc801d1920bdc703fcfb8e03ea13c49b97212e44fa992c57bf0679c37f7133fe089cbf6f547437a49edca024af2419a31961bd049dc88a6e5f6a429a7dbd63822673e8183593833532f05e4c75b485a3f52f1178cdcad7c7747fe0be659117b60930c189b47f336260774e7fbcdb0315ebad715b495e59bb6f71afc7b16423a9dfc20c066c166a9cf2e0f829db534fb6611072503ae33de1d48bd311ab294750b32b61abb01df0977741b7b41203f82379734577cc3bd150307a0322a994c47103fe655c5b326614972fde0e0e18c2424982a495a89d13582d27556f99186eace9d749cc24508dc15e4a58d1bbad377c0a6ad333df5fed5a7a3a71471e5fff52b4a96bae69dfa5b50325d915243c15c8858b69924a69163b28bad0329a52f3dbecaf7c33063c9665873684c728e45c00520add0a44c1675af1d69de2ac686cf17ff0be1b121b95ecc6256ea7bc062ea76d53b70095c5f3935dd56c3a6b5670b926212b1311aa07782d7a57603f34fe7b97cb7809e5eb59bd0a4ee8316a532e39b713e7ab473d46300a2e7718096d56202b0c0c34871ee86621f7db4149a3dbf6e72142a9b58c8d6cbf8fbe7de00adeee3a10b133b1f0d2a7d14e7d37f1985eb81cf8717d10374e171ff8eb0468990385a8299ef921062eb33174eec58f97c96101634772eb4a37cc957e97849284e38c3cefaf48e52530344b757fad055d6f280f5ce2798f850a820b810056f85710e2205bc004cc21ef42eeb88a0cc50e615594be9672565833ec12dbcc8caa45c5994711eb7c6725d564725d421f88336d8f2459d7e7f3ea940f94e566a4a8bbc6213ae7d59cd29cd52369e65621d3ba4836ddca4fe8491e21398de2818d2c55cd66cf3f47d54a2daa4bc35b5b32dca0996aa3b1de05b53f66a107766e6cf7d755cd07f35837bbd50b0f474050ac350d323c44d67a4a6a493663dc9e5e424bb2a33b78a7d363c5371527fed56ec0019db5badec86587ceed2c47e03f5f138f8f83f4c0b6ec79596e73e7a4f2fe4e16e77aa54a118300697edeaaf891a5233d43ae7e5d06411b3c903a8f720b6d03956ceb80bff870425fcbb3a866828b7fd5dd0d936ddcf69413828bcbd83e098d8a0139a675313ed60fbf2450499d7101fab5080d65bd423d5275e3beff888a43c0b5d891faf72281c455edc6915b84174731c425b62b2ea46df7e7a66ab0732ef1a2f4378d0d95697089c9fe726c2eb03b262fa65257ec6b808a7f178a7b82d882fc46e381661cf88ffc1d1654f2e114cc34450b9d352221f66dfe876bfaf38415d02dc6fe6f59638ac4ce74b6652e9f92fc7af9f5af47f2d72ccbc9d40f82503d0f798636b1bd90fb7d7742241eddab9f368caf1d5208f25de410708f143eeb5f22668799eb0cb8c8eb82d7d911da6b43f46873a08871a5290f5fb047eb3815b6ed9bb8a3790601f6eb3f1ff0561a3a75f688c71008ec5c6f0f291b6064db8db3ab4b30e3c6ab3aea526275db08c10da98ad6e4949b21c515d008ac53aaba87c7d02642d96e07232316f484aaa45769c3501761a74e23f5885deedd0c01570aa5abd7a79b6632466df761ccca32cad104141094231c6a6428f1e0e8442de0e5e8836af7cfc419284094b1064c7f5ef513639ec3e784180d72cd0490f3ed42e3eb2015882d86d0deaf1d44cfe68a8b6f3517ede2b1b2c2c5fb2932824acf47cee49be31ee19d5beb0f568679c93d6e2f02e4ba394ac86373e194187db477301a0cf92ff31c31d3f4bd564e6dea3cda19348be4703bcd4cf4b6de43884de397e96e23bbfbd8ce414efabed5354cade54ec3436760c5f0ad5beed3d545c4aeefdb56187b189da6bb970bcf423a8eb060cf2281c210dc977f8aea843c61c9bd869b7cbf025652b345e444f002e38c3e1fde439200db6e22d40e3b088ffbaaab12528db3c2e00a471e2caec437ec8027f67ddf774d174f3faf2194bc6c1e3267fcc06afc015423936ae8324c5fc8332fa0627343921ef72df1da718372ce2370073fb47c9df0d91ad13c6e21dbb6fa49a445beaaf57739d2285ba0accbae0972cb5bc03a2bcfc9cb24048c864444344da0c25f97c211a4c4932cb54c22a76ce757bdd06e4344f6a503ea38982e1276164a25ca2c79fba06630bfd8c1fac8c775fd5b1e945d43595926bc0d2783e6d3da23112865b37cf0cb1310a3bd6d971edbb763c155651e597cf24e00aa357f6f5f1168314e50fb908688a9e098b38f2629a880a1347f1ef0ab0bbbb6ddb578e7ce6716f1638eff5aef14160403890707d1148c1631a6b5c10afda42404b9f8d83f8caef2da495a88214694b7729cd8ff287cd3c56b74a542c6e7f2582b68e65bf6a3c079e7cb3d95625e7f8a890a77d40573e6d980327b98305def0b8a81d1a9dba82290226a496e9a9c9124d19cbda6cc0561f3d561327fca0975a399214d14acf620cf21805c471e8b15b226ae8ff125e3868b83e57000c8ccb7485562a0f2ae6e99df8da56bff3fb4d4e28050521708ec1ef8cee5159122b21b05cab34a4fe4203780567a09bf91ac1657c5f2d0081ea31561b67385d115f6dc4fe78a3c12fd78e63167d6e59a619439f9b8db538f17fe311ad8d84e28fbd4a224beb1668819dc7f6d8cab37eda5a2d933b1ff5711275a82e8cac088427ab466056b413df03157461e93d76b3a0f3fdf3ae4b476e8423ee79a436d19acb0f9b834288230e1e0f94d72e668b337ec27c9d3914674aaa396bc68c11e78830e4c27a2e093eeb968b217192e0edc569dd2b672b7f3018f7e4e0aeaa0352fab3d0600e7a80025ae31fe67137fedf7fe7c731beb231e807106f01230ef5817328cb695f462baebcd83ce58614f6c9329429366d1ef1ecd3f05146b5b14af935ed8d2c7592e26786e3e357e37e68d2dfc6519fb719340fbf14c00cf71935614e56550ad049791b3e18db1eeee92c6c61be31f37f2f8d721f2da07511461b3f9fee524ed8fead979ef03bed2a1f36e9298f7ae38bb2c0e569aed8b3d0de5725cfede297fc5fb079777c78b0e1cb718d8864615cfa4833bbfb462b206e84c9c31b60405234c523d780ff98451d26877c0005214cc32e4961064bf76a3afc2d4728c5c092dc9e5100e23f8d7f1b1596e7cc8a501ad896aeb22ffad26e2cfd7c2b69d3100c0960b7dd2baba403c6feb1047e764368df26c5934f3c5d575543f4b5affa57dab47ad2cff6c0002b997ce31784951bb92163c839211ae823d3f15f16176e8dc1c8b20719f59c0581707b8f1b32ab2f8b43d0bac03ad9f37ec851411e50b1c4ad9e554a9aca09c98b710e0b6cdfeb0a4d14705ded5b24a572a6cf294fa106adcbbb2f76606a59c2dd53e9c4390b51d4858f84b1e9a77290428df3da8ce145e1194a2c016d913cdcf4b99ef442ee072074675361b6dad2fdc4ad783130a0baee1659c7e86aaf0c906a49859a3c2ddf4bb5c3b1d300144b7008296520bf7b7e1991cda41e5a87c257e6739ccbb58af26a8fc87aab616d19e8924aa42475feb07c97f2bf0843d8a13da06941e0f1b9d22b11d6fde9af4fddb68577f229cd086d03887889e28f6137b6619454e799e58c913936c5b2278bf78429442a669eda008376c857ccfb2a6e8b0ccbb2079a3677c4ff4afc98f7b7de072a7967a8876ec41314edb0cdf41eaf317ca0917f62eb7e11b120f4ca36598d46e82dab137db0611d8a1296c99f13c010cb81acf3ce9a3716d3393bdfd7d279e4f1af3423eaac7dde0773e679466f8f250ab46e4c07c6899a8f0f3c37c3e6b132727778f852ae8db514cd0a88688615bffb3f28441e35642f937c7eedec5486e537af253e1523ee8bd69e4f4363b1124722bee767fb51b13fc15d1cd17d7624de592862b513ea578116bf0cc43f82be93cc572d90eb6366c525ef77a499749663801365ba62cd6061a2b1f8db49128f996fee9266b77b1ffecc1d04d8d069abbbce31f9a5b6833d57ad22cf2b4f11302ac82c1b45d08bdcac0efe94a1523dbe7ee36cd43021c3bef6e65d8d50a179730ee885a01056ae04e3b2fcb6e8d1527b605db2ad3d34693be74ced27498775d2a15368ff2028a84f18a9a08e09a58b62a2c445078d35c6dc76a5afd749d28ccd63a973d55d0943fc72ada2d45ec0d2b0883d1b357c93e98914a495669d7665ef959bceadaf26ac4933fcd530d08a68e4873864c08c10a2a0088fc45d5d20efd478091ab29371a5ab0fbcd720d763b41170c7e6dcb298b6c69f97fcd4a7e397bcc5b4c99a00ed9a24a8884645d6cc0bec3aad6d59aef9c4fc75e7ecb804fea141bcd76205dd3fd45a275417cff2ef724baa1813f2b12ac59377107a064f9734acf29f4a24a3cb4d1dbf8755b53ad05572b412b65c0772207b9e1cd7438e1f2f7935fe26321ebd490001f77ae633511f1e79ba82c69a85cc9ee5f1760ddeeea699591ff53f8637393946b7cdcea23313f620e57f3a211beaf0970eacfc8d6f0371aa7294d03b38534b11731a2c5914c2b5361618431550cc765b463e1f48e3d4341f04a437aa683930337cac8179d3622ba510524e408167984267d688685b06586a1ae4993676afd6ca3ed0d17301996d74e095dca2423b59870972221d38d5c75a131bcfa8ff2ff33b8ff8933b822c8a83cd5064038077c910bac0ef0f7a3077426b8663196008b64fe9f09ab87778a31b770554c443bb65dd1b1bf2d1eca2b69af46b33db8f4dd0c33e503e3a382efbe256ae677e3971219930c020610104447102c33f95e946f683a122d9992e48bd1063beb95cae39128ff2d78b7f15232dcc3a3b47eff46e75070b134bd67870328fe6b9a6461bc76eb90893fcc38e66dc03fda77aa94e0527d40a5a5f77423e1fcdb776c9ba8d0a2fe1e0d9ea44915956044037de7b3e16f74d179627840041fe918f0bc63fe2070f198e8737938ffc053999dcc0487ac931f0e7c4780685f53739387ba27e523121cadcc923031c58e15eeb1405d4cd3f4472344a2c9564e01f42131da47887af76f319a06921a4b522a5abf8a6f4a69468e855e8fd1652a36ce9676e078002e642d29f3baaa10f02e014cec1140665bf6e246107935f0cdba8d35f32c9e3195971e506826b9f4510ea949767c86384e82289b2ddef8a5baa7b49e9867220a73f8e7edd02d79b8eca039698cac7a2f8e1dbb1250d594301a2bef372da16b6a60883e61c1c6a3774e9ba51b77b24ad52559afb445868b8e9fa6ed315e7e8bc4baa59b732bc297c53d5b9d5c3de5a81d03472432f9f518765daa559fcf25d7a7dc7ae63f94037cc6923483569529cc25e96138e27681f793c4ca039425eba58a3db14ba6622914c5c58573e7874b149252b983073eb91c317a835d8a5aa52485e1aa4264ea6a987c68af01cd9b3640cd69376f7007c535498674aa519dfc78af7c8433613b032b456d1ba7a2925df01fceda1ea8bf0e05ac6def83a52e4375eb1963bd2bd59dcc8f0024521aca210706d1c8a1775b8c10b189ce33ee8bd04692198504687db8cff07ba6347519bc6d9890ca4c00bb65ec07e8563dc10324a6e2a7c4d149763d20ce1efa2c59840d4b4a1a1edd3c75274812cd537c55c2e3d77f85e931cc1884447997cd34ec30ce763ca7ea011d0ad1370e39c6f07c58ba7ac79fd43546092e17e1835e6ee8f972085ca8732fba3f2006b315d7fe1e916f1221bad02dc5789b827037db2e69b5f248c7cf46553362018055fd1151f61819262f7e1f419444ae34e78d54d2106a67a6747e241797f16691cde8294ef0b1a4dd4677d46daa1d0f94b0ace2c6a963734a0751d932231ac21cb6d6678198767854174d4665c956a61f8d9c2efad7f7b7ddea30a24dcea50bf1a8240f5e449915fd9d831fc549db2f2dfc71984bae082a961a25e5e3be7c348be353a1627ea3f852f5f10492c784a6dd2e90719d44c6fca6509aa63ee70c0047bbb45a025a31b98fb03adc52dabd5fb4f62a8c753a6fbb03d5c627ca7a301c3c0ebce3bb129dabd9c8b2ed2e79c22dd63bf82eebf4a3686a30e7060769e73e8eeeeb6200239d778ca03eaa390e49ab7cc2b268b31bf6998360e68edf0c754bb1637a23eb03ae16f6a28e033d4c1e8d500240a5ef07164296c890e43b74d06e80b886cf4870c2794f544cc524dc7446e8366a90fb7ebe90fe9201e99230eb3b74f88ea350206479aaa10aabe20c99d9b7e1cde775ca9d081c76b9624621377eb48cfd764ef476a34c76c34f8fc87c386fb1cc3b6419e7116a7753a1951fc7ce61b0353a246aba9004dee7fd24149c67f620bc7d11e14c535b18c2ee5c3bbdd98089e02cb74369d3b57d8d94f395067112a7bcab1a2175f4b62c7a2a91ca25d218af9b397db9189280a328123d22a359351d2357bd6a2621681684d9439f11db3ffa40e452bbcd32a4f936111b964bbe744821570da8ea3beb9600a42a6c180bf706eb1d7c3b36d31bf2bb41ec2299af0fd8f037f03be2c69da1e90eee37abe88c66910811d93c7241ca95ec3016858b99a000f3f026e90c99ce0d913e71f0b2fd080953e523a7a109e8952fd1a4751d7734dd831a674eb7347b677ab3b54cab50ab06d6a7d4be96a81be667257df4389444bf25fe177cd2f096bfb5784765b3cf9ebef39b37d4e3f455eff56a449ebbdcdff3f393ebbd8729b060ebbdf759d3cd5680268208329557b5f35e887b5d7c54da60be24640d63ce8688e69218ba18b4b8b6d7830475a239f4868d294976aec6e2916b3ac7b2214f354770dad838aaa3adc57f98ecfdf147841cd753e701c231098e46763b3ddc85f940ded4eb703cc9fb53703565474a47a06a1ac3fc01f590da75fe19702d7ba289f18fe777a003a0798df474458a012da467c4f8363e526d037206d4dfb6ac1363a0f0b95582e1f7f7685ba06718b897f2c3834abea2efd7f5f0a6487bba431202538ffb31ff847b76ec86dcf73b84c1279d09540e42820170710725bb9098d7763a16242bd0488699a73952b294335dca7c4f65143d6a452229492bc7da77c6c5ffc0b597b3aa405fc01f999bf52a6fe9c988c1a96a5057051927ff9899a00c070270ab95fe656a535368347b40acb230d49eac76bc967de178cbcbbffb53b2ad2d2d306ab514051e0413c162e8c832cd3d7cc90f6dfa7e34d09b9c221af83a79bab566a913b867c297a77c31fef88bbb38903b91ef061f566b8def4b70a28c73c07376f11f07a05db6ab9698f8891177fbc2507c0ffc054228cbca6a528bb4ad5a5c41cae4748821c0ced46bbff311677e016c305edb8f700568fad7e61be0b4ec1b326d5e4886d71575e52c5b32f798172b6ad9c38dacdb87d65961aa5e2de7202816185764e4dd846e588b52cbc472a3c2c6600c7d1d30b16def836287994696a10f4c3dfd98c110670373a0e105d6238418e58f7952968145e4345629791d22f88b07a8bb576dba156bd3963d3d42f80649ee7abc9538cf5bb82562332c2bcbe92e0f84a50a072958d6835a08ea8ac94e46f4b4918f26103c4728837942b42a84d0247e31d25a9934c0c301c429e3f7eaab7d2f20cfde4b2ca3190c67daa109af8c04b4b1859c0aa2d9ebb3e44a055522f5526c4a8b17f2ddcbb1766e522f811e7e282ca1b772999fc6d2b2f834a5e96713419d7e7568f91e84886d0023e6ad914fb06cbe15f801426239ef20d2086fcaa37b4a9972a993ca008f58a3f26cff5e9b4ea451340b21c3b7fb7c87ccee9e81cc2dedd77590335c5bd7ad556eef49f87a2963ff643750dcca6dfb9e6d8803e94519919c553119c38f21269aa80dafb0576798fd9c2cbb406687a20025acd951531fc2cd667b9dad77eecaed3eadc32ca58b2d5f534fbd611ae61b42fb4375c8951082d4f7fc02dfd73fa4682dd51a2ce70b6b857259e7b356b59fecce0785ff32c699fb7505909f473034562f04bee34043d4cfeb9365c76860c4288fe571a08f50ebf873e2d8f668804644aa9478b07ef2c73bc5f3bbf0db2343de237e7050efbffc7a80a53215d48441a3ae337f478330722c0016f0bd92738951789cef9b7e286f033085be9b225581f60b0af377e17a7f92ca8cec072311bc80f1b33a515def0bc4b4d6471645c7ade54e8e4386849cc6bd3ceade3137a0dfb64267409ad5a17c5b0cb7dc95585c045bc433f2b523bd1e7e91028e25dbeb4f12feeabc4d2b1d70168bb6b34743cdf22ef066422e4be761f69c8534e459e6c50b7ed4337ab8c0e0cb86472d9df11825af9229308b78586cb5fef7942c2406345a1b44322e93257bbb255e944f65498c4d26affc4417ee36e6b0499b3f438090308b121eddfe25308ef098ced9ea9d0cc34b02c2203feebbc24fc36b8dbd49f3d52db15cc273a746d1f48ead8583cdf045f6cb4a8929079f6f8c04d6614541c3cc11d262492ca002bd0dfa27c1ef01534de88a1a2a6dc80c3ba428f423179a17b1217109f744b5a77af37eeee2d58b86a82c6d6ad37ddc575fb6625f5701bfdb9cd0e43c6e9eb4336d3b4077e5654ef5f8e63b708417df4c537a641a0ba1785097a12b2392e04f6bc7706c36622bfde6187192cb13828e734f1d122d7b2d888f0c666b7dd12643c585e9c46556ba291552858fa8225de56eef76981e0fcc0e73652b10c019b2ec2be56b98afdd77db43ee796b553411b672d917260d2533c78d068e8bdd937d4317ab4ff965630cd85dbea97b0f0d129d821e024b8adbf95e9b75dee4447b6d5be1ce928ae6acc10ec9980c2572fe051b419079546e2374b38c758d096255789df4986dbb043da3c92c1a553db6e33c0e37bf3f2eb6a1cb506861ba0efdff36729256bdcdda6a86521e8a56f62e703e8c9d7a9bc794513f35a96198be000665d16d9a792b75cb011da06d8bd80840d2603fc761ee00c783ec584480d23cffb733331b4d15c0cbdba9b45a811101c2d6752d2313fd5cc9ce36c8265ca6305c71ec98e8f319c1ad168c125d8bfa6dba0ad4bef4ffbfddef8b2dca167ad93f1ef0ffbfcf320b0a999fc598f8f7c5063a6ac5257eab1c02603ef4412a8aaea0bb428a7043cc758bd4e50c56b35db354bc07b22b25777faa92dbe9fe357a0a543046fca232d2b72553b3e07060d6d26ef17b2983743efdb5a8b1485c22c0d2b7ee99c66a7c27f7d18ca629a6e1b0c2fc920bdc3d1ec7c8962a4b2d5824e6ffa760758231a8515b3396366a4e3daa5d25fa85a7e826eccbccddc02f77ce2431ac98fcd0b12f3006e9f7df782d3cf229ed2fb0807cca13629435c253986dd178036fb723ab9159ce14e49fdfd8eadf21c29e5018d7d958d0c85e69bb7ade16a1ac899a30fe1345943d46a251592fdccdbc37a978cc9cc1d4897e155e88b7e9019f7a0e944f550f7d3a4b84d0fc372d7382e3151e21744b0ff4de6e1bd7b412c25ac50a7d1906d005c70c885c05c640a57d34291bf4069209f12e0e9bc5b6425c5653909ba892ed67b1ed65afb74ea6d83e36c88b035160e241704593f11616fcced94c7fd3be78a6dda069a9b7b5486ec5434dae41d4b28bf4732d4386d0b2435f8e41e918eb3652dd3b6a799d09185e089630bce42a196ce9659edcff744ab8ef5a2cab81a1ebed56f22fe3a89ac72855ef2e31139c117580abf8aa4d55fa5db64f8f1b2ac82cb31ab71bac4d9e35486262a889357871a19ac8376e8273f8364215ce07b936ba9d4d1f79f0be4f60fce1f7100fdebb5f5a18e3ae35d831d16dfd21854c99dbffd2693f72045cc91d426e72106a2ee6f3e54884350c550ea47a6742396affef3964e43300a871401e5edeca1ac2c41dc65f1eb52b383098deb3b985192f1dc903e0173b6f9d2e851fbeef1fff82f6ccc6b9439dd4a58de83e9a5f5edf90f68db4da5df7697854615ba545326c5f61ff5731f1e964ab038850c8fdf5ea5e1c3fdcb5b7278f68090d8dd04748dce5edfed60cfe60ec5501a271d5ae4f5939c7c54ba53208a40391ce161914635609abce45995f37b043fe799c9e23af7b9a121b60ffe56f01671d8bd9fc96135fae082a0962beae7109e1f5aaf70e95962dbcd3b6081cba9f6a665775664efa064c621aeef3f9d9288306046cb39083b7439b61e229478c81044cfb4552a89413ef43ef97e948916811b60422cfc88ed4fccb9ff84e18b5367ed35c1880e2541f2e9a66d263837fbe942121455e20576ce14c8ef4d7140710c489f8b1cc87a56ee9b698591827be127f3c1c984968b3c5ae08af71c9f953c3a4709e3c8347ef8a14682a63eba0e07a67e46c58831fc42fd427150b447b6f581a7f9c9855ed739a4d167e95efcfeaba9f2e9ab79a57a6dd80ce25b8f11f9ba530c0171a13da3379f4e5236361345e7ec7cf85497d02efe40740b6f6eca9a5c82852c03ebb63c2387fa0536268e0b39f38a60664d1484406e9620a2270ca6062d1551b9cd853dc99edcebc89034a8f466f471b33630d1c7f1692bf28968d137aa47eda8c2e052b393e892f3ad12fdba8065afc59240b6d61ea9a712b5cdf7cc04ace49281caa9e484d88db5a06acb417fc19b271a7ae49708a5185167bd3a6daec5e42e6fbb9e92c17f64208a4eea71f1f73c6fd2a7852e35253ff9a77af360ffad53e7c728111ccfca01f4a43be196ce8e84597f570a481936e1dc6d927b63f17c6277a788f9b385f56b04206b83c94cd9e7b92cda22381a694668eb5539e13262173a2571af16dc32b26d76e21fa9c8f9917b609e395f182106e429fc0b18113ece6126da9c0a3fe684bf33b82b7f8badc52ac6ed9daac5cb7d033a1601f484fa04b47e697190bdca4e670449a895c0df23734f7b9bec15f10fe0af676b2aa03d3ca6badc6c12828b99907e2b678e25c70583ae382f3cd73d4ec1804dd37b15b9d99e81d041a33d0d738d5a31e25da3f1f2f854926a82bbe576c1eda7584db51da672247711e0141a0479306f3bf7962f2b3af01014fd570cbbb8eff26db7b4e74b92d925eab84d38ef104a75c0edcb78196008facc73dde1231504aabbb7d554ae50cc68f9ef123d35cfa8e812e33fa19d64b8a9b6a9e248c4d1680672980ef266c991268b2c5d2e43c51b03c6c927a43c99372bb3f5c96876388f7d9bc199926ec98a2adfad711c982fbae6757300c1dd915e5c65a390fc30058cadf1be3ddeba7d5bfe8fa0daea24d1331aa364b31446cef1648d4ea56455c9f1f2e43721fe2d568b47c7d0ca3de0c544e00e03a13fa52338cb78010c14d6738b0a0bb7a13996afc979cc57c0583b3d9c0a31a31d469cfa59af616bdab918a5d5f5545122426a4029d6ead6d77272c26fd521ddac68568a34478f6b4fcced80dbfa0c7402b4265c4902f2f47df5c2793cecacecc103824eaaf7f27e378918db3467553170cb3c3cdf415878eeb8e2eb5ffcb7400e13465fffee9b4d49251c70601947f682153071d6a0bbf5cca098a6a0c28a570e9ff3f03d8d5f419055313a402fccec67b410440fcc7f29ecf793b37f92fb223973f85d9320aa4a938db1c1f42f6caf42fcd059810729106871dc7544f04674b74b376a044830d3a4f4eb597caff3fcdc2495d513eeac9b55f42cb9ec96943028814ee9676fba22ba7643659d46c1acd72e0174b8607e480091ddda993f037c1937bf90b8b998480446ae8df7eb99ce535e7b69d4da20cb7528fe6a69bec831af9f449069c59126088dddd12d5861729a49164e397b7a28531376f861beed5964cccdc91e43659dd7c3dadd81490fb2d4c5d2e8837009267a7bc51a119e77214b28eaf20adc73c7545826467e43cb25872f8bb662146aec72a790c5cb3eb29f254f87533ccfc5dbdc8f5208b7372659f8f271a9f7d3cd4d346d86275b3afa9ee3f4669b99d97d463f93ce1991fb453111ec9a48003d3dc65c90b1ac86ec3109c47291f992ed13456569db9ddcead3eeb106b10e732f5d95995dfdb31d1095d1760ef9a1f409985f6e640a46ff28432319da05757e1bafeb7cc9495160dbba9331757ea2e248772cdb2c54332466cce03fcd595cf50ba142ace0c353062fac6b11bcfb57282e45bfb97b22a6600607bd2ad2a0620ea523af6904605e7139c04d80ad1e7a68fb2e394fe5160f62161f7718ff3ad6833ae2bb7e93bde4e5556d0947147e509305c5bb66266698b62310bb7fcdd15ee8099067e092fe959665c6bc1c2f41a08fdb0035c4824cc68f79d153d20fd39fb0275d8d6d5fe0ac6c038f97bf47f0a5751078bcc6d27c5f35ccebdce946b9fba30cf0149a2a80206fb9a5e7827c9086648f428e26fafd793b784bf997b906d15b1aaaf581d9d36a01b7f0572a8fbe811516b61cb2de2d2fdf8fce661d4852fa93ed5fcae2cb4be70c3e24a77d04e976c089e5ec59f3d2240ec1a4304bcd5e95b28af53e9e5a39293e9bfef60cb8af224bf4e3baa1909474a351a5fefe3541a09ea4a4a00c7969d1bee62018acdc23d881987f052e456b96bfe3bc731c12778c3f7db9c68453207de7205a50e666c7d35d86708059db36b8e0852bbf085e24334143999a20924a8c4101b0a942f33a0d89217e435beec448b27ca5448da1973dbfb14a146e8cb68568482098c4e62b948c22d2b9447738a34399bae682b59b955a820d2d415830b2b9a5bc83963ad35c8893fa03336727e2f58cae9e292ec161d246508723b34cb88b8a5304a09a6902587a886a530439e0bf9dfe0fad4f0d0dd596e856fcd2d883ad60b8370e2c6519191a572fb8ddec4f4bd1097141e61ca1ef81cf46b107c5dfa8958ebb9f935e68cfc83d665428cec612dd70507a767825752fe28213caada61b3a64965fc10c496e9b216ae424fdf3653c3a49bd4f2d68ea0f5d497f98442797080edfe5f9431b2b3f9df95ad7822742758f6e4455b26015c29cc26fb1e0e0b01eaccfbc2f340624aa0b07f0fd973f8418b50e3415be303172f7ac2f6e244f0d5795ea1eaa7b868921fc8289fe2e752484d071692978c4f886ad2162a6c41272a2f62640f9c36e0cf1fbf5442d1645c5ae8dce4db209e635948228599d2578725dd0e668805bda1dbb2cf0dbb7609b4fb3942a625c9a86737e2902b0e3a6561956a8affa41cfba19d903f7537d4bdb86eda4e5bb4ef25021cf7db71342e29561973598ae7ed9d48fef261a9c5753610df3c798bb05ba1d1f664af81fc6e267553be29a8570f2ab1b70785a06700f52b9b003467e976a9f201cc6ac52d56bf268f1e3f978f07a72341399264aeba20f9e8fe44dd978cf0423be8f72f3801a5b46f9372c7a0f3bd22594f96bbde9f7dc32c3155a097d17ca7fc056a67bb9386f6f25f9fdbf0488e96cc8421020da2af185281f502857a754454fa5eff541ce96c1aa7a03a77eceb1031801a666d6ebe7f29ecaddb750028efebb19999db717ccbc83ca74e9280b5383ea6ffe5fde46e182df74cda173c1cfb10d066c6565992e15084a30a4328242a21da69a0ed408ef848be522f10fa4fb0f4c12cdc2b880af16cbcfb1e7d2cc6a403fe15470a234aab4ddc86bba728a727fa7a79593ffd58142e688c160ed912de051f023009be21254dd7b1a121632fe9577030eadd7c6bfd2986e44d9594816fdb7afdcdda5b4ac6e8fb7827e2561c7553b34a9be1b553d5e45e0a59896551a33d65385a38e33714cae90ce6d3c4435d37a6ed11012f6ec229ea9caeb4777b1b2162392851d0eceeea42c5c2a4ebc0706e97131254bc66e96b554a7a9d848b655e9c72f2c30d74eb6be44d403316b63d07aaab38ababbde6f136371420dd07d8cf40d11c1297fbfb1f4ad66efce72b5f243206e136598d40b31288cf4125f248e11e4b89caecc3241ccb8f18c77b00182b29b416248863fa1da827f8e6d2d521ad15d42043fbebc760348757a4e0fe5f2ceab0eefb3fab5bbfb5d3b2608d2ae8537a922b4beda9d3d5bdab2262e77d8dac2f765c332e47ea2d16fae1996f22e3486707b4906acde34c7ca281992aa5927ade26926c5e880db7906bf19370f2b34184981b215652e4dff78b774b6f31edad9bb0e7a96173cecd1f081631f274aac979f8f23f0af879f0c01bd18c184bf2532ceb11e3fa123efb987786a52050ddbba3c3fb815094cd1d93bfc537478d483d5b7af6ae4a34990938cf3c741e82696a2085794433c8a695ed19121356cd4246b7d2fc6b8baa94a024e5afa8068ad4888038d1b3425e00cca2ca79fc89ef1d41585073a88d5c490f6596b8679a38b942ec77806e561699d51cc02a5755e6df4ef64ca88ce7637aab2c04bb2c22ba8521719859ca8474015f22fc62d131dcf899f7c3be741dc6b054d5a105890d00ac0ed1e9b51c2a73e1caaf9af550e6b09fba6d7a185e970cdc9abaec612933046710c9e00be3115c25325478f58354f50d30d6522905ee37a6279cec97534f59f7d81de52cfcb314be444424253df08c2e4da637b32f1a511c09f0b407fff4a682103934d13e843ec5f65007de624bd87ddcbe8ba067c65287bb577866b98119f65ccc0fd1d5e774075861103e22d622da23a1b54fc68026a6765f2f18003934448a0a183b57c91c9b02342c8503fdc6111b239be524a383efdd91f9720f0d1be41abb673c5bcffd56c78e979062f1b9c311ecf9e6395e6c5cb7ead4f8d95457f5c2bc764a28b15feb51e618de9f679c352d02ff07a36fe70b1064e3073524b98f89b16f9c80825d64d5561844de0083503a429c84ed8f0c6cc6b74e971de4720e3a60498deb942e46848f70e6b22cf9c624101bdfb152fb31988e9d1969c926a9660a149d0fd64c49c7b0a5ccc91d1ba315e0882ddf5b4d9bb3c3c4308711b2907e7d33c6aaeaf1b3d60f8be3e17607f1a11f9957280c94570ef4d16eb8c5c3a924871815d535e5d7e94ca100c59a0c4ea1812d692cc240ce8bc16da35fcec2b62df600398f58801097d28f705140710933365105e583ff7f080dbbf289f87c80f72559086b57d0ac57ed0cf56eb775fdbd60ee12fc9c718f75e00e80ac1bc17a756df4fa9f40f923f74d0c3f8a6792db9134df761c8f0e6a0ebecd2b34e1eb8a9e276f00874ee6880d9dff3298a7b51b4e25c46c191ee8dc419919a70ff5b04c6d8d143cff0326ef1c983c332209f19bba45316b07b3b0c95ac581ada0af55124645db05e313c34dd07b9327355512bfd99f49e2543878a64cf33a373359129af77e951ac3250fde32e5534c1207de27498311ed2dbb9b52178c5016adee969b851dafe616437c5b75342c68706cbaec99a07e2daa9999b9c7be65835821dc408a037fc7b3716be3fceb713ebd4132fa99bab1a269bdb83d8c2e5ec0eb6747c630d7ecdce0037a68f5b211c2b3b0a81ddc2c66120ea2861b90455bedc1af62a9f6a09f7de5eda610563d5956a9ff21885db46984b5137858ef0b0ceef4a7ae3e90c64500236cabbc8378989d268ec6eb835960b769b7109209edb8b2b94b3591f7c54e249dd9a8e07f5199eef42c17e7548824a6ce6cd953aa84f0ef571c280d2d406a3d9948bdd5a0aa9e56c4eb5f0aad789f256e11383572f560a55475f3e8e00ca8e72ed9d8bf7464ffe8fe5792f218d554829ee02bbc6c1db73418c495a48eeb11622337b160cb20ef59754f17e5fd1448ff38668a003fc477cb5ecb8eca1befc1168bde91a29f473cb5a21bfdf043f0319d12c76119bea9edbc7555d27d9cbae3eb14b7288ed5c52800363061f5ba5c00369dec4e3a0ca4000c05fb88a8b2011e5253c27cf238921f821f8361175e25384148a368510388657d1c7837e77ab83aeb8656e99cab52e30a4a07593bf56c28901f47d6af7c1e7a4f3fd46a230133003831bb1c0acf0f4985e2b9adedcd5a01eb585928060d97032f13b75528d32f9f85b2ea6d5ab6c0e27731cb6f6d8b7ba979a8c6904af9a6fd9273c79346ce834167249512ce1ae8ebb645e47e2a05f168fce90c293dedfd66d4d01e59c5e9e904d4ad55ef083b08cc9c6b34b659611787c70371136e16238289150ff468b4761621807c22462b1f3adedc4028ad153b69d30a9f9203ccbaabd4f3afb14e676d718e918cf6a10b7dd429af3bf25f18678d5567fa8739898f88db847563c72a0ee5d8a8dc591bfc26fd280f7d7ebd8fd6f08256e2d3548e39b0851625bca8bfb17eff66661e7f82b32da1666d51ed7c41cf9d9b05e2006c243733d121c532db6fd307af0d793634831cbfd3adff021e721067f0651c48a44009640a1da4eb0cab2429ab21327abb6d466f50636cd0bf1cd84b67cef50e2eb7d0eb6a3d0a2dc763f3b3221bf0223e755418a6321933ec80c98b15ed0846bce4e8b0997e5ac04da7e72e42905c8882e48a26ace9542541aed3ea323dd508a4775532c641a364180caaad9eb31c65617d04a7cc0c1f13a6e9f5af7b9fd22ec329748750815aacfd14881da4acd350f4524a4d3d","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
