<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"42b24335fa8ffa97a66ffb6cd34732285d5146d7ae125edc2a338b8390dd4b92ee121bba1f476eab598e55e634486aba73aa8782252388f8b4df8898091223e977362be96f33e17c50ffb3287547a84a21647d85098855bc0a43327d393c3ebaa85f65c9ea460ca160a9d1ea1172798ac29d009f66a9252cb5cab97e4b41627bf0a3d6131ee735de09ad70d1ef83bc1d121ce774f75cfaa5e093409c438f08a37e3e1e0d6509664d28777ffa327ec30eb607a8b70480dc17dfae4c59553bf2478da3c85d5036a4f14420fccaad7ab68eafc151aff4c70ee85ea0746f549b4b8bd349c95f09366217b554801d095c76fe22348e27b8f5994cd6550f212639ca319b6393af05acea8b490549201005667d9e03220ebb493e8c13563b9c78c8384ae819807473936ddca89f92848af56bc8ac0777f056f57b7c4a514e854ba0e7414917c011fbb96b6367eb43e9945ed19558bd113cdd95e471fc1290a984505f370e2cecc077961b1337518534d4df09597fbc070b172d0842c36866a5f2ee73453addb5c0389d6f9e7605b09e1dbea8d9cfb64f767e26c2ec5ff7aadf75cf72bb119b02d5b0260d5b7e683bbaad348eff7e84f8f7a0ca710e1bd6273865d4aa029977a7457633d1c2b43935630c2d2ae81798b362b90ece03b1f45fcd292bf8d20f3434d492abb2254f153922b4edab8cbd49cf3b72873c2b2aa8191169fafd5f7d213b8217cef9fdca0f47fa2ad04f8fd6e5ddb0b28161be2c562bf22768a48e14645af7f468317a054f2143d6947ca147776abba181ef5cf2d750dfa1ad94fbe29f2ed4b88db622e37eb09f973c8519b630b1fd47b06c47986b2053c5f4c9dddab1d94c2c2b9d4be01f451f0d3b32d78c9a3eaa843ec2659df91037374facb56a1d121086acdb2560943e3302aeea9d1cd63de002fda438a73cf6fe7e3f1bed5438144bb07c8c2175e3c3fc1ee8c78a1612eae6a3c034131653267cfe876ec48cf083df1168a2c59b227ed7a4083c149ad183985a94ef82aec2706beb562e5b321a85b548e8ce820ddbb6dc4a0ebf5b9ef2c8e60042ea09332e171e8cd574723aa7d4c07cf354accda28aadeaa388868343cb12ce82634508952c26bf115114c715435f51cc1317f96c4645287a41d2ef092ea8c5989049fe5db74ed157488a5cdadd9286a4eceadd53fee08606ed93b1c377581ef61dddc883462932c7b1d7a58508072ed4e60f07a0c19e5d65e6fd99dc81fd4fa5aee7381939eee1016f4f833c5834bd208e5afbbdb276bab14aaa85a2df08db5f8981243a6309676c5adc377fe48c585b396eb41f6462245276b30c0c0a8ee6c2cb402d156672e1ef39fdcaa03d067533938598fa8b73e3f50d56eb5e203f7033407565dcbddd9f9384bc4a1365931b0f732245253d84c1c549400f15169317fe0de74146cef3a74825f3a9ba50df7b7e99a31f997e760d8971d484876f005a5a32d00be60977f656a5d262e8311d46e6e76249954b721c012f8c6417e382b640f3630ff177d9224338754c5605df9a70a2d0afcc3d3baae550b443bce0d9b5d074db4bf96c918ed507f29da22c2a612cb0bbf4e9ce47b81d64fbe6c48632e7a9ed0d9eaa18900c2b891f1e1c070749a880e5c950e4433ccd85009481e562057ec9ae3b15de4327d10675c6e49474e26a42f447e808e644389d7ff0ab5d1746e659b2aa466bd7e84a3c8ab0a60dba2a990a4a64cf95102fd9de1f8d84667d6d680a328b64134a02c68b45366dde2db67e0582fa0f5359177fdd1f20a526f8cbd831c7336847ce8d2cd6ee4fd8f6c5d7253c66c24de9fe9f85284457806dee82cd0c06fe67cdb036d7430d364b5fd25598d2090851fb2eb68511b611190cff0995a404c07326f1b3df344a233b82a1fa116dcebc59d213515ad185927cfd94bf619d7eca79c82f79cf63d39696d478edc76d2083140e01006ff79cb18efd906524c37da19c4639370eba24e235def230b0d4941f604228a95e13d8e54482796ddedd757d0675186eaa2d3218bc60e283e81893ebc42760fbd4da95be721640b9d00acfd78d50b5298459073ee1602c0229b1d5212ef5ab69289353a4db57f765089b363f625f265fc6d7a12420ea956ef57155699faa76ed4fa47c894d5260e917822d2923d05779df705406dc41cf1b0af90585f8e30033499d20799306102fedecd167e1c4f56c4584a009bfe691ba41ef79df6d88b27772a15904d78f2daf1064c54f48fd1dbdba517b6f66f803869e41347437d31186626ef90048a2eeaedd5cec3654b42ab218a050e46f87049c85c7056dd7c0a220bbcf6b509ca29361640794a734c2fdabb9fdbb97982b6840a1af0b5fb52961853af5aaa6bda90b10badd4fad3bec8b5f5d9c0e61eb74b66c679acc0f959abac3f5d72cf40575825183a16865b979f095976c4afa5db471c541277ca8ae88821adb79e8b03aa8f62ae1f2d5b4467f4c6ecd3d65ca859d214c1610da7d441c6d3b7b9896de9a4de85c6a5dc7bedd94d680b5aa334695788c461f54a3e587eec63c9f813b01c8284f82545949f43a32f3370f3b1cdfb64a1703d2d3cf052acf7ae487aca99f4fbec79ab5e5c9e4e774fb636824b8cc47339900422815cc76d640e729573c6423ab8cf9327547bc425d47335e6102023ddd1bb8890c0c3290e3552655575d5a5fca5a8e2da51fec8407ab05b3970018caee2639160c28852f50a107365168c6c301bd3b82c5d05c53cf5306361f720f0c8a492038c041394d1c7b362bb8ffe7a50fe98e5e1029996da4dbd92ff899ea2246eb5becaf6590d12f56fc7f4675274cee278fcba9f2ee63fbc4ea8f3cdb6fe03aace8ddb7910fd185d59abe0e9dcd93cf1474a76fde133567ffd5227de2461c226a65c360312ad70d2e433e4a361a32611e284eeb130a524c09ef2b58412f81abc59fad91089dfb20103f12bf61a5d3d625a1304d91ab33eadede72285ed86806c514f43bb06389817e6950ce705d3072df6127f56d0db615a76a1598118f6938b621ac120d3e24594877435a88172fd7fcd3f0f921f1ea33948686586bb0ecb28823531417ba868eebbbd41f8298ab8539bb5e5f0ef6bec8b77143c9b43d65fcebb29885a19a710c5a13acf99789a613a62134a6340edfb0acbb275f622130aaeded556a56a7f67832e0ce2e419b9f2a845f2d37dd9b7615c16651353ef8c78a3f0c56a281f3a630be31c7ce644eda42737e6420623ba3686865d06d404d7c90dc6dc8e55457defd2fe05cc278866b1d1be186c209548d58fb5207e2abafc5ff830f045c4dee42314f911484a43e261997792806aebbd24323426a92e8bf7d0638d817465466ea46a24c7a04bf56a7384d45b84f7d5431a3966c8643fae1fecb87203ac006cede00ba5dcf4ba5ee5c4b9f9b51cd546503f1293da3dbb9ee1e2bad64b6530aeb5ddcb60359fa0522377db274c2531f94ff0ce6c2367039bc77591f940c40f4b6e1ab809a694fb322972a4b9a0a3406e4db8995b83615616f094640d0a5f0749910f24b6c35b92c5f3a434d51ace5d83b0a87a558cad038c72e5b08afe40b05ebb0890d34c209eb73952881a7cbff02685aaf3aeb59379a9aad32e8635920de93dc55323f758b045772d34be9d59f42d891272f57f118fa7556d230e13e2e48ff8b5a88ff594236dad43de1be849cb691fdf613deff5c141c7824c3c7c95cc5fced9aa34ccb8b613eaaf4c5a0cef1dcba39c066f42110dbc71e2a241ec4fcce65b701e3b1ccd7a24d4804ce11cd7f11ab5f7b67942bf1c279e09e815719d794f5ae73cb08befe6ecfc838de1fbbca7563e20e1823a73fb702e9f15395ef4824f27306bcd0106f798969dd53f8b18a880674e4ecafb284bbca81518c50d2466b2dfcfafdaf21a7d2a6159bee4502cfde84d712d118b756ff752833c225a4f64ef4e69d907eb3ffbfdc05e2a7613c1832438051b2e3bb570a6c5f27a0ab4cadb92c6b0823182b561487c134083568da56dff5e0b3bd2b4daeea676e349b3e12ec34c3c31785abeb35abaf2e2d580ec49d64200764ec0d8ecada9637e0545b66f0ebff29000a9d1963238bb3d0805baba4fc1f3361b5e0eacf65b4d503131aff1cddd211b49dc754820fddf2b0f1128a4685af42ea56b206fffff80fd7de069d642fe1080cadeb9d729f713ffeda30e06f352076eff3cb67b7522b9087169a7ae6f16db6ffff2d4e527dbada3c4be17f083a10c657678cded6cd8f407e540faa96ada3b03913d35551806e14f49d1496c0f1a216e004b24adf081fd85c53ad94a42107c196800eece20c0df69af425c47699f9134623b3f1bd3d05249949f944b434b87a2b91fd0f326de1b3b0c79399357ee6db9b0c83ed8394253828ed0d776063109d9f94e7736e637092bfe33cf1481f79a9ceb0ddb2f89ef63ec06a4cedd55b96ef10b4e621a5c418211410154474cafd9f6f9545a666fa9e74f2d8be1ac75651877de5a093860568ac2c480602363f0fe89f39503cbaf14846f771b65410013ed230885b245b2841fe3eb2deb15a877209468760f644c0409cbfa99f35fe0229922a95cc2f8cb34059163d959bafe9496790f4174322a2062fe42c81a9914a6bd8b73ae26d5b1f17994917bbc75cac428eecbacecbb9c03b912504b418457eccdae4855e8c065768bf9a3d5ae2dac389ede292045f7a40e0e094b48a2562f0fcef3361fd11f0f46ae7e47b225d3a96fbaf310db12c8ff4c74b2e11c6476f559d138c47bb74f44b7055ab3772683d8f6b54d0cd73a17c940ae68857b046c13318ae664ae49ff2e594d85fd2de30a3ec972a9266ecbfeac0a9771fd288958378de83d94d4dc6424c70ff080e81a4d3f3a455260c1eb4f6228871e61ddeffcc952fbacb600ec50d9af3eb6397bf933ba9a4c4fab02cf9b2138c94f8329390b817d59afe5f38cccae065314a285d078aaf3ea5e009a58eacd84b29e536e8d6c8ef4540ae90637380ca7626aa4572cf266ec9e203f7f34485553452ec6199114b6b5ef3f59401fc8a94af7a0c4f3299b98ec43935880612c7f2f47264ea06822c1f80726a14cbd59722b6ef9913aa16ac4c29cba53318b9cc4e1de2af11eeb50364f84413a832e8095f7e5ac47f4a5a43d7ab51592e4de52f358f6a75f16d224e51c728d4dcb7a8631d436d061c38aed4719c9c8d4744ee7459cb1a9c69e75959bd86ba041ead12c501caaf11bca0931ef34fd35b96af8b6b5c2843ba3628471bd4d5b617aae0b3b3d6b9fae16442c58357b724ceb88f8f3603bc6707020ee7aac45b5a9d6a14900ab94a86b3b5f5b18196b45227c5a212f3ec6b0f8abcbde9928cf9a628918495867f4c5e4234f0ffe7edc9688d674367a573b5317b315060d5586fc778c83245660e604aa9475c5e35b17d5512381c8bc082e57539941e23ee03fc3df5c57435c507db1b08e8d72add378624afe676753ff85b703fa0463138b5f45d6a73fb3d7ef3563538ea05b7f000dfd74744d8f32e120b1faa7cbb107a350a5a7df67a8805b032a1f308859da2aeb81ff992613d2f9614d155e42ab9bfe9fba2643847ed00fa02a8b81a0541f38846214eb21fa63bd90265e991d340426eaa309e8cb81d90e2f538a09e5fad999afe8218d89402e971a319bf837e1c417802acff452e977c011f36e23d380720c7cd9bf5b750efa60fba0e1042703b4f93711decba6b67bfd3875bdc7b9a401149f3d5824f422378b6a0d16beb6952e670a2bb5ecc4e95c07af9f8f7157ac1b0203c63d428fdae5001fb62723726ccd4518ebb809a990b56ef6f2d7cd5868058b0159516498f7e20ad34ae41be39daa64a8c41c997f8299e14ee6680832bc5d5bf94caeb4f8ce7284498883c489bc7dec92d2e641810e502b7303cc294cd94c49974b7f162c52497eabb3e8b8af31956803e31d245188a7c833846beb612740f7e69506d865a7732e201ec8ee8312257872d2747dcd24d07f4fde48d0276d9a5ca7c4210656a528c9845c6f1f005d487fab1696bd59354c3efc3927563704701c7721fec8d0e5069fc57613b67e81894b39af7ec3796f9116346fc5e5ac854c8a29b625e940ba09959942eb57c9225e88b5b0c2303f94639e11138e107334114aaf18afc9cfce1896b1728339218683fac5482862536f1ad7adebdfed8a0964bcb258ab23b14e8ffaecc65d7c139d5dd5b8e2b9387f2b66d70a6af0f8f524338248597e3f666312a65a26db55bee5285f42ddfa20825e5368890cc419c27e7f76f5ad4a91abcb48ef740ca0631d9b84bf595348469550538c935461ee5dc0f819178e3381c2d90d13bd49964612610a9a5b57462e59407ff31eee51e65f51efc4563f0b15bf025ce41783936480a81c0405182a5021ee0e2fe9143e8f163efafac24451117bacfe21ded344bf6f8f0b01a251bf88337ee6e74a4fad2fd33720b953e91c9d02a7f200507952b13e53f9998e415f1efbd3858a0261dda552ed39c1a9d614d9762d8807f1820ba4029d11496efb4173886187f1dbd33768d93d24d476e31fdf54f2f0f108ac723b0dfb58de9429566d72ae27232ec721d3c0417c167523e928946f63c8296b37073bce4cd512064538827b551ed88696f013b5b8ba021cccaf8afa3e5daa7f17cd04ae261327255b80f9fc9e25737c54e2872a8f784c11c0d0b340da28339a1e4ce511222352ce373455aaedad4ee568e12696a1ba4bf051e79531b2fcdad111937da4e57b2f1117387c78ec6cfa6ca04abf46e6cb9fc3955f2aef2c743d8aedc560da25d30e523029cd6231124410df1554537282c3d9bbde4731c73973c38f689e9e7cf4f565296e47d0df7849eee924f6d27f8ade42ccd6f9cf040215a369b3e5e57eb93eebe1f6792cd19c09eaba9606affde6b5a9ed05c050ae2a124c3a4ff93b901ddd9df713d83e458d8752630b6e16445cdbd126a6ec173f9297bfe6cc8daeee02a13d424d8909bc500c53b56e2388d6603170c3cb9534082dff5666eacea698034bbd6a9840a67022024efc2e36d5ea29b0a54a2e7fb6da90a290361144e392479ae86ed37be404b58cf88529d93854eaed89623585e9bba6ffb3c96d4a3c2cd16ad10d3bb7f50c8659190193ac50f0a963d428f0c786287ac08ee571bd632103f683701680418a3bd9e457e9c398e14657a4342679235010d1f3430d6a910b1e6055f4abc9024a6b5aaab312a64dd717aa90ba04b603fa2f3618a4800ec609ee26cbdefe41c7d969b6b4e624e141b1bc31d72f6c9f900e15a3101b26ee41f85d2cdfac238ae993a8b0d576c5fee2cdf719b5fdf919871b80601713f1cd8c030c9867a2971a7161019f67871f96c0ccca71489afebcd3385bd308d878847c4ace7473034e7e94b987a9791063e80214defc822966474b706bc74277140c53ce3954aefb3e6b2e28e74e1170184691a1fed3dfda6d2cb61f59c2f29eed3cb1b632905759ca86b463b9cf0214b05c1b4b457dfc94a11ada7fdf8b39aa58ac456681ab6af9d878d052ed7597ec834e7c0601db2dcaea31a1787df3b902f858203e727426ed3f1910653eb408c99e67dc68a01902ff6ae9dce41170821937106327bc6bf58aa2c72c70b866a981a4937e39f50563d9c86125e026ea5caa767ec3d4faf1e0c852a32bb82b3c6bebf4de29f022c79e0e437cd383760d4a5017a0913eb8be212cea475c11c2dd95a0d21949224b558c146ec26f4694fa429f2f60b654de51b7516de16b649320a42d4360a0df6a12d04cd50f9a57d214a7f80f0b5edbb3da051eba89b49ef96d7613cd672010e995070057497df64b589b0835071f14f6b4028553a6d3c6da277db7f0aa041b258b1f3888e6bb36cb5d406b3d8e2030ed728d3dea5d267196ab7b391e18f2f5553760b62634a93371b30d0e7a7023f642ec47636b52ff5fead7cd18ed37a802c047a7e050cced129df13eef5acf3dc909214f9aacf905fd14f5075b8d31ce3f6b259db0bdc5b6dd5a47ce1e29ee84cf33264875ec89f5e6af6a92138a03c94a2ee4e9da07517cb54b866cb491c3a13137f26af6433da6d251cbce5ae2fabdb40fdaca4ef0df8256f3c41d29007fe8aac924dfb5095479e3229ebd50ba74121844876728892f103e6b6c7a9910fb39330e086c066921873fcbce20c7414413308afc245474c8cb39ef4cd11a74e069bf546f602bc4e5738a805cec9cfa4f7c81523851b7b08615f3779ded85653ed323c200f2d81ae64b260806bf920baa01ac5bd96ccad21326590a9086fad357cdad2f0b5cb4c40b4ec2b3611c0c5c2aa502a4db2c8eef724ac2d7dc7bece48c9e594f2c5974b9444a307888d9313bf3d2bdc506280d188509cf6d8d5ea0901d8ae07a8cee4b8aa34a6a21982f8d6a41fc82dd2bfdf4acf1ca51f1f185982be268c6a0a9af7ecc1c698395831c4bf581421e60dc3c4c060678f122badba7827239ec022cd7de4ba2a0f2cb5c72a8c5a472faa0c0ac0669174641c8da58a617029b940ef757053accd790e0d13d6cfdf61400fa2f12f15224d9c1ffd04b5357acd1dd617a5ca33361d54bcb330aebc42238bea6d3e941aa4aaebdc531e9c2c66b0e9f43b6f6f8d7c5588adce021857e825591f0462299276e10244072e168cee7cf1d5937fa63d96ffecebfe92abd80cd31f47cb83943384774c6cef20d55879fac3dd0bdfa21a1bcb263d729cafa7a7a116b6e7521b302de417406fcca3ef6e65b894276b8784daf18c9e605a4f518635a5539ea8e71e1fed9f0288961c286333228f087932cbfe7e68c8d086ac62a0000e344aca8977d1e1fdd7ff07f97b36590fe0aea9a492fbfceb3968cc4453d20905c685bdb774ec8058d7190a613ca946bfb9c4bcd8e1b51763d85861afc77301118a52d554c0af867223635553f53fb180e03f970c3e07afc173e9f3568a1e13e94434fdac924ecb74fd3e5205b72a2ee31c395a653e6a975e80cdd923146ea592840f91ac50908cffaef8bd8c903aaddd8f078cde3d21880b12fb8005737584308f223492a2f92e152bc37315adac475229c056b125e0f0859339170bcb9a3e6dc775f2e2f28a2c4bdc9326f441e45949086abef760eeaf4b775a792a28a7d5192f7724e84d8b3c4dfb049bdac9f87fc3567576dc13b322a9e5cd5631a128cd32a0e12ccd8d25482f5b2bad37ad65d05afa001e2a18dabe43e89a8aaa96cedd68f26a96d7d4f73afc52361236b12e52db2cf0f3da627594dd4d18c0297b433a73007bdb4dda621b9f681d7bb4a387fda4bff74d0d2d423ccd4707438036c9cfc10bddf9b4de1bb0e64b01824b52d4a2973f3a92d74595cc6cb55d4a11c9eaa3b45e425e98fff5a528d4cfe9a0de9d3614cbe8d339e84da4c4d33dba6c41e8ace1f4e050b2033df83ac5e074ddb394eaabcad3b232b5d8dc56e0250fe1fe677abe0888950e2480635badf491b2afbc47f9e3e986eb7dc6036d14194969d37a86463f033909da6b4f0b51bbbd959780ddfdd1139427173bd6f1afca70db0c45c3c610aacca9ed0135234b0b7fc67527455f0ad40435276a2b4999814bf1c897b8e16160685f86dae8af795384d9eabc48acc681b4ac1afc7fe61c26ae6c61377cb0113379cb75a5e4058cd648b90fcda4d7cb67b542b64fea2ea14876c3cccd15f38e0ea40ce6aa6b1d2ba702430db2185b8c2a54b7e6612d4d2c2709f63eb9131cf31d5a4cf09e0d0d501217d7996c078adb67dcfe630dac7370d7adebad30643147c48259d745ca887c6808d5a1a6a78b649c35abff84f91f60c96377b5c970c03068502fe962d404521ee9fe68fb39190e2e7e608149212e12478acec8dcecb32f2a28364edf3c912fe734a3c63f913c0b793fdf212161c5746c8b6704d637e91903ad078dc1480e477549b10b079bfda4907141a2de3cd352a7bea4614ef6f564837cfe0e18f52e32dd312615fd2fca3b5b40234d358da439777bd4c51a870dadd1c55337fe1c0c1efcc5f56bbcef6dad3af955852b856ca5264f85f22fb365d50291e3666991022d32cd1b62f7158bf774ec6285781d519d26665336ebc96b00e863d0733ab7d845d49dd22878ea9efeba62bba86f4c0491b2ae753d43bb9db33d8a5b45cd13b2ccaee412da9c76354f4a7e618384b448a2d137c97e907331c855c4e8c0ec72d218b5ba5ab1ef16fc7008994ed6ee8b201e938681b896c5ccd97fdf7e8ffcb5a1974556e3266145e6c641198bbefd454efec1935fba0c40e5ae8ce3e90f3fd83f9558032e3a9bc43638fd025d350b42ba2ac58d1a8c66bc2d66f5ce85f256ea5bb6039522a9f02c11b5d9fdcafa8d9ea2596416a3ab252c5795b2b6e959daa1001fc64b5560699ab807baa495697d9068d0314d6e5df5eafd2d55c45b73079c238810312f0abf647c353e78d15e997e244ddb7eb5bcdf6a90ca3584b786d608e7c58b4f33e56202893fe185fee2578c50eb678189391eb19015d870d49cd9a38e979ebb88cbced42392b8802446c172ff57d7a0b0fb1e4a2941fe0a17c4b6295e3548ceea9e34b78fe551a122f6319a0480f6f1536b91c43af7167b505f032546b7a02a99175cde69b30b0f65086a93a75534a0eb35d9b626ba3ec685e545918b3bb89239300bc950890301d4e39cde0d6edc6c012d1d554af3cdcc4cf886182fb6490d7b89715b6aaa2d35770d5a9ab9cd7bfc063dbd2c19b7534e7b6961d23e098bd308cd7eabdb9b0acb0c063226018e1fcd36077d72259fb9c2b9bae7416add1fb7e365df34f59edd2b6e4db4b11a5855c9ae136337ff5ffdf90ffcd2408f8863cbcba959603727937cb66c093d082d565d649e0812a1193e6262ec764f08cca06b132ef2bc32489feb07106b300b7c55a99e6ec71bad7baf5e0f9bc29975e8d613eb9d61961aa5d32d304216c73a0b97cd35dd829b8ab5f1d763e4ceab3f04e83265cd69f6f786d2e7d33f3ffa058d47ff63839681f34a0027c74962e411c7f8484339f6f98ac40ee4df0cb0baf8275149e7555305366c8ad4838eb003a97147a573d6f44d34b458716ee4840d829f49462c20145f2d013b9ebc116b40f401101deec61b40edea3d17d4b8287fb446302b488bc888b304b0ee0acc9b541f6f6365ab508fd40a96c7d593e652ccf51ed004f97a248b827e9e1851173bdd274741155e38aee5a7d806510b606302dfbc43e16472989dae3225ff023366835be9ae5b2c9d9fb09e8fe3d0b3af5d3432a362bbfa03bcea6bf7e50176f9141247fd169043af5ff57261cfe7071e2142b022d490057913f5e959b52b372430928722275ba5a8bc8752c7f71e7b4e95b58b0a6865403727c3f2b6d752722a18c49431c36a01d0a6d942d292cd5fd5d488ea37da9d5b843ca8779143e4cdff34fd04bc511c36cb6b8b0bae768f980d9522018b8ec13737fe8d94883243165cef15a39954be13cf514a17e84aae48d4b63f486ce4cd991081b87af796bab1e07759f6e216292a1af5b8069a63dd9c306f221d9c923d90abb93789c19b7eb7a1d47cdc8f8b55c6b78f22899abf4e9ba9dcc6479cd94f9e26ff9588c966a75506de50b34bbe6e789e45528a8eca7e63397780eff4cbf7eae833f1ab45ecf607de2baa627ed92dc4bdb0321773e19d4d83534244eb6ee4d603e2b61cec572969b3d4f41a34c346da073eabcb76a3f0b9b3661a750e194e710fb24f2f15418a819e58a864c19bbee7d68abc7e601caa50f2fab38024718192fab35167de840a0cc3ec33915ac6e8c24a821d35dac98f2d9abcd30fabee212c8fa9647d55968fbd21d259967971162e3ebbea0ee42534f7f44480d198d15a58666bac125662a5b477816f338c49725a993afa2c1e1ea1d28ea3ed7f3e5692bf4584b845a2ff7a03f008a83ebd1298337a42e45dcf348c4e64787fb8322c19fa5e7839395ba1c58a30dc2df5965ff1f4dca872a912b11d7266f0784fa716427542585d153cff1117fa1dd6e64de981ff63ed0104a4af10b3b5303a77631ef09775596f6a90a1e075164e26b7ca3f8b57daab7daee027ab4df1989bf24302d665c7cc746d834e303d9dfc8387555b17902c7acbe0314cb281669c588fd0a7eadead819d775ea03c61a492d250faaf322fea3d1a02c73d7565da8e93a0f027931fdfb386c7be808f5cc088e426f5fe20e85022b0ffc7db50eec66aeb7853c51214730c97cee17dbfc6815791e75136a75572894b8692f32cce9f1fe75c34eaa16671fabea4493de1b9e22873adf265c649db600e3d8839f5de4c47df668d34b3433c6fa0a49ff5779ac7f1845adec8e266c0680d481296250dd79717fe0e0401a99e5e7d15777ba67aa6a3db4767f9cfca530c970471229b05b0cfa29375ff47e74b89129b84d197e1c52b91141c0c85d03e740cdf21372082da8de58a7f7b2aabc0b69baf38cab1cc3b056cafe20871489f6704e3f00867a9db9811c5a791698fbaaf88d4052a01c4e6fcc5610f74da677c8b883fa074a40aef9a94b79626eab6cdcf39551a9748a47e1b013f818da5a5b1cfd509763bcab86ec72f3cea6c801277943575ed9c5e75b82acc033d902f6693165f43f4864dceab224df490a714ea2c0f5f703d1d99cff845331bb76292aafb40a6aef9ef0b2a74b1fe791a93c0ff0b55daaa146578ad8e0154b018712ae2857e6d8c86c2428d28b9de46ab8ffe803322b2736dc2f9d22542b78bce6c7403b1666ba308ad2aa2ea8feb1d0320e278b8d07de8dcc2e143060baf4629431c76b71ffb2de049254f23c6790a802b1a9722e559f9f3e66a43ddd1864ac1d5c84a1453e1b373d4358924226d7b337b3627635f7f3cca9a165a52300173f0b2e582a86b73fcd8db667f9aa286ae38b5dda54b53eb786e3270efeedd2d1f6db5c09b88d28772666fb143b1cb6fc9e3b692f2008c85ae23b3a68d30990ebc2cb654c972c591899a94d881ab31abd68c36dcc1c53371e580b86976e51289bcc37e0601fcf0a8037e13ddeb181d1ef1d245780fae6df10c534e843f4c1a7eea8b89d7edfc4178e6ae45699f35c1c5b8c7ff786b43f830b6b633e7ed0f53bb25ff9283c5d2d9290e4591f8b167dec2297743c3b32bfccb678bd1b5e8c32de1ec2824514cf1c18b42c1cf20b19c249394b9b42edc1a01a07d9f2403f6b3429d7dcc2824b39b9f45599452dfb9b3d8bca331dc3a34b685b34ad2ba52e6f0e3e8a1f8d84e731f60caee28f33062e277b7acf3378c55aecae02cb218c1ceb98cb38362fdb8a0eb61aa426141a457046154e569d2cba9e46c15b211602ef1d6df8545c4dcdc576ffa11c9487f7307e9576488d8328ebd0c92491de4d39a1eac0b72d3c7b243af8b3085b5c5049d2c7754f3f58c0f7aa93a6d0311434e0a146759dec1157f4fd8e4176a029271f25f49ec155bc2693834b9ed406599f6ca4950934380ac09c2b359e258581582e788501ec4eec6825ec1b57b26d80d23d38ba7f46e8e296f1555f281dfb8b1ebee6ed48c73fd5dbec9714995c78ebb3cda6ba4c5360e390ecd195b215d6d2cb244dc5eeaab8a395c55a74f3e674e784deed92ead9e94dc349c9617b36a4ec019b3bad7a423b1be917883a07d74844a7d7aa474c56f82c6ed82b38e36898a28fdd6533b3ddffc9efde036f84e38956adec2c5c009c5c8df2fc2b5db15487cd0f5eea7e225fd144762b1b8c9a2c2be0275eeb10bd88d2f160aa52439c424a977dcf314d6200c0c4c8dbd67f0a9236f4a10618d221100135e7c74ced74cc153ce94faba9d7192601e931399898fbede29d8f4ae67f6dca5e226f9397f97599f63acb5952264e50292c0b46959a63c11a30e657e4f0eeb1e5f212b1f0f3f2a2a5fca664ae7bd5f727d06d1a89fddf60f12a63835d0aab5ad3ae4e121d76deae19c2c1d371633c51c9cc82bdcebe5f9dfdc9182daf43b4a13b97fc8f4b97f202b7d5fb2f2cff0530f718a71eb706fc6d47ccca42329890df32dbfa12213ccd87c4847791226fc346f03e0b12e4cdf11102b7ca6b1696fc5d7a136409215b774029a634afc0887432524e736257e9fe4169c995d79fb2c287e8741544d418000059ae318fe16a38f6a500684b6158a59153e347e6ff8e6520f4c09db4ef69e82a6442cf6eaac3a64e4626f24770c8277de964dc1a0d512b840fcbe31fa53fa5152eda914f149aaeece90d0a39c904824ebe21191c4dfa4cc3b26c61a45700fdedf8f941a886b44f5301de19e19f71a9d3a5ba735cb003bc203d86b2be60de48c073b4ac41c4fc8721f88a3cb92166a0d5abee944ead4a8625d26be459acdd2b5925c424675010000fb7ba5ff668d6dcab14e72e08d1e4eb1de8b722df9c4ca32cd87820db744f40179b1bfc79453611ca57c550cad59a1b0c62b64150eba5a5edf7845e52b6c9aa54e084c796cc77dfa589d65dc7254a14dc7758784cef1cb60c4e4c773f87b9bc77a8347ff0a51b11fa6924abf387abd6c8e897b143899caa4fa8feb0af21d98734a2ef19e8ebdce3d75e027176a63664dfa1b39bf636d6ec798233a846340fa8d1d36c05ef5600584a58a32b1b1390881944be359fae59641265ae259d71d4861df94bd030ecc1043bc5c2dbb3c23df3b3bc1e7efdf66dcd022d7758204e24b5e90103e0239584110727ec6303db26801ba756338ad1600919d1f74b41f8523f733832144e69dda2ec47f2ef0e7797a31e4c69fcde9853a07d7fc08f5818539d339255510335ccc246e6b14e1b6ec6449286aa318186a4470f457e9f8f6954afd5eaa77931ba2a6b6a2ed7ef2bcd2c1e581acce8973887e7186208bf5c5c33fbb02f04579b85af21d435196b119e0263720dbfc98c1ec4e861a1421d8f671a61b325a68ce20744856dd86a2bcd312b2b141483bc3bebb61a42a8d3f69290ecb02d75b7067e2a38af9332a7da94eb2be67185b504bcd2eb0c09c9cef579fe385a8490898637e8841b12f5635794d6433a16f0d5d67d3ce19cd3c15a033b660f3512abe0fc57ac8f8a68decbdaaa5f036be91d73c946132aa337dc9e51980e85cc89bd54cdc160854bf46efa222fa3ec34abf132bcf1feaa0fa4950137fe52eb60c7b8a92d8e6a4dc1b5bcba863aea259a5bb2b184b680228118ff5caa7e1c733c3a1789f58a63db14a22e71935f657466cd06c491a0a260e65835a5c6aa4f80a400df7c94bc616d283cefbd91b8c605bcc50aa007f60963b3cb4e21d8d8b9954e411ca8d209b66ef24808d8da29f76e6924e96dcbc5640cf9b7baf77c74305ae49007210ee328b289e59870dad5c961113c57001551137d7c3769db5fa153ae3a42320e28422664be03f77fd10882ebae27db9c8203b0b3b597a42a434bdefca9de359fa54c051e57c400a864ce19759b0673a39459eabeb5df5a36d827800f83ecf28af317fe14160ae4e1d8132c43792bceec480c20c748f425e1edeb93bb7dd5a639964cb8b20cc32189c747490e1ae976d92387355fd5668aad2c942455827a6086413359ff36f069d7d51f6245e8bf8665d85e7f071ab0e2040f8904a9d40f9634019526fe3bac56cab590429a850b4a8ebfffc96d2b8a69db7b29aab2bc6d08478c47bc958028d192d18f0f9bd3ce0b3fc04a2bc3de44490e1e77880e276677d40ef401e7a6123a6346693cdc0d567cf8224de4793d1a0e3c65bea8a0312ed4df14a5c7c59171bdab2ad53e7fc242687fd358d4c2d190cc8a14c809bfe426e3f85cc7a21d4d1002c6469590f1afc2999b6fbf92283cfd2b6148c5c8e486d7af281573b422598a35b9e7a3dc732c34feff9da96ec39bab98d32c5f5160e438ea855ed85f34b27ddb9530050a0a8f6773f8f7a7d172f601eeff1b6e3098741277d48fbf1db3a0aa1ef7226c678cf7538ad883f4269f95db833d367d4ff3db00ebd7ea5132b0d4b95e7e1eef1f1fda342f313122466c0f5bddecaf590b8cbe071eabf66d480a8eeaca319f28bd351003093a26869fe6eda7613a730f7e2988f97497e13350bed4ae630835541eca2235b1e3e372aa24abdc7b9cb93756046a10a16007eefa0f9e248df50df63645b33a6b7970143b53ac4f7fb4cc44df0d9828284c0b260ee53f83b61475d0c71b8821a33a4fb3c4e921464f82289e7f23adae8072ee830c27103e0ce6e946f55f29c3f3f614bf0fcf0a4de5d692e39dd2b966e18c2fbab93c92b7d78bf4fef2d6be109a595d9808aab2ef0803d1b9f47d1ef62f46046f34e86daaf642a23d185e13a5b4fa4178818360bcd33d773f1235d546cbd42bc67fa155b613264e5cc13eda2d1a62f2dc9089188d2d8f242b2c8d6cde81a3c06403893a6affdf704bb4020f0fc9e3c2ef4ad06aff8a507c9c5f43b6a5ff6d4974aaf6cc13547a7c40ea3bc971fc091e570c03e59686db881d6269233211715317a8234c306b23323a5a66089ee54e6789605d3794762f27601145f5ffead4b0c922642fd261f8852d4dfa39f42a49e6b9f31339a4c1667d14bce29c928b1741a236598c6cc1fc19fc859fbb89eea3acc5b5da1e13de7a746aa23a0fed520fd256f1c7cbc2a23475a35b49daea53a45834c76ee759c8a0a30befb92822961002c5846b250b687365a8b1f801a1ac7eb0ea078d21d742ff925ad52fc58d853725a2836f5b6e0b33c68aab07ea509c3e4f01ddc5172c097522d871a10caa007e0187adf02db797e21f944616f3bc879079f811515e4e29a22f3d88e89a9b0364e465ec56f39770f69c01d9c22067923fbaaf7141cc7521f8bc42c6c07fd682d3f398e0c5f5b9349feef68c413659b26dad6e19d7e623c5fd946e288ede87a30fb32bdaafae9e2bf2aa3a497f816dd1ba53f74990c18dbf686292e48276bdb97e621b83537195cb3557d1c0252597fbc46d07db7847a4e8d874314ef844249003127e3b4411550b62f46c58bd733d83494201cc2e1bcc5185b44c167e66682155e47e4183f5b50e53b69858dc0fddaf31ddf2725e5b9a2b907cf606db2925fd34ebde7cf1ce8ad13ec8558a71aec7bdbf0daa7d3fda4fe3a54321d5a3c82b2310b6b07c6549b8df494f4d8b1f31c740f9a3bc12297fc20db907d5d48946bb298af7d28a6cbcf6950a485976a9ee124b0a5325e5a6cde29076e8f41717bcadeb1a19f22816fcd6b3a81eb715ee480e71241fb0e37f965e9dae177452ca75e851e6e62b61a141ba4257f6e8eeb60fe6041f58c26f4954679a48072c8654229998f1b8cca93446d5162795a931fe25cad3e3f937f3ef0102e96946e2c7eb34ba78fc387e63ea2b7d365b98710190053023b402303b6ff40fcf3660fc6c1c6dfdcd7aba8016b6c7b4bcc6e4290458803bcb5ec803ebfbd9b0e39d2d37e43e311aa95817d4b1299941a21fa2ff1cbf6978f14dfab0f1bcaec9842dadd06bdd89b6a1ddbf1c9282f7c764fc79bf7b33d8d1333b082d4a20fb4395ee5dc0b5c8287bdf8c11ec1cb9c3f09e702f4f6b736846bf121265f9096a9939ed4f14dd982d54dbf5ceb1fcc2c7633ce8a8ddbe305cece52b81c6a7cf9b0c76cb07f5804b99c6a2e0706dcc36194e973af81a6beb270cba92edabb83a7917c9b60c7aac63c4d7d65d9db5e50b499abb87f8c1c540a69239f24d7e8c9111c88c090bf5781c6846d64cf845ab2c690ada645566e807dc5a8cf8c77de936a4a8ca52252451f1372b1490ce377873ea640aaad50d0b77961e2805980b8826d8dafa862b4629a692176c776f8ceaa7c2f59ba3ee6f474f3c145888052878fe481767f1705c040ef1a87dfabedae20d7ea0c50f481b584122c1d9d2464b06542ba9d813ffce0ee0d12c6dd85c7214cf46029e241f84e39d90c24c09a20442991c12217b0a633e77a9d029f241e5a2ad9d849087e278289d2b01e421089a4df3a8bc01810cadf286fe935a15e78320eb4d96ef64d0d67ea2c2a990a045dcdebee03c47378548adc4099f39e6a4c65c154a5f8a11e41ba6c1d0fd3814ebdc4baa3e3128910f3c082a3063846ba835ff3a247b1b9a522f5442262ecbafd5674232b4475002bcef4a42a88d7a870cc8b73cef08b05c61c11ab25c7de7be476d208481daf4207f54fe7f2431837399d5db7a5005993204b0610bd39f2130f5ba6180f4abd5cdb35d2f4bb5bf89639f265ac22b871124deb84a770bf6d113b884a8780b1655ced0a0880acec0d879e0b49093ab3c746569f40d13d67afc859bbf3a7d9201800f8a38ea396e4bd19b39cbc3e9985c074da86fcc5129a19377ab113654fa3c2de51929803c749a40a0962369b089606e1ae2255c50757e3e116229f4dc38fa7847ce81a367a9ad4afd9974af99721b37e06d41b120d1a7d5ccb7f00e6e1ec6ccd9b6b2899b43d788da4994ff476daf3c37ab9b4a5ac9658cc64f76e727fddd318a090d144c60c9838a98849d3f33564be4e955e8d72f9b82990599bf8df5ef5df07fcd81c87aa4ba88e039de04d6320e710c92a646cac5756541727b1f952f488752b017eb9c7f5c2ded910710110479e572187fc1c364b1f9c2e00f382cb5c1eae712a79b769226f2b039f50507527c42de30b2c9e44ab3634b0c8b247cd0f8c373a5d2da1be1fbddde81cd8be71187ac34a1f4ce21a45f8c66f16a0e891e3d84adfb98feb9001682c4b4ad2a3977a3d16e31fe7136a39d43122fc43691f4f22488bd18cc05de5c452a13fb27e481218f3482790a944269766e41c99248d72cae329c9d5c648a285d369e8cdf6da9862efee579de3d12c69f94a627f0a24c5237be5f51b6cf9e57ba3a0223664c8a2f153be30e1b083a240d6ff1dead23631222b8450a12ad51bda49f2e8cf6ec1fc06a1af941d247f0859fe18bd22814083e599291199c7f7203dfa389797d390e6bbe3a46dc8cc9c45cf936311da4285bbcf2ab2872be173ef8dd1e80830c6280e52af7bb165366da15a72ffbb266f3f257f47006fddd3351fd98075e6be133e95b0409cd595c329596716f1fc777c9ca243f91f10b427065afe256159d15a7cf8ed353e1688ca8911862c69dbb01fc15688912d032f9ac1f177f1611b69f737a5c13ee83a53767c8049926956d98632d3943bd57dbb0a3e4fba9c1844bb4d2eeb0bf053bb7a46c2a230aa3e80df6e89f9035c23266055e944973cb67e05adbb582c867b0576aecbea0ac8edf4ddeb857a6fc826e7d99f0eecd01b466ea7f2a0aa0e9e22002f7c02daccc42e287e116867dc303ba0427477cc7ed4e802f52e73528340d7d99d59a8b1db226cf719cb5c23f2235a769f498912abba9de9b82773d5ad7ce53aca2610fe8a497f86b130f2103a81ac5a5ea375cf1377c62697f2c655779a174456a62ede4e7a880aba479562b6cedb74a8aa6014b8ea12fe0a1de6874e0f4e91cd24e1d2660f5f6373bd9b356517885b73ce0cafb5fd872cf0b584111d7edef8b415638f23332f0d0006210157b641514d364267e951bde5fd10064b081ca43a9c15c854446887c26fdbd96c1d2e0cd857564abc58969095fec14e0e4be552b5e749c6af4afb9e22706fb4859b2d5cd1fa3650873cdb50751f94f23a0ba6f730612d4f8bb550427c96baef64b376e2bb25c131497fea1634975f4b755b8c0caebf6f8fe63f2cbee7a57f2fa6643c03925bb7649c38b9e269bc0174b701d6190a4c26ec38f6de297049c67a9c83a0309c16a186c94f1d739892e8dded0709bff35eec82153489375e33d67168bd1919b123f09c86b9746ce19aafc334127ff6ff7766690254f795dd9814c4be163dbf528a47f70bdee2768a8aca7ab72a647b10b88f7177698c663b22e3e032a22f29545288f5621ecafb6e3356a6e528794b03a0fa9403e64fa438048df0555310720e7e96a4d0601655ad903e8bc773070cc5ca5efaa2f40e2a5d9bd2f9d8e63b8f17a235ac7448afaa76cdc7da498594e894a917786d4b572ad45d92c5fe7d40afe96949be550ae1fd029b7bbff9e08c5cf62f4b535ba3751aef597f04156b90f257667f6f6fdd536d04208fc85221e0b2b73c7395404954180ffe0521e22258bd45a25b593b3c1f100d8bd8ca5639dfe9f2054df00861ffd483acf8a1157b42db697dd39053c69882e2634af4473e7cff5ca978361af4e42a9aed835c6245f874ddc9735cca796b81f84546cfc17aa0710f0f90cf943a2e5a8df2df917a1ed54c4f629d43cf1bac2c558408ed0598eff936c7e3b01054215625d5a96bd61d2dcb97cad22d51cb491446cc97365632ab9332e6383d7cb96767ed6f97a24baa7b333fb403968f3b50a6c497ec5ac9b0597840821a0027c8c136a0230d8574a2da46f421bb8dec452b10f0c7b454917a6a77a91a3d36f7fff461145fa4a5725fe7d2f46decb364d20702d909476415846e7e1efb1696113d8b05b3bd1b44c6d2f5942f61e62bab90a224af1c17db9953b680a302ea9b4efe3c34cc28eb0e7438de6bc30bd2b8b1a1d0da25ab3c5c6b06383321637e10802c7ab41d3b2a72c6028a8f5a9ccab6cf252937e51df863495de61878983d69b57b5b915d769e06e5b6a1e188719a69c24c96901b3643ff713f2c37898ce317fc0fede861a9094d33721b99ac60e0ffb316661f9fe9b26410abf0cd4109438020fa8a9049f7c61376868c03c476c1a876b28d0157e3cda91c03d939ca51a36d1f6873de6a001639127a1ae9e34636cc2e64b0426ba894ff69bcfce7052eae9293209a4b57df37049a29b96660285a5afe9e29d74c4382c13293e02cccb3011c264b23416dd208dca1d6d6903403532b83e527aebb813822229867534d82ca4641f0a4dfea04e178b350c3c8671863e84d5fe68d264939f3ecbd535108cc762812ae5c721049699d6af4ae3e8bd824b93345bbd1c3d72893aa1456e11dce47c2b78f2f613dabd1ae22d8aa07c1edff5b33103d9f1630d2e50ab0d2fb975c9badecfc4bd5b97ab7f94f3975ad04bd462b3f278f1ffa18eefd9d70e2d4e3bf0126d7f1945c1d82107fc3b72f67d926b3bdf72923caddb9a06afd17a7e9b6396d5ff9caadbfc9dda8ffacc73318ff4697d2a0823e7b9b0cc60e4013e0940cb916567f0a4fc21835d36df5b05a2d82a0e8efadc80290330f59bb30f5c5bae06ee63277d159450e4a778155eccf76d887f129f1f08a37a7ad73c5a5809a034e4c2d6583879e1dbedc085cef683fdf028bae8489e8ba4c2123ab79bd63fcadb657d054bfc68552696d9187060a3a67d2d98d51d8b915e08ffd044b60d652dfa1cc6e873bcc7183a81d1985e06659d9a43379f53750a990ee5011f1caaf8ccb72d57a68579adfe183667e351185ca57e69560b042c376d7d190ecdf37377b7e22a1a3a2909366fd33c1dc18917f9883f7a0d83b23a5173ce988aac96ff810d02e8a16349b70de851a364f2f2d34b3698389a43f4747ba4ab460ce25b57d94f8d00334307bc4f13c962e6c51e4c4e3c5b98d3fe9667a4d72096190b38027152effaef0b77ba0","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
