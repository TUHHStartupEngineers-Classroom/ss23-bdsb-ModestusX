<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"27848345b78f492c647b156c5eba4396838e33f27eb045a8c8209a9bcb38ddc3f1e7a74fc6e863687fdeb7b99e9c88175597765a32914b87c4dc44a7ae1373b92d81b3ae36ef232d4b30c6701f7920edeef0145f5d8a358e9d33296c55b75d3cec07de8cb5a4d43c5e93e2f03b4bdee917e87d9e692137e198bb1cb2f6103b9d63c09deee9fd445753f0317442f38f54d00ac314f09a272b7b3f82e860896d36eb84b7c445be81b1ed168187b1f4d53e56a08bfa405205dcc2c97c9e7994605cfd8bce4db85e6e8da09de63671b693ce5f405510ffc0fe71f87b44a7bf61dbf2692ee9d24420fe7d9ca3dadce4bd69b74439e4b74deebc425e4fcf58f78dfc8d0dc49d642afb2bfa9c7c1166a7bc1e062ec8b00badcb5536bd018555b1859f353e957e8168db88c93f59807fe8a2b2813a8ad1d92ac9847da0997e361587041a3a1d335f4196c4ea408f3e398fbe67f5e619a8885f6948e9b76cf5243043e788a901ccdd61edf488f9653e19fb3516b178a762507ad08cccc2cb4d334e28515a2b3c1555126a96c7d4edbe031ee08a30422d7813488510d6292dd33ef07433af8b36f2ae0a6637c51778b999875e2ffa8aa2b08d22a43ca559f890eb614545a5b7b5fae456ad1150ca3fabe829d9da29a28ec6a11590f5deb87bd497b980b814f38b8d7394e6a267d6ef0d6bebe7262b2a520c7107633a7a6db5b9048a333976eb3c6f4e9438488874fdc622a66517ef9b83125fde7ecf8987127eefaa65112f14ceedc8b084a69b259e5669094bdafd79603a0c37aeb19f9a981542895c920f8f3946107a854312ed170bde63270a1a0c3a89a95e49320caee2ef32376046d373f0197f6d1a4d89b96890e0ceecc66966e6ed484a1fdcf3775bddf3ccd46a67afee1aeeac8eb7b2ea7298f0ab4bbc748c9c89a2dacb044cb3dc08a5dd2a535198b4b3990ab5c979d8098d0ab5628679abbaebb6b8865dbd13c208ee220a38f1f333e7ba6a413b665064df7786c2fbcbaccce5a79a3dcdc768b2764e6684b5da1339ae7d43ba96afc6158b5cca81b9030c97c28e342b5aa8d6ae96760d759fcba3735a2c6d330e8cd8d460b65950d8afb7ec47aea217af8f0142c6c8a5347982eb3afa5376123f47b14583e003b56ad3960679e831bd54902184141c7d9c6daa0c33e806ebb3abc047e6982cc701eb3e465c7ef0123118a7c36580500e15f361ddee671670a6ecd40c471b3067bbe33e0272ed2b0ef3fdb37976ebd596732de12cad70fc13d52d34a35b69f0cc84c1a14c8eb586c584a8b09c1615946bdee4d3f571083bf0d67a0521c88a0657bbd710f6bc13eec54bf9d9f88612bcbaddc9c225517deede2f9441d3dc435488f93a300a76e4c279c3e147a2c8585c8bbffb36b6ff1c32bc1f3de1c83ffd315e07f0292816794c1d13307099d353d7ded83f576f2d704a3e1a763b432f494b44c47be4e1231467abc1dfdccc8ab0784e48adda3e5b8f95010b53527b83b2b7c8913fce270651b1281b2f471d7b321de9bf89d9881a98e3a8e6f119274a2a58ef1ee630e1b3df2c6175c0101a51d2eebd809a29f06a05484d82bf1eaa169253aaf79710c211014d22a2857d625e231e1ad2bc4ba0268bea429315179faa1a5d6804052dfa22d638d7f4f4be0a0167ae785c93945606f544baf4d48238a039c32f91b20590c51190602b9a1f64de451e2788de78e4671ea8859f2a30d57036a2882df7fb4f0249a2e2321d677ffcb0017a1a671055dc8592a8a5f0822e9d3f258f886783e59c4160646a302965b05c5d8ffd6a34cb9ccd535c9005179aa3f7c487eac16a7b710ca0b04567c2e46a31b19edd3bc6361da3d91f971a4d0c0021acfb2cff980d56fe59b3d50b82270aaa409c37c867fa885aeac45f5dde516e27f4acc668d797fab5b77943ae293ca69ba02768dbf6ebaf81e0f0bc5de0f76d093c7823c88a344b7c9f8b813baa33a00a3fe92ecac8403b6dc95c439f8893ba0d2c21f9cfa8b5e027db22c0be0c68b5f375cf64a9f37f66f319142297c1089f93519fec8d7593d06fc050e93f9822ca237ee52a31b09fb120c79301875ad5568056b66157d51302a9b5ce83835757e831ad81ff50eda5e72b357966125820ac9a31d725dc1de28d8aef1929d2f757b824e020e6159ecd71fe5033ced4ab1260b39fd65366214fc3229afb3771b356884982a32797a5840ab5c608872d9f40b8a7ccbc83dda72d2788bbbc8385168ce8db9d3975985043b73c24dd041d3376ab983c17f44d8aab523067531fdeec9ecbe20579ee5eaa71a129259b0edfca0fa9f004ce5c33038663308026a3425e091e2f7327457d392c237005644be5e240b6d2a7225e367504d2e4dad6d41961508ee49cf4a1efd9dc41703f2051d3afcad3b07372d5d6e5da7e1a7aa7c791d7beac197ec400c3544952e6a7a7b69334d26ebe8aebc7fc9c3e31aaaef8e23aa9398f209b8185b3abd35bb95944b399a1cfae2808bc735d0f4daa9601d40c589709c82e29c6273d4bf400c7f814f52d4cb1124ae83b35f64be0a2498dfd2229cd845fa4c001838baf34a3874ccff5b1ecfd62576c1ac1f736e57f54502ead05a44fdc4f7d34212a97d3b497617a18be40e077f7cb371d773cda3afb1f9f2647a62c5490656064549133869df6ab5d27cefa66fd10159c56d40d6f241c0f81b7bbe224bfc8811c0ca99b189f72295e3be991775add078c0cb9b9fe652287202a917cf0f6d8608b674943d28799cf5e18e91e2e9ebfe0f7a88e9f4d1fdc183e97be3e1df3b9f0c245b1ca4519e1daddaae49ede6917af5dbb99407fe56d56aea34c622739b23b2aa860476eeb81f02e83234887923a0507c5b40888976c5e0d692af622f1352df7aaa4d897b73159a6f22e0250acdba32870e66325775df775eb146a53f718f9130f5eec225e77de0359bd865089af0ce77706765814e4a0910f60edf46dd3740c00cbd95d935028ee33d1e090d36af740d44908d6f874082042fa47f65caf0b802a06cad7717fdf792705de2112e8521ad3a1324e847c322408e6629488e46c13397383acae155187096722fc16ea24796801084af47c353648ac6dbd1b5eaa9e66494f0ac71160d93d00e3f2ba3d1d1387ddfb6ab488554a06dbd31d44b6550c4f3aedfd582be14d95050e791ee0ae64f735a3f617da81811b38a4ee736f6ada282cae6169ae8391e5be1f3fcc98f159ad9cfa09e0673f9f17b575344dbcef3549c21dfbc63a0eb0c8ff37734b0cc7c7769f3f56aeefc375243b6a41242fe34e2a6200b79b0e2e890c0d446684628cca41746e70832395354e777f45dd2f24fb730f0ac7888328c9f57d72fbb2be7cd6ac3383b6908343ca0e9d15244b3646659e0df010ebe38f0d8b66b5cc57e0ac4e0d9d72de6018816cacc423dc9379b215cffb3517144b16ad49abb4faaa0a5e287f0720fc9df0e75f9fe952ed7cfd004413664bd7bfe7d1957de422e7f1cf04a0a18ff282bf21e58d2bd937f2b76cf2b04582a59e249b58f238c2bad971f11ceeeea860f08578d0784a407b534c04b562b91071573c2e6db5a511756a97d58de9bcc46994cb729d97027f680e3abaf61fbbdd57d40226b3edad419a6528c59481a279405eb8c797d9a93b2515f600d38e66f3ccdf5de7fa28070b982dd7c6b33f6d2c6152c4ab30dab4d4c9941a6a11adfe7805c232993fc3469ef7b1b115adb611d6aa92bb5a98461c8ff78b26fd8469c1d2d467b08dd0cff8a6924ca40070c17b110ed77614c83343501b99d025ca6a9dd9894abe536611f5b2beeaeada63da78e3a978ff31ecb0287033a9716cfa012b0e3e8b31545050d17dd31823d35066023118c12fbef640e84d77d2dcfd2653803c63bd8ed8aec9e85b8d9915e97e7d14b15feae4dcf39c352b8b56136132946770e853b88a4eef0fdee83c977ac85d33981a99e1085eb3527d785502513274df5dc7dc361fc3b846a778b8112bd25b44f67cc10e9f19099616b84125e64238352352c9336dcb99a00f3538c4f027c9ca444ef828c0871d0d5491cc44541f3993dab375a2de6e38387780c133464a93a82c71b6235f29f95ec660b95c4dc1306cf89c55ccdf5f8985aef3f0fdcb645c9f8c5e6f9e1e4436ec179048ad852ea5409226fcde6f6f26e614a150e30dfb4a08cb7742647b6434a4ef6f34a519c204de7bc48ab07b26658189e794740de21f6bfdc1bbe192e7030c6daab2d7d420dfa1dfac77f3028a040dfbc0ee40fa139b5cbe5c4729a68dcb93edf13e1d3675edd26eea17c092f3b0159c1ed603c311efd1674c94ac50edde1baffdac3cdafd5b7ff1d2d4a73ac3250b509fa7b8413c86c93176cb70dc7a70ad162febcb5e75b7b2b76b398abff730629d6d6b0dca42a736276531da3369b649793b53a84c3adf7f99fca1ea587f5747899df25d0b125f424504d815a3da46a10a565a4a4b906296287982de1b2a9b9380847a9659a7e5504113a781dffee8b039d1e13afdb01231fa339d3d109695accf98c90a9789bb6400455ad2aca358c33f6ae5bb60b8fefe24749a1d6b201e75612363f15901b4b345207ee9de949622f5eb290c0b157068c04bf3ae88e705a40a4206ea27d3c9ffd20960e547ad6cb5d17437362f12e4b24330411bdeb3a0fe22233a331819f66b21c3f20ea355116c0d51dbbb95edc1229e502a310a509040cc05582fc605acd1c4d0b74e825400f0c2ee6c2f4eb7a3535b3739737afa2c9dcf612f0cdac6559175a9ed3d8a70acad97b8826cea1e88e6da93b6b9e1b563a309a963cacf09cf567bc03a1286e3790e258741a49cfce94db23f8bfdf32607885913760b249a50c973347cef8dd1e7ef48293f8c3032fff19749d853be8e435cea0506fbf8f07650abb06a294122ab5df916bab10f63ba009e1b172c0f87bf52b67083235f0f08b8775bb0ffae3c17327dbdb02392b13af18ddf551a9a5fece2e2b052d4e58543af68559992e2e57b90dba7abd8c2fd63c30838a49d6501ac3451bca7ed36ae3b49cfd6c0227260176b274481642cc9350e0ac7de9466ae035c816890f8d6c45de87c8033989d0e44841d7e52f63e492026e825dbb17ab8e27722c06fc5473b3e792e9ef7ec7eba9868f929d0da9148b1d6308ae0312e84ea5325300606fa752fe0ec87f652a0ccc28ed0173c7619d483a0e91c84d68996d9fe8a82d5e2f0ce9ec5c8edff9bc8206fbcf9a48e9ae532351385948e2346ecbd3657ff7940c69e0f6e0580fc6af99dd03af65503dc89246996623f6ac7b103108b00e30f4e37f8cb5aa63706595c96f2558dcf673971104de4b1887559a36f1839a32e9e94883c337f6dfc8d1464bff3c22390fd23ec518ea8d61e6faa09a5a2b92bbadc063d9039ec65b1f6e43f1881ac385d83569f058a0e01650adda9a4cd774c751cf5f0dc4bb56bb985e6784753acedcc1f315ea91b329b181f47cd4e88f88beb5c585def2a3fd939d4d961375af973347a21a1bf61e5ef54a1b030dede35629fb6224ff92debd42df29a4387204c0413f1382805c29a3f2c9f094887b6bc28ce069b27dc8d91a8376edc7c63331ac490cf5e544825b1a6e3282db589c8db16ba80abc05b4c42aaaf9b676e940e7a3cfead83adf54a16f1217be91d220f1fa5a5ecf9f8d3df3347a9ee8dfc75c168f0c11610a60cf871ee39d983ae0eec83e4f63d9caac3dfd0273cf770c17cc459bf3eb411b0fab761bb4cb2b83e51dbab5226ac652651133eb083351e7dc571c24ee213443c5a870a6204f1d50b17a9e229c7362ffec71140dba2e2c4caabbd18ceddad62287b4344e5b47d4976b9f6e1bd528dc9d4bd0608465eaf97e047299972147346fc8e413be74cf69b607e14e5dea1d4e63cb803492b4521214860ae50ff9407fa117af3b951d649451d8dad3643d279a63ec3ef0fdbd25c30e4bd91eea2b6e270051f8e5716e0a7fe0e511548d549365706eafbd4ba2e01fb7bf965416e83e685e8a07befa211477bb1031a1fc4818cdca321b19b1697217c6fcc0552215d5c1b56c75f23a61034716062c1e20d6393ea6e56bb33e9be29d02a1d81d27b4e77ac955652582f3eacf4f93c8e4549fbcec22d61e6feb3d0b72a33b07c8c524e054c5ca9a99097d0ce8b097b879afe862d8aff74d802081d56b5f2d9726b4bbfb40ae52bb6f623d1f13fa2540dfd3f5cbedde7131c35543ea420b7d8fc56c9e564404f8a8aa15e269afe162b01263f76069d6595454bd77e1aba470eb0ab1c1e423963987005606da43bf000ac95335f76a872f525e59cb766c0d3c7813745f2886a46cf74220e7c28cec1035a8c29798e6b5469e204658822923c589f0c7e3e6b85073618b48ce735b110bc9147fe78b89176fcc3adb7d3d20981422373c2fb5a0ae35caad079f5a71be9f40ef3a40768fadbc86fda8a5c731e5fddeeb58a5ae1f82d74995a202ec4e2a01e3237d78181c86b9ef46dae5d0c2b8b3fb1e588ee393f267f18e96474ef677e414c26ed8c59df7c3127daa8ccbc218d9817c995ff2beeba1b795bf09eaa75e3f93cca44106de980ae714c77aaeb6ce62d9f7e3a3c654f6e9ade5c7c8b8878d1a54a08163d257f1a5269595acdaa9a00473053221c06e1738917253eeba7ab5e85660144fd18e52b92a39a7fd7a2ee9b7941da3ed90f78f21e67e4e0a90af4cae70caca290c2f139597e9e9fd1831701b8be2120a01c6cb32a707bbbf8440087f7c12a3525f158b1d9543c771f0e6db36b6bd8c434e1a4581612a8fe550e7b7e310f23eeee02cfcefc2d22d6536c2b5ce7c67c2ccf9b3a4d64b38481843ea10af6576c8bf4d6cd689366ff369f8743a5e4973fb48e7ac5215e630edb490af7f1f1cabb2897bbda1c5400700f65a5deb2d4c75fcbf7be73e007b403ce07ef0d7f2b097379f78005cdd100657f7344d6926245d1770cb39395461b9a7afc627cd97b739d2d484c4f3587a6e6e0b820698dbc402b64270ac5bc11da663f0f5da6d712b67410611b0e7f63f734cd36127c5449ca28e2c615860b379d7a972b6d4133d81491c8eca9c1e815235ba91a98323c2dab05cf7a2a14770a6717811b6ccad665af38ccd1a37d1462bb4f3eb7cdb85ddd801e9d434ec2f031ffe8d356c50561f53ce111893d71bc9d2d1ee17b2e7ea79f8f34737b5f6304704933133faa64037d94d99acfcc0b16e7c716a9164e08681907705bdbb0c9fbf10a9b32a9911e175fec64b1f1a20cdb1357ee921a023f67b3430e9437d9700dd6218e7279c83ebfeac615d95249b4b3d19e1669a5f6d4636faa444a70ae4015a7c6f23d5bbe6bdf41327604b471e68460a6f254277caf3c488adf2c0b85037f57619e2286027fe90c0318926b11eb57589e7ffb6b2354b05e0977fc8502cb7c09262dc9d7d3162988b0652a4e2f046e0c14d5acfa8f9eb5f3aa807639fb7a0bfb89f526a7f384f0fbecff44814413691e16f792793e588d0125dbd95333fc0f2aa80244f73467551ce779fafa905498c7938836fbf33cff39df14b06acfb48e734b2574291ea7f77b3dea91b9540da5c3f448f2b2990f788a7dc4ce055d30ec018527d26e15bb66c73164bac41c49f927d1e951da9ec539f276146a1be743e1a30c91d112c45e8ca3fd41acd0bc8d368870da33d2c118cf4fd94d6a7f823f2324ea3f05ca1dcf1765aeb9b848ec493d2e8129ac134715d71b314702ce46cf1e82aa104a83546ad97f5e4d92d051514b158ccd5e16ac8a79909ebce770d43ffddace0ae62808f2fa511857d1b8962a2379cc662fd0a5526af3eed5440a3b98440f9946846a765494e4e9d93408cd76911cc473ace39ca51f9fcfe062705f2f0f8767d49750b2357c1028909a1adf6623186b268a6e13329820530cb547bc1dbfff9891214ff8f4b22a93d5828eca4646a9bcfe6b263c3832585671b1f740f52e72476b4bfdd4bc859dca4dede8e65b9189a94cd888a946a597a2baafd2de330a6dc77d95951c0ff0bc182d66fe9ed49f92571feae473c076cf84f230e3e787aa05a0f6009f8fb5ea2fd3dea786546bbede938220bb2b26e4b8cf6ee1140dcbd439f92695c3ad8d5b79189bfc79bd0b0936cfc7cf946330264343b12c4af3de619eb995d6acc282b833a862c467661e737b49eb4d22397969e586a0a357c98d015f338f48c1a3dfe4b046c8d5105fba0e59b41985acf1ab0baafd6c3d81ea3821ef781860331a8ea1ab744e155ac40762a1070c3cf956894034f420b3207ee51ad734da118166c4df7459bf06c5a4828a46a16cb45ae73757fcf1da77991d562100b902898efa22528b4491d8252a2cfa3cadadd20d305727c79ca599827c366b28f076b38bf2f8f15ba3dd390dd4eb9e23e45cddc25fe681c290855a1627b53bdf2a8cfb251456f80fef4592af794a796b20b4480b13571a921b876e1e2b0a608d07d42d3462fb47086abe7500dd2590be3e581eb1d1cdf70a1bebf2680589fa17f848bae438e46a0fe92f726f713b09ed38582d778ceaaa94e3ee9945a07bfbb7e03fa4816af745b058ad13552479ede8523199b3d7c396d86403ce690485bd7efb5132a694bad02c1e44fe001defaf91e8415e403dd75e0fef3284592b360ac9b8044f686a7acf7dbf8e26314e1b9c6d8c084219733f562eff975a628627d42252c4f45dc3798e8b68b287cee1aebc3ee37e12190962dbee1601fa65493bbe19599d7d147bc9d580d9dcecc1ed9d4b9b88a723ce1ffb435e39fb7992ccc65aba3c64dca79ee236e97600da5d77cedeba5b7609b2afb94474fedb7def7cd3c82536050462fa4cb4c06296ef863630efd81f6dc29f80e6e7b10f6bca76382aa941fb6a678ab253b693167cebf73eeec5ba0c9b1b2205497a435ae231f53637af5952a983ba685c9976e3dddd137448860cf8bee4c07106afb86390119ae89fd920f67a882e2f65635979067c9f87cb7364a482d93d37e4b9777a0a76318fe43758d2d08b9af68cde9f822c6fc88379a012ce5738f0d9f61675076b7ee2118e8b7e369d953c251e1d28fdcd90cc4c65087772f9e81ff5cc84d9702d265f0b83c5efe52768ab926cddfe376f14618262f4575c61d3c7c8cfb1ed07e1c64c4e251c2f67f4cafc9a8ca810bab9993d567fbc50bc5e20023e88d0572fef6324d4e50dd9332764939797474c010a992a3547c19a35b1551f753ac963c5b056ac4580ee98403f8fa9d784db8af58e8edb0a860a413317388b0e0857bc3baae85fde997cb9f5eafa3051e8e7e90a373769c82b14ea9eff45244d927d4b19fc45c99275a5ece849e2c1628a9a499c358216505c9716e949a49ce0406bd4a861776ddfa3071d3d581fac5af3b3932fe2bf9e2299049441e6cd6cc42b2200f5ae22567c820d78ad437d789d8d8d39119341f8e687fe859291ed0ec1d0188bb7ecc60654528fa0eee21e3563aefca9257d8627e34086f6f334e9ea13e0b233bc7c66cd0bdc3b4598e5ff1cc4502a8be81108737ccd8f663ac2a1645e949634636e7dd86d7db21e8cccefabc52cfe9196a7b4254063e94114adda01f60c8bc3faf1f6940ac61e470e3bba78ef1f0562331b22a82cb0fda3c204910750c50a4292bf0b6d0b8283dd64ffb8d7bf536a9b07c14497e23f24c3a6068039cf666ee81c628f1534e7ec251a07b7ac7e68fb4292982078c780bc9895f315bcd63262d9ffe72ca4f22385ffcc1737a0ebc461569a437f5eaed0eadd1f18d7788717914cb8ad8a0bceccbb3645d123544cb0019cc8fb9a653115b1f8e4189bb0841594c627c6820c8e57b0da4f46b778a7eabe82e88275380c96a6d2d67b36a4c40e86f4bdd9e8b13f9d9f966e8a5fb714c33c5ddb65da142356273d5e90c316d2b79b35b74462e496587b0a17f65c96f070fa5cd1a90000a643a9d9f995a9591484c7f70f057e5968c7e2c25c87f95c71cfa6a5f3c49b8400aedc51dad835b33a82d7edacc0999fc5b9953a1cb707d7bbd6f6ab45c220a160249c21f7140a4e071b02ab712030da219e14ca8d5df35b1ce65856f0e6c3ce6ebee10c761e1eebf6184aea27a6292b560083aef78624b25e38e7972d31dba15bb355c1341e67399e6b9ce6a8b1e57d653f09fa5ed03fa3b9718ee87ce8b83e4fef109357067326431490834895fe9a279c09e5755649cee6383b0365d650ad73f539f44f41f6ac16e6ced924d7ccc311f5720de023ade87045802b928f0bd24ca5274fcf68278a4f4b91880342d38d97eb6e530eccf1e2e1da924201580aa3e47d29a84964f2ed153db43b9f82cf3e90a3c555fa2683fd0cf066169d3d44665cb30012b1843bcd36027101709684119908bc93b21ae64c130550996d1660a45358392091aaeebb4e6265945b496133b34b4304f9f185957a24b818cb384f0422ad68a885e4f683ef555732e7132fa3939c3f09d214acee1fde140e0bd4d24a320d9f51b2e28abde0d6f4b144c647656e5806d0117ac168b29f34b2f17496bed995222975cb9896d80c2fd490ad9ebc75286b0708c09db5e4a6ea3efb4637cd814964c89dc0dd3e3698519b72da0b9b1461456168524e1ccf71c81446d938bafb8481f987f5de0972e15247e6f0727c2d2ee0195d63f1733e1632da2f9fa9e5b4a77ff533f497a5fc0e7e9f26eda3fcdc30f9234bcd3afd43f26f2b93a1d37b06c603c4fda90e206057182692a62cd0d26fe12132163069050b19bb2e4221a3b4d8740150bdd9b1be5d44d6dfacff22929e5722e88c20e9dbf0a5e427748de1070d2a42375910fdf60487e0daf174b0898d67cfa2e3d7dc3cd56b88d66226345b69d0f27c710b12ae87dcf842deff6d548998fe3b7e1f1d6a07e0507e9932792cb9191e5fee8c81381f105604a6ba1b577508176964bb2d30fe3e73c6758db0e5b98ec4656f65a50b0fec4d1cf92b653d7d279cb389f64eee25392da04da7e6c6ef709a56a7c5ef04ae2f963dab6211ece572c9bfc8b35173bb7461160ee5616bcd990b040922326bf8c53bf4e72449f3149a228235213c160728cd2c86f429b2f01b2ba79e5ab7a84a1ed70d396da88fc35cca9c2598673d8b542da312d559a9c8fd00f765f075f96f168754a212e709d7bb82875dce5017a8f2643b901824869c68d3d7d1e1919611986ab366363bcde67d7875e33960a873de5781bcbf3c79b18f397437c1855b890b3c65c680f6ee7b7bdb29e6e6f2bb92e7cf763f2bfa1ecb35a74f25895361bad5f8710730015529711f234fd2c33106197e0df5f30a4ed3f64530cdd636b78065130d3c9dfb85b958a4465088cd44c76d9b62badf1f8c1d996c55713ab0447cbc6695d8ad1865212ff1af9b4cc132fb3fd31c2a5869e0ea7242ad76312cad14593d91a75d708de53f3c11dd9c581e40052dcb4f1d0b562f39de0ea06feac3af989f969ae8cb59241459a541491310a95906d65c93e9fbdf6e78d2c2777855c56af1de79daedda77ff07073cc5d07bf764c96b1b7ee4571dae588cbd358989b441f0bd172aa66f87be028c78eb42880778d0c767a7eea6864a62082db764a28767df5c90028ee7be724bc1ac25cc353cbfb89509434b1a2f6574cb7d5b8b0b9209f127f05fecc8775ccf96a9013eba053209ec36efca62f9144671f2ae4f6f735d2c2c8b423e540cdc2b9ca3c37f027b56f624b807155ce0b4d203465bae9cc626cbc6c254e93774f6cc7cea4d436d33173143c9e999bc9169d414e0b5faac8b00ce6b8c2590f62c856e5c4b49d94971bed3c4f77aec114fe0bea8128d9b39ef4c070c95e45cf68c02ba8c750174e92c7cc1ea285ea5e25446822945d70c18b3cefc03be675c0e406c8b6573c80ebb0242ad212620404d48a47ef0dd923e7609a0c442fbd71b4ab18df878a69207e25154352933739830781b6189a5ac81159fdc2e4f38f9242df12e128ca8cf8bd0c28df3b594063706069d49b3d0b5e3f22a315bd23e97c2be961f0f05525871772a06bacd6361a20bc313a62fb35503f3b4a066ded93783be2018d917bcbaddfd064e97a156ad73422bdccdb3db60f5d3d3be1c7eb023bd9db1ff1aa9171ad166cd4215a8638bbd372aea89da114ae491dde96d45865decf3d45d6b8e2890d8312a7b25c633db0bcb6ac9ecf872684851bbe3b8529f76eac78f79d5d6c7fee1434e2319bace900988c0a0706b230083b7f1c14dd9c25ef4176edeceb263f54ac22d4712e1c70e3f6feb9cb56db288a171adab727dad6506376d23626a215874e695cf276ef106fe536b09b953b2f8b12a50f4f215717d14d3e1b4ef67c308e67e6e95decccfba4c3685edd6759bb0e9f37d3d31d7d4594c6da51b7c80c9da67ab9da8ebcf2225197ec734c94f0af1a65903ef854399712af6e1a1c426a0210631d40f70a67f21995916462a4df4f051882a916bba284688d8ddd808c89bc690e64e4ddf73e34153c32e4709cb6575594bba943525e4f18caf84f31aab22fae720abc1feb181e32fba2acfc8b07c0c8859b8bfc2bed895a302922245e8511626de317db5cb17506dd9e9d2b9fea30372e54624ab95bebf5d4ed1e053b847e9b45af0db7fda6bce9bb40d2afaa82f6747a98625e93330fd707813de4ff8e4732c218618ffcc84d71e31dc9036ea4d67b25b6d56d8eb653be81c47cc1123f2e73f2042433b3716f81f974f8e97781600ada702491f42250447ab3373b5ede347ee5b91f4c9edb971d38229f6d341cf450aadfa88844d3e2056e37f346245c43b73dc74e9bec30d99266f6f65072781b119f208b6d49c47b673d751312b2c44928e9e3f5b3500a4f11543eb93d2c7e08d1c54271ca3e20202f6d0a03ad1ca05c214372e7f6a4b44a8f2269e40d5f51ad8074042830599636a80826c95c225264648d6e39047171973141812570f5967e823185fbce5b9fd1aad451b7dd57a899e08975bbea33f64593c7290b46c6385fad9514076d599add5f5ea4018e839a16dba2ea48e737d9ea4bbaef770d95f7ddd4334b2a445fa48ca5f68b74806d12b96921316e5c194cf7ac0796341af35e6b89798a13808bd48cfd8de5a2f05aece6688b5d1ccae6d858995a5e319ae21bfe1312e19a5b9b1a718ee6fd81dc39a94e4602e00987b3cc10e338098981846635711d9664d87eb06577200566efd7e645eed097dce0efa52a2d739d7de2e7fa271fab9d97e28fd96c8afc2ec5dc0f2236c494e32d16f298fa1b3103bb420d3c26775aeb6fbb2c47b2f1a495997f171a53f618a0cf9dffd003419ecf78bc8a033a9aba5ed2d501108f9316140fd30c67cfef0a3d4e6e6f94e6f4558e822e7adef3f253781ca081936a4c18e81ecd80d5f937003613658383f026ada39ba7ddccc1182e0243f72792527ee761ab5d7961f876dcd24742f88ef0a7ee5582d1b4fdbab263f17ab9ce617fb1823bba5c2e51c5905c4df5862523fd1b4cc31395083f401c829d6ab15db275a437e91fee5507164e04255d0becc0fb0c4202b35fc24dbb9b8063403a0ffedf5fbd62fbde9081ebe2b53732631b0b9aef44d0f62cdd74a743695faf3a93c25cbe51ca6108e82c1ae29faabf850ffd3d0db0bc29bd6500c40b22d619beae2761d74d22c146584a689de0ff23722f0d9713c3f183a3859720b795a9c291b344b7ed75287a3bf130bf07059a03cccc64d1dfa7711b7873fd8eafbb06e47d95f22e45047db05409c5d29b5b25e0d73f430160bf80637421291c91ff976f07e31271db15693b89f528c87704b7dddfaecf1de72a42e88a5558aa950eac542fca4942a1f1c6f15ab904b2ffd8b303846e427fab2f08b470929f74d41b00da209d6bc638a398d98947d190fc30ecad42dfc34c6c8cbfa784396a1437a8cf4c521f0d5f21f7a2fa7c086f00272bafd2644deec763e207302534022d3f638c201700c66e44f946f14190e459d643f46165a5aca00c7c20746006a9b5e12be4fb1761fabe9220f51688e09071e83d688425a9b124757245111ac765fcdd058a1425d3a6dbb7e224dcb436915612e4c475d4c563081f17509b716458b8e81b613be19671d9ef742d015a84d8952f3faeb9786e2b66cca4e8741309bcb7186ec99dd76dcb8df7c8c096acc76099eeb2edebb03c30eed7d55297d2493b1d0ec565c6c1a3fe6189cc5e3a2277a7df26d63a319f7b334a6e6425f5b99030d7e34122e57b7b0f64969aed2adc1b367722aab538f05a3e2f309d11747d3733cd5abe384d9ddf1adf08f1ab9c9ee357396394f04e7ad4b16572afad72ed4ff0ac4e2f8d6d5ca87ae544e45a7fec6b1684e4bf585eeb1f44abce9c0771d1fe906581b71b254af0c5e2a55599e936198727b9b88d337c2905e7a571b83088dd6fe2b57eadec51d90a128d4e49ba135ce492444c1b63151250f093cbe98accebc33f26c85f02b29d2343fefd4bf08fbfc1d5b96d4f04f21fbfa973e41385e8967c872a77e6e5f5be7fed519e67202b2de2f34288f9c4f3db653d516afd7bc4f62c0e022d86356aac8bb020d0e29e2f9c9dc736b742c3298ecada2ea1c9c9bf5d89ba4ffb2b80c27f25bf873a74a0ee35f67d636afdaba573955ddffdae1059e3fbd96d9b6946659bf3a9e1830ef2741ac670e535e2588794fce38c98eb695c693bd7f43e5a0f61afdf340e9ba52448518cbec1880e712e2108df925e3b71317b60cc399830836e37a3b64d8f6d196adb79ea6b34cae9846ea4267778fb3326455242cb365ba5d6dcb8779c99939e9dea1e8c6785bab6541d0e635f45738b0e486b7591d1f322a78f825072cdf1cdb47b0c2f8db75cee5a17e9dd86381112e80bb4dcb34a8cb3a853ce9a77f5bce8da72461eb8d6e39df4b1613abd09b29a0a8b3d5cd7b6d7d505060844822bc7787d3c97bfc0f52060a5cf3da51de7bbf0a7075c12ecd6b4d2967d509d3c55c370af38b491b80e92092257c4d0edb27b0fb316dcd4534f23942f7a5dc41127ce6468af75673d864845ef13abf9fbf2c6eb495756e818248a7439a92780acdfb659ceecb7ddae8711d2090275c278e1bbf17ce1a5dae9fa359c6282203602d543da3af10725e712916dfb22fba7397df5a0491123cf4a4b90e2addd3b0a241a752cb1860daf0d373035835ed107dd7becf60b5d7b11b0166ba0047b3590ad0acf407e61e04a2de47177c56da01550d236f4b373be4cce0ed01f725682fa353354c2287aa2e3c50b1fdabd4ac7117bd0fe4cf450ca04d98393de85fada2c0bb1fa769566cb55df63835084c1bec29f0347c4f609bdc05bf1476a3f35c27bf2dcc3d4ae67a0bfba49256294b915a22f26504ca4ef4675b06b9318f1b084ca1ea105fbfb5248255f6897e211c8d1078779c4664e49f05db77355bee6d460d5f545b7ba366c61ccb80988887be7023af0d8f568637fda603905fd970bb8378688ed01df96c1095f7d0695f1217a3f20701e323f98bc2f791077ddef087ca61033174835a325922633a3f45230c8d45d514308808fa36938f53ac012dfd76bbc7b8b3cedaa3132481b86f01810b404ab24fcb81f7746b55989a72d5310e7a07adcef47cbe283a982b5e8f3a6b05a6b558389b9692c8575571deb78f1fceaa2605446cfad7d6dc5196abef141886d4055d26021c9853baaaee1235cb42bb7e41ae7c7e06ebf21689b8f131f6f3ae9f4a44dc55d290e188eb3ff56caa81d0765fbf939873657b5de97b6ca0146c1161e470e95a606c50d3be15aa96e0f3b2c343a93ae1f2613b9f0c16489fd1ab830aa83ba145f33b6d83bd0b8c0fa943532e81f04f87c56631166a4eebe61c3aafb4f6d1f9eb845e007f6a85e28681a11b3e73f472b6a2bc926b26258f46da4e0ca25c6c5c38cf5015e8371cd48064e76d7e1ba2aa198a7ed3e33edf6fce235f83121a5e5a12b4b6b2dec38b0d2271da4fda1f4ad8edbd8d4241b62094cd44c74585342ec8114e471b76ced02da600376de1f8fb6dab803c13235e87c4dfbc2e6ad3016b1f983d48436686f2c3364e4af891ebe92bb558fed3d51e5aeb432e50f81477764f301e2a9b786f78979d8866cfcab4cf81e5865a2dc919f154c15143631df907f02766fee942d09f88c7bc8b147fa747ea11a07c337ed621e0f376aa915636aa37c0390e55215c29e660315134b9ac69ec86fdf1547923a938dba758ceb58551e1ba741b0e52a3f3b9a84261b57e817f0ae3f39788068db240196f45870118a3511a201bde7bb54b75a4231dc75804921bbfc0966a14e59f8b5a5d23e0ebeb94323e034d44077a7f55f09554480c4f458edc09cddfbae86b36093e1c1c1789861fcfe1b03f21f96f13c4e1a788f46cb4b2de493d30d438c0b403a78e19b87f795194288b2458206745e9eab20af68fb2196f49eee6523b65fc9e7fb1f8660d711abddd4d0d1b1daf6e9ea121be51e1e3a1b61510dba0edf714517db21f456cfefc2bc2cdc236a158464134e622e8a5ffaa52aff53c1271645d9ff4ce26ccc7e435a9f78642175dddbf4a5f83701dd2e9af83182f352de52b3d86b6b800a4715e0f0f81fb2ea917e0c30d059b2c3baf3e46d7d5d2cbe341936defe207824f57e5ac255cb8772e8db44b0ea4a88d58b15515f0e242f39d3ee52b3a5b9fb3073ffe6d895e6845f60756da1f529d7ad14b58278f5a382004187274f389f76ee7e12acfa5f3d6c4dbbce632bd84df31512d3582f764a0da0e92dc757410d83095b6f3ef956f62da91e6e4076b07c42dd563fc8d29cbafcf14f1428036220dffa8efe32650af88fc5be44277bdff24043b64b78429fc8f9214770fb5dc82b4e461cefb8168dd4af26c586639b7c8367845dc6292d51204b4a8996cede69af650f3f9c42de1ad4d2ac9f09a3da4a73dc85e5302492e1908c6773088ae7352428b82c1323c7ef9a83be4e875486b4726c827321e98141e6fea322c665aa71da6f791378d67f84e171eef25979bca47e821d78d4ccaf098c6bd641ff7c6ff913098c6e40693ac6950cc7a9a10277b7520e352f4bf05d30f1bd49fd1d5c498f40f120aea794d318237c434a5c29a9b3a89f4419fe22bb56a2d1a71945cbf4c2a463ac4b7cfdadf173557f76e6b3d3e839a6cd6fbc9438a52d38f43bd402d8f19612c82e4a148dcc78a769e3b3fd58acd3c4a09f88d1601bfbebfd7323729bf6356414d367cb84f6102c8d4c4e0c04294154d051fa2072881ea11396d1c613d8df7a6d7c1f1375940853d9fab3d898ae58062dc03a736bb3835d6268aba5d292abd9eb92dad109456210216982bd4a05cec862c89dc97bdb65f56561f6ade447d606570d0a62ff973763b14c4896c7773ccc057e16f70c8962d98746eda87ccda514d38bdf77e01d8864916974f4def56e4f7d147b9b57eef4ae1456d37216014555fa51767ab197960e48bd2c8c22afd35a47780c889b41da5628fe5eca497ee157a2755686d6242d2449de15337d5228d0a2b1548f747a2be9ee343b951d4d609ccfcb2a56bc47fcea8cbfaa2534991f63c4a84bf3615cd10c47b5d7a089dab2e35d4b835032255961dbf20d87d48d2580babf113c654a6e003cc84bcb2786141166a759a7e2634b7a66a860df72e34ee3f08711581068afd413b83bb9b5d537cf9de4ceae8fcfed75afb22bae554d2581c8a512e6d8f04bb75e0983b96f019ad2a0c6355b6c1269fa5a33bf9ce836690183ada1f404fe0b5dcd8a8325dce6c19fee85eb07d3651d6b3fc43356271d7045eb42876c1326fe775d55dac68b214c9c85d3917f0d7ec1ce268c846eaffc0657c96f89123d48add48e19c3df0786939de3e7c7e5d11e96aae3542c67fefce911fae25d34047ab2bc00b3a3d2074e98c0bcdf20e9698889d8cd8f7735d53ef32bbb82b7bb0e8ef758d567a476c1a2e71d5006302c886897f0c8140d583ddb278178dbb1536e9b5492ed1cd08a3b695d948bb935babfa2b7839b05161abfbba2b109988657922f9bca61794144ec9e497f5446e92dbaa5b7e9de6ce9460027f589750a7b3624dacb6e8864071c16458e81fab6089b0a8fc4fefe1cd21ec7bde2f08388bf05732657de2d81d061aa7809893d6c21d4d2c089e51357f970475494fa1c65a41d7c293036235a25f6f9fd872abd219fdb4eb0c1550d916379e6be4ec1311fb62ecd4864a5b0ec5510d1a02e78978cced277364d21d9ffb22d1248f98382d3cb4b9af71300c1890da6c353649a66fe76b7cffa905d401cf96f4ff190262188d8b0e8a440543c7ba59059dc0189c1a521a579d03dc71ec983fa12b6070b196c6baef1a56859579169c883d5df99a484ad0a5daa8781dfd45572228c863220ec41e0fbcd6a16e5a8fb3968df7073da52ccbcb4db542961fa4dbf3cd7df91fae0daed91902d46b5151262f62723f13f56bff04fb8d94ba93b68549c923465a74645447b12322c38c25bd321723c8836601951c3abc0721cf17aeb14ad75c3c3ef50158739378b1d78853043254da5c010db9924cf9495d9207428f23c5a7bd73f9a478e3e98abc457ef5ec72aa8f35b35313645108b81b47566104b9ff79b54112e123ccd2a65f13656580ed17760d2954ce17f7aad7c28b665b7e10edc72d571252383f535cf526b156aa40ab0a917319a81580765def972d49547a6594e9bd743f3b88629e8430c7890fecd48bd251b1a13033d0079329c324ecfe52bde8a9de5c70ff3df4002a13b88118b0d1b7cc4bfae380181ebc56c807a0d4bfedeed8f27c10f734ae9d4e0b023de19547966eb5b839e8e8867ec19061685f91406b009ca76278578735cb765ebe42b827b43e10376bc55c70d8b12fd66a05b8e7e07994aa79f8e12dee8acd2b29e815ce2f961d7f20bbd77a3fdc101a7f56f19a9e45e7a6ce6b97d39234f0b8fbccee2d595bc0524d1429e0845b7a80343735756b3eb288bef36bfced07ee4a13446489bd484ecd8dd81273aa93246452269d26aa8807c13f70ea8eb470f5c67fd584d55c6632a0fbb2f33a193661cb2b07f39be1ac9a3b99fab1c767b06fbf26915c18c5e82a1a0966f236b7617b1942018575efce154294628a073193757aa4a5cc2d7a05b697a3876dfa8e112b956d066869cfb743d7de1b2b3586a49ddba1fe43d8eb1af263a506c6726dfc765c9a0feaa6f186ba38525f9006fb7c48db9faeed357fdb410d40f5c2fdeb7b7ea49ecc30156a6b821b2fc3eaed419b87cec4d86766f614dc241eae2e07772b1c2b13f6f60dfbc06047da5a72da859d8eaf6aa23504eb3e01a3d1db8cf8e56572fd8f4006197e3e0a4060e348e2ab35b9b696ea58e531950601cd168731d51e748b99d81f1864894587400c97cfc0a60abe455d2ac5a098182d0e623c3ae08b8cc43f20b841400d1069d6a5c844014f3d2f0f63d7f552adb1f6f92a60f648f35f2f7d30292c251a248acee7be7bf5ae8ac26c35c11e50b9badd5fc2229d77059e4f6bd8cc5109eb033f78edd2adc16874f01690224fa3b9f5aaa99b87d1ea66b914f0307f90e3c4feb15725274a94f9aa88a17498e48c51dc6662ceddc4d925f19063604e09af859f9acf57a799b1ff90aa78afbe8ff193e2d3bf38353599ac830b6c23c717e5e8dbcf1e50f035043cb95bca708d8b5af923fc18f6bdb853d56b930d1a0ddb519e7608d280d67f36d664b80bbdef27b17a4c6d5d3bc746f9eb3e544e05704bd7d0b05d78a3b9b25a369fa8576f123806d4cb6ceb1c49394987766d2086d7e5c8d7896568caf4bdf8b34ac214c6e855790f4a7fb66f69ea4883040caf439e2a3e0ce5aae8fdc3b02d1b54dd69d3e5a15e1373801ff696e6145f52f0743df16f1a7166fcd227cd522c2802f82289c8292c7f38d40e9d695b64aab0a077f09d79555bf5b940e1cbe10621e3cd3755e9fc48f65d54fb5b6b7d9c4ef97d96b8a92f5b21cc2a95fbcf8eac4c8398650ae8de98b275bfc8b08fe6f71a58648b856adeaf5311a9d1aaa0ac4965405d991b0d26bd9bd2547efc91e3022bbad3c92d15c3f5b3458fcbcffac1b61b72f6009d4306bdd084b5033c9daa431c76c3b25bd1e600835eabd04e1bf036fd891263ca19944f1e9acec1479f658068999d388a829ceb50e337ac99b97834a07cf09c7907fda5491f1d03b52965a8f6816798b6e2b4ebd8dd55fc0db404c6af4740f81d83a46817f4b782aa5098407cb4996126968c8180cf5e526478d71cdf2e0cb0e43fe8ecc365d264f9c13dabe0b82e89d79e3f31f6c57cef70784acc9b9837f26e249adeff7656348bf070bcab26eae4a1da3d046fecae21767a347231a099871177c2605b558c24115c22513f14ae48ec159b53c1286ea78290b196e2bf2dffcd7fd505374e299c07152b77bd379c44d411687536b867b5f0b16cf3e39f4bcf9078b0a888d23b55d17ed80fe5f1b84b24cc170410131a1b97ad0b0233a3e29831b4fa0c7b28a518d9931fed7ef719ca966e17f54b7dc031602259678f07c9398bf544b3beae4dd2ac3c37ed28e7ee087701a45a9bcae5de84c5b7f25c03c0547f5c6946c81814a56a5f238b48630cee61d9f1ff5cd26f47760bbf18d30941d02fd8ca9b76fa0f91e9c30645e1945cfbd08cb4cd45aa8c6edadbee2b9789c20a9ec54ec07401c6cd106e563fea0888d3e1cf88fe750915d0a289f6a0c0d427dbb016df40db2d7f4e46052628dc491188785a55e20288f2634723d7dc9a1b18385dd71207b6b767be9a68c54e1deb2c9e5cf6edddc9e0e7938cbfc4bdc49e83cc1f04e7b56c27969910f631b1d05c0ea576dd02877c92ef37a34ff7d98840041ed33f848f5c4cd0e8545371a24f4d67912eb5fb6c525d79ac6c8183b37745e595a689bd0d78f692e0efce2f965e3014bc2354b4d33c8bbd4a92f59e2e9d6bd268466b6bbe65df761d1ef8f2027f0b455027677caef2f918f02f3dbc5679f38abaa017ea2631aab5f059e9e1388cc996d61f3b10d4a3a803451938b163901d8de04d18298f4415db7c3c87bb5ba9b4639cb47563f8d223add569f0b24055cdda1338cc760d1e4501628c59fe4533afc07560477f536fdaed85bc9bc33b64d0a5876bbf327262e83c3e8f63acdc55a2dc4ce9b464b5c8a76014c326aacba4363c78726c788438332f969fc09984418450560464959839a2b31981fc78a88c43e1dfeb6de2a0729cc0881d0d734faf5695e6cdedc2684881705f2e7be12a2d18fba99ba8e05f971ce3c2f0a27ebd4c0de89e136e5fba82d18bd583a3d2d1f1a222d80a18a342da12c96a29f056003d7c71e7b46849d1ceed4f9b3ce97f578b1610a5ce8ecd4d7c0236517d5e75f106bb20966c9c3a121e1d2ed750a1b5c34679355eb89566c0e2a092c21618d062c0e2174e61b48ae0803103b03154b6d406c4d0fbcf9318f1a71644886e361220e240d1bc7750e185a9f0e152e94ccb5174c5e0ea433f3f2e3a314a9a6797aaa8f73362a3339575e61ae949bb5dc307a1083bf6","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
