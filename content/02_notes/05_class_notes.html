<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"d46087ea3efe63a4430db697fcaf81951d512a2fd51c84b9d06d03d0a5962d719ca58a4d063295e81387e7e10ba2c4242787708a379284d0b3b0272b2b30e1969dcb644e903ccbf970e95555aab8baa95c62d58980cb81392d1c15e3d4464d533c28c2b2916e9c9026848bb5ddd2fb7412ea6dfd40516dfd053ce80cb378721f1789617a7b2fd7ac1cb656f2fdd47b9f29fbed72e5711939a5d91765a9187652dce9c021420b799f5c02df5337d2fda1bc703962dcceee14f023c2108a1c83655c2ddd399719c6f1e1b617a9fa67255b59cdfdd2fc99a34d064343861ac91eb1caa30bba83fc317e24f526f313e854ccaea7fe4f59346dc0a310b6ece66ed90d7a3f6fee602d274804a74e8883815b887d150a9c6662aa32d5cbd18e10d2fe61e178f8cd37a32771636117eb9a25b3561635267591317c7e281795e00d8e1367b94891e9091ec37a6460a05ff2eaf710dd6f0c787965758df899830a1b027b393a60fd5bec1737f1bac91a8fbaa2854e10fd6bfee7dc39b4a4a46dc6a34bfde985aa445114c850f4915e5257c79c718b3afce3d4b676b750fe41bd9f259e674c39d361d0e7b7acf0100b4b05cf2fc3130afe0d13a018b7f8aa8d28612cf98fe3f4e2b24fae0730a1844632b7fbd569675fb4f90df0488edcc858d435c29189be2a079b2ab52001ff346792d2c9460f95b383aced0c434af281c137741c6fccc1d16abb24292841b167750e10508de3537854521500f5d468c6f9b4ce1f7c0468afe2ba78dec93aaf8df44c2b9905299b8eacf0f99e9a204c932662834dee1f7152f20d44357ea55aef6297de28a30de5c25abdf5068bfc3b1c4047f1d43ac0a8babab27bd0480a21efae8f398749865d74f05703dfbc78696e02b712839e2e76216d6016ad7338d6605b40c8e4a6891b0add4ee4603c16bb259873bbfcac4024fc1fdc45f38b38a293cd3438d193c0b1b60f041e47a32ad6398b75f9c1f8c11b72f972234dcd24310665bb7618a9c39453944aa59aabcbaadfefa9be86e4bac11c941e761d287468f586c4b8d32f64523cceab99a43f908b15154701a709b2e56a3e34188b8c60b6d5109f9ab58a6693335e5fb080781d8a05d70948464207aeb8e1ef300f6c6336a49a152910236fe279f06bb449e0cb588d1995ed35309ea650def010b561ccddd61db124ebc668b7d0c06ef09d9c3fd0b7d5a425648877215ea0c4c5c3f50d3fb72df320c5f5993efa5f20b1cfc125876d2c57a9d149f9bfefb24bb85a76fe6bdeba48a0a40de2eb19814073d6c928856863c2cfbae42ac50b30ac42829902b77e0f62e6a2ac9cf6c1b9544f4da47bcf6b3f02782bcc8ed40f6ff947cf6c02733d6c2197c85176cd68a6e50c948285e4446cfe840a31ac74755f86a4ba950208b8ddc0155b62102afed0cb7d499d692c7276f359b8d10e82ee422de6e80eb0a8fec827df0034790866d1207ea7ec7b52193fa92a82ce98449202db5c8470d7624df0b9a63aa1ad2576246babf0194f436020f75afeb07a5d2af8b4db5e0311b33c994e18ba11af64fd335dd6d3f5930cbcf45f6d0b0096032f53d3541342109250e89e3ccc18c9987260c2c8addfac94fe0dc1fef19cc327bc93a79f89e9a370b8894e34dca4f68fecc91d1e073c00ef41a1d80b7b10fcc82166eae0602fbdb5b28cd63d369bc528fc8a4c6322a5d304043f5081bb272b1cd4f691225804c558a0b99c8e70fddb56f929e8e2dcf1ef6dc04bb0f3cfb6c558bcb86a03a6b240724e322cf80d46043a78c5252e765e83aa17020130b1087cbd3cf4d8cb535f7a02f884e881efe0b673901ba99de03fee1b36efc2163284a359252395a9a5844543e59af4775faf70ea046c96c3ee0bc6ceb8317311dcdb14e47727aef8148254039faa6dda71e8cc2b0167a00177bf9054dbede1effa6863619fcc8a55368caa08d1a071e2940f63db393e250b5e7201b3b0c041da60e191b361867f229d7a43aa2a58e3bfd3e728cbed593d3fce5e20a87b31610d993b550b9708132da3fc6cf68d28a67ca15e0a7bb243e1093c436872fd017a19e7a06094e79281b42f74ee7173a5c096b4e84b903722ba342c888ae160f0d2f9bb102cf6dbff6e9cfae13c70c8f3424e82083686e965b1f6bc65611c4c3d3c322a92032bc50a484d47a159cfa3517d4f0e3285988638d528444e22f70a3c0dcd5407500f4335134cbc77d5293f48a1b7d5e703588e68562764342c033052f240766d7eb23424ace9afc7b81352cafe4391b42f6ebab0193843f824476bb83bd63e3bd3ecaf4e970d8e7314091a2f68e3b3dbfd1a7079aa7c5cf29d93508a004bc6bea8d0995e3baebc077603e73bd3ec791f7924a46a0d6b9d20234d6a707b791d93025b0b3ee1c6973d6e6cf54a289689b4efc1fb6416ca3085a77b03cb48356378d9485b548f02b32c5e41f6b7473c7f1e8ca8496185640bd71af41705e92605b211c6aff65507504ca5473f5374cc3510af97bd660174281a3742d3ba2b4f18a85af4180c30d0ed6c2c69ec771bb71b3b6a79181d77697dab7ddaf0143be31e20127d76385404bbc4cf10219b079cf2f2951350f620180a7feac8bfa5650c3408ea9b843884f5c2b12426c8db82dec24e2f2f2902aa10cf19bf9007b75bc89e5b6e28cc10d9e536e8c792b208bb013776db4bbbb26d972e3487b4fd6b387cc1d27987669a0a75a3e9c75a42d2e0d7e6ff92a4208264286ef3fb60a1e3b9635cbbd0ecb1610edb3a3e00f3e2eeaf46669cb9ba12399dcf6d462aa16a9c05ca3121698c50054aa06361133441d21ac1ebc57b83fd5a9ff820bbbd4539499e6941eb15cb1924c27ebf1f35ee0ea7eff671ac10ed29f990bc0117eea7bfc79df6c46cca859e07dcd1d175602c17adf485c0cb811776974597a4b6e0aacd2683c3ca6f2730707f4cbd61780e88fb9f7dfd7e603fdf2659f6c17c8e784915cc37b0e2b1ef28312ab25c5f3ddfe9792b35ea0adfc6924647b260d7c3e408f59300ebfde6a2ca08f380217fee9fa8bb56a148e56367e241d46a1e29273c470e812f5839f8d468de44e9ac771933477f6d209ef0452280bf31da701e9d4c67d1c9694bfbaac3afa97a0b94e08496edeeb1e7a20e372efd985b29fc2e80db46794b95f39a7c363009f34cfbbd7be74de1118d488bf1acb39fb7baba92446e2e3d1337d028c5dce3ce4e85455b74fc7befa98c8c32d70c229dfafe89cd10a345491ff6d500a17f25da7194ad6b7e5b2d65e1596d7a9d5311d1e8fda4f8e784ab855ad62352b486a914d6143b415a681e6f3a04fd23c410bc4453ffa31fb73f26228c5ffe8b7fbcf17eae514ef193467327c581890e25871422e233c96c0e1e700614d5ac002500dfb7e56e5d7530409195524ff5088e04f4ed3c602f7b3b5467624937b84db33ffdcd5667872f30bc440a15827871ca2bc097409c779884d099743c375260276d0af92a0850349779ad7d485e3862f48265432345216bc57c679ad82998bf443c613423547c80a4d3173bc165a5492ca75e8703b1401e794f4430c499a0f7a050e4800edc5a3c285fbdc02afd7be1ce62af30698f6e9bdcc0fc3625d48e02d97341a5c538db6d24de7942daecdf7cc1022212c1171453693d9c37284af848a8d025d80244fd0569b21efd3f795422508c5d57014b445e0ffbe13b633af4823721bd25439acc48a40a49a548e23d55cbf0a64371f1fd2a44e489aad82cf7178a706136747df18e170b787d457d3bebc05f44d6da71f4c7407e74cef29c227549b84213107c2468a8250cf6d35f886cddae34647d37f801b09ca94ce5927572e2f632d4488e6dc8cd36380c82933d86a6a7d33d829e7bce90c36b2a990848aecf53d107bf30d59dd6c4458f623435c3e1e4858536b4e81b654aed36728f2f467a72985f4acf1e549f96742c89372af6ee2c6583eb1f47cc18140767c1c42c5fc5039c51c9a54257ecf8a53caeda013f0a659cc484282dd57f60e2a72efeb2d187720f9905d87f9f01f4a9a5569f7f0275e1abf0f29945d2af4d1cb8f73cf1dc9047985e40fc9ecba59dde2a454a253e2d8bca6ef79de7780853603d9d7d9aa08f2834bf4fa51e93bba56e67e473e18d8b68b504f3a569d5f92c3a78d256c238f4d3e2dd4b94ae07c0209f585222daa08ed5cac16b8164d1b4f71148fbb1f3647d7ec098f4d9f8d95a682de7c9ef5a6705bde15b44c22c6c4a04ba9e5ff96b0dbb1a7de8f48864b9ec7bba9a89abd14fd95d5b42a20da3a2b19baf3fc494973a391e95b2ef91e5db818497d67d844341ff4e22edd75f34832bb82f1f179fce52789e0026c02697f0c99b7f6d257e046bd91ba9f1a0aad1db5af0bc07475bd6754bc24f8f0d5072160917a55f12dcf162f96cd12424c3366884e7615157ce999b2d713ddd146876a311c9c7c26e523f0d29734d21acd972c0f9ad87986d317a87373fd5053000246d695740cc4b5a61de30a59b5ddfb2f71678f8bd7b40d7bcd3ef1db7a3125c2413d5eb576192a20e406c06e1e105900242223be190c0976d22bb36c040c0dd9c19bb33eafa78076e7fcf15ae40310574b700be4211b73b8f2e19a38e2c80ba40e72c618699c9b40a133b8ca456d749a60f30c5b90719a0877117d059667c2693acb5b3febce831f1a8b84a0d343c3099a5ff7df0f889a6e0dd97e0dcf3d79d5c6544dd44b4c142027b12315239c2808449ff5108ebc3adca50f4093076ba23fef326fe37962ef38e54fd86600da1590438c98c6a3691d989ee08514c4f43d572d166d6732a13bb3f71013f7319be0b1272558c4472f340c6ab4d8ee4514edaa51f369c10c7f79e7e5ac22b468f0220e9d97c456bb42631f2936b522bcdb38cdf28c6b7f3ba67292db79bded12f0ee6c523c069763834b70b9765cff6ae8582c93ad6051cf488d3d2a3d705c9db9659756c55a63dacb3767a217f77bcbc00053a26414bb5427fb814e27de1cb030d9aa2abdb8962f30272c7c7e1b71b36a048dfeaa97dacf39c05617c3f219afac5ac9d1448812883f22e799eeb400358b6a3deb6498e7456c27f2a41f2ff3ed576cd579fede9ef1cce28c2d5a661270f0f7486190b9c5795b1170cabd601ffa1b621f2a26a9beed0ea5832c2c604012619ce1c853562e65a41eb13515903eb13bc7fddfb9f59a62d5a5194dc03f71032621873d18c9a9f77b8ea6cd12086f0a82656ecb286ba8c4da9857dc5886297245f869f7936af830183ce610702d152364259e91651ac87d097b9e3350e262ca67d906df93518971878c3472a1b25f2b0f70ca2da66a84edf25bc1576b6949abc9819639a6dceb6848c61396bf2082308771f78b11c66a6f835977853e0d2625139ccdb789317ca9ef2e6a948d54efee34ec49a77658f5a58800917073bc643a2ad9bb612ea40d3737598a0f6058a1afd72a1cece175be2d5d453f5357fcdc19e32ab236a4b9e8485574d3cdfaffbd8054468fdda5d20d706212b3ace314db06d4c8c9aa9fd6f2f71564d6da1a52d81dd151f75d126a00dc80f41575b3cd964dbc4bb22d8e782b86a0d82f20e0a2950327c70fb99457650f3a92b9c52b413e597c014cab280c9a447111964b1d9caab16237309c28021df6bbac9bf34fa06f65f0ab4cd5818417bbb3bd97efa8b5cc119c543c6eb6db14f69b20a590c1331abbb11ff2585ed5827a9257cdc3f2058d5e7aaa793d4a6699b38525a0263f24ae7de0def25aac8f91421b10d4fea82e4c051c0564d6f5aff4aeb46b2013f9cfe37bd9bfa56c7abaf195c2c8449e67e1a3531a2a4a76b9901ae12656e0203051408d4339229b9f9806ce80d9dd345406c8a33966020ab424d9b0cdfa3c0dae00f2606f9b88e336cb0dab9d73f6856648979802b3f4d33ebd32aef2e7fe9dfbc32df18676283eb02226676de0f06033c374ba81c38718e6f9b2d2bf66b7ec0eb29aa21fd911cd39af94ca32942e714ec2a3138a1ff53beb5ebae4b21315c2e9cf8e6300ee19c59f943585a12800087fbfca08245aaf302d6b48b5f8450decf0564076915256bb4727da242e0b3dde95056336f540426f928469aee3b5e1f56a8b186d6e9402e7e8e662a2003c2fa053e8f3dde7bdd40c79c69784bd529a2b00de97d4fc7db560b11faed0864c341de03cddc74352f7aca75bb5bb0f07f2497e8795167519ce8a600a2d741a8c51e36e3799219f4f648169001766f89b1bb58cddc2c3bcb0e3e58d915dc6f79e24466f7d17a6d8e6caa43f51dede135850dca600709bb896e045b5f3159d36f06f03ac80a32c0fdf08f50798e00a29c17faaf71227984934fa5cfb311ca954f7815fb8bf5682ad104ab347d018177b1b884b021e8b9ab46d12b84e13eb30797ce4f64cc20a9283a1d02f5e8d77d20a8a14f595e04b46a55ca1f60a915a368b8abd5995b881cf31700245967cf52c2ff363189949a5ceca19a57fe869d35dda1a148e1c285dfa33989c1566544ccbbca6a854f30fca4b69e298dc718c86258e5d7821e1e4a282b1326a511a656b6caf2428db24781823bdbb4fd3fe289d0f0e019c3b6056da40a89958a54cd292ae426fc5440b9f77aecaec7c4e42aad029cd20d2d416966c477f4d2632b07ef03479fb2bfd9a241dad4770eb61ad14c9a30a2fa723d001a9048b6094667b3a579789191758ef3a02a5a5367b862cbb83bcb170a13c93b83cedc4f770e99de58cfade53434883ed580f2729a196a035ff5bba8556354d7d0c2769f8b5128be176f1c2155e34b8f9bd788d6cc5869039b43454a8610f1f729cbbdf1785a2dc5da2faf6b725cbe148e0253d5a51ed2bc823eae646639ed6abce865f1b07e4c3aef5cf9d86938f4aa774b82b51c91d53a4823922d40410be778967df5a0d6f31d91a8ffe7f175df475f05d1b635eb1839853f8eac52036353c158910c8a5d3ad50d0d80170a7bd1a142ac4e293f9dbe2c3f6b3a4b200bd290ee7eb4a8e313065890bbcea826b2aa9ea9b70dc5987e051406a27d0cde72d94dea76dedef8232b9d84d87a94fa0e41d8aaf4d5e8ea054465e47ab759df382818c05bfb9c2e542147341ad011e866b9f6bb5f5d865ec866036ce1dd75f0be50688a769b23d485e5a65e38706976805a8c99567c952195237f2c366f89312f888aeba259a596084112b9e66535685a5d4e78d3ed88eb614e6be87e4dbbd833108a87ff3c029f98754dd09e6ec479825ee5c0d41b90362807e8be9549db382817e3d100d8e4b5c98949c8eb3ef1f0724da89520476bc23f0c61c57af2eccce28c81dc6676c960af0e1ab574f81a1ef331cbd158db82dae3cdc8ae52bb7ba955e618d3db88a9ba49bc5a973e2d602baba4019b256dc98540bcd0a675d3ec86b775ee0f78af428381e0d8bbcf00ffc17999ddb09492d39d79208bc7cc6b3bdc2901372db26d83c8bbaf8470279f38d814a827672cae44a2cf000c242a63e9431462abf44c208dc21c2c71a29adca843351396e68840e81988b3a7c2dd237c85d34d3d9dc9b044c5652a4a075cb2822fa7dbc0564a3528a11a19681d9a85cf0480bea29c9d9853ad2335d440744cc37f72961c89e77e387d8c1cb7a21688985ee7ebb9052088571501bc4431466ef4e695aa250d1050d8a5b8ec36cb1717a1eb5f81f2b482e3ff4a8d1edd15cb38a538e320427f03ca4f98402a481230a3e48ccb93ec6a38c2a7fa3acad0f80b3f232e7651a93a11fce7e042e200dd79b33fbaef290822420b2c3c64b00ee310cce5e00dfcec42a05fd105ed1dc31767443542973aa0f81b7315eb2c43b39027b10b4b7170e42ccfe4509b54f4a96b0d4d4cffb8b7f9fb5b7cbd0332607642d9caf42aa643f65374b56646bf9ee704f0c953b5ef7d694310572eb0fcf8af01b008899aa173b6cbd8f77114d901a0c1c3e3ce99626f4b3784840e989bee88f073033f7176f736fa0f111e0d74c500b9604abeb26cac57cd2ff9d74e8dd0320f33d40091c237961ad06428c18c8ae2f9ea9fbeda845b02e406ad7a3d24d36f14ec72118b1a20909e0a1d6f8d0650317e4373bc0532c48478c0f2c561c73255d14ee1c6d4ad9232dca8bcb5cae3614aa737e1d898b106faf655ed0373c22f76dbdf82b0dedd056bad7832d02b8c9d4046fd9763a28d5db9dcc7e16f09933ea2f8fdaedae1a091e900a93117b80ea473a86a56ac6160d54c9132b1515a849bcc90d359933ba2d7b7bc5ebb7cdcaebec49925af140df3c293c6ee3ea695041ddfaa4c84f938ae86b74bccfd33953ba06fbf927ba9deff386ae4b06bcde296732d7f8d0a4f3a21c99cf8c45daa35029ca825a1d966f83aa8395d688768e8bc2ea336cca185f1e581bbf7c8ec4e25b388554b3f906031eec0bae0e2f67818bb234d5ac83b810541d9752ad392d5a03d30c0894c5e16e44ec7fc9483de9eea3aa7b937928ae9cd106a1c823b7bb534e91a3020beb96273ef54ec010a419e68726c9b118f8e1e7663e60880b6408ff06d4ce5f7ce879bb0691967efa1094d6e12997b035435f80efcb8a0697cacad96e739750a11358f142f58bcab7e5efcfbb25338fffab5da5cffc137b18c26b7ffe5bf696b30daa4444637a0723936698709a3c011f2e39585058630997cc190cae93051f8b5dd9dec0a8a625bd27ae56e145bb80f35007fe6f5aaa809e3026cff3c7e6aa72722888659f7efa7e11f41e29f97b5fe5d9af30330dc25b97ada730a72688c9af9c9c2364d359d8b12763eeb47d925c672de9f0269b41d12467fcc5bb64e7bd493764b9f9ce7c759daa753fa3d3c4d3428e9548f351db3d0d91e8d433d390aef41254416ba717e53f4f8ad8c9115d1692a80ec655d4c9012021a7771307da8bd5f353db4f202d4a463f2c485278fb2c6262e82debbf1df00087ad4494e71e1204708184a74f76cf662873e93bea388f643b92a7a18765790f7857649b7b74220494c54499b461e2a4abc0f2ab7e27429996be20eed77ab189ba61b14e62931415a28cb73fb29e7f015ff89752eda5e37880f5f5c8be04b040fb09e5277fa43ffc2d126e16b8230bf030071d106129a94ef9de5421e43ec39b471efc29d16cc75e94367e26f9664cd07fa1b120cb6a32d3920dd691df1bbbbc8dff4d444892fa6f4259351ddc04a1431dfa4b48dc222c1716cfb64ca2dc25eadcee060cbe5e462e233979e6488f4bcf98911720d45a312fe87aee62198cbbb90cb1cf303df904cb19dafa3af76f5e29b62669ef465fbc53a11bfe66da5fbb398253360cbd63b2b07e3c5d10cbb293a01d30e3b3b79ec31a5a534df9d90e70b4d5e91f16eabbffb17d7c8cdd654bf97ba7975213530be16a722233083eebb52273bd7332260e61ca48565cd9a1123b67576958bf0dd9e83ff7a7ee35cfd933625b44b7d1bddc77864b42c1ec344e04287e34d0a851842fb3c27d91382c067dce135fc60fedb3fe2bb4a2035be77c715c46e27f5c2db3f2e361b04dcd86bb04bb96e151999891ad3a2bf6e8194ed2bf3f90a1b690fb74d6521c72db7566aa3af3aa1f593861c9e3b273470f7434185f9f4f734d3109a731e7fad0e130613a07689de672a72ee1c325b90943c4331985ab33c20dabcba1c90c7f464c40c72a25597a9d7cef81040d082534ad33ef1de15df79709f94e749c6c94e34d8a16b6e0ed308a5c22eb3bf94fa2327fd1b5e1d6600343c3e77f64ad11c73d1e04bf1e007b27d6acda0fd7358a128524929a830cc867d684821d0294c43e2ec2d8b65387d54e49160fa7d93ca5ec2829e87b65cc4161a23656a18c9aa61f713dcdea0f18cec91a83606f5b7401eb4412fdb71963e1efb9cfd5f3ea863ee8580f428ae886387823f3c3d0864aa956b2b22288aa0cdbed8bb04776827f3868ccea3aa2f0f8b6b67cb38de9e6086e296a15f8e16a0dca81b2cf24ce310f0217c3681539ccf843cb57107800120e5fff84329cf802fad9b5dd05f4bcff95629b8fda9b301b68c2d9e0a5e0bda21eaa8fbb467dbe3029938db091bfe5b38421e9b387eb914268b7436ff4e453b8c37120dd4f5a97a339b5ebef1ad147d9335497050db21d62b462ee2fd38feb2efb2c4491991b19bb4e049a7ab3609ebf2852d8290692893f2a16001d310d0dacf8bfad621e95023ae66f171f428a7822a485dcdd2daab9279dd314ab4b9599978b3806ca35f7a390f99aeddff31b7d8bfcc1955dcfab8df96db1586df0929436b90d1c819d857e269650f0919e50272f1f1b59456c31984214c9748abf92c6ca4e0f5e9a92771aacb0d9b0f6f3c0f93cdef08dc6077b51f237771078e9d79ddc8f79b1c765b2727fdf158e25b043f35b8d3e5df4467ffe6f4cf1a68eaa54752055dfdef9ac5a304bcffb8247eda2412307b0b3653f165fbab9040d204fe86a18c326f10f31866abdc3d3107252b09ed6972415c0401f7a14ef3864c8a890cc15be2da3350be7c50a4ec238f020ea31641fadf49977ee970d73c825963b9616637bf078988df30f1ece32043f3d17d28078a428110f4953b635ce856c095cebd1ce1082e55ec9f87432b1e254d1aad076c9a61ccbc1aa0aac244180fc38b4361d8c28b4bf887e71859db5717fe2284d2df6c1126978a72cbc75273491b2deb846f534279f9685ad59539c7294e8cb0adfe5dd657d1bd5b8acca1d2e7c0556c43bf86f6cb2f78c561d1c1c7d8a02fdff79e250154b8b000e07e095671e00d2926bf4ce2254bea7044df223c0764b6e71b6ba20372f7a2f924918c2c46ac3965d59b5d18db96a0268749ee22ec4975c3f71099d5870d623eced393e936584c31c9708629d353383b10eefbcf045095630c01f0f9dadb2793b64466b0171061bba866bd77829ef968f2ace35aedcfc58a40e59eb67fdf6874129c199d3f6c677afc2074dff088d4c12b35e28b87be0c8fc991e269d9e304ef4af3e35dfd7bc0d7fb57c0562ccbbdf3a9c559cdb87175d802854c28d56d6fb7334caf67aebe71edf55d841bfad1c801e74a4332b82d80ddf7737f07591694871518236cca3184c7af281bd363d72b9667bc493fa11bfba62515b93bfacbdb4bc97a47830cf0fc0f3c48ae18c36fd4cf79a1bb1ba840fff2ee323fa37f1b0e8da476f744654045af00963aa35ecdbc07bb075289867a476309c127cf6a86f8564933b2f26aa52ea004f6783339c33a4e4fdb24d0dc97b93c585765eba076d592d08ac0980c90800d338a68688a47c359836c397596cb209628e7c4f654d3033028cd8c9d74b7171482c28607f8ac0bbca7aadced767822f9ce4434dc73a0b07e3e40f3689d0526861554920e1e308e71be9788e19a3b39e47ac7a28fdea2c49989472e93d65eb40f9ec5dd23340948218c0edad6b2b63fdf6adfd155004560181b9c3d5d9ec9b6af711cdd8c3babe930323dbd81ac5d84c681373ac823f17196502771b9a2f89de6ad88991900c4c771f0f97ca21d2bb422cab82bc412e5d98b72d7cae7295ef8e53b5fcc317fc9ff7c6192fabf533fb9bbfb09962a0f2b95ea7b2d2360afc884b9201ca1ea1e71846f8683edcd47e1de30b2b7befa718bfd4890d947341e7a29d957d0fe4fe2e9222c66ef5117d2bf6cded525940ca4c3d200294982f21ac8f826caf9648855c69a07171faae21d8af6176697a9853b21bb97118876d9b17de4706381f02e9fb750c5fd458928edcebabbadfe53c4d4bac8321e6fe88b689d07b0abd4c7627ae2410fe53f1ea4b15d442cc98cf80d5b87bd5798e713945e96af1d7eeaa8af7e03354e8dd4ced7cc37e17d67114e2d755f6d886104ed4beae751f924f8fcb603f05b3bf688d9cdc40a5b86c0bb829426a5df29338e6ca3157b0c01826596d4173b1e7cf3070186c15a8ee8a0ee476fe5517075e802ecebcd63ece3dca65cac1bb698f66fe69cd9ecd5fe10cf69f089d67736875e11b3a09c76900546cac858d21bdccd7c3463688ec7f8bc9eac269043bf1e9457587efbf61f06e577969bbff68dd61832d6066058652420b484119043fc47692496528770e34d959cc4d896361f2278ccf910599b5544988fb40971ae063e79925efe924e2d3af4fe696e3993a00306821b3a413983479f9131a9f310449815c134bed98ee5850187fc17083bbacbcc9f61813ec91d158384b09fd9b7c28acfcfe3eced3f151ba08f35923b170458466a5caa14294d7119a42589bdfc3cb9a400a83b2fc45d03eaccc2bf14d3a0c7101a0dd3ec0bd3d2d5ffbd2e8b146985dde2f8f0a03d7b1ea03fadc2ca6caa88b15102ad2d1e750c57bfd8a7e85c4b7d9b36ec085305f58d4597ad443a925f782495219fdfc6debc05650d10fe007f3a3541a000e99715ca9a02d72b5a97d97ec32575dfcd15ea9dd8cc5c9663e507e5ac299e0d3564c2c25fb252d8e61e05e60e6adfa252e948d8df1982c6d909781f8451fb7c632269efb889678c0e8da1d607ec461b4d35d70da8cef22243db8b05d4587c504812daa4166302400a86bc83375265715922f480bef7f7570418db18951a52e2d0856d0e737e81b5965dc6118fb3b9616d2e294e17d75d74641878e159a06aa4c36788358260691f2a3bd441fea31758cfb4358eaab177f23519c11c3c2eb506655e95caa8cba4625c19788b8e6ad293ca77c11bb55118bfcca68ad8dcd845d63563abc3fe198f86e7ed72e61309ba4a6d01cf496df275e6b67103d4019bd2dbf81f6932471d652f8f08b4f5b1d9f188f9994fd95de8af6cf7c81212a430937a4192f3a3abbdb2cdd4799ba20748fa622967625e624dfc27ed4cf73f41147cc8abed20f257a2323e97c7d50eb19a96c94961cf8117522b16021d580cd37f40bfdd93c113d3d37741740cc38df4d9b72236c0f5801d773ce26a2c02d0eaf32eed34a16c48c475900fedbd539cc325a22f0a9500b4a4e00a1a9ed13efb7da107e503a98848ea04969b170056271f61ad7b0463fa057f966e188769d672607f2f14b74c1cdadbeea91a60429175a10a1e29e09572b2671578d614d31a977e2bec400cd0e8b64fd5324d027135ec3090b3d47a6424ee62087007a31fcd263d6bdbfebfce1e23400f5b165e0c5268bb7dd0ec7bf0821103f40284310f926f8511c0ecc522ce5436ca27c4d8ff3a4bc75e6cd040ed71cf7226221b5d3a011ec898ecc8b4adfa7823d9926ff702d9b8262fa2b154b5746a68e2bcb9a2ed25fe4d5bb001d9978f6731dca99191820289a1d0c01794654ea067b04c8bd04b3fdf28a8d174c782d143e0dac18f0dca1dc16d5cd85a4f50182da18281c21cb5efa7ca11743dafc766bf5ad95d0aa56781325dc50adc0cfd5f510a7251f712567a7b02aa9c3f47965a6e7a1b86a5da2031099c10215cffff55a9f4ad6c375484cefd69d4a9c1b76729dbf84cc045c201ad323b7b71ac7b8b511cc91b06044bfc80b3de632f0bb6ab9e15e448ca1275124b7fd4bffb911a6eaaf2613a73bec168296438c957d1fc5996306772d843e011f9ea091f9968d73ec7217c090a8250a8e029dece5b3c1acd03a5684b0c16056590b102ffa9f42fee337c028a275a1a8092fa93f8f4a1aa3ee6e00bc83abcb8f93443fff9cb8d1f9f6a3802c76f58ceef3dee3a7974920de2ffaa5596b6e0a86b367f3832f6659f1924d4bb5fdc1b97e211b8fd7b46f72d735c1c6163ee8313ed5d278e28e94cf4f6685400e3362bac1b0198aa1a6a36addec2ef62ef83a8fa5a0ddd6f77e5725143d93952b7de039bf675784e1ccc08487aeba16fdb32682325045e79a3d0dcbd3e3f4fcaa6a99e275870fb775fe0a143be50bcc0d56892b336784667e5cc9ba4df1eb7f7c5456d1d923896743d9fd6f8ff74de2836a6257c61a9a84235db75b5a8b982f017aaf3adb061fdefeaeab19d32d2a3bac890be830b21b21c19548185d21dc9c70fd6504da1df3962ea7d920cd6b3d2633e0cec3596861961cfa41b71394070192eb4133504008f71a35152c7bf36f634edd9be74b01c7b19ca9a686d385d46b7641607456d67f79cacf36cd07c692a01197bb0ac03d8c413def85754487e9c975d4aae093417f8e8ef9eece6b8e364ecf86833230f76555d39d2eb5d22583b5e145a73b31a286ad50bb813c2a73c1f6b1166a98261c2ca1bec67fb78a7fc3939581a6c5e9e28efc7178b2bbacf5d900518987cd5fe5a0e4270e83596abe2280819eb8f12bb70589e255099d13f5eba3d8b6d042139b7d425f1ec2c4005a92c2f124abb30b84b6d35d8aa0c115c15dfe787d1d70ae93f9b295c0770d338351abe2d1f3d687b1fdcd57acf7212b8b4361b969d800b0feae0a924d1abc67e0e3a989206a044a9fb0d3f7240429dd9dac220c18b254eb4f241b9a9a6c1ada695a68725e9861a22dd5ab71df8fa719d6e1295092a42fb406d7dbda104f1deeebd528ace8df2e1ac5a2dbd11004c38424bfc46874be640ce303844df05c347ed320c046141faecda6e03ce0135bbc3ea0530e71b52148662f55d15b29b2b62736a858da13f62353bcf3fcaffdbc9d1df781b61ca76ace8f4451fb6177e6ffd9d0a521933aa2329e8cdc08a6594d38a76127218b0c40d8fd0fdb58cadabdce139e5a06015fbd4939989883b7ee7b3d713e169ea14abc09f9500bce35e2440f908182f4d7d45bcc4052b910783f5d070bda8e989e9cab7c8d664158d2b8b5987d4f5da5858bab0ab5871419f914fe3d98364ecd89b4d461b43130c74a5ce66d55b6183371f6a28e6777539af2f49ec74f046517ec19164fd98a21b4cabb8b2730b4fbce63c95b9305f8fc8e6ddb28b3e80b0f2b93fb2d99c70dfe8c0fc34014d749cf1217ebacb6a7c8008dc814892d6a760cfb36f95ee0431d65648f1942fd6d944c136a44b099c528450af7e2ccbc9a5f392a05988634093b1ccdb9056293d19389e5a888b32ca39170f994fb082142d4fe163b63701d2381e14eae3baea29ff99b68a212ee7309a968b49872d229fe2bd8963cc16814146e405f78129f0e54a7cc25d98e82b177ffdd12c6f5b37c60b8f3232810dac9ac6ac5a0b26fcd4350216c337e93febf7642466683d785975cf92e95f3b959297ecfde703a02f92b702a7958dd803943431de16f9990a2ffd1da754e515baf65c968811bef9f63dfae69bab8a3dc3a1ac532da0a8e22d8f404021177513441b634f55224fee64701e7e3067e20b4cd6845cbc41961294bf031fad9d4968407688451c3fd69626d249a2bf5d57d8015a24578823bfd69bcfcbfeea5e7c5e7479c5237b8629d300851e1656a657daea2874f0be732fec0dc26b965b2cc7dd42a111748c92d5cc7b35fe4ac9fe8b098787c848a6a98f55b538f6176d11e45359d19e1141e882f0de4394134fcbf47e345b9ed3ab488880607edcce244d01f1dddafbad3677505cc87642fc49c4e6353cc9c9cabc9a9e01b3d3774276d7613b397fde69e4e5810098dee72832d4656bb619e53a7cbc166d1ae1323f56f33fe8d925e65adcda61fe4f9d785591ffaa93579672cece7b544996118efefe9bd17d4a58cb3a0a3c1432d65eca74813a5944e3489076ffc8e40b8a9bf3a5bb28cb0b571f98803f69ee16277059a886a8b8b797bea5f03819825eb55fc5b608ebdcef7cb1d2644327b33400bd87ae4b5587d9cc97553175a93e023e2428349aa7cd4180aee79f3089bb3f0c98f7980eac1dfb423642c74e36b3b7ec3ae98433d0d6b5418fb8e0c601ec46b2bf75a77a8a6f346a321a74068d7bfc396ffcce5ae07dd4799a822b260e638fe83440327f6ebe12148afcd5584dde6e1d1964459f0ccad0b171c62c5fb6cc3b38210e5599187933946de04dc8ae654a4f2a571a33b6512ceb0cacfbb5b96c3e86dc8474e47975ebf490060a4cdb02906583f0a39ab157a5f3a8abcfa7befc08c87c8ec757cdef41b0763e2caf4e7ae1baafab2e79d4ac6020b11a2a9b3c2b95f7924e15f9c99e01619188d0ef8f736f45103d6dac6395dc05c8729038b2a8835b451a686530a1f711cf86de8247b3275de380e23503c87055a747fda040650b890aad217a20a2d9e46e4188e7159b82089b57b70f983b5180873ca566a65656a476bd8b20392f49b89a80a0d2ec93872f41474f2510de7c6a69e0b8ea4a50851bd3548549a1451b0791298e77efe356f508cf33521431219935c41c62e790588a8b959a48d7210ec210a7935165f76f2860f9e863c1033a327b9e5c26932465d84c190a81e41fdcdda36a32069a50e12514e990b81752869b9c6da579fe653f0771caf8d94a6483747de3db259ce26c1b2e405c8e60de3c8bc178a27ed325e78f51fd7f117dae7f70c04bfb03c69809678e1cbdf52c931f96858ddd64a4a08245f2b4897fbd0631eb4bc85a9c0bc5419ff848d897e4fe9eda3521affd8aaf6247bc2d5392bf32fed51bf7e1f9fed2c63d185b5b229f6d1e7eeed5e62f77946ae0572f760643aaf99cc6d2650bb40a6438ac0c08b79da36906702c26564f10d38c7476f7b9728e06b4d58d6bda642389e21982b6ea6800cde19b18b9dd15f0eba1a758c1dff69c25e4e56a7dc617d042e2ff2e25fe71be1444492f9832598237b041de63bd70248c027d88c9322e96f88eb037591c7e168696bfb5cb2e6d1b8dfe291d914f0dc81a12637b8c2da10ad12abf27f6d4ef7a6492773e65d86d2bdeaa2c33354eccf29a0518841b3fd7ceda5a2601fcef2117459b06835a989c809bf04680602d500eca107bf7a2aae7dd953db10fbbf43b7f2ad4d8cd08875dc88652f8450acc84407738c5e507bc95e8b8b6e5b69d28821c1ef1a989a96743a90880cd35849a82d811109e6cbb4ad6d605d0462e5dfdf3c903dab6f11a187b8033ceeabf7c320c164b8cdfbdc5dd4fbcef30a351dfe5abb65d6314805458b3ec2ecb737f8d1e874fe630eb83acbcd242e7317501231d6855779d0ce7704e4f057ee8632555c61b1dc15029497aaf20094dcb53a3735d2e619bba0f87cfaee66de4cfca34a1c0469c36f3bc3c715a6c4319280c7d8652129d80b0bb11e2c331a6123e5a6e33e179eac671f604bde8c70c025d6b18a11c9fbf62dea22f04f4b97454a16be1ccf3e69e29c9e012654b10c02d5f76ce55658769874bad2633dc35ccad9da14bc4805b7c2cbfddc161550913fbf974ddfeceb448ef77d47a156e26efc4ba5b40255f87a57808389333ca2ac0c5eb897830cb1c8476275396f705ce2a4bcfbc5a563ba356d4108da634a924ac19cf07dbcd1cfc2c06dc13d4bfa2119692584f931ec57cd3fdfec4ea2783c08b99fce3cbff33c5ed49eac4203e1de6debe205275fd59ad87ccfb6c1dcabb449dc652ff3f0a716a05ddc562937e3e9e25d4a3c80bc091291f2980ac344d928d169f08caba7fcbe8d4c4aa49b541a13b36661b13e2623f66352f84eca92034586a9ae287eca97037cc62496c8eea3984bc78c9c0b8b40d1aca4e659cc4fb4c7a0e5f26a346f90ff3bd288180b35b8ca97b4a33b8bed86be33136a788c9e251d30267ad9046f08191cbedbd4cca88adb8bea70508844f274b96e3610acf0557db2b14bd4ee95608221ee0906b19eee7df1ed5e2a1b8b65db1727f9ef6b43254c1f52096b8a3bc21fccf001afa13ae7c098b42846628b485a61c39db8d7009fde60925639a35375e43e4ace7a4786c819d676ccd652f6ee69030ea9c0c1ab634fed8285c4cf65444f8c519f1cfcf22da23e181958fa2e2b85fdcfba840f8af217612ca92515f5df11a2a2cba6f6a888ebafb3543c6aa0eb56244b2c4009d470ea47ff3afabdbf2db2393df25ac6523320eb0561225653481da0dfdfeac86822acbf951652b70b3f06692f6bbb7ff14bd29232dfd804f07ba3d6fa0db6389300ba12d1fa2dbf6217414e721e0de3abf9cbd20472ab2c1ce1de6fce72e98dbc685336f64631125fe8033a1364481e23137a7db6daf98ad211b218cbbed8e5baef57a49c24ee10238adbacdc54031a7fc44635b1be6ab55bc926626e7ca2cabedd6930be923a7cce1c9fa283534cad3375f157735def8bb97875db079e7df26f388a3d2e99a081db378fa3caec150e48a12654a2a39c8cfcf635e5af4dca1ede51f067314f9cddc711b62ead607f8d839747e5ddf2f0181aba45d6d4626f13e700d2b1e5fbf36d665bef4c3a78a6e13939e365074224c01820c1a95ba7b61c16589e682716187d44b8e24cc86641859d9192b66dc6bf18ad3e36684fa709c9a5480c0b9750ecf9b4124cb9a486f02711b5a23b2d899c77982ea662cb4a44f1eec0478d20059d8e050e74f911e16dbdba5391a08fdcf7739f7c8df2f5ef6e1b7a2795bb7004214d69a7a9ce4aed7038ca02a599b5aad44054ee9565c38f58a6d4c971081120ac0cf08d796981cda7274f3aeb5d6e8d41521b94406c6b2fccf60385b172cb6ddc8cf76e488691e25e236311fc532cbc279fd74689bb645242ae27abf2d2ba30bc2e97dd6cddaa5c405890e8484c256dc41e38953a28a7e68e9cd3a3d93c71859b4cfe7c2ca8dd0b7d69940d756b3cdca01f31a34608ee9dde95ea0cf6a0c47a8a9d697fbd685dc9a4ded4ed5122e78880e1c1575c7cb73f4650f154128b745c59b73bad5dab937a844fe7e6488010b08655aa110d5d6dcc9a8ce9f71e5c526399573a959f412a9f5e065b47f4139cd0914338ab25d08be4ab9d6ac4338bb23bc6268c1cd4de59839a7d60862c66aabfc7eb43e8284ee81d2cfe0f4bad36dc0ec7314a8dc6328ea4c667bdcce6159556f884f3ee2ac32e795a130a4b28d21b8868431703aeace4f6ebb0b9c5e17cea34cae1d4ee3818edaec24c25eef74b2fefc561b8dc52f11fca1b5a68fa4a5de41d8d7e80813e19761f04a8c31920f450af74269406fb42a633e46c6e311a6e88abbea6bbbe6044417d3d1c1a10e2a3134b98437bc95a60605cc7646ff2dc3a80c12aa9886da9bb1d1819598e24b9027a81a188a8dc4c3a3ffd2233e83294447a4bb713e3d54ce6b496d995b4e9f958ab87e6d47ec00c729eec63578bdd08ff94e9f29ff64334dff995657492b137fcc6b08eaa5c1baa87cf0597ef0c50fbfc379a1310233a938256a059b20b1e3e43616a38eb04f7b326168b8687a11184d096a31acf1c543715e55ad7ea1a35c95867eafc1f398307c51f27ab8059c4071e03785f3cf2dc3e2d448fc801720ed32f4e5546fbab72bdc08532597a1d631eddc3f0610a1ff6b6cbd339d74a259aca2c653dc3605c67facf1d8ee794898730a61a7bd4c385bc010501454a3c45af41e853c37fab71166d0958030f80c825e47947ff4bccc6b2dc8bb1ad44af3f2bd578f8e431ccc659119503901e4f8cb85de7914c014e6461cc6c13c08565ca87419b43c43ffaa7d9d1ef365ac2cb6d86160f0fbc7339287583cde9649f3d519f84f552ffe28c7791f1a480b6763280bdbdbc79ed252938aacd181dbab69a43aa53c70f019f5593eaba743782d1d1de99245349689180f6c608e700232a14b838a0f3f7f5721c5ab2ed579be56fe390cdaf649641f8153ae11d9c057188a12267002c1a65d87a67dd4618a9d771dcc02584cacf066f5646da1a1d24d2d93cf105d75c8489b20b12e718a4f056e247b088d5ae4adc05af3e32449388cc853728b954a284b21a1fdec078b2a7fbc621dbd15b405065f1082035092c61f0d563772321da6b61c4fa31364b0ccc76df3f277a999c31422f1f6db018aafdc2e865e55ba5d74c9d16c8527de0223ec668acf6fd5d8a16c76b93794b467fca50ac6cabbbd5c977beb36ba4bcab4db394562dd0f09caec4c9efd8b68dfa075aed710e803cd80ebed4fa725d1cf272d5347686364886c5cd260393f75829c04e9128be1db656fd4179a2e04625fea58b3233a3a5127e41c3cb2247f4371489c002b4f748db67103520d451137e63bd6d4d58aa9bbabcaf177d654e431de05f481261b4e0405ee10663d0d3cd5a67f6625f070dd3fb8a62ebcfadc5f06f471835de0683267f053cc563aecd2794f90456e7b2a29a77fe8a4edc563beaa2177bb6ed8145bc0b8662679b76de1ae0d0f8617015004910341ac6fe597bfae581429d101ee9766d35eda381fbe1ef5b4be05bb1377886c7dd3fda60577520c6f817643e87277580330d2c9e2524e47e041df74237ef22f095e71a761ba493094f28efd6adf8af495fddc6839ae114650c8e978feac08a86f75566740a2ffef329fc06ab583b92133fd9363bbc2ceef15ca6fe7641408a4006097b4c81f6769e61de91883ccfc447e8514ebfc3cbc79928e1df98873c1aaa87b31bfe426c05f363280c0a2b0720da913df82c1701ee3fa6819494536efbdb4e62c0520eca7205b058b0e573fdf08768f7224e7a37c871c6c741bb89cd90b005bd710cc0c017b70560732dfe2eeb9a3188cd26c9d89aa4b4d61ee5248e815bd4d46b67735e30dd779a7684deea159e26349cafcfe7dbcfba76057fc48e722ce86f74db171431556147d6e0545205743afee66ebf2481a419715b2a84ad98d67e2959d8337c245b41bafd1c93342142772b01627333801b86b2a24d9c46f48f6b60c50f47801e4f6dd22216f0a4c0a3aa1586b25d87156260f8ba678bf20120e91179f1e3daae2bc0c4270cd1dcdb40e9b5ddea697c63d64b0f124691a0760be717a8257017f882b2b295c9fb06aa8261e5e082684052f89fe4e384cdd745e5abf83c2146207db393819d5c89c999412cc720321d84da01a8167ad2838de0de3c0d356d1895b20b3771783ac60b573b6775859c200ada94c602ea7bb77573ffdf77dd7fb5f718879d36a8dda732f5114440c47685d604d8521484a06c1480f8f3924084ead154107a729bbbd27951608f0e9445e39365b40323649b4c082e1cb98c1c25244c0232bb328bf13ee2f741a5eee7c65dd9901f9dc6795099112b966295dfb1a5cefb0c8407c1d7b6e6c122974023a58a7eb8dd8e8d42f13d03decae094182c19e4319888d31aa66193b80975b7af4689358821d648325c6a282e305ce6b4bdcd144318a480e80221abe8836e900ab833232418d88609d0022e59bedfb57894bea015f5fa266f61f9e60b8549d32a6c8ee1074a8df0d8207cfc87d90b147bda2876d3d085d4638ee50900fcfa156ca3b087c7728cd4f1baa3ddda05c16c2e600eb40f98970d82aff86e198b517f6c34d9bf5849c7491eb805b91a661d43001e528fca02a69f63a35e650f896db24dcf16788c6aee271ed40ac335b2d525d7110c2fe5f2c60d1ff61915fe8f88c6a419d056ae2f514d2cf3396ddd58babce82c8aaf0aefa9a0626f75d25cb5bf2d1334550e32cd5e8d1a4fd894a1e59c443ea9e79321f163849eca1a1d0584d0c36d32ccd8e0d05cb4705a36de45d47f9d2a1a13bd4b8ba4119e59d34b3a6f6f4fc8652a0d6821c4a027d4b1e5cec7928994ab55a23ead09848fea9a071cadffb6036165cff","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
