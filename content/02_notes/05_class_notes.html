<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"853bcee6869d0df109e8fad94eec07a7685fed11ae206bbc255f2e5025f2548d71b34d915de8e027164d36ed1f300a9f8a7601118a956847985910462e0da6e5b69c31d4d4394448e82690d54ca2ff345395c64222073afc64332281a12bd228ab7495147da464f9404eab38a0472e2e31baebace87423072866ad8fd4b0d26ed62ae1acaae3d5744bde68e4b5373ec5972891cf326942e53b73fda5ed8ac039f48b03a557f491a9ba2da273c6b9b88b34cee0bec302201dd1edf5f1ccf241e867d8e1fc0efa1b2853b5a35dbcd3918861fa4843ee0793e8fb47b340365cfe250ddcc16cc8479398b106fa3871f47845f1d97db4cfc50c440c2857ae8257fe7f8e2aefc27d701b4472431e5fd5457271f5c736f0c13f0a1e84017e47db65b17fbf9f7f74ac479785a694c4abdffcfb6cb1bbf86712ead78698a5db3210d1e2fa102a3873b5971fc1e3a1641439b91d603fb59dc8a747494e02426ea3084052387a1fd84f47ecf434cd244c73dde1bdfa95ca1f087a303138bfa71108b6f516b063cbfd4cbe0695d0e3120064cb1f318c2eac53f390fb083501fdb270bfa2871e065aa12d8faf6ed382d3d3d93cf44160a7c159b3ce6b7c26172e5e2b3fe9120c4fc1ef406bb009e9e4fad63ea02d5f455e822c82525fd6932946c0fa67527627881e0a94398826bc29f221e6a3c296de8c64b3c71cbaf961d6434a6a0cefc74e34f7f06a8dc5ba511791e1b3379ae62327930813c555b183b4d31d802f1cb54f341faff99b52a9d925a3580128f0939230e4d07adf9954a922316a346647ad031a272a8ceb1cda2ffc9b8fc20691d9be02239cd4f68aa67f98e3c99938e4c16fb747432e53c552b7fd94198441828a22e9292b9560f49367715a3a6cdc1ebe9be93e545349105cd18d9a9526f593bc6c59ce3e0419dd17daf8b45451bb81a95378bc60d95b66894f3ad85fca4e46108d5d963fb34249c9806e958da0adbf2553437859b05443907dbd29d34d16107376fc2d13137e6b878892351857d8e9dc49c4bfd8b3a67488159f24551b9858fa2e7d18497b82ac2bde558ecc79e8e02d678260ef11ceff9166c7e8fcd542359f65cad987a8cc8dd7a2a15915971a063e56cb913c0444c5f6af6e2e9a0068fb666e800a754335e1d737a62b164cbd3377fc6dd18a97b0300793277fb7e2009c607e53e8dad846e4769406547cb8b8206eea9662790fdd02367894b42becfe9e61037ac785e951e61378b1dcdbd701f661b4aaaff3a12f534e87c510e27b439fba4b4c2c0f883eb39ed5eb0d227f5e6dd8f6db9c295889930fb06a37af9e2da0028b5e0bc4c049b97a42e2f5ec1dfbb4c5288fd8e2019d331327c94c2ac47e76af8da754dc9f56bbda9f41d4e276461d52ee0b53bc5c8f376d0fe64f36cf2764ba0f99ac2a1d99e9f9746c48590f5f30e11e8667ae7a8eb577cea19dc320b91ecd0bb458ac1efa4693ae2c8c14a300e671d4636429459eaca5f29927705583e88bf9ade89d2c973bdb9992079ead6d1913475ccf1c2a189c571bd6ea21b2142219bb24f5f09aeeab20ea70c60e2ed621e3199b21446e9685630a223ba9cf3134645a164868bcee6970b74f52757cc68e57f1e1dbf715dc7cbf71429b6c3b2599251c4ccbbebf691b542f50dc91bb9597c93db88ae52db777a2f8b63dfdff1d3d2952ce34079676a180c933cecc1bb5ced93170fc1ddb66eb215af32192544c8b858f1b20a0a3ff50e2d85b06b17905a8b277e48814e6f3709bb64065b42b6594681b4c628b4919fa8cb7963d90c78929c8ea462b12ab6fb440822c0582ca165cc0a7a3b789c36a1a1fcb8e81e240ceaf9bd0c31a5d1a458bc62f26487d7600e26bd893c4175c3b84bc5adb55b50d30000c3fd779194a445c6320a51ee1414aa279e5cb75cce18a354c1e7de690e91dbbe3c845e5f94b9db57094595518238c218e78abf61ac28cbe20c956fc366810ee228dc5d2f22be59a9f14571226310fcc30d4906b16cbf0d52f367584b9af9538ec675f6ff361ef063a47a4debda86689ec934b798b6b9515f5950c3f2e94f046579916f29ca8f6988c5faca6183e5579e646a1550b830fa3adf1482d656a3cff04cadc28813a4d7d39220ccfdd999196eec25ecd76a2ae4a1ead6e72c43c1cb27880a457879c147dd9a988115df73d3aa6c332bbf26fcf841412924f16ea23e9045b720668a100e66856b13c6c8966b3368ead58be0b77596ad26a244065f5afe5aefbb8ad2ef73b8eb20bfd8419845df94ee68ce978a7c5bcc85763ac8bcd00e0feafb69c2e2a8e900a79dd5dd93c65560e6813450878f81c5abf714fdc508fc72ce94db8dce4c250611c118cf680fcdc728c06fc9e05046dc2111ed014688451bcf426e9fce1b118557275c75df08deb5f126d600b8ca81fd67ce96e7c701d5cc9987d4bb5762f106e1e323b7f5335dcecabac12a585633c06ff5d2467b7644018ea13b76316cb1678bc9b71a435bc51ef8a42a4c69a6af4246c61eb745080176834603e1fa73258d7f6ee21f8dfcb14506c97758816c7af5a17e3bb3ee64088dfd35ac1135aaa8358736e914896ee512a4b0b5137b4b7942d2e9c0b4b3ac9fd6b7c5306ad08c03935f031be9adb9d7b3de9b21ef9d544f9592f700cffec54ae5c84a5a63dff9230320dcb4ff29690dd521bbfe44d8268b1bcb3de7c328e95a5daf7ff305cacec2ff977226651a398ff42ff8784733a80205b47fdbd48c5a2c9d3a74a682b0543b713a3273c09df65db8bd82eb1f619be232bfd8cad440f82b473a33c306fa200ae3883e8e5fa1f7c46f99be66ba03e614642d2c0be6c0fdf0b1d9af563bce2195dfea1bbfbd9d6bc1beed6825e866439bba131e0838a2e30033453ff4a7816d0949251f55116cb447d6b9e66ce9a5b6f72dc3c475eacf549c47b65d8f2980aba0b791c52e5076ced9522d0313e0008697e294fe055493277b13e04b117c561d6858c6834c43319eeea51f280174847060ab2cc6efc940bb4af4786eb3238c11c2cda53a79ad6ebff8fe815e2ab432db9be660e2fdba7d2cc357169b1e0ad408119eb14ad8640699dedaf3a814e397e57f176e2cfa2dbf4081ca95fd1902d71acbbc0aa2de8a6e22e82ab3724b1835032287401861f97adcbcba0beeda53c104df7a05be1fb48831926a7dc9b6c1e91464562a7ed9f9666b0836022f5905c8d2865cefee5e3be5b14467cef6673e5c26862bb2b55eecc3fc61a0f99229a6fe2e93b5cdd7ef7260a059031695738a08869fe66979898a108f8b05f09625dee85334e5620ac46afae48d2cc4a56419749c8fbc4daa8dd540ffa61ce866f61ea45c731f1877dc06b589974b421cbbf8c087f3c67fb4cf7f81c555c42d4c72ce3a6707eef54269f07fc7943a4ce91bb5e68a19198f435e5bf5f26ca4d2a27ab0678277f94fe65bbaf2292e5de32403d125fa24c04f2376cdb0f0e0c5226ad4ad72387c35e8bb8f37d9dc5cad2caad4bc8d514968012953780383cd1f49aae5b09424ef7fad6156bbf54ce1d854f9dbcfc44c0b90f2435187b17df055f6c84759eadfb45be3064d1c4b6b2d7613a3d0e9b2d739a3e76e21baf02890fe0e5a3b95028650727f4f0ad9b63396af4532b2003244cb61f1298d5b70a767e5ba63df2b930a7e607046c1ded793a541b4aa3a8923a8a311fca100b5f6950cf2bc078f04a5671d942d54fd9e678c083161cf030fa76571858f8702e25e9e4f87cd00d3df49fa5b720f52f954e60a80bc68df64b9664551bc60a5b816979b130236d10747423ac999859234eeeb5f4dc7725a198bdbd51176afff2fa4edd1eacdd830978356230187e2711c59d620e25681dd42675c22569216f471513ccf7c2c896c9009ef6ae09da69f6f73227c953ec1417455b270f8c1c436881d0fd774eeab5afa75cd39b10dd4086a7d5bc5767f2d8a334dd3666450326e4f5cb20821d5922eb346a81a773890f03e32b273c6d7a9a9e002de15034ad9028265c0db993d363e8903cebc6e9fcf4c7fba9cfa4bb87ea61dc7ee63528a6cb4e4bbeafd48ad68e19f1f9a57a65708fbbd2b86303839ffa62c4aaf784e95ceec5dccb8993fb415c87d879a82f7a8a3fd5eae34e7b950a70b8688f59ca538f42eab6cdc542fb95ca20cea03a446aa1f83947d335960726e70e146db6e2b56752b83823ba6697076331c2597b7572b52c41c4f460e28317e90eeb1acd835fa96a400056aab1dce857e49772526bbf0de8f6c12d78c30e38f7d58150df96b14e2aea022441196b1d340aba8ed9f294615582a4259d5470f390b288752d4a2834ba9ade9a21369a6572b39b6bee69892f1e54e58e9aa7d549a3d741623a062ef5efbdd4c30f2cd34f013ad26777795c910fb6708c1c170db558d19ee3da1058e4a98f6d8c1e6fd8a1c609efcf117e35a9d01e7c6d33d8ef93250612985cfbc136a1e254c9ceb05f28143d25bc4748fc43f9be8a666d2b9db333b87bf731d16d461b9b1df8f7a84a5ca0540b2de4a8296aaa64f2ff386f6d829d6da92531cc6b399e39a490deb4f0780c202fd19f86ec20a00c18bb28dafbcd4de05257cc5915f2b009c1e3ac15bd196838f1b99e94883134b3fbd78af2eb32590c506a1c5b48acf656e72439bbf89ca9109a89f27a22a5ada0531d81ede893971536379597a64cf40e72c533a32e681c06d9ac49d4ae7a6bee644356046244a42e5f2d92cd7bd79570af1bf615ee731042cd84d3df779dc35b7d8055d93026d9f2d2207d2f111910e183cd90dccb9466ffffe1744c6b909272d1c2597ea93516f4590a06c17063bef843f35d6c3cf4b813bd06f8bea27564c262a28c63ec90142143ab5572bc897da2ea406f564dae36ffe751b52eca7e3ab8c4b16dd875fc7efb6bd2fd1dba2003c8cad6d49fdd02fabdffcedbea6185ab622390099d8cbf5d3aa2d127d7b80a55d8e87d9652e7b792fdf23ee2b313e795ef9c53ee3cd2b371d92c7f215f8e667cba93466597dd6abdee8813dd34afeee6b853612a3e8f4fc72d8c442625d92cbe1952606e589a742526da5afccad8bb46ff2676650166ecc4ba5030117dfd88c3b140c96bfe99ff96032804c71ee4077cd80535ad9ec44ec7dfb57fd42d7688f1565bf4f4d829289e4193e57afc6bd989879002c767e9e80c6b6f82d39d78ce4039f9e1102bb38f3d5af7a324b6f51f93c345b40523e202f6573fe7a36074ba460196fb49018910c3346ae6aedde902ef6274cfb4889e343698ee95207b73fec64ffed6b84685a303598a68a8a7670df0560b04c6813d4ef378c00c4ccde7821a0fc742636f4e1271e07e5efe55052c7e59eb06bd4450467e4e9be978dc6f30d2ed61bd6da01bfdf74d12f1dd9042e111d9e34c903c7f68fa1aad7d1573ef7ea37007b63a2fb5a8b885c22e3f26012e8cffdf05ee599a5ec41ecab2334a846a4486e977b6b282d261f35f288f91e1730f6635c2c7e5a958eadf5005eee5bd98cf8721031c4bd4c2bb9aef85dd9ff15044d1bbfb30346095c3706b0abe5137ee15ca97875948a4317765e8ddafc74e4fc5734b4ff4b2d66a46e8e7342b653aa5d1dd542f71cc20ba905e4811ecd06bc1f56a0f4c297d89b8aecfb651c001b6f9706d3b34aca33c70a7b2ee95588e3dea41ee4ecffc72ef9b019ec8c90fd332966da15dd1461d2cde3d9c81c42752ea61ddf56af799fc6153ca53f2aafaf5f207c0e37eec29b76fb2f62d1b43abddfcf2eeaae9ee93da59f915193e6dcda45e296b712ba46550a10ea97b6d7c816dac7aad891e2f7afc493d70947548baefdfa078f4313fb783df2ce47b2b1f4e405c2b58aaaf83a258199db78bb56171f84afc7d716cb7a481b2272591e4bdeecb51bcb360e2c271eeaff5169210ffa5d542669788fb6244a969aea3379cb6375775f38a8931875961b53527029d50f4f5e89843e2f6cad05a9b347b7519ba977e408fc3b2d7f097df5d5727a3c3fce631df662b527e884bcd3dbcb880131673e1c7b358f01cd2d60b8d5aaae0ef9aae502b28eeca3f22195f0b2f27f8484daaaa60081a82ba2bdfe50ef1f055f7fd0213e2f8096be1d7d797f212d26f39e2eba404211e4104403116a231f50f0e0cf86b49c9c7de4bdcea363b1651ce6351519b8af52dda559a6cab67ef003505ebfac46e27125645c77874f31e7e017a14f96ccc7bb0ecd1e4149d9a6d4a212c363cb8721406538bb108fcb9ea0513e819c312945f18987838879f298b22a6ba577cb301790bd3d1f972020abc12bf13ffe41c3226b8ee9d7c334f7aed582a4bacfeaf29b03309f67d8505e34afa1bfe64d006f18f8fc643321d948fbfc41824bb5e5c3416653448b30bb7d33765ea57c021f2e7949188bd1d62a00cbf5814e3dec2c0d05d1c049f4acd71820dc773c35b72df4c00d283d8a49f6524f9ba4e57a5b7d43f1f35c21e6fd969db93e3427b94d5e1647f67c285d023c6189b829c481952bb576886883525536a239f908f82a1ceafc91b569db250a382fcffb6fb89701755560debe384873afb13bdb34a1f78d60c010622031dd9126f4fb967c9af0a979e735e71296baed733c4a48e666081ccd82d5b9d9dbadea303902f22fe6ddf86aa4a10a5c094e2323cae6e95ecffc883f58d480dc8c544c70dbe748fd72b57575947d0bd98918cf4f18c5a5d96b679cff48363e8fad582cfae5e2f0ecdbaff390a4b93b65d4d6d22c777f0474bbf7e1a45dde574d4bd11a877f9b46177dc6f916fd23be299891db1fb5491ace798e93baa512cae4c0bc2392d99fd8571024a3cb7d2836f9b308f4652ce066826d4c10907543d9c3e912e4b8f42f265ff6f4d83453c3a7f19c8592421ea236260c0745b4ac413bbc03ec061fc7fbb9093e51250df3ddcf22b11abf5f2b3bac962caf0a23fd71e453a6827a4ba3a8da05c8a6115d05778121ae6b60a0bc0caaac36f69683934ccd9be6a4be36f2645e689842ae6f735bcab8d91d1e4d1a3f25c60104d3098518b5a966c0650695eaaafcb2634e0679e138ed0758336b451653422cb7cd2fdbe193552fd076193acc9f3c3837c17d2d0ed263d43e3356cb05371b839683c4bb005b663dfbcaea0ad791e2b9d526ac082520e1bd5c675c77f4cb84b10d144ecaf451cf276278eda6b2e6278cd8159bcae35ec03e08a3cc6aa6415badc220f6d179779e824602d1d039f1553dbdbe7187d8ff1ed70eed12fe79a7d7bddaeeb17e416d6b9e3a9aecbd992ba7f99783738df9d7821c7d2cb5c4e91e07f0b3bb4f5af79fdccf6e4437115ed790841b533f3041dce76694ccdb9989bbbf5a7d960da184a136c1fbc93536287c0f245306193a1a2bad90dbcfd0d4c363e5cefe2969e3a100ba22ad210ac9788d269c4a4d4e18e4fc60fff0efda17b188c41769f02a11af2c9974368c0f3d919f71cbc6bc465029452d59f33ca6383028855456b02f47dbf6bc63d5e8f5c6479a64f0a0397e4dcdc1c918984468275ad4007e38280f91ae7484a7f5acc1a5198d71360454470a6b017ad446061dc7a744cd6e3a744e1cf3326a1b1856a84418b8ececa890c1ab92387dbc86a348d3bbe0f88ffa9b8cda64df189af1a0cfa5c7f3b8adddea10cef37e49774df9f80d88bd3e8fe03e97e1bcdb35a72e8a45160f22768471600321679097c402fbe8f76d1787547f03c863decb8a45575c65d2ebff7d9a76ee06fbf53102e185dc440ab172f41a5fc19546578bc27ff4343e324516cad50e2dedd1b6adb0053816cc51ad18808fa498d4dfeecb78449b03ec7f32814a1b342a95f31fbb9dcbbeb3f70df207157a6c3c436a83894ed737da62e23444572e72a76057c38ad603f28fb655c7da8ab86758076adf1c196d8b38903441368eeb51e879a4407eda99633a6e83b171d9be7e69d40be36fa1dbd02d76309453510c932a52b02b34631827f05d2abac4d4401c11ae1f78d17c51996e7cd7405a1957b97eb474f91ed0b6976325f21db756c67f93d3b700dfdd17a290e5914e708c94f929b8fe917ad763fab14694c2ca4d17a126d773d53cb67af5cb3a667b48c9882a79c9e84a8b09bbf099e72a0ce0601b2acab7194640506fb56d07133cea06aa5f523863f33d693bb74edb812fd509c91c1331e7596b924e0320720e517ba418eeb2b391ebbc8907d28e4c3737b8568b25181c27f98f9b9ba1d283b761443761f9d362c894024954f2263dc6b54894ed62b03bd1baacc15ca82b6299e3cbc5758f07526b2e8136c6667a5a2476793b32d0cc7787d6b181a155dbe1d47710e9379dd38f87e3623ac02add8e06c263cd4b957885f40c10f1f37499ba347690b982a131ecd4f9597c86dc9810e498aeb4b465867c6241dc5fee286a33e28851ff9538d056c53d3261b4474da1cfdabd3a3384998947519bb9981af159bf871f212d5255faf9a73dde59a05a1613e34204cd8de8530060b7d3db197dc0f61a31d59c969974d2267d7a208d7b59417ac3e44645c999056d5a1457021bc6fb41adc4a6a02f7f4c91716f6222ba8cd8a2e6a19b48b19c0245256b3be4143b6d8f47f8d99f0756be337af98d11dda4dbe40feca93cee4a8a09045e11110e36d75e4a6c8a7a22360599363c7b2d02afeac6020667658aedced608790ab5d0920bdbea0fef5c87915092612bcc56262746aaf857e5a1e616bd328bae538c807a93cd7631509f2fae9d6f213d08ff6c6b3e09d88ddeb465cc41f97e4bd229401690eccee017759103abc11c0d30ab5076180d80f69a23b93d0f6cd3c5ba46a0ae1e5aee2cc53a8c9aa879863b6b65219529df694f662e5b8b799e8cf3838e8808c7f45fddb9203d187097513d7d36952719ce70e7f43e33fedd62c5c87245b0ab75bd1c989f5d591380f39b8864c50ef83ea7e932ddd7d532a635ef4ebb5dcc55a78695435668187e3f7f226e57d194190b4f5144070ee0749296363c9b561c275d3412d24a6899a37012b93e99fb0ad1ca4ea115a6e6f7e2f6e1fbcfbe0cf7cace9bf6667045fdc959c500e76ca9e39744c7c0123fbb03ae2cd4962668c8242ce66297b129d322a8bbc1743ba7fb3cee11f86d5489adf3c1c5e0c0e4e6618f551afddf800362aa4951308e0789d17e74d7bf65b020a7afac1cccd04e33f05092e1441b2e032758cb4d0756764a73487404ad5f080f325060ce054e3c6e452862f199815e6756b085b285bfe410176744ae7970f6190d95c926e808d1a31fe8ee50ccbdcb46cf2c5135e69daa17a79ca3b4309ed943974e75ab2b783d38a7d790fe6e9e05818b976c9185c15d128758881bc86e7cdb6d47000581efb1ec24804d42cf1c7310180560b145c5ba5f2d56232d247bbdcdca0ca816784adacf38ef697a3184f08f6d8bed1014b586bef01b0b0a711e24c8feb3b0df50e2727e4ebbb99069bb2c4b1d8bdad8e754dc9a3c19c7200449553e745073d2dfc1ad9a8efd72b16eeb79d5d16a76e90ae9ea29150d1122aa5a73ae4a51ae4f949afdd8313ea91e78d553a4f2ea9927d76d5518da7d82017550aa45e3b2875668d5a9f4d88871d872bc789b6325c62693ee9aba0f0f919cfcdcf51e0fb4eac8f2ea1703ab3e331a914b669cff0a33cc7512d02402699003946fe432d2ad24bb553c15c28a4ce6c59ad3b2dcf18fde3897e7ca092190713890bac5dad063399506d0c3aff01dbb8feea6fe37921e51aa83aac9407543cd8e5ad6882fc6242ce1e064a475442d59009a4fb92dae10e449389384eddfe55dd727f71084d412f8f56f057b29d92d886e6ddb0f37e476d69bc333dc5a4d7c53b3f7db886a48c48a816ce3fc753d272881e4f0f8e1a0efed7f7e53b07ab5aaf1da81594715b20043088ece570012125c762d2dabcf99d00ca1745db5f23ea9c978f88e1ffc5bbe9d7b1ffdc0323e2b95405f4a4a511ff4f2c090cd658824110bbbd41d342c470376d690728816b4cc3709962e726f94f69e0edd30287f8c426ffe5efe1fc149bc9480b83ce01af6ec4b0ceb23eed479f3a7dfb017fb025d25d0ae9018ce9b89ca141b0b89a33cf9e272cf5c499110b83532a6749877ad4aa28afe6ae7bb2786f0dce1ebef4ebeb0cb480315367136070ea95e0a1f8c2a2f9abfd179ac5d3f5280b42fdbc6c62a79dfcbc7271fab27df1e55f0128e97281a96121614314fd3a42b3048ec52166b533a0189aaf0ed507110d9866083a4675f9ba05d74936f403ff52c5aac5d5c575ff825f147592dee6fadccfc4e9819c04bde8ea6cd19cee04da7681f3fb5d17776c4a3bd9d56279c30bfceb0f21762f404022347247a12e3b84394d30c627edb5dfcb5dc880fdb90abcc1e7ad6057d696fb2e0b3ced7169fe05b082401ab037ca6c0cdafc691c23dc75f9b949a7f9b81abbb7c00043e23bc2aee18a6208b637abea234f5487428751aecf30573d764c9c31306a6872770861de815b32146633c3967277f0e42f8c46ad1c3a07d56fd77c401ebe0485a3eb93b3059a88685aef2652e60723fa2b3ee9876c3ae36beb01158acc22339582cbe6101a7a52e91f76d18583d8011453a9a6c9d8a0d542e240aa645d9ccd51a51ba62905968ef5e0071937a3adb8fe5b3aa0d171012f00736776f2f048fb40e3050ec6c74ed7d0501fa2f9950246a115ce055e5acb43c55f576738665966a757327d5e374272b335c531035e6bf39ea5f33560f6cefe591b39d97bdf224bc12757c532b319ff8a36c8c50cf8ec056804a50e9c0de36c7968646c1d7977576028125c03be2071bb21bcf77a85261412e8840dbdb1c0a2fb78f7c801399d9c38a32c9f67de8de0e984e09dcbf0fdb467c444589a2e36db8666113cb478e95902370bf4c8868402fb36a790fdd66b8bf7c6c6c1b61e7ad219c69c9cea73243c5798e2802d2796804edca8b60a9ad3b246d2011fb73d4658873e1ec419d98b4e94a1f8aa864f508f8b30b3690e1ed7b793457a4ec16ec0e6fba4d1b3d81eb9ad10b4ff046412e0fb0baa91eb7d8117564e2c1c50efb1f9f2483ba2afe9a30060797eaeecb9187aab799e4d137be599f32d5e5cb12efa16212bbef1b0f3ad15c951c28194f9cb19f172dd3c73df9f802ae1e01780fc12f75161393cd72d81b63176a0a24013de422bda5eb2f2c3d305011e7271fcd50541193f28a9431f428728efcdc3dac1b690e0494a316359f68d849ba1eff13331773f7340aee4012343a4ef1f61d5c85cef4339f15b86085acee7594d5240cf2bb48fb20e659aff5fb8232f7ab3c64761db6004cf543550344fdc1cb3bc77cb267665a723648fdc76a2c1f07f6e590d9d88a21c35d4b5e816af3def4fcac5569c4bbdcc2521d54fd888ba9683bfa9d16b03c3303fbdb00bac0b6e235d0e5ff21bfaa23d45ff6aa730e80552df5e77b5fcd7571937029c9e85b1b8675ddb0899b0f87f0f4986d90af3e27fef6e7605e40ea7c21d8f154cd02fac0cf5e79aac89528c3758b31bd8eaab22aa3c9a0d5dce35da8ebf698493e177a78deaa642e0138810ddc475dd65f177f4011e5fce25c4a04f7a8d1ffe13e04812a9158ef69790be03e62ab1a083ef5a05e923183ace71b7026af5c8ed512755c51e51bb2fb0b3329103ae43ae5e3964feb1bb1c097c30f043b08bd07f27fb12428527eaf8e8a4b78481f852e6520b471a596d909209ce5828c929b70b47436b5c28b6748c2f4f17c1f7f255fe42b93c6a4b85b3568d7a70dc068165f95c66690700c501cc81e2ae2b8e81e1ab9a1e687c35242f21571cf13caef03649da6e92ed97fcc8dea831fe270a2fb74b77ca0c2d8591a69209d3df040868461a191d1a0f6c6db9aad040bf3b2e263dc3095886a94e9582f207608f3d800317e3bd8b5eb9184db4128eead38e91025397387fb641049b4c96fd69b5590891e94c5898b93d87d7888eeb042eaade2497195d3a11830acb4a4430ac695132e160e1c3f45ad00aa75989112d1fab2b61afa78f5c6e586aa4a9d2f536e8030750f26a67da545ea59c6c8ea211cc6448b5ffcb810b38fb96cbd95a6fe0a5f806a81362d8ead75c90cf48a8ff6b601491af48f64cb195bce4bdb66d3a7b4ae8f48107896861c7d3814bff5c85da3f2004df4be3620474354a97a36d4cd557a4b2569e87dc9e6758ca065ade4713818e50f22331e209b105ae4c1a171121060e6f7deb60c27cec52051b0ea8ea393f33b21ab3cb3506367b1e5bb53c8e42a907960242c8780fdeddae6528df1ac4637b51e05000c37cf0f3e473e034926faa533057e7e307462f94dc68199aa8292c55cacd1039d0d0aa6fcaf74aabb363889025b9c85a2f01d629ff5fa05ac3f6566df49167d8067b918c8be946f69768d0bf9b5ce2814fae6cddc1fbf86ec4f5a7688a7c1a4339823cf651cc6cf2011ae0e84976fceba1aa4704487348fe7376b72e1806925b61eb8ceab3c029999facdb6e01972ff718f4e58f7f4085ece90555f30b27e13c981eb51a56973f4bb6a093658af4314022ae1d4fbece051e243197cf6dfbf00ce6f2926583b0cdf5eec6d27afddca604868820ed83ce32801055cdf95b85df9ae6840534b55fec40003e1c6838ca5f1dffb8572f0fab53c408c9fba73e4be88f6693ead7cb38e7b1c4fce1f5f9d8b3d1b801660e6f412862d2ffcc57180b05b057b230456dbe7ec69b3a2295b1d66fe43f1e5df9ef57507069602362646d695e25ca9960e83c5802087fa772ac4537c28f279f573c640eeab093c0d847f5dea3c968fae3dbf69edc60158c47fd937c95a4806abdc925a68323636a1ff7850b4ceb437fe105416f95dbedc67a9c5afc0965c4f691621d23973ad1ed4919bce8eb54a1d684059337c391a3be0d7e8f67a802e21a3481288e4d3413139f1979f5f355920ce73e68d423425c5df852e87885cc261e555cb44f9ae83216b7ab131437aaf14e19ce36bc8dcc97394b25613894a5a4b5503b72f500bb64a0b73170c4d39019d085515ac59c1944d1b5de7542966b2eaebd41a2133ced71d85c33e33cbc81a7160004e28e4ab9fba447619008789c36c0fa2672427e36b870974cd9ee3d0defc0cb5539f7e6843f57df9444000496415280c5ea71eee92ed5ea7f4291394d7cb9c5a58b92ae6b093ba872129a180471b6f72baf7cd52b91e2384d7a5394dfe7429e02d9181de78e3d364b24e565294a43b74d518fc2a28e09efcd976ac47aff2ffb3b78ce98ce5f6918a612ee3b1d682e0e1acc0fdfda97023782a8fb227748fe4acde7cec4869b2942ea603b983137eafdd6ee9887ac4fc00149e7e86302612b82d88a256f206c892d95fa17c068e33ae7dcc41ed686417afda9dc72811cd4fbbaa1f3e55e9e4249cc0bc8c0867f9b455a5842616423f9c37ddc524fcf5e8824276b0c317da653a47f535245d3750fca05ec10e2ba92bb082025385e8917292a77a21b55875eeef488149b374ffc919b375a81715cefcdf39f3795424efbfbabec9b33534445808e37b9f62ecb1e71904371d3f7244369421ce283b0c83a69e9b3917a2f7388bb27659963c1e5cc350a8d4a9d485683c4898af02eabe4a1c8f267276f487f436a3a3d640927e38900b3bc11710436f6ec6feeb8b8d62ada23352e40eec5117df2c40728daf0672e038e8b967d5a02cd9099d5ddfd9eb4d15ea80c2dd990a403b08b1081d511c1f8856e78d1e89818a6bf4a39c3c70791cfd15908d3e5cdeee795a1ea673dab3884ee06e1e4535c1de9f0fc73312739eb6dd0b9970c7cb78624a6089c7b210a8b11b4545ee81ff296024dcf452274ee052a0b4f8d9281964e492181abe3f49aadcf547b971a34ae611f888865b0c9aa6c59ed49d620002b627fc9c6a0c9b0d2859730217a60ac333481200fb0254cff66cf7992ff1a7bf96ab0ea699f8d8c8daad9548d224f164775fb30762ef06cc37d6a713a888454a3dbeb75082979b56be5cfa0a9a07228e88c9868c6bc7cb8d731d9d0f20b64a1f8e337852bdea0e85961acd0011641088b4fa93b65ede433797f441333149d546ede38325b2826633fe37ed31a1fe09d6bc29f04e9f5ff160eedd4902d17ba300ae91ad60ab210f7e7d1f45a3635740016a11257a2d2674b46f2ea5debb173bfb2d711ff9b0bee0458a6378590b2d67f930a667f30d60107ec339fc69c264edae3de3fbae5e4e2d4eb2e6b208e5134925f74fe90617626b96b0811054b9f3ab634da490b493a74d541ee52cffbb3d13708ce9acf1f03f1bd32fd379cd090add0162d405c7bc2154534380e15ac3ee2029df49841d5db4fd1bb9f4ffc414168f0d18e60b6684af65034c1274e440a96d41f0079bcc1f091bec3a970e994cf5b89603ae5e2df1fc78add087b1ae36fa59170418ef949a49697107baedd0efa8d44b52c506337daeba99524728633dd83079319759e91bc9d0b9ff9217b03a97b2b5c1bb097946734f1558ff7815454b45680f1ca0a681c9b1dfc3853808897dee29c52c2b1d847c7f4e4034868a5e802c15e0085bdbc233ae92f303437f832c6f305d394be1acca2be74699f2cfbcfb2e9f4438346ee6130f334942bb072b1d9790a1cc028aa61dc2ea4c4c056fb701e086cd44cd9e89cae0812304c94986c89f6e9b958af8d0a6dec3427ffdf2e2e234aa4ce24dc7af32fb84f02dde4c17b90ffd81e29ede44c729841482a047efe8f1d130707f43662ded0932c1d4ab6b168e5bf517749a08e53f24569ce1d9189ea064c812c7b7fef9a337299a7720fff1f24fe77124ff5d16933bcc755498cf5b474968dfd9a8b8fcf6d9feee6f4105bcaa619c4866dd031200e862193c53f7d0c74a665f75e377ca66702163f5e5fa911a599937a11095040d3a36ab0c89d0c4cbf64b3d2818d8c3a565c39311fde3669b7bda23f944d6358f07afe0b3366b422f034259bebb6a866bc9c2f827afcd0af72fc170b8b327743c2f90cda2996cf74fcd31f29481cfb3a1ed5fae6340fd1e4b08224c55a52944b9fe245236575d0ec747267d532489e84da690c627c219fb2574e4ca113e73c0eb21f9d5671398a61d004d3e84931eebbb19fcf789d1ee264b38d7368920fec3e832ef332178858c198280a442b811c3cbb43809336d1533ce4d67a675a66611cf433f1f734242bb2d5a21a43c32bc304107d77fe513ecac983dbac0ffb315ee078dd4c03b387d304f324a21ab3fd4a96d4c758f77095c9807f9d47602ea5db53a6109e1891254be5a5918cbdaf3c8cea5f1963a842288431878304c6485cefbf87cf61dd05b88413fce09f3d74999a636cb458adf91c7cd0905778b18f574f767cbb7c8a95ec81713ff8ebfe5384374d53351976f50ceddf1f87ddff582c197e323c4306279e642ab369ee96c99ffd9caa048b3bbe4d59fd27d74d185392052b8a74df7d094326145d1e211fb97dc835319c419cefb25bf6e7bafe2371a743bb60844132a2cda43d8e6e80b55cd4ecee799792c943771ce943a90065919c1c8220c8f312bfe2ed2f954cd70f66a80101b5f5417255292493af91556cc189aa818d0aa0f55e76ce941854168369885ec3f8483830cd5cbe4a8461fa0d06e285e5cba43bb6962b324dbc9ea280d1f3b31d9378ce7020c921ac1528aa5bca5792cfe2671f48d2dee85dfbb4f677252023c2f7ca181fc42f5c5889863d1b99176e45dca6576539c89d9522b2f8d7265f8ae112e2418356ac93179aa9fcd8ce238a46babbe5c18d4d0573a8457d0090b74745e5ddd5554986cf6e6c58fecb7970fb689a023704cbafca665b844d01e785722e6db72326fed07f66a804374c5aa1c7516e8da69d277b7fc0a5f4736489d4edca13d93c52d8e3b3fd39ee734e49f419843f0727179f8790087fb769c07b4aea37d99e2caaf9be3085c2683fc117cacb05c1c5a33726f72203f025293f749ac8c3fdb2af27c419ddc5dd36203d3fcd926a179b621116e96c5eeb74c152ab34b0993cc0e07bcfa413ee924e866926a35f2c68a9c94c50533621ad29ed9782107c31a152c07bff17f5b727825cfe943981e47027c98c77fd578e922929ebc758763961c0715435c6ed46f33b1caf8681e6b8d44c8f413e934b3a2365c340a806f94e828ece70432535abefa4b67a372bdf36a3d4e23e8300dfb83cb0ea89ca09bca0ba5fa0ba40c72897eb789a9501ea80b2e9418b8c3e9070718834c9712a21f69dcd51f6dbe3955d55d4e888e9cd92a195110e73de6b17f07fbd4e2c05ba918ca145f30b31347e9ff0fd40f861264ec92a3cc7fe77012c7d12da9e492124c758d1cf715872dc9cce9a566dfb7028a13de9330934f34b450e28f1c7305aee62e714afab848c04ec2adf9b93b64a1df4adc1ba112d9e0b0f4c2604e05adbe3c4be61d4ab08e924e7bd2497d82dae6d37bec78ec132407f335b9597011e960f5870f8c1624ae1b5fa321537da7eccbbb273532ee61e6e54aeb4f7f13bc73f8fc7c44a675ea0862dc3686c9ac31011ed4375052867def714f8347b894313ddbeefbc60824154d5f4611dcaaad5609d5b2eb07b485698dc794955364b732ab8ddac5997ba6efea7622511656c392015682b67f888fb0a7b224e5df8d6ceb450e70081fee1dadd29b15501f1259b9f0689540641b42743721a4abc80b42323a3ff232ea0a7a805ac74b628a941bbc688f47f007dad38c4dc7b3101a33ef32e83eabe264032ffde92ed6034176b400f90f160208b27b9d6f99b051217826bb963e036934cd93900137bd6e959274816bc08b7a4b458a11a1475ad73ed3f2bb5b336eea781bb0f48e046216463360be569786429bd8769b4fe0cd9b472dbe0aebd54a87c78810105f4cbf4256768cda3f05a2c404c2f9a27269e2d46a5f7c2f9cdba7220d175bf79da08d4d179ea5bb3cacf93eba9c9c9bd7924d49caef7b458e42f399805b4a8b90465c05608ef1c383c1ec433175c05d7f264468a577a0bedff8733fd07f6a17fb805fc2243890123c8b1bb9236cabae65ace4e1ed373e44a6953365abdd5bba8ede6db21f48a66a4f6e01bf80403ab01197623565f9c2e52b0ad0a263a191a40cec70becf3186029ecdbcf9252f298569b1952899dd5595323daec32cb4626dc03ae3ea18f0cc454a6982e6e0bbe71b23c5b6ec3262266bad2fad0f2346b9fb166eb2e6eafa81c76dae3e88903ab86af6361fc078ed2b57bc319f4d88a381345fe2ee3bd521a113e542d06e6a723b1eb56df4e30307541ef574a6276b76cf43af2b78f22143bdad0e7bdb6e84a825f48c351848758eb81639cbe6bf1fbb29c6b01895e079dd9c5c043e7e55e615b1af546758f8c040805ce34d0aa73f023bd2a474d39092de8cd9555aac693ac7a20ba68defda54c16ac61cee036c1122be77db73eba6e54947a17f2d39bff9f7f69a4a513bd7b674fd18f5d366ec80574050c9b5b97f81ca53761c75d9a5137a5e900b6e989d3af6de960ada0e811ef290e32f7252ccd82243a2693cdbe682fb564b6c25598d3658bb0c526df57dfe9ff996bdc49039999ff29646cb1c86af4e45b443f362ddc81215efbae67ee3eebda292b2c174b1373d793db249b3dc9223a9242fbd3de1e85ab5fd789ae2f3681490b7afdddb610a5442ffdb3c62d82484089ac4c0fb9efbea3bad351c94b78f50ffb6c4085e559af5d1cbdf2e066314366bf6b512ee2d291623242c3eaceaec9ae43b32c68ce0002c0da7c43b72ca797027bc094217733f8d2efee9f9de996098de156cf3a87ee3347fb2df6c35a76dff24a0f0445e0ef47d4b2300ff65fdea99ba0e15a1f803ab3fba7bfe9ebdfe271125b60a8b19bfac340df9cc8b5f472474471429fec7e071d295cbce06ac64c7938dd59153f48be7c97622a889b18720d820ff4adc4ff57c010cad5ff00da67302372c4ecc97762a398e889080f1bbd51a4c374a5cc44005be61ae4f88604023d7709df02c973036d9f3e96465d4a1cef39859024dad8f821817000276aa1182283e8e0ad4516b58bef6eb1505d31a1a5d0685aada5ca47aaf8339e9045ff0b6875a85dcbfbe6163814d76e15ed40eead3e6bc9e2a636b7fe1a6438534a68ba63499411c3129e8c889eccabf0eb52e6bacbb24bd823e43828e74162ce81bafaca6a2823e575a6afdaad78dd6237463e1d7211e9bd52053468b913d403b32bea743060722a01322054cd0cb4d6963daebbe827139e1523355aad1ee1abe44d67081c0f6edc911d3892d24dace251e3fff167abb84ec77a59ece39006cbb6d0c0817a30eaba113e69e902fe22c56b0e33ecfff30d8793a40570e048998ebb4002c1b6735c3cdac5aa11286d233c99ad54751298c784d7dd29332d181eebfa31a4937862fd1df53629152ba1cfcdfd7fe598075750cf469a429b3caeb7e1a1adec48145118751378297acab08611c7079dff0b9eb810db5c966b4517a6c3c670b4eae8235da7d12963178d8ab6f91c40f0a74e7afb5d2b6b09bcbf487baccbe584c5804869d66e61250bd07bbc478be9b503a9b6f9f75071fcc7cfa78002349990ca17a3e47dd574ab4066269a572cbe8de1469f8e0c2fd387062d1203956c13f644ff052d7f54f7475d0ff20d4280b658bf83d1ddb0a84280f01e5c25be7fdea0e9a882cd82e4c5b2d0e229b1da519eca2c21d799c8cbd4b675a47fa4df631e3686931f3ec86ef969b7ee41c33c1687b7591ba513adfc987baf5369c716209c07ae5a1459da0d2cdedb2ef4a110016fc9d341d94bf5c106d3e09a8d6f47fadbf43fa06816f2bb18ec45cc72e9b898020c22d2ea31986d73e9e6f55dd02d273c8501133cf76dc2cb5576929cab102487183bbaef34946f80fc1d824f17827cf4bec1dd26d51ddad8847db9f686491f33733333d50efb1d599b1168d10152cccdbc2962d1cf3fb59bc39d30bf0030d8976147ffac5e8e72c14b8eb43e9e409c69755ceffeb6aa80db76601dea2c514c16912e1b67083d1bc6dc2cc87c962c5e5f78067fb6f95aaa1b751695667e5b95b6682db825099190717b338b645234cbd839c60805ba13156fe46b00f2abd0c5cb4cb5feeab62f061ba34e57bec1144aeb8957c6f10cb8b9d2b615c1ce7edeb90211d99f4502b7e95b2cbe32bc7a74bd3d9c29b76f54ca06a38b9bce2b4581b4371d0eb624ee5ffc08b9b313b3b6b633abf61504a76ea7212238e6b3de0b2aa3ded157c9134715fb536c7d42c086611ee7b2434f66d5110a5383f2a55dba2d227a41b64ae2da02a65f50473dddb917718b82c63f5a5c0c66e99632e0d095523fb409172fa2d6aeca2a48257e38695f96a6325ee19ea949e3fc2b6a4592a3a3fd836c0c956d4ce80093dbc6a3f3b7b1a42d3caa1bdb66e6c0daed79c9b76559b0829db6b11aff48157cfdbeaa3cd277a9a32c73ff788799bff27c6346a5d5a257a3b3e435d120e638934bf0496a31272724712c421f58d18ae9d0d12dd9fe2d7451931119a0c24a8d0231517ef23d9fadbb3ebfe1a579cadf724dbf7f88effdee639871e2da37a6bf113758a3393d7bce7e902c4e707b010bee30f5e178611d2c6bbb1e432b41995ec06b077fdf45f77520ba6bec1091c9b0fc0d30b998771348b8fd7f9ee2be710e1a6906061b08e29c44a8919ee96f24ba521999950704c02e255b4ecef07bf8b7ca4c620c27d281756c77f1d3bfc31231a91984672717592c122f1c12a1a9235dcfddd23923d058d20e4be5f354af07017d6f44ea4525ffb2c5c0aeb06fa2e51e611784d0643c621f92e760f0206daa76b33c16b078f7d29657b18e97522115730f3b023896f7349497b93f1f7789a74ad711bcb3866a120407f1f1346c73fa392d0ffdf4d7000f3e11b2a50f1818a074232a68015eab803a8d5e351e7e7a885441d7e9f6b2df5ba8515d0b67d85c8e5c067bd2bf5a871e9c0f2ed0f6b0f94a1a34bcf04f31f7c954c5c7bda2dc4df735a8a6424186f19a222cb7b5ec06b62d06188741eb2b0713775ffff21837aa7753f43810ccb422c80dee1302fd245b3102bddce950168c42755a89d5d6b3e266abc10c6838d0a7d874a4df3de0e22bfab0ceb9e565e7806e62750e5a8b100e25eeda15affa96e6ca4dad352b3aaaa98abb63ab93226fbac58e488322f9b67ae29dc520b24f6410a8148de4a85194813ec7fa51d0a1bf00e5c24dae2b1b6a787318e4a028f37ebfa0b5ceb13a8ac2aceff4e18b94d859d644d9b02bc054f73e8fc3bbf9fbb3220d2a57e33c25a59c8a1ea3eea89e4f310cbfd7fce305eefaf934029b6c66a529fd624a80d8e6adeee570997a40b9ae43f9a07fae72a15e69427bbb87ea22b2e01e757efd679a71f20dfa80696f65e900ec942b8ca242a99e4546134fc1aa7f8aa58eb52a26e82fe834669c3c9ae69091be9afd774d753892deab26bceed9d06ca52e4adc0a365338d742877d93308ddc82dcf281ebbd2072e12ac60af4837c35fe9d02dab90888c715c0116b6e2f617a0d3298f2dd52f360153a85f99571749ccc4ecc03f3a3fd0c7ea39103bd04eaa9fe86c922a822f41144c913d91a38db4798bfca26df3e00edda40a0c249b8078b4f5fb39f3cd2c4f340f14664a6a6aff732b5dac095a18437b5ad47515d5dfecdf0408988f1d0eba51b461f94147b1c55edb3f24a6192cd263d4906d78054caaa738203d7968b20a38183843a99470427ea0dd680d66be0b109f76cd1a514c89491ab73f8d2da7e26eec74e1c512dbe755580005a9a13f6389bf4b925e430d01928f4fcb19d5da5b77c241efcfd40d242b455e688b6d570f5add577e6f9bd4d929bcf5d9a35261e1131f1b00fa196ebe228943d44e4198175a0eed22618c707022222e164044b903ec370888e5fcabc50d87e081022380deb12f846467458110ed59186cfbaa7a0f9a0467f7ff9c524738e2f7f7688a0b5f5da615809a9c636968f6ff165f1e1b35a5ddc063159299cab10df7aa874984243b6abd14eb58f6e732f13d0545ec5fc1294aa7025e20baf9215a559a1c5dfcbd5a8f45ae8212712df2dbf853abea0fb77f913507a05075529a03db96a7721a20427a0304c9e8069cddd25a89736372e22a75cd2bcf1b6a3f0944de406f435f0e23b03c08a78605dd19464979efcee0e1453d08fd58ec7cd95dfbdd044eafff0f2f04392061806c39da0a80a135a0014595e86ce310016a0322650d7cd9ada41ede11c0f10ed42156466bc512815cf6f34e8e72e316ec678506e5d07ffc2752add1adf058a7e760e847393253b5183742f7a5d4ca15082731fff64ebff1044c1846e21dafe8f1e45e3031bdc690cddb5751feb0262affe8d48bb94a85e235b5345468325c7c120f02e07f3230e6fe3b5ddcdfe55b5e7873861337a5b52de06f15dc8dd128862e010c4cc1cc0aba4b797c980730119d9a9731ed52f35d6cbc8f764dc6386b42c066047efb89a7bdfc352ba52b084093ec0e9e12f5dbfc760416b2ebbea9d0495c15e","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
