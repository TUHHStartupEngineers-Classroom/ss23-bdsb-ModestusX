<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"9f0ab087c7c30426d45299442551742d3c6a250f05a8d191b07c72ef8aacde231ed0e7b342c3c01274d2222cad7572b70ceffc689be4ec58ad6aaa2dee30b1bc679d6e409a5008f69f66b60294c18f2edd81a42fe2f4cbef7b133f90a6c42fa10f49a091dbba0248028a492a05f4fb7d4ef4a01335d6d58ff9ba37d43b0a4a82b5b8bb200fa04c841897c0c87a941a9d9c1e3ee4e3ecb438253e1e327d935f74a967a2b947339c7a943aab984f2b89ec18ccfc62116707cb9de69dd71e0a07021080b6013750c83a0aa4c0f8e2c5477278e451b117abb4c7aff57b2b660dc46d3d772c1c497ad47b30c7d98190cc4ff6883d2d4457a0b2e68a7aaf8fe5a88c92b1e705ba8729101c12ed7303a123e4c53ff265b69f7b8706dbf8fa766c4d29d65dbb2de9c88f5f71507b77ec40a2452a9a396689009635db8f7a0a15a30531a078efbd543cccdc9c1ee4f240d56cf72d052cb3270505931b4cbc93a4c1df9cf496911ef0df345df13bbe66af20c1ae1070f7fc3fd7a4826e0526cd7aea78bb551e71e7e451595dca2a67156fb4263795f899e790ad7fba9c6463444d654321f807c449854fb029209068b559a3eb52e9552d6966236d25c10cc2174b6bdfeade84ba75bc1a0afa49b71591a9e89c39241f4e51222dd2f3eb6f13b8133cd461890fd8602dc9eec4cd30a1cf2a5b0a8f065f04a6bc32597e5102ab99b9312e8da35a094b06d5c67bc5517d97cc3f31bf0f4c61598217b1906c11fd0e5bf225e5018230d87396b0b7f7981ed09b6dab654f4b860fed045d0656dbe3206e740296143ba3a5755597d72e1745b070de1ad985955cd4a2714c6e6dd4a7ff3b05a3516cbcb1a6567ed245e2c5d4e0cd4a5f48d0011877c4ac017e5193675cc40d3684ca780580b1152026e1a2fee919499c635e36fe2183d37dd3ca3a9aa139fe295afe73322c23f685c1ebbbf1a4d63378c651d7405b749844d29a2911a26482045065d2c4f37481a5a3ec1aa2eb88a6fdf895ab2b53d688b3e82347c0bea4ee1f7666ac0add791c2ea646e9e5804b5af3e75a7caa2aa774b4ede623347cf5f3d687e97f08469adaa7e58607332c6fea2123a3698a73b37680a28d08640a7a02ae5dc359af0644c571ce39f6a9244daa552b4ff7b99c0ba1cc306e7961a040104ef1d3a3daac80b83bb5412327a2a6281faac7969701c51f2259730fcf507b93731b9a5bed172ac5b432d29beea3a29ca98bdf37a25a12aa476b0f725428c2a1e4cadc2b512f9abe63e33d05470ddfb53b1380141f7dcb3c8a8c6d7d55fe209515bd95d2f8d705a8588a8b22bfa4349c93ca59d40bc20b77f1047ce78c84d966d87e93cde6838338f9417bcf18d7116fddd4a3e009ffcaf4a73678a421ab21a3d945aba355268afd2b5df5e62dd760065ccaefed3785d541aa1aa7123a8afd0d7b0384f131999dde294f8f6ba58d3520ac90f490272ba5dbf0c370305f1a6790dbd83c75cf463c75848e781f6f463105e60f32e39c47f5c996f1fd5b19e86ed08596a118ac3b09f9e7ac1dfcdbad80b6a5bf7b04e6d70434e8a01c30cb2d18670839ad6780c9b0eda6e12b1b52281990b3097093ec7d22a7dd95734361e8e50a6fa9107fc74b1c435e11b438ee18b2855310a19829002a8a27d9588f964388dfbe0a70e9ae4c6a7c760d593de11678d404f63d58792097f544b46c10b5d31dcc858a4f916d57c627456357cb016e8f5c5df469b47d7836e3ccc3df31ced7aee4cf5529abf8e6e3276e2216955a07f5a78096c79f670838733045ed2c66a7e03e1870fa6cdc076e6ad89789686e92010b3fbd527fcc9906ed0bc0b73278bf819c59638befcb88aa6ba2bb2cf035ae9340213c761bb707413112b3822ae8ad5f5e4aec504fb391a6c680469c412682d297b6b0d6f790b341ac99d3503adaa6d322f4adcd2f4188b1d1ff50bc5c0d5579261abe0062c80ce5a6092b6b85283901559d587eecbe5f7235b17bb67b467ce6eff9daa638d902c312f3abd69b2212af5a2ccebed1987a8a7579d180786ee5bb4bd9f1a20e9952d9255b2885464c875f15e47c827d5c90dde18cac1b5b14cc61229c0438c3c1fb238914e4045e90b87bc3e95fb9063036000ceb7497c65b33b4386062380c8610755d070b6d54dc90cbae80248c7cdc05d124f36807e0d9725d41a4e816819cbf1ed7cf35dafc823889814f99b1b08134e73a77f7ba7f5f556093a4511232c0292198948ccc3b32094be72fdce46b67efd2866a4259b03750456ee7733f2a9dbaab64416b8b6c2dde325097d583623aed8d21c27823bcc0bff6cde24b236691b76c5f1d481de87ec9a50fc661c7f3fefd380076e66ee40d9d47e3df0bcb639c94714ea5ec2fd39bc13b9a90cc64b419eb2b953ff891b7525b5dbf6be07a30d634ab8329c5d45a5371890785f95ccefb54e9cf314af59d6422b0339b28f6423a108dfc059dd98eb6355016aeed4733c92c9d5b746fa8c223f526cd9415b64bd0decdf2be8f2fb47c0a0ab0b239e141d8e57e5ff92b581c0a7f4a1dc419868e2a9f1660a50d372d7f55a56d032ab91b9b1fb0b48e02db37b029b8b8df8fa1112d73bd04508f3cbcd0162521764f2ca013781a9db57c1a24e9236346781ac30b65dfc02a65e4c3257c704c9726515393b8b2961267c8d912866131407904a1e2461626982b5ffb1406ef7afd1c387a7b94b808cc3af1e119d639ae05baf3741e85745beba641a7cab1570755a00c4589875888f18881ac6ae64241eca7516811fa092db3e9f92f8a5bbf4ecef176bc0a88935da0d95308fb46c98a77be02617939bece72d79e6cda4e0d38c56b823cd1eca03a4437bacb53edef7e533d576f328dcb7ccd4c164314b31a7c02320811407af64e188a9bcc2eaac90198fa89ff0ca80bbe960119fb445df9c600cb2ea9054a59a6a2801e83a13b84c823996a20255f3522cede019b7613bff08180ab0968eec19b5c4adece1b3d07b24d9689a6c204accb1a172ba08d1c01a5a0bbc0409ab4035f1e305933b585ad1cbd3df7d545f774bbdc87fd3d872f8fd4014d382a0020d462df7e2ba9b605698c44c24ef6a7f3caca36f5dad85f15cb0c0e026051c29a7579a446564ccb1c4a8ad5ba644250bfaab684474f83973bee4e5532662ad8ab574c1082f69fb5ca0d15266766e39921e1eb9c35d635f0e3eba97bee8f8436ff9ce5ecdb97e0cfda48cd1614dca9e4e2f43f7f3462856e89c5aef3b370025354ab4da6a807a7d97a0da36ee63258f2b21a21de409c4993e432d1bdb210116ff96c76415a2122e7ed725e673f175314bf163b01bb14cfb7507787e86ac7cffa7927212c9ef14ed688e2315998fa38e93cb298e7c5f3f590ba0cb1f61ec39d2f4d6586b031d4c715b3ec08201519298a9685d1acca48bb9ffa4b7c9950609dfd3f55f197c5823df92133b7f8a6e535b6654d49b992c760ad05f264e32db31a2cf7dd1873fbb0474ab0a52ddf3eea34f0a5cfc4868a600af966d24a1ae1257e1e2fda73759fb5392ec5b72d95237494f3cf3174c9a45c40763082fc6cf817513efd530f9918e11d127a0644ba5c2241593d47ff079b3c3e618f4a9df2437ee768ea40647379f32e79e87905111b495bd30985eda1d0e32601c23732bf1d7abd2ebd279c61179e7f64cd557ed45e57b04f8d26d16506f5293a30c60615a7736b76251924101ad850980b91ba79d592cdbf39e97dd8be507a0d270b592ff98cf9a43d4651ebcff48646ec874e1fe341ae853fe84501fc4f396c7917c541df3f6fdab01cea5c184a7cff1bacdabf1027127ac6ae1c59e228741aadbfa3c37a04cf9672f175c1b7c7a2ae54c7c5f6ac3edcf920aaea0c89177167a0699bc3bb4c158ffb42c985f41009300fc1ce65120a82b4a1c00d2ce959d31341afed56b6bc2a5c30a2730b96a5c02ec6d280cc8db300222206042a91fd0aeb6966110060efafc0f64783182e11f5182e96eec1eb84bf1333ecc5799df9fcc37f01d2255e338d67a394af7f49c288c2f373de44103cb741fee8701958fd387f618997ed21b706ed88ff9eab93878b24cf9a2bd3959c836c5f77ee280645f8f04439dfdcdadde96f755df5d3e3c26ad01bf18cb40f5c267d82e77aeae5ae2ea278e8a50660bafc0933a3db39b7468ad060edaef54e71ffcbcf2e17d514a2dd2c6588902c71218704fac98e852217a5d83d2eaa294a664e8afc1e69f15bf36193d89944bbcbc876d6a4bc9c587acd460311032a02260795b77a3edcd7fba572321691a176a53b69a489e4f9a220fff71fc566a97dfaf6bec7041bc3814353b4cdb4d910ded23bb9019e4025ead7fe38f63f34fb086fb447d8ad60552de6ab787110f7b33a66f4860a0a91e7fbf72e1514fae4c7c1199100832030ad19fd3c43ee767aad3e7a1354c645265e2f9bce2c5e2b2072760142118a289a5d047d01f5848d4809fef1b688373cd552f81c3dcb79c569f4d94c4531c65b2ab804bb635fd657e93a38b03eab10157a260050372c0b2b4334abf156f74bc4733082c15622b27fd229995fe78ad9797a5aa3ea31394dc7461042845d258cd1837c2428a1f0f5027152f365c0292ccf440ccca96fc578e72467a22337747f1a7821cc03eb497309caa8818b86828665e16f059fe646cd9d97a9d845bd6a6176ea5f5a13c21af62c786dca3d9b95001e784ad1cf9575ec493f26c5ba65983ea681f5fea0fd36d4cde898833fa43db5243689eb873153a4bab3ce5ea96c2ab99fe9cd7fbb8f479def47dcccfac7066364ff64111f353058f52efad5ed7692bd6084cd448f22412d8c2f47cd41015399c2a857c0ecb8e36de1dfa4f064b77ed8aff6252c87068b2fa295dbb402bacd67cf7028c2fe4a69b941a88040df2f79bf8b21900d34eb4e668ebe267220762d52eaa686ab8895eb150d61459e2c4a0627af3e7cc44d86aaa0ae515c154fb4cef1063bc862745a62aee6ce6f8dd81f830b956eb5975bfb23787db16d5d1ae47f6222dee0c781f00afaac6e24888c30371b68155fbfa8cad310659b7bfa96700a692c270e35f8d8639485bdea56eba79fa86c041a684e8431f05528db24c64503ab0015470a257c325e7097c294cf1a1edc5a099cb23a6418223fd845548d530af0a3b5ee47030ed0b62648e96bc8d96158cb5ca9e69a7927e467751fe9aafd1e63fcc63349fe792fae05194dc9de808f696ec03b35b61bd41f229bf17c90061e9051b561c0ee915ad2ae0d3d4a5160b03b34ae3f736efd5c22d0b7d016848fb95b99b64bda6f14d59665b493d3451f15268b38f0f944e47a5bb88bf2d3759798f7baa8634db04b397604e3c404b89b019b9a3d037ffd8c69f5863d457cf6356d2d5279f70ca54ca64b3801e6e95a416b56390e3ba438a957949cfbb39fdb23ac4ce991b438df2076389c3e5f58abfa1b5e4fecd1e6acde49b7e216c1986affe5f115986c9c6890c861751f9d949761a68a4fe10bac1d739859756b3f40f6ac7998c8611f46af8dff671a5c171b971ad2a8f9921c6ea877919ee86ebc52d372abc7a0007aa0cdf17bae8a9d6a0e99763dd1dc82ce608ed1b8eece07a32b7c28ceff8993ff89927c37b61028fc7b1e34eebe909cd3135d08e8891a4b06f69836f4154bab161e8d54e0ce89ef48b3eabb99488d28f8cb10268cb84fc2e5629a7b085bd619648e8e3fb9adfde24ebac54628532311d425811999199e802348a22daecacf816b265ce373777fb3191c106f9f1d1043000a9f5c02960cd46349b6a63b98cd72f88b01bc9bb497b18294709d7097cf5deea81f3ec004313a9f6c9f66ebf11a6c26ff7249df11304b4678434595a1f81ff3958b12a5169d7c3ee6d5738b3dea5db363e03a99d592986e54f24f0d1f49dfafcbeba2cf32f111c16cdb2819b780ddee095fc449bbcb5809efaa4c2d0bccdae5d5c09c7eb66472a42b01ea340548403728a2e1266d3173072193c52c40749f0ab4290dd3a77ff3cc8ef430e46fa75513a8aecccc61c3a912362866053ea041599002b417b15a94d69eb57ef040b26a99f9c8b6dda10f3638f2fda36da4998b7bd435c0178118c69e2f6dc750fb399e39ec708a1c1a7209606670679189e7e2b1754b5db3b0e1c99d62094f97d1118bb69de66f2a8efdd630863bce953456a4082b61193f49c5fce97ead7779c6a1df54b278e526893dec6704d15cf204302550e2474723866dc987ad547e01b24974d1e30000525a99790604852621f3059fe160c4f4b4e8f0a142df7a5b3eb1f70ff28be869ceba678fed9707bd482b63900ceb59e03a6fe0f7eba2e4cc0941a3b2c4c56f7400fea2d3938e87e22fb2f658adb9bf7d7f692f6f3e4beb1c068f076199d6ced04f9285c722c439a5f726e5668161890c5a202a0563cb22fe8c85d16163fb009d52e9787e4bb4421c29daece9e284927c4c1c1170b6ec73483e3ae8ae11d0f600a4895ce488a746048def6f24a7689d624abf411d1f99ecde9e46d3e6c704246b093257fd3adeaeaa508b84f7245673a0e48ecbf2677ea3111aaf3d78d52c154564983ebf2a2bd301d6d66daebe85ff8dd1db96197e47133a08844dfdd24336c17561d2b7e19e0cb27ba7f4b51ef325293063203e081f08791f72b1bb15abd1d58773409242079d2f5d5e321d5580f70ff9289a6004d836356410ea6dfed279fb25455424c688e67478cd49c74ff5b9842d58de4973e368212dff6f3e72029831f3e1445f9f3b15a45ee68ac5b693c2f874b7454d3ef10458f7b4dd25f98aea315ba5cecc445525fe9f78b75d327989f6119425b6db4c4cad32408ccf0294b76e0bfd5364b329b9bd95b23a84ef859b8b65734c4706ea0c3266673cec766b09f8832b55fbf779f13723c0c39e1d7f0fbade910a6ab5dc877e3921222ac5358fe67273b63169d6bcdb6f0ca42e1a3dfd1d1976082d2c27f32ff53d53c562f2761ee09ac89a23e615008609ff6af479a695891ac83a70d8f917b86962068aa15fb088b8d16d8e99fd6febbdd252ebd4982b963dba0d86075398e250fa9c696acae1ec043956b70bff21e3a97bb17f60ddd4e6e45dd138ba11b5e5043cbd6b52c7995a420b61ca018fac100a05670413ed641068357dc23c202da85aaff1eb2875277527de77d21c240a60cc07ef9de1eb95afd17de7a97ccef13e8420970d6dbd444b7597f10ffbbcbb6158cc512bd933403d1893f75d888164920276c3b48ba937e73b1a9819b4ee143c93486ab655e4115913a721c4ceba52e3bffa7b56a9fd16e949987df63379d4c0eccf33d9d5f48b79145fe1c4e1ded21aeb352596ef08fa5ddd826a2f76e13ec99e2e5456c040ac522ae8cbc0f79bad7cd7b5b90d30aafd5edc043fbe6ac3477766c6d72b13d9f1eb23b95c601e757d319bb99612644b492fac0480dd9f0932c1718971f4d81572ec3b62f30df8edba9aac6dbe5582cc4e675c1d1b1a803fd23f92167f0e0ee31be3b48584553c243a58afbe32b73a570bb0215b353a72d7931285d6e878b3741bf5da24eff8459977f1750a69f3d0052bc4541013d122e4e8b1da9d2d3aeae660e64ebf4f1b69d78814282a17309bcbe6512edb2f994a36e6cbe048859596c15985a28605a0ef2e66e5b6cb1ab9acc2e12b7ef1994f70eb52bd803393131fe29cec5892c8f79f04e40aec3154af67b3f18cbea2a7f1ace161219700ee3fb2c01c7227448ad8cb4e6bdd4a827f1ec60f8c7189923907a908733ed947e6a1506bf6001329791107ea4d147735115387239a1560deb4babfdbbe71b93fcfd1a5a8b5263224e27009d4951e2eb38ca3d155a453d21c7fac590b451679791c7fcea80e9a01e41af5e2536a91683e13c4984a05b2805e8e05019785c27a877a1e633ad9504d38a2f6929179b4b037834b10b8fafa266c0a3674c17dfa0a519ed6e7a8b54e0014b73cc23c98be434af47d7294ddd34c19bf7586112b75df868e6a235d11d3363093e4abee2c4f82e9f914757235b52e9a363931a1c1085043c5995e65b4fb056317bdda34fac2faf0355ac6b7001fedab8d286a09acf9aa1409d743b323669b3dd4e7cc37bf5adedf0a07730a8f50560729b25a4ebe76ae2828cf97db84ebd8227581db1754f15933cb131813945fe6806715841f4d4cd19e7a3a456a586b041c5ed6285f9bd2123ccebef15562f042cd63ec2cee3886ca26e01659c2af1319e75f292d19479d42d9dcbab1325646bd938d4357f86bbd17aee87899b30a13a70c238dfacf917e4c6d2914d5f1f3da49f661dac2bd340247288c5f5dee97c730be771d6abf23ba47a925523dfc6fc5237f7e720738dd4b0bfb5597c73acf9a1f31d607b3b8049af4f025888312140c87e8833d9a156519dd646aabc9f34186121289a41c169aa99f7c1e89f9179d3b448095583e0f3787f2063955152188fb1118278bb7e59a0fbe4a46bc0c332959f0733688fa4bcd86b0b1c8788976bf713605690e7fd281f60eb3de0b739eade9049be85f5eb2bcfa9d896ab9aaa8ac216a086c1ba969992a4424b8775c045c689a9244c170190a4049048aab566913fddc4bdf390602063edfd93ed6cf12ab197b42250e90d3316006ab07548d15655a10518f919c61b0fadca9ffba07fcef4e2cbc4281471067528d1a7111534bcec943632031217d2f6d0ca843530340edcb132446097fef8a7515851ea0672f018510aac7c8983535885ba26284d6d3f5594e7b1731a90ed90150644525e9e676444f9fd9a0f635d0e36ae98823bec9bec8e3b8abcae410d59cd3c759dd575081bd828554eeba19e4a6c9ae54e42a7f0e8ecf75fdd65811f3a28d74f9028097bf42d5f0dc95558fadf8f62296da1d852218e3b2c96b9dce4b3c0f9e81d1897db8fde7c540e8620349bd12c13b94aa01aa27981b5d75cdee0572fb39b2f1890bbb60fef164ed1d7cb333bdeff61c78192e33a9fc214f408df5ac2ccaa6ac8b6f8a992d2fe67a6ae1f5b744ad9627445cafdc9dae8c4686d4f5db6cec45acd67542792046870c757dea230b0dbccb841e171ffd4b2a0a6fb636e783df914780da89e23dbc5380dd8dcc0ddf6f7aca7b03d9ee1aaec7cec380685972b0a7cef647aac33f0dfd91c53b2e576c1348f1728887cbfd8dd70dc9b6253a4d6bc44611e1cc5f74bf16858e3cbb2c06c75d899a77893dcd0cea95eb267d6de01a35b207a7601781ff8ef9b853c519b8592ae7b65efe5c8e3314d4b579e89885fddd2ed4b2a4c67318c39c10b70f4396626f3cbfc145e06d158c40a659eebe491cebc8034e40d8247dbab704f34b7369cecd4ec29259503d30a8404d92f14144696ba051bb34794e1ed7615954e3e49fa737cd89af489d292e8aeab72e2bce5c57ba655e47f0dd4b4488835447817f7ff2840e6a0ce8456e7469d76be3e3b09732ae390855cadb345209898887edaf459ff5eea0a08fcdfde36922a8f5868f9086a920c10ac73fa69bd2aa7220fb04d745dd3d680c4835ed79757c9226a82b40401df55eab60154a12b5ce67880366819d73a01252520ae5a07ccb50c171ca9c3904213d12470dd20c8f75a9292a3f3cdb38509324f4d8446cfbbab153643c953007111dfc4e40996d1ea721390afcf80b41242fefc5a246ee003b9a930a00301e97501e064e411c7b957c3945d35a8d8ce5161d927fdc33f386066c4417873232b5568a12ba3f96b798c4501eb815ff3bf0ecfc8c5ac1c38135d923bf3f1439890bbcd2e2c51e61a5bccb5120dbd4aa64484dbcf83a995b797d447f846af1b6536f090a28809ca4524078cd10aade51039b67e23c4c43bbda13e1a1e2b12913d56e1e6749207b017ad1ca9b9b4fcadc5a886a95a7e6cc2ef0cffaa11943e0cf2abe29d97cc5b417630a93a51eaaabfe36102ec801b848d77b760d4acca5194e32edc31ecf14a4aa50255d0c6b16639a41b7f29ff2d26da6b6714244eaa37f43836e6ae66ce92d0e24634a21206e895e5c983b01750efa5a704abb5ea623ec1fc301da4495a18f41c231e4c843e7ddc6815c53affa242d74e81693f3dac423c4f0b29d9918dcc565d3ac98d8b557d3352aa0fffb79e4f2046e1a43f8dc5be0dc31e1e2b5ab5a381865f7ae7af891ee866a96f79268a083a3f4f28d3c664246e3fea1cb639e12332eab55ef3d502be203c9f055ec52eede7d7f942d94f6c2a99531d762bac6ed57d050f5742603da5e417aa998a1ccf67ce4ee3c7ba4451d036baf864b925d4a30622313a1933c7011e55b80689d8b59aedb784709cbd0386269aee422348e72c9b359afff1d38e11d10725619f05217d5c144f41e782fa54f4def5d852eb45ce6298ba3de32d06f20907456bb9bff86b8de2305d736b5f306eba00aabda17853e4c59d16fb093cbdb3eff8a75e605b5bc6b40beb90ff1dcf4653c507d86fd144ecc13f3207327284806977f9e6de61dc343ae4c1a56a06f289bb40269b047f8ce7f09b0fe779150a030ea265e825f37c3a5dd218eb1d59a9ce3b5681aba9eb0b00b1ea3fb1d04982b98369c92a17d7e4641110b5bc21cf3eb1c5f9bc954243487b960f91c01f1458b7ed54fb761ba77a3ac10e2d7238ecd847088500b915f0671d4b27607e63e432ede8700f38a6e17ace6e2ed96e63056dc51de7f78bdabadf6fa29dd5b9a3d4876c36daef5b827dcbab72365ab5a81264d01efa3edae82f894b044ce16d10fae840c6ab09546984802b29829b2b6d49bcbc101183182f6e946d94936a6191da3325f7294de1134b09f8d39bb321ec2a7eebf0458da518419cbb5339010bcc50f964a9b96cd25f4e3b89311f25ea365bba65480d7b7698ee578c42381f56091ebfaa2aa32dfd135485a65dce3563eb4e52bd512a2d51b971e8c4277a7cdef112a4e40dfeb358ca9df224f2f9cf3a387bc52c8444515f63ec0f30042a5d517495e5a2638cd4b4c2b8816a0c239ba7b18cd55f274ca1569a9f7f41b157122742565c06e5bdd6b02d87e0ad1b9440d352b6c615bab37b6069dfcc9c3a77b9f97a7298985cf4952dacb88588a8b3cee72992641d7cd24b0109b5738e9db434fcb2bd722517ac7ce2505e78d6ec8ff429637dad6fb7049e095328b06af28f08a6a34dd1210a07da252a911e042a7e9baaf61c75b7232339b07df074f236821da418ff641d87526f8709257020754fbf129e32d9e6e22b2c97772d2b290848afb8b7dd7fd81c248f5217e3fc7dd2c68c13525940c4e7b3af068ca8fa16e4cbf00be347d929ebc011a4eb73656edf2f4aedf3edd9793b6a63853803580a02750461a1c4b0af625c2e5dd5edb48d0596a626259e43393c7b338eb17abe57e2868b96318cdee29a77723bce376b8c5cf1925a5898578c3d685f8b519849f2940c190086bc2056d841e41412e83c0d5734e882c42b9a5036ddcf06527a99023d99c75f9fa158fac7d29f4433028f6cadf17d33d0ac5c65794acc0f9dd5b6e8df59bbe48f0c62820a7b1b9555a2951e0280b903e8d49d1de7e1eeab10cfac4638dbbe423ac20217efa2eab7ab8d913b9ad849bcff822d6e3002a9cc264e433a856a9483fc9d314f3963e086ba3fbc0cbf2a182e65605e981b28caae781c4dea85cf4fc754b093d2da4f6ba40c2b0c54f96a7641c15d41d5d5847a46cc0104cf1c21f46303fc072fa739e4fb84d17fa059319431bf5167b42a886a9f80d56821680febd85ee83d8c864a200b8ec72a00db88b0a64d731db5c1019ce7093841702d3c9bdd47d37c827bf417cedf501b08fea9e3040f2017e597428d6bad6424035470db011f021895ae171f895ecc4dfbed8fa88f302de398f9ff49e3a8c17c78c98459d6dab1a370c803e3f2564d56845773f29eaa2ce6df4d21ec8a5ee7a62334d24dda4cfd9012c24c786df23afe92b32ef22501e9f1ba0224122e4205e44abcacec1e61037986bbb0490fd000e0cbb83d35df8ea288e03d2f4f3d1b04908f904dd1d62195034bf08e9275cce577503abf0b73e7b681cc3160203eeff495ee9cf57018507cecd39d4c89750cb38f092452501c36f61f0f434314625dfb4802950d891e5d86417b916084dfc6c55b07c1b60a0bceefacd238e7311bf0b4e70b4ef39c84b5d179a2261e8f2e589bde2d9ae440015b619c5c36359a2ba5d970a1855bde09fcb5f4500eb96007c2ffb83ef2fb54199c7eaf953c8a9dddb3ff9e08072fcba71e4ac8f7cb4492ca090f8661b41f202d3380e1018eab66ebaf7618466733a0c550e7de1e06cf778ffa5d11df6334009b4c555e08396b5d38aeb765448f9d9fdfd71a3ffd3dcfb9b8d606cd553780580f28db8c903934f2031f90e012119e807737b3c0f241778f443368caa538766b1e29ce57ea1e0541b9dbfe26bba4a4f5317273cfbf5c870a254234225cb31fea283232b7c06496c39a169a2efa33bab1df0fa879b3399e3fa86d7c76c94da828af32081149567c76a20a5424ebcc1cf29f047c63a0650476e0ff12d76d79e13182e65e639b60b439aa53803d7463a6eacc44af0a392806089ba58301f1760b986d9c10cc4ff8267f5deb07dd74260aa38f8888a766df0362323071871c5cfb639a03c9167581de7f61fc91c474983d6badf8a454455ab135bd7542f59e9145c37f8f0c520a7d80ae078843987e30390e42d63ae831ae071a15e6435038d72f8280d5e53d97ecaff06199cde73c87adc7726bf3354b1593256036b4d4f94a6bb7b002b47d9d1a5a25e664a51e6cbfb440b51856bec920f5f3b2941dc2b72f066b3afacde65641b9f80418c6b919a565297177d483e391f12c46419fff716e750b3ceff2ffbe42e11c5c59057dd5141af33b64ca82750a03b56d01b55e7cf30d763b86bba0b6f154d9fc83c180e545350eedc4105121242843df3500548a263943173d85d4fa4ba732c2ef82c72a12c2712dde453f5d84eac0895c5f7cea4fa05f209621194bd8d7070fe14e864c3ea327482aeab1d09e72e1edd76ed33bcac4419679db9bcbae99451d4d7baccc41e6bf9417ac1140333e12db3d91cf2a5990d967e2a73ffafdf536ca4ea7fb007666c23c0e8043135e37f703a5c4268553789b9355b8e5d26b7c466bed1bc26f1f424ceb92c4adbbe81a65ae8a06310790bf844f64f57e040401cbf05acf5b9ab8363fe8fc8ff9dc99579e69d1a43194fec5be9ea35b48703d01952fc3943bbd5fc0bc55d6c04708acb8cc79fbdac53b601085880a5d62470702cf4256186df162aa3c86da7cc5640c807b34f67871ab0b6bd10558ca7e3a1c281307b25e62f1627f8168a4f15b4984f9bc5d8183903e26b52d7df61d4ad77286b3fc14b252019914ddc1d4963042136706a9637ead92066144a82d914ad9bd104f97fb6151cae5f447a8336b69c58b4c48f0b902262428594be76916eb68f18f4f9f85d08535d631f88314dcb19f6d15d3a0aef543d81590122e9abe84d74a61a5c901324c2953bdd2d8bb06d079cc67f6de88a04b491dd81be89fb7771d6eb503b340c6d2738a061dd3719ddd5786dace306bc87b1fb349fbf4cff85c219051c5c1013ee6b95d87ed908fbf88264992e09df009d05a1d8128353be9a2cbffb59e559a2f561bab6903eb1ea746ca7404c3ad4eff1671967055dcdf6256b45a2cc400a6f725ad1cd700f2425a5b354de49e9aeb87c608f699e505cc1b10a961baccf90cd3de30236ec01742ba36cd6295c49ed327dbdcae47e1e13183b03335e4fc7b471ef200462a00d0abf677fb475be5ced49a77e8c09086bc80d327274b7a31fbcd91b4982f115b2d8b7922ce228dba4f7845a8f0fe7e52599a90718511e824dc5d20ba01ef39ce00e2a7bd01025b5f5bdba6e70b577fe2ea451d3c28b4355f8eeb43748787437363588230def63efabbb08b84f284785bcc974b0eb108e6dda9ba11a2910405fd65b89b744e9447b33657e21d414212a4d12ece887a6a61c8ddecccb2b0a00d61888312ef0ae935e78b8c4390d44ee1bbd45ed952b12fde9f4e383ef71f0a89a03c0963bdcb282387c7a27dde17a2225339cc358b8c700072c3ab3064ac4667527b447b5fb962c542d569cb7cf3053fe26f5b70be9e00c3eee15b6887a1bd1eb75780e2ff55ae92379008de0df012b533707c068d91cf5ee99b1faf11bb03defa432e603c3c77455ffd2587ff16284a54ad87aede7db4441ed98bed7fbe10d36d2a777ebef3109f5a296def405ba32c54f43f64c9bcd60ff0011fc10744de28eb0415460b85b070ac2a4ec7d384e92308276a72ee70cb8fc3c2e17ab91d91d1804ef8e951af3b4e42c70092d13a50b03b582d65a3385c475ded44388b6c84aa9e6efcdf57fe326ed33809e10b2e2d48630d26384080f1a5ae76acd67c4c8661e7e548c6d8099cbbebf7cda3cb39322f681c57effaac9324b2ec33b156a672f1dc3b77ce787db7ad21a43d100af7f0b2a4769d46a0a0082446125ea9a237563520d72c174f561feb120e074df23683946fc1b3ef2ebfaa020a7b8c9a4e0eff128d674b03fa5f34d561a0ac3b5f7da62c4c2017830a43cb3ec4656010a88a1af41e44dc76975afc1c9aa02932d0bd76754a2c78eb81096358d6616d73e46d3d94e2fc98e2dd8b0f991bb50718f4893eec74818fbe38aeb3085b3a7813c3047c58714a8269403b7719e2ede6e0c354d5a068f27f21dd56839f8a6c4187b395ecdb343c658dcd3c48d7722ae7bd589f4db76e23324b93813a13e6da55001fbe1fecac99984b3c61fa2e91bb5e226dd8179a7ac57a1de3d53e8374389cc55ec51112eb9f3ac836cec3a1b3754b38bc792cac632ff1c2871abd09d17d7e1813823165da1cf04aa4bdd75176262749205e57288ebe519557e5a0516a61215773463dc1a2e239caf3ea7c56f3d267ff3d910579a3dd7d43f77190b07ef85884a63017dfbb34cc5a765272b7aa86ac5c5d3c24688927e001153b52159e2848f30c19c5ae08abba4c6c1417159fc03030d0cc755d0fc4c939ad2a9dd4d5547f7996890456fdba3f1f5bbb2ac3bb63fef66139932e8ec81d866ca456edaece1a5c6d459eff5a77af99cd3da8498024426ecd8cc08dccc97daede1bf9699aa8e7b0557a9ef03e4c8db3eb9170b3bb484309300da08f75c8c54ab10ce95dccaee725a8653d6c8e1377dd78466fd8154e2291c088d50eb29f344508b50ff734529d4a2e51075721c64974acc82689dc49a4f475416c0bbd3c50ad112ff0fc102496eb1a31114206333a4b67fc4e0c2fe40801d3c21df6772fe2719b94c5d3ac7b317abeffa77b563987f9ac14634ecdf1f71abd950a68c7b25e99ad3010d9d86467d133c8db9d71c553aaf7ae1746167e6e38427d0558ffedbd72538fffca3ac2c4468ecb2701e5db4272f820df08a38809967cc0f17f12047af3495561b6961edaee1b891a92339b8e9079bac75d4b48d9b9d2fa7976c88d339aa17e6848ac992ae2c7675cbad59760957a32ae82b6ca6c0cd3a7a900fac88b1c9173686a226c386639255a199ac53c95a7996dc70f56c5a84a0bc00cbe5aa0b2cd640fadece76eac1e4707b288a71f2d564fb0074fe2aa82341728934680ed2eb1719a7a6d5a0ba7460da65cac1bfd7b1070bc5b67ed7fc1e916d31ee319c15f9c8351430964917e7b54d1678cf245c8953261cd32aec92c6eca0c8728e033c715612277e2c799b0602bbccc0eb28097889ea6c2bbe03cd2e6162cb170d69c0eed04c8eb25f7625878a7b93aee6fe6b50b6908e57111fbb66a3d76165aa563bd75da7c7823e3058a518bb775e0e5ee5d7b72f86c93dc65978b929d1f7c240425e0f8df209c4d4382aeb8c9b3797aa5a068527f6c113fa9334f5e1bd27d3fcec9a6d5b13440dcdb5dbac9ff15d9da2f815fffd061fff2f1a4c43b0123873776d099c008e199e5843fda35ed8846e3fe42e5184ea14736cb6536e984642707eef2bbc63403db10165099feddda3b8165fb5cc3f909301b395c904d9dec217b6db6bad6c292d612beeae2fbe4321a8a4132be4a2f4373691e77bdc07a6611048bf0818b7ccd3ea38d01d251fcf1b59449ccb6f97e9d6f30a9245529b361a746b296ac61af5d07f3ad0082e4878e5a8852c215ad1e2f237180e4242c3c3a63619d6e4f39cf6a540164595d9d942a6d5aac5e0387a6652a604b37c1a31ed86e9ce80f07f1baefb706e90d8d0613ad0861fe316a9707237e2ad8d607b0fe499c8bf303264e9ecc284995e6ba6a5afcd778aa650b646f16d677e141862e867c8f3f08c1e0102e9c94fb8e12bedf29526ec389160b9cd1629b26649fa04e0bcf37effa55fa3774116478fc9e30a710303738595d0e125aab3e08ba91e01d1c4a343999380a84db9bf7e299a621598ef6175bec510677f8991b0f774fb96d2aeeaee20a88ede50dce871eb3ff8431267518cd868ca7f1028f0fe5e2ae556db533dd7c74967055dbde1f670874034a8d9915356462d338733ea7573daf11b32ba6e1521b8b9b496eeb338577c425df74a1f6bdc165993fc02af7e80f062ce003dd1494785f7b0bb977e082ad9c2fcff877c03ccdd355253721879fd711c11accec660d7cbaff23405d861c58fd893adb39ae53bd69678beaa24d26114173437f40762675d5d127b760da4943ec06c5453b4607d60d066f3fab5984874fd411ddc0049bd12db9d497586501f68acb56358a6aecde39e341370285463f9d3df435bf72985328758b336b9a60abe5629bdbc322a31e5d73ad2d38d2299100a12e58ced171d227fcf24d3088c98d9fea218b8779cf623a381fadbdf811be73a60d8d9575671455971bf499d7f9c4add2467282c28fbf667f459169c3449947a244ec41a5da2a441f0031b369c82e983ebfd5c507844033eb07f1dc31f401571a3d22bb23846b6136acc1f7d294f8a718f98e22fe1a5f91a660de7963f1090f51fb8d1dfa00958a8dd7070d985a571b1e5b75d58145bea41eb28638776cf4b50dfded0219363e3f0da38d7f4b52d3af388b661acccaf4b47a01e1f99b0af03edf3eafbe9de690cf64174c37a61eb5e0441aaf310cb3b6c7562b847f769356b3126c96d23f8bfd3794511d3b474da3b4b7c0c8b0ad2993446ccb7a4071df2dc940c4e85b6242644ff0a95412c30447c24c0171a0f6ca96149adb5131bbcca4dfe7974ee25e6e0ddd7bdcb2deddcf97a5d20d9e1975186b976ff9d58e3a63be2c751bc9d5fd3b6d1e50fc566966492f84ddd455c097bb0e3c2709c32385c5b626f5200b24b3bf6375e043368d477259ff70904dc6d57a6f8bdffa8f4c6c961f923c2192339a16725841d1347b277b8c77acf7f6f39631cd363f7e6e82d729fcb6afda81a2be5badf3b47a1b283f5a7151e6d7607c22d6a6e47f96d9b416b67475179fa0d195294cede1424f74e7aaa9a1256cd9302e2321a793c48a3385600f6ccab41551e17b50800ae6c5a63a34d3d6bef7beb993eaf55031e197ebfcce4a9fa29f486cd32ea551385df317786383bd3255ccb30061d924c8c2d8b15a6e001b993c5a734cdc06701146540d94edbe533dcab1fd51507373ee52c17186e534feb17ed8e0272f1976218c227f24c9c66e9745a45b7d430f00d250a75b369245b4f8c0235349996effea2bb5c698ff36bc6a65148e0e8a24792a6049794c6adef39ee3517889004253637b841cff20f1507a6bf32286569fb49ea3c8a94dd4065520a3aad301378dfb7c6d8b64b28bb006353ffaae5be6bccfcf312e00397704bca9786d81aed3397eed33938874176393ec913bec32099ecfb58dc8a53bfe5fe04c3d19ab9b8f3bb1e5ffb935e7f1d2b8d9bb3b028f7bff80771f74019ba0648d72f7494f67e501bc45bc5f59c250618760ec2b040db87dc75173861da571d4b8326e3726dcf36f41b99d4331cee10b995e72164650e05220db90316ce0922373dce405fe9c37f4e7b4b1c788dada6b5ea04fac0affcb04b6345d0fdb7ed52de884cc9a2b168b0e9f2354b7be2144de363745c0c9c678e2712e92e1bb134c2ca96612d4bc3a5ac13d1811f818941ba84136c93fa0e13fe2d9ac5fe9cd2576d3da96174766dc64cc604d750fba4fd3a787ae3ba82eeee3b210bf9d47760775264172311ddf90c28c1c1fbce87cd249ab4e4a7c8cac0fa9a48ba147b94df9d4c2f8039b4a54113e463884585bb185da1e088f4ab9177fd12d822dff4ac910cf444e65a8c7b8111383f5e4c287f4ae6524458b935d0208105dd4683c4c6b40e9c54449c989809faf91103a3690aa8347dba30ff62f246bda757a11db1591d5d93352b776bb2891bb398f5b08ebad65b289696f1610baa135923a92e5f577a8d669ad0c1828e01d44a8ba9ca38a03f367cde15d1b32240d0f5e2f1efec70eead74e4e1248ad8a8f39f9b4c7bf937521fa52b512f8d4f38ce83ba3896d6d9d96660037cbcdbcafeca57b329ec15da81191ea6adfc87b03fccfe0c301c68782657db613c47fa881ddec681aa01c99e45d7c98d9eb11a61606242e18d59ede0a125ba52dc7250247da8651506d654a458c37cb9bb0c749552f32726241c6c2ecf819ea00a975da3807b367006ee7ca2ade99b8bf9d3e87154eba7d858d623e52c7b27ac77d7f1367c96c5003a81b47808dc0f06b5d80b91470569c999d0d67838126451d982452173d6eb57b4006a92d52398bf09fd2b593875fede46ec3e8bbbbe022fa6e0d88fb1ca5e88884a1ad0c0f13e70ae5e86475527a525cea1615e174c7cf76831c31152c57ec799c370725ff50e9616e23cb13e101c5082f0625217da05e16c6ae04986202759bb93fa1c796f44809d73f10a7f7d842dbe69d90402d0cf01d9b2d3a4cad5b3c34ff7854412d3d1ba1fd7ba17519f39a70b8ac5107bf66f208fafb19eb459c0ab7b3bf47f20db81d5eee2db4ecdd7945f85a277e191ad683f57d3f8cfcc8aba267a4d868d388ca904a410f91ef55a62666073742236f0379a0c0d716b8a39af3148988f18715e6f797dee179349241e08b42a515eda5807b3e7ff1ed66f6a8ab13a866db4717dd734f15712fa2820d28589725709b24606fd5b410da9344767155684d11fc223e55b53adc322794e736636a8a820d375c0958b5fd0ab7056a1e03cca33670322bc724d8e7fe53d049b729efb9b29151b101e70970a9e7d2d9b83adf159f0c6ed67d09fef6d8b64bcb68609eee6d7226a070cd15ffefbfe88d20b6063472b91ccc139ca115ff0336a76e6b9b215afcef6624610e8941812a132266eb7dfcd8b5afbb3d63603926a94e3b99a7e192a7b7e3e7d1815c16b3365aea58cbf221ac33ae48959bdcea155eae1533b48aaead38abc9ac751ee6abab36a4d1142f778e556dbc8c50639debc45cfa70d2583c10822e2c1dca15caae5a9ff5ba55f43ddc75d226fb011ac212654f17813574f3435c3e26245b41b24d753abaff639086c38819e5e3b3623be7e589d7a87f1522990338ef4a9582e36154af22597db580ef8684f07e302300ca1b02d0c8101b3b5b038eb906e8c5e5c271062c8221418c1bebca7d9cf1a31bce5e339fb42ce29bc8152e28b84c309f24f1675874add80bbb824267f3f1b04ea2cb2218b995e7b3391a22f25aa54fb4d239d20628a7f7f3f697a22e23445ab5cb1161547c83d82341f47cffaa4528f91c105de7924b68a41e9d2389612b9547e103d32fbbb8ffc6750d7c233e15e55638e9c359366b121a3b764c14f316f47d066f7f19332f1d589deaf64f1b137f1536b4bac0bef2f8e4ae5d229d9e6440769ec6b09a859e7a7afe815e72d62db386c5b5cec70ea7045bc77446389ba539c8f27b904962194f21c5a3c6ec81f7255a5fbd2bf9bd8dd8aaa50bb06823b03422271741c1c281c59505a7901af5ddddcb457122cc3ab60236d3b46dbe70eac01ca2a01fe7c85cea079fb4160129d8bef664d9d4005d8cbffa8371179a34fe30cf696d8856bf51ef74739fd4ed681aa4955759833e9c951705b1aa01c8f860779eabd2dbc819b27961bfa22b898b642f6584895a377dd4c81d5936637f0ba4e3bd06a787c4699f1316e8903b76ecf1d12f614da60fec7ec2c543d18c19280334dd66c9dbc6c109fca9cb7f1545f1e98296288c58c4036c6bf959144d1bff2fff29b544d17370da88a9b6c1431b667335f3f8fea0427510e62633ba2cf2f6be4e70b7ce3c9bdbdcfc0714976690ba87ab56208d2f20d68c8eb726a8c9d283698b317b17ea1a62f2e15b7591f0b78c3d662eb11f1638ec514b0ff1e2c9e9363f7fffe06741ab4cbbcdb8226f5dfea9be4ffd01bc93333dd388633b37e3f7560ebe06a8717685d6e8517794c7a0c758a7fa9dec79e6e398f4d6e8497c58bcb055b0d1b8552d9bdd92874dd3c8382d0ff1a8c6e97333b74345d4fb85d71ed564581d34acd8fb3550991ef4adf3a64d17bbc74b17b9692fd16870f7489de83357a7bb038ad50522aabcc333903060ed255e084f60ab87ba44924f3f5bdf14b6a9f6f258052250e88f7b7541a5d995478013a7fe40d21ce03d039f0f16c974847c94e168c5bed98fd340548c7681567c7bf9b24d8e9bdb75e290ac2106aced3ca64ad7df9d726056c8ffb23586e7a200013f3e7077ad5d39236fb732150788ef64ae3a95d8cd43640231faa15d1ad4b4cf6ddc95acc036d3f6152a65b7fc34a6a2802617a3a82a3b0a0e40c37ccfdf4b8a66f5a023509d1817ea9449c5e04f2c07e97766fe9fbb2a9e7f9bffdbaff2902eed85c3b33203624f743373a44fa537bd292cf1748a829147573e6e4c579ad0fd1dd5a7854986a11a6713568f2e360094c83e5a12a42124ceb54cd872ce3e63680b8ebc9553f14a5256629ca4b3226835b00efdb318dfcf015f038687ebb01056be6df86ba361a8792fd455206ec60146a6c7966b254ec5e7843d77b31644f7b749d88baab5df58cfd1c7b925bceaa64c7c84505a7d6cfe2dbb70ba6ca6517829a0b57e4a22c53fc3824371eef136ef6b3111ea2891da87415fef0b6215998be77c0894919e45ed9add772c7ad69d0acef3fd5a9e20b73def3abf59b6644ba05a34fa6f677500c466fb59f3ea651533a20d3b1eedb1c67863ffb378e9bc9251d104c75960f21d96d072ec0be5ae6a7526300c536546195b7ceacf5f1987646977d8d9a14e5e51866bacfe050989a8add69b6d9537fe62d4353ee6d81f86d68fc68b99ef846a281f7a78d4dd6ce054052bad3c3acdc01a1e37eaf179ab5acc0ad5d7d138dc0f590f9b17f1c03f2a3376d843d708564a5c70e1840d433d6b13851064a518051365ee50c713ead2a686187673c7f8fc6009c46faab82ac2a11f2e6df5ea34c71c71bac1d5174e371cdc01c329633fed80433343fc5bacdc151a0dc48e331125511c476e0f7c9c6f711064716aeb6932c752f4191d2fbdf7241200da64c70e03848d2da5d171b899be30c3482213440fb48523d6409","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
