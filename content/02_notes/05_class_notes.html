<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"136987b4d430f5c399025022f3a377e6572a025df724fb8a46869e78d946f8ce9d57eeaf9198181da397af03c9bdd3b96118a2ac90d89518bff9db25d78781157594e06bdd539c8a250644b51b46c0868a4479e8b7accf3edd5481bb511a1e52965d5c600837c9a9e99027531b84710d8daff9bf04d22e259336041cd892187a130c6f70d5766aff7c481d61c5d0aaba861583c1e227b8c15db2171ea922553e739319860c63888cb29b50cc47c03a850935071d3bb5c35faf7866fc5e8d8f8a0d0976083a6df66dea570fa21810f71b5a677463602c3ae66d3e66a8e0315a4d9691c269519c71b1f1ce148a71842488ed6bb2ec2a2f1ed7e11e5b18e1cd31115a1ce1f5420f2cb627bc48c610977e52e3135602937392ef36c6c5098c6da1790371092bd0e30e1a2c6a646c9e637ecb24c8bacfd083e081666d60a54c916c54574fb57522f86ed5184d76283e619cfc8d6686562b92137c8dab2cad5740b468c8d31600ef29db43c2bcb10194fc67bf80678c5204b308b1c4b1eea6c73c852c001dc467609bd456f91e1cd6acb298a2dc0e430c8081093694797cd1d5e6f665a9f30e48c1928adab0835d2c4fc4c08593f9d9b384111c543d20cf00d3c313a9977c3b39561bebda05f15c16fd5833311306491c28de42dd44e106003633db59ce450a2dbcd60ab8c92ce3f2f56ccc258db158d7d0936bc72d0232dd8406231a4aa1377a28ee806c60c0f7d1ad10ced1dfadf4b49333f658f810d3b63ea534e0d5bb739ae0d43b8fff194a7dd250323be73473fca9df8de10c9328c0857f933be77617db7962d5f22aac1429e684cd0db2a8daa719be1e22d20a0bf44d86f97fcc511b10b99ab4c1f998142ccada9f0d0a5b10fb54d345949be8e0383544700a04a9e9fd4f4685285e384501297ff521b3d0aa6e2b95af8832e8ba77570dadcfd2079fab78f89968eedae28e22b3cf83b576ef2aca7ceb91e5943f34bbd19dc1859b007e4a096aef0196a105b2ed5506a40bbadda31ed18df8e9dc9c10ff35f4e971618f96d01a68d29077274737f108ba32800055475a5380a83186ef19d973e3de9e69e9df70a62100c8c00cebd7a61cad4a083179847913eae60779650be4e8ee024d411431c43161e6a27cd2ccb362e2d38b6b9ac05326bd8d430ea3d53983cd4bdb181e1da34f77986504bfe6461269a800548de9853bde69491ffe529394521e19a3dbee38f3ef0072e49a2d9edbc0ac0efbff89dc98269302f958d3ef6772b5e51de5c73085f750c63303ba51b2a089d0cc9315f7cccf85ab6470a449d00f08a9649f77c017019f819da0f33dd96aafdbd418691788161921fee74c93d2c94e674c5930198a973ee96191e4ca791586b3c880a03b3c6fe9ebfd50854b65f22496926fc6dfde5221b34f8452fbb3c5b7b2cc820711ceec4d8bad0bf8401c25c63a0e4ef4ed0344e5f3cf24c9f279da4780814538d3a19fbf3cf55fa27dd8ddaaf25cbdd49826f55160ee6f60636ee32998f1abf50c74a2b49d8bf5ef16a2b8c3b010e7059e6cb7d0e63e6c1b7c9eca10772a4a03e904454333ac278a3801b34502596d1a9c615dc7b3fd3ce30bfab6062e2514873d84bc005338076dc264deb762d0e0e5a8d8df9b50739c7a2a550a9dc230bb761e1779808144b9b24a0d75e1c16b7a487497f68f846350d11ffff9a9fd7f2064f898f765dbd6203a689522e69dc3e7938b268c149e2bfbcc90b86e66b597d7d0095012f8fa15272383343ca22af029065ad6029eee3860312fbc0d6c3fd3cc64d3f542d189fda53c4acbd0b554e7cc464133ef3edc46178dcee441bb9aebf198feb28fb0f7c9c96d5114ddfa5f5cdf8c1ee7ae5e6d642e28632c03107a83223830568b44723d31daa8d7e6aa1eef9f9a34e740f7bf71381d7994b9e7c19dc2a62aee3c3295c0ebac1c184f64057ab17b6d9e5b8e596a5dc724ee45e2ee21ef836f4adf399b96c6da1abb125c4690137b2e861c62a7b9991b9c302f7d66aa554663655116aa7af20f9a82ec42ffb88a2bb66886b5f5de3961d18ae093f77d8664deb5d564b5270e11b8c35a43db16f498727dff75effc94c66093ffa0a782f96f6f88d22f243152b07fafbb8fb695230729ce0fe7677b87ece0154c1546a9fd0622790468f150e06a0060a4f69efbfd5472af3e8772cb183e3f571e5172f9e68442dc97389cf1f63edb37d2b683b3886248f02524479c1bcc1c55f13f9d02f9e221e4b318d7ab713571259d75e7cda14d6938eaa7c0fa869ac90cd7ded6841f5fa35d525fec9644e6f66d4b9f30e5c736f8fa5f2d7af6db20c8e03043ac4e175892dbfd9f4ebabc7ea14d71d054daac33f8879e6badca39d92f70a473fe55062d0622e1d384af6c0c96e48a610e5c7a6f1656489bceef380f2a3a46a059e963ebfb4a67cdb6d741b80e9962d6336f879a8f83afd0b325c77263e180d0d2861be598da7cc509c46e017b4726a8b9c37e67f1d1abcaef4a703d5e9a664f711b9fba1b1f392a59a73ba2ca354d603d94fc44afc961cddccdf14b4481cf057e03b39f3af6b6fa0010d0b1420fab1673d23e8d4dfecc916ea5c3600565fb5719a3b3f5a4a02076565bb4f0f672401f4cc4caac2bfeeb8b334f82d7b89b263c18da83fdc1db8866a812513cbf8999a8d7b8a00bcf3eb15c5390e7d1e1072d7df18ff1fdf97730005a70e2f218badb0c51ac23d9a2e6db197ab7c75d5f9f41cf81927fa6586bb771f7a4b89212439e191c9d6242a67b4e20a7a0e4fe5ec84104715b26da471ba097bd8e796c49ec8fa9b505d82297c58a83e3e2a0ce3fa9704503137cc40427abcdbae1472f80bf44fa4ae1087ce5976a60c9d18891876df17dedb0cd81d1ac5bed3f1e9487d91eb91a653f2da287201522481043a6f99bf67b7e8480b987170c8f9572611daf6faea09ddd87169988e27c73aa9dd76026bb9bbfd5207846e1143cafd1f5c17e19d97a405314e37482251356412e17078dd03bfc8c545a3f818e1cfb649b118e3603518aec54d22a9ba0a547b3e899a6334d03b86d3ba60f38bcfa09b401c839d6606e27676deba97ca542ff08d98dd031353c7a278462cc05b78df1b87e6aa133e148120beb13b5c5d9bf2532f3c5f93fd46223bee2d6638bf541d3f15ea2327ca64c89660d23a71c4fd5e82c0cbc54e94ff34a03f78c11126ec5a94656a581d27224e78c50d2e7642474176427ab8b2bb37c0c68d42750a9a636c78a1e490c011852829048318aa7e8f13c7a595069f06b064f6f0cab6d8c125f455749fcedb2096c826ad321819edcfe199a9f27c1d030f73b5b32a0799a50a710bf3bcdc336af617822d51654468f69d71278e0ab8319dececf4932b1bac3a25935c35b2ba7e0d76a28c97ab0986e5606eeea6d65f17aede12b7f02bcb67a391b53de6dff545c6e128e8a7bbfc8e49667ca73d8d66407a0c9bfda7b063ed57410dbff7b38aa9aad09694920df00153819b4da5881d617bea707a2450e6ec2063a4a92c30b189e89fc8bfb4e81759de6d54641a2b329128f227ac0fee88c687532495eeb814fcee834bff4e77f6cdda4daea95e02bddbea120b37422dea61cf728a6b2085e6a862e9a5629ff9958d5781a84faf63778fe595bfb1ea84ee159f7cbd9bf2340578bc8a8dac21c6a7c7a302550b54973a85714053f9d22a9ea71ffb22ec12602280148733b9e91cd8f4a0325bc0659e0cc6f7445890d1f5286b9a5326e39acce837fed3dd692767e9c6071245019e8f8c392694faffb0dfa3873d42c99b99e3dff5a45428f2005cc5109e09feae794d91b9db88cfa3572e654cfe14db4973dc50cd166d293be8ca28258115c99cc48c6c562614020be8e8399aa537628cfcc9f19f0d440a15e065c59888ecb921be0db27fc42abc14a73a190132dcbfb9d713213dc7bd12c992fe076db645c45f443710098d774d68dbd54cfdab0b7dcfb9da04dc1238f99182af5333f319b5d6830d265edceaf785fd5375dfdef10b6a01650ffae77f4e3f8d7381420205fc27f12f5d983b63c8c8e78d0edcf02da915478c8f479e591382a36da53d2d1bbcf4e34a8183c2f3ad2d1d61c8faeab73db8c35683814722fb9d9fda7c572282e3814cc137cd595b9c2e28be1ddb160ce1257cbb1152c7890325e63fbb2e9b1e8edf83f5e25ebc4b39e613e42e2b57be93596deaef61b9eb6a2506f5bdc38c3ad490b74842487a812eb848de5437d2918e24b251e0efcd382deadffcbecef19b71c9eec4d37cf0da4d9230357dad9161d4630052de846f743a567357e0f5845a31266845056c7ee217739c5e76e63bc1da6e3ebc733a18888bf07fb2659324f4869d02ea50ca1c5aa6f9b5937b8f797c3d869150c592217ad3dd579b31bf3a12ba544fc3a547bfb8eeb51cec417fdaa06aa8f386c00a67edd161cf782f6648d569e7cd530293cf11ed7e1b8df4223b023bba20c1c214ada177f52ffe673a909e6a52f3574508e9c16cac22c25584ed6dfcb8dfbc5cf4cb68d096193984b84c695340f2ded7cc828b7077383f48ad6390146fa346ad20d369030c515cb3c353d1e4ddeb4b1f769351469fa688cd4c175f877c54253f17b1027a09f271307ae1780092222ea9d99d330550c27067833bf3e6cac5741246811fa32190d38641009d9d9001edac626d00b784a2ebd56fa6e19378005f53005076bd57a051964cc27a946ae48195a880400204005b36ba3ba61db44b5e0d01846ed63babc9843ba5e82e5965592629e00c58f9ac173ee932688fa6c266b8ed8dc80c8d2bc9432a4bbc000f770a468392c390f98b4459628c110bd242cbcd29cdfe22163a6229bc3ca077a62b114f956f5b6bc2e030929028dd968f3b33e1840e94532ad020af873a9b922c6d4abdfd1ebe9ed8ef6b215929052c3ecc6f48f7b0cd8946cc7d1178538f501ba5be37eb726adea72687043b3e7143436be21a49e45e80a9c47950d96a9632922dbc1fd2996efe927abe5070e6e8c05aec5e1e15499977f25b76f8e6a035beb8b234e461c28e7eccb1d1e2488231571dc43dbf01016be163ba5ff97faa5782229e4db6ec4b25ae72939eaf75b30b01f3640bea9ecca240e5adcbc01ffae0ed611729cf274f5c28837a5a7e8cb8c2610eea3cd16eec1f2d8d116e3bbbc981eb375c937151624d684de835714f312084165be0e2b3de232a27986b6a9c90f58eb0c28f5f12dc7367c7dd82788813d1e37c30b082436c5065508480604120f93ce5a6c811b661c30790d107c0862e4fd4f49cc3c6416f6401f289d92088b35323011c342b4add6dea6e9398b3a88775e5b19bc0030f1f318fe8b80610360c5dbd41f93147fb9a2e63e8a6c7cf1a840c69d3f85574386b3284e9e375272b1ea040f86a3cb9a613eecaafeed4866341bef5270f6fee2984f28ca85f0929689a4473ec84471956f7b3550c62614b2c23378011de5c02956cdb802f3f2881f4f38a75a1daeafe532c612007c44a0e909f301e2d0b91dc8fc8fd9c342452f42f9f86e41f08dfdf78415ba62d4726564b2718a275206883c5f3550c21b1bcbb97476f477f3a17be1c68cf8214c022cbfc9e9f88c2ea1887b5a33179e1190019507963565f66695306fde87a4baf4465c6fc3ca169430568c58722a407332ab53ec9ea458cca682bf3c2f37853312f97ddaac8e2b3b7c08549e682ee42bf28f7accf0d47b2019d25e2d9a95c1a72466308bbb6c2e86d88903780404c4414291d2932a639677e58be7c22a64c2b45d5f047a757febe00df09779fcdeeda98e56d7cb63a883552b7198665b10a87be76f51a61c0c712d5cbdbb720e95b377d84305b14aa4a463aa2e26b6b325079872f6db878baabdc18ebaee7c7f82869d7e89da6ee925b780a31374242c35c0bfe74c4db66e6ba689739b585a1c3c6e02c05c31a7f5628bdfe05efc57fe231695f3cbd92e984fd48dc9cb07a7e47145c0f0b88d5a25440b9a2a8b19ee10be74e24b31e9b700eef412868f34d7673e18e9d44644a407ef78f02d769c0e6976ff6f781c1a726507070dc4fccbe9577cdb4048f043342cd36c8deb85cbde8f7e5c178da9efa480f9be4b7ff955d8880da284def6241ecf460476a03ef1b3c7a1648b982322e827862244a00d295b67a2cda2f641e0cb1aca5a3c4a8bafb8bcc9ecf4e0b93c9c0ce93eb774f7991c784020e56a7e417ab45f1bd1a1f5995a73c2293f48fa68166e66ac3988551ba66147b204bf27fca33f90fd4394b87d0785d839562a1816aadb698c7e10610914a79ac10d5df61b36278428ac516347f3a1cd5af33fb96d336490fd707ad3a5c0a94015a6de19231caf80b28562988859dcc5e1215cc2eba0e4094df486288df96c302d62aa620ed17c6293d547235b413fb2ff8141ccae667e1bec1952dae690c9733bab52ec4ebc093c876a6fbb5bc3089bf5aa842e397bac78c8d5bcdf5094a9f0abfe9d42681c29a2edc6f4f9c881a2bc189c660eb604608ec7679e471d4ae9cd17c7091002262d7d223e7603ae43a2266cd8f73823d9c41ae5167fc4594b6d795af6951c6562a9671934bd97b18087b8f6ae6d79338da10587bdbf0d8fe4843c90f4a953a15a54c7f13fb02e9c865de42ff1a7ac8e181f6dd81b962438aea072275343782210bedd0776a136d45ace7e301565638e2226dfc1067218162c6ff9090ffbc308fce05bc33153f8915483b149845e411bd69394b7dcd61de37233347e06e80a2166526a2e8e18ea14f6de6f83d132b7b7fe8e9c0fbdb25b04129a55636a9128c5b1999bfd351d8a7c39a3eb030225e7d922b3dc006c1da8b6a2faed30e98a7ac8f93e3af64e61405784745c40e06b381de09ea39bd571bb44836da3b805ddd2a58002e6a4d1a2e85f672b3e423aaa60cd2923d0cac603ffef30f1d76284de9dffec4fa294df873b96b3572fb432561bb4c8a28c5375cbce9f90f790f3901a0e3caa032bfa0d6e24da51ee491626582df36b715f58e57b8f28da4adeb4fb543840f1ee0c0230dbbb9d69fe756c7530e1b0bf15c66676e6e32730758cb2b8ac72cfb1a7ebbe532d4217b38c18e94ea4b15c10c21092f48e84b6b558bb32bafce461666e6bf76d0b064a1701a28a5a5a932b11b437279eea1e44d2a3d52e233eaef2281ec2a1f1736c686406c74e0f11031dcfb48ebfd0eedee7784eef87c32484fbb0690f38336a2a82fd00a4c7f3acc39ed8c94c8b32dcb12e993a8d47b65fe6663fcd9bcb6d9c8ddfa235815d9bf53432210d87ccfcb369a06a789e85695f0b63f07cdaeff3723c1022f13bbc8d0fae7db123ece3a3c940a0b2dcd40b10c0937e2ef7246f2bf161cd53e93c174f8c0bd08272bce286a5daef492e2770c87c0a7be53bf8e8dbd57f299b75797501ef0829ef2bb4c941193166ee50779a2ac59373cb4a3e59844b375679334c206896646fe229cf5d5c0dd44ea1415a246f92f374ee1b7f7fcbf74fa3e2ef1328ecda3df53001235da3ad59e25797c92cc7e80f2d9ac7af7f814ed3b9e6d5cbf065f356fbddb0d178bd845e854de866a08888c83350011c3541d1b84ad250ef64ab8700f8310e64f3ab51553088b45e186be1837db8cd8579c7b0f08b9a522716dec6dc7f5ead5d5f3464d6b6e72362dc79e1b2be9ed7e235bfa3c97ae012a37772cc3163ad442e97e23dc6cd89091e6ba2ad38e1801fa0b5fbd249206ce45b4ed6213c4d7fb09af3eaf035d3802e76f086a1443e2c1434e9331daae230f8abac4f6b9d61f5e064f8b15fa1173c40fd11c06ce9f8a83790127185d1ea4d8316f581af51677ff34ab99f2b144b00ec0c1e5ac7a8297a27e7b3d6aa93073be00ec4bcfa7ed5ef203b621e1d17a06f128dc9f6583d252eebb20f88bc0a5d14400d3b854063af63c792c95576e6c4cfa0bfe740f9809830b6eeaa0f71998a661a900ea84b7152127e6ee7fa138ba508b713288eb9875a23cd9fb4b8d5ecbc9d5143df44db1d4c1b2f69ac239a24107136512843d57fa680e0a7a134833cb7a8db1cecedfdcde1d0af9a920cf61a902150000df9b8231cf8f082e79f88ff1d22adfe541b253b431671d56ddc8787175af87c9776fc84acda597b8f5904e19dcfa972aef5195de9fd4b89d815bdf9c4a53dd200e2626a0f77a148bb29d876e83aab17c6a1e3eea8cd09d8faaf0b6caa36c6af62b7c081dddd4c78eb718e1f10bce967b7eaf2f0bd9e2fef5fb9cf8a5f7143bc889f3990350cb7c65ee647e33c651af5cd0b138952a302950fb32cf61bcf78f05fdf906c09ff96d3ee42395f7c5ff36427916ac02f51ba17bb27e24a7c4f5742eb4239feefd1604c8ab7ac08b0ff4a7ad7febae2bbf0cc0f28640fcaffa9911b75f3fe2e9939f6dbbecf0624485aa6b8676ba94c6474a24de730ff8dff7d439e80449d08d58227ce24d52069d74ce604ef6140eef93f503dd10ef2731b6067743bd32eb323389c505d3386781e4508ecf6b645392966830490e9b5fa135e9a5d443371b207563406a6108931af7ff2d9848c91c636aeb0b35b5019be4a1e838b96444d196cc9b0dca403ca17359b6bf8505ad796ae70a1a2c954a5a99fed5c6fa37e27a89d52fa013ee2cfc8f4c5fa47bac244b1181022476386774a98de587bfc8fbf87d42d07359656322c2ceeb545fdff7feb11d05ac1b5b70d2f2421eca4312682edbee612b888616642afc9b7a3fb308bc03cd9fdcc3c04c332d3b205100fd17895794f9c37eb1fcb6e4e06d32f8838ffa0b6bbefa3bf1516f9df8b8a987532e15f16bdee4a20c58ba214051a2f38d5ac6f06e0a44f216f13f495935797e4f64509a1f7b00f1cb7bd8a51665313e74a105b022b24470290a48417660b1780fde15f4ac45c1d1e62788b23d6670e798ec9476f26bebd7aff05d9b3fc67207fcac911fc6266519cb05747da8ea830e20e62991ba94886837d500d2e10c08bf4b72ca5234ee4d00f3ea5307c746cf44e278bdf56e50c2fb41edd8d57234e0dadd0b6ebe6fee1d6f09d58ec021fa05d12717b023b2baa5c6671b27b4afe05d10ac72c0569166aa65739e031be7735fa13691422c4b444498cd24921fdd501cdf793d3f88110d416439d42ef89b88cdfb6bc0669d7cca2f22f5415f0e218146c74d38ac064ba9706752564c3be7688173dae024fea071edcb9422f8fac3c29bf261493e88091bed8741c14e2e4647b708e60aea9fb3d579d113c97fe8c85957ed4239513185c1100aa96e1cce504b10ffed88e2b315457c776b8cb86588cca2a1673f7c18a9792717ad023f3f6d52a5469b137f32bffddfea5fb48d0e6045073e09250bf9e3273a1c3303ab8a5bdf788dde32722a436e2c49f8606e40c7a6c215171534bd56ece8a6ae89ffde71c1611de9fe70366994abc4cd16ed070bfa996f60150fd3fbe7c401d2c72dd9e7d07a896b71830d2ca6b70d400875146f562d7c21666a511e6b77c333d2d393fea79a646046655aa70b57bb51d26980c6e64733a0291870adbeb9dcd2eb1a34d723924fa8a8c745e8919705b979745621d7cdbf32a0d1649576b724a1abdf8e9b7578b15f1320e66efead88d4b04e183c7504904e16bcc75a2daa175e9aaf122808b52d62f8e356a6993f87a6ca6bc98c39df430aa7149bd940dde19aa5a94b6437fee0c9831e5d49d33efd87dca3d2e9a61f40d11ad35e796c1b5ad8d22c513e202c6cade9d2dacf6cae04fc6bfab4a16b72340931b6add426f154e025818f6cd3bcb9de93473f24706bd85cd9515bb383c78ebb94fa02f3f5ea3b0b62b675745b6756d01d6b383215ef5bb1fbbc17feaf7246acfb889e82f35e2ab3fd70b19636240b397acd67565c67e3dd156e7c230abe7af93cc8d9e918cd93ca02b45a416c1a1ea2e4d81172f7931e79dfe28ed3d6dac06e270cd3fa306334e37ce4eca5ffc9733d33bac8f9630f9a76ad096e8ec6cf3e85e195ba51fafa95bf4972e970b542b3ddb1c1553bce5371bdf180cc50829df9abb57025c51ee25aeb450dbac090f809dac47b5435df49d535d50f7d2066f8baaced4c2f44793efa4e14487356dbfc71745f79b6d7f47d089848fa12731ced4d7da84afd33fc25cf6a2831505c9937cf487af2e0ef688b8dd56e39c5eefe2f25518b1f0d8a6c279c1fd77e9473af494ab7a7e3f1061da492b9cc3c1bb4f793bdb2789c0f2e171e4e9cd7fe6ebeb4f12774ae5c59da36cb2ce2b51ad5a586f21e3c7ae459ba26b55d4b7d6898cf5fd4db38b0d86f11bf3422851d60a1fd5188dd8a0d4902707295cc963097cd268915ed8cc77f53fed8b49e737bbca092421fc135960bf1d86ae44a5e251e838dee63f989c73627692e663ff9cc52b8068085a63e0993d13db5534bf4bdac020e8bdd7e9fd355c0dfc31c515607343025d3d0be40ebfb77c9c17928cc1679712679a50fa41757b0c75612b34b269ab097b9810f4fdc3d8f1d9c56de7e6abb8d6d2406be7dd65627061ee5154a2cf6a60335ad2a409933368f811fe3fbeeb3e82484ea685a6b166efbe11d543ce385d33c0bcd9131e0c4254001bbe508e04abc656b2eab0ea3a121ab51374a119e6fcb216374744d60b73e458c2b764fa6c9079f8fd113449fb15120a362d2199929883e85744800839b2e78e766921c6d6754fb3c0a9d0b31f81d6e1ed28800047d64cf866160646342176f50ed914158edfe44343744e29bea62dea18ec59b2bb7612dfb8107bfedb6f369fb9e5ec24392eb2b0ce362936d6a79cec30e41a7bde3db4f4b412089916e18f653f0443b36d081c4fb65b1c2aa3783b45fe889886bf0de7c350e6ff8872298b2cd6d9a12187b3d6325e661627adefe621d008c9df39dbdf7d05dc65005a05eedf43f57ad2a4034432614388cddad51e74e3baac4e2cf32f5aaf2749412f2d8043e29ce25a89aa81585073ca5377547620585ac84ccb87f57b8f05395186d6609a37d0461b93d19bfaf9273d0777f3454114b8f8991cc3669adfc559bd474f86680b54ad20e679100837d30ac89fc8eef9a269a99f3ada02be20b740d37ba21ae1ea20bd33d579f0ef9194e9659b00824d5efe5e994faa54d4692d9bb51b705bd829e17d7063d3db4a787a955c0dff232b303af645ef2374725f0279c465de664129d84645d568f0efc9a961d46f2fef7099d537daa76f8dfc0d958f90a293a52303bf8fd3bf106932cb2f6d135016c2c2f11f942412dbdbd6d7ebc13d6b90b331bdb74f3fde74132786f372a0ba4a54ac2af2bc53eb10735bc1b6b74db5e2a86d8763b03a95f5c049919e0dcfd9e1db0babd15a8ddafcfb692224e7ffee08a040df184467531088dc4e7e9dff609c6321003ab00e4b2102210dfe78ef0be101643360e8ec68894f97ac5ab7087aa680511c3cbfd765e74658691c81529c5ba812c23f2a1eecaa7a21bfc36d993ab717da022390b92ad7415d11a29b0610a92ba6f8cff216aa472d0753ba7f4ed0b82d351506c3575d9c82b231488aa5251b3067375e2c967605093c76a9d4af0bbba16931aee7fc6424bc6d414a3d4c5e1abd17804a661f58c0dcc2c64ccd67961a54ddc492b1ae23339c31c2ae2d9bbe4cd1cd20fdf62a9c6b62737c14e7ba9bf5e9ead6214a4ef20a251b2d9605cff1a1b795eb1e0b4dc71a539f71a9674f5b9a39a2c1d413a2b3e3fe3c8481233db10e8b916a5a433dee04ccfd9743d92a38d87c50640e9320990225a8aaaea056ef05c6e0d0ff52349ecdccac6c3e5e474d60c7aefb9d6d4ac34443e6f76ace8924efa8c6c37f1afc72cc6ff9aff5cb2369e42aecaeaba45d7d6da78d98457424f79954fc82d7b44af5f74e08a78030bc81ee01ff7eae8b92a2d853e014ced0877c890b7f580eae644c90a0c999b8153c8da24c92eac94337c9511c16b5eaa18e5a727b0985e019df59d1018f7d6b4ee463b2bc6b84c49a81268f5eccaca1087e11ac9894ccb1f9fd5d090c7b503a12442f0a69fb8e80b3b77e2d81d3e5a10f6f36ffd8a81b9174df190b1fd5ffd6160c9823ae94f46c2fee427a7cb5603d76beae44ad10806aebae0c76c27908a20fc514ee3d374bac56655714aeb35082e8fee3f67ec678d989ac6d49adf595339e776f179f0bb18feee17445ad965e9394a6df250797d8fedacbeca2392b92cefc4f6baafc5e4e59fb9c25dae44fc00fa015bb7fe20e2a39d3e68b491e62f91c5ebf5db05dd20358609bfe1b936ca3f6b6146aa580718004b3cc38dc5bbf26deb8141b8a8a0823e7e896878203eb569289712477eb379e3d15d2084466a5018d256c7596c34d76403552e33bdcea4f3eb09b992a835e7ccb15a788cafa5e0b7867979823175b20ada1e8fce8d8bfa2b5d3df25e49c36e3ec62218e83114cdf20d90fa19b707f93530912417aea1408bd4b7d2c0182ed6c79e32ee93411d1f3585df0905848f6b98e4dc112774afdf063d7877eb311da8f4c034d78d059e8d2eaa23fc6b9e9ac7fac9886020efb963687933c5661c509ebb561f337d15993bd7e8e37a5a6c850b4918f388a6a7205ed56cf4d064cf9048a3b6b69cdb15f213df482a81af3e864d8d1f5ee1eff2eee026c98b2b9458e89656d8a527613470010bbff87cacfe3eae511161692bb5ab2e9f76a5f2c6c88aa6a3e5aa27657baba27ccc99bc6e6f0062bbb3be871447f66e1bf827b96b678ae0692da0a00b81638b8779287da0a7555e1e60b97eb0dc099f26c2a1893a48aea35ef8fd75bcfe675251f460b3eb664e6dd1d1f73c839a050f3708bf3efc3a48ed225b0bb11506ace1a6003290876dbde42d1af7a7257ff77b49985718642b5cbbbc9c6b92bbcf6565eb2d5a35ef3935f1562487748f217d16cfbb616c839d9017ed6b614ccf791481d2c3713d378d5b3e78386e7f057a5b19ef87c717c584623086a6e1a8441b8ec1336b9862dc99e75ae9c3e04fe3ba49d1cd1c99ebfc8d43b14ceb17d21c4840b3fe82c26157f7442b257f19f77e2dec8a7314c9500c497e62bbbc7c7e666f3dab8f773ac2f69c5608a3d1e2319e9c60dff526feec0e6eb1328685255cf4cfee8a6ee2eb3482a5bba3a7be67bf2f192fa512c0be326e5bf8746e3f05c5156bd7c8f65fc950b9b57987fce21ae5091bb5d525f05508d7059eb9201939ffd0274f8ba311985f5e680e3ee62d77c87cf43dae1932ab7d254f24e6b090b76857c4fd129ac9ad6527f2c5094707ea1f407f7c522038155593de738a90725b066c1e57d75092025b542fb3f0a5c144d0b15b6a9ce258dd95035f73dc03833d3b060e43eb08fb70d73261dde252f46ef7e08bfa7c97c343e8e4f10168ebdcfb43806bbbcb66b9b7674bfdee1801383da4cd67cd518487a3314bb0050ac68fb7ff4cf4b2293affd1df02e1ea7aec2c0ed95e3df6a74381b1f121e3cae9cde6f73bfb1dcd999fa4aef14ca18ca0f559eb04d100ce07033bbc4b2205c8b6d3a117fe602eddfd1ed09170465c42227759728a6a43610cd5050128ac9c20a5fca30fad39e2d213f572bd3cef8f73d834d300abc29c5129a7a52fca3886e847ed02684cc71ca8a8bf06116ce7bc08505f4a7fdb8c0e1100d4d11dbdd0a73f823e1133597ffe5ea81493f436b2f609d1bd8706fbc1e7fc56b5ec372e47e13177c9a133453084d266a3a27d5709fda685162736069a9872fa290946e901ede1a158c6c5681542d272770a403f725a7d40fa9c0a0c4bc4c796adf3d28429dea4a561d20837d0475dd1dfc9058a459c426239e23eeca279884ece0244448dd7b7c55fda34a9610ea3c958bda73d23260976ac163ca10ecf918448a4db0ab46ad8f851b944a9e6ce03a4b82ad9e44222af7d232da0e5a4fd30c541d224eb234a9c32801d185ce3dc10135676bdea8355655f140804638652e68f3e18eb5eb3399ebf62352fe5a322693d20d9422ffe071d2b03edfd45be88a900487d039fa2ab5a605d248dd93fc8d936536de909d8332902f1bfb917947e8bdd86b4d7290cbe612ae3d8438423a9e032ef5e5d1cb57fb5e9736173527f93884cc36028f7068c4333f5d3c9282cca0554a9f950bc11d73a2d39251285feb5f6f547e94f71b901e9a93a05c40c76bfff2b69a0ea6c6f86f2d1f92b39e05b54973eb9f9624c90763870ecde592f78f6f63e6be1e04a2e26a1f469451899f26a005f6be6178bbc24ec4b1db1cbf085de0bab6652e12d8483868de34e996f4991bfc8cae266dfc80923be9cd005c67b47e5adef80334336926636616557a2e096d19006aca5e44f9a6196f4950b6c73e337b793a3cd0bdcee3788d3513900af06d2953e1dd00601de6fb655cc600a2071ca13534bee99487874f85c23f24b8939d678166cda4a942c75a9fdb50c996855386daa1185957789728cfa98743e1261d387163400c0957e7e417620d4bf5c96cfc7820aa0d0cb3e9e195ddeb316b77c85729b40566275cab1e6bab337733f43382076816067eddd88d057cc2531cc87dc6b58b2afdcb8849f7e34b0195ff0233359670cf49a340ef4a1403686867855f3d74a12576fd2ca725b0fd584f4bc24c106f886441148a802177bf086c90290bfb7a5f2ca45921e8bcbfea80a4d3edfc22a451d0b01bc0ba5a9a577cbaf38786313986615627b86f9da3576cc02420c4a4ac3fef48338680626043c7cfe295b505c17afc32f0f22eb40e9e8924ae0fa3986de2da8e103907f07d509cc5183b18b4bee080e39ac42db7ea332eecc87c184fdb3e2454604a4783fa614d1ac6f8ff8f61c2f3b662c10f560114736ff108c8acc7e006014f7ceca655575e8470c85882d13295e6b60b59e9e0bae37ad4380ef803a71eededf09e04e17badedc55968ffb8401c35c1e7534c0aaa957b3321e329d4eb85c4972bd91ce0e1361d63e02ed4a28ce6f657d77071903e2643781f5e3de21225379a47cce8fb992d35ddcdfe6f70d32fcd954294423eaea40b2796a3b924b9a2d500affad085c9e6c0538b686f0839aad3d37f7446fc78f2ab410c11d01f0a843c994000a132aba251a22beb1d2e4b230dfc12bfa89cbf7dcca43e4106e71e736f4704acf25ccf8953a5aa79c3f38069a428c48edec285ccfa4e07d040854ea4d08c2546da6ef2728dda5afb0e87cc38baaf8904d538d558a0d815269a1ea88c403a3982accbb709d74a8665e7e359f03508f982534e00dcfde35726d0f527ee20e51b2c4e9beb7976957c983def67478b7a6df7e351ccd6bf074bffad396b595f960971d0ffa1e9be114562564a481fc5c91daf215a5b4a7c674983b6908dc60c987f50efeb553692e3b3acd1497acbb6774a6a206447127e55bbf90129f2c1e60ae483f9620378812d58fa749be08d1127d198aa00f0f1e1478020c98ffb832ddbe7ae630c81c0e0ccbec76f2713a51ee778f1d946cbe7eb393a86a2adbbe23dbad743d8c3185cde95b4211bf455c62cbc3a5c47e271572b0df844f608b048b037fe8c2cb93d79fd6662411259fa002cd9cbc820a3889d98321e02b74e5e3a1cd964fb5065811e5404ed099e739eefaa17717bbda99d03367826b8b6d3a14dfb2554b719e61284e27baa6189b26b0850b883542baeeead8ecd803440354c336a340fa2bc3121af4a918eb81025d803d00f335bc8d7936a710345ddb03ca5d286d83aace44bb958d19b340d2aa8436c3b943c25712e97287cd3ee553203e8d50aa3ec1e5403b091083eb72e5493b47d9d652bb7be2e1896389a6ebfbee4069c66ceaf43568dd32767a14422a4207ad3eb54634c942a575041b8552491730e9e4b7920fdecde7ceb88a5bef03c7d97e921833286e6988b69e3f396e9fdadf5c2efae9c2e1245df0558bd46400a79e2f0833bf8d5eea04dc0109f68cb21a0c24f60f94e3584ecd02c4bcbcda61e609567d0ae2914df843e4148a1b9161dab74b00321dc3c4e3bd45231b71ab7a9132e08ef5aa9e93088d77acd36db1d03a7fd41d886f194169179f906b48a68e7e194e78edb7bce13bff552799357bcc0369e1f258c1e98080f0e9d1f26d33d18ee58f807b2032c1ba097c2779bc4c60ad310bfbf57f375a7ee971e742660c40a4d5184fd56e72b2c5b65987a189685eeebcb374c36ea906bca090f25ac7c502152d70439fad5013102a68e17097e467cdcbb0b84332e1c49601dbdc7dd5897ef6fb33120a19cd95539ad0a00dd5b6a119c86e4788ed28f75c08af97350a2474b8d3675b823fe2a9993d14e8339404c3667325195b3cc29558b4602cc17ff38d17ee18c6f10ab3515c60727eead9e9f5bd91e383ca042df6f4d9d124ef30be0d2df2896f45fb522a1314837ea3493dae202ff4b71d16462ed18bdd221fd040e9750087da28639a35f1bc0576d8fcb7024b9d981d9d728f8c164182c4a3d833ca82a45cc4fbf78bfd9abd8d59986c23a311ec6299f0e39be3d652c1bfc7eb0d1b07246b8bd9d512fc705f022cd9c8872a763c19ac009f14939d03628f6c5016a3436b8f97ef139f8fc4032c0367a97ed1b32b12b510036e60467bc63da643084c749e4f76ec36f18c1ae837309fb9fde306c4567e99d5adae24fe88293754f53bc59e91337eabeb324293d6942c4fc6b66e27caab96a4edc9aaa231871b3dfc3fb6492940e95079947294c3fc8219b909dab4b29e584fcd5fc0b04f67660730f4d1e9268d7d868cc5719abaa945c50559fb6f5b3f90e76ef407b5d2e7312b05253fd9cb849198d81fc6b99cf0e61ef5788dd8f769f676e5c13128a8d6fbc7f3254d1e636e6c8b14d71564adaf7a96931f14a9caa10a50422d7b0b42e69c554fe1fced4a1eb8df3f52707b552c35c9b14fad9ed07a07f8429ddb9855c084eaed7030f050a13aae61eb465c77f5d306716c2dccf249d93c61dabe61eacf172df95dc33fb60887800920ba9337083645e5b006752018f22744e07ba81801c2da275f70d5f1e08b80af5d6f72bc44e8de809cdc4f5257d8691f38adc55425a979353c78fcbdba3fc547db173e2df5e0ad463e025ba7833349b70e5869b7450935e0d02708141ca7cb402ce7bb9e6694e0a37b954cdef1d7d612c8a334855f1e9d8c08b7c6ef9027a9178eac3ac6155ce9cb0f722de3d24ca7ee3ee09d54730c437049a99a9a09bfd20100af4369344106f964f11ce009dd5cddbcd3bb7213ee3f33568e48aa83dc9f6e57708dcb942c6c8b1541c475ca2ce97803538b8fdfed39ece9b0aad0bfd21b5f20a2c104fd0f530d39efbc305bb14b07ea10779efc5ff9c927619d96d31b0f3712f766974bb97dc8a006c8e202d8905a9c070810506e79034342ba6c8ec07f7a7e9942f5e8565578ef6a8fef751631858469c188dbf47fdd6c759a725a910d74a034cc3132cc1295b7332de8eb9e5a5c5af899286723029d3d0d06f69dba96fa0aa33cc713c4ae48b60dab78737f10d4520b5b637eadce809ef846cb039925f74dad190531535d3aa8714d9c13743c866be6ad5e4e488dc4832ff7be082eecd08ca9c9bd610d86a9aeddfec70dd82eb5691872cac0dfe27b8955aca612e382e268b50943cdc9d137e8053d617a7112bcd00227ea0fed4ddda3ccb6534205b6c241703c4df849ae95b07ee4b3885a8940bfc5d45940c703a8477e43b28aa2c15e8e539a4a4385db702f21bd687c56fd63bf5f3f962003d9076a96f06d977fd9203b55aa1fd559cd4b3fa72d43e690fb9bd598e5411e38f08e1443696dc77037409e0c196647204561f73319d4724b6469c6aca66b0124b7f3b3d8c5f719542530f0f206c0d050072903e01611f2310c8ca25cda76b7a0ee4bd6206feae7ac41e041b8806e06bd8a3f0ce29aee7261f1f1608f65e5f5c4b9473ff3b0eca80bb0c78d50374ddad8334c82ff7d370b7bc066e7a1c1994059881c3677ed6112b0b716468d8a78cc71b2b3a025ddbd8ff97244b191230dd4ab7d4b192be5eb26fd4330c0eb6b8faeceaa792caaa3ea9e0280a31f2a11e47f5a948526c07eb440c3fbb048fba4293e993e9d57fca0586df7d6f2b98a0039e105a278cb871ad860d7f40d42ea00698cd0ec3d5cd3fc26ccdb492820f39f6b7d0572d7c01439d5fd3aab1e4f46c0a88e133ba68c1a9003ded1f301d0a6e8d4e96396e09ba899feb5f1c05e29a82c29dc627c5157a806913c8077c7f8c88ab1516ee7e3160a8cd06707a97084a05051ba22ec1a16c0d68e0efd5e424007acdbb5fb4a2bf159111b06d402b2cd61e35b11bcd1c6c5764515ea0542e505b55fb06a44a44e7fd012dd0b8d2f397589f25a481428ab64434bf693de603a524ae61c9d8b7ecd631957a49f8ec19b36b8a621205a16ba502ce31706f17869e472be086d2022e38798d85e6054408ac923321fb63434e65df8208fe456f75be5842b0ac45c1dc1799e0f006754306cd3171356c908132f6980b0465497a4ea8456a1e82c8da08410a97885aaaa04b4cbe2ca7672b91a04eaf2368bd14bb44a1f797e47f8b62005a37a0c938f9eb935d9a3fc3c02f736f1ad45ed64c95776961782cdb2aa4a43dd1c18b8b111630148ce50d273b043d0eb792e1cb3f2e3453d45a008e73c8efd1126564e3c906c0e1bd2cd09bdc91eedff8356c1ea5a650a5f14dce630c87328fe5bbe3f0ebb82761d7c60ed9d75dea2fb6d0f935717b426b754730b79bf0ef4e84d22fe389b035b0b700ad5d0436185810d2e6f7b35e68067f4652e1f30b4d9629f38ff9cc20b8b821e797968bf2143b3b01dd40bc80e27090d172079fb2330b151a75105d523650460391ac9b567bc7d4b6a93b062ee914e5f2d592aea73c68e354330a550ae6535e16d342bd539fbb9bbfdf1c82736516315cbe7dd562fa1e6df7e31f4d3f1ce6ff1ec5095b3a66a646d716a9ddf61ddeb4f9f52a9cf52f418b30758c4667f5d0055c3b76ba6f61f7c93b0fc8896290edc486a054a437e15e91a5e124c54c2471b7abaf1f6e3e7f34028abb0150e7e5bbce34477e51c81c24f9315a16f8f92efa2a7757f37a7597e73e3b25e5a531777c39595eef85a68a41a58d50d66f07743c8ee3851f303e440fe0f5c30e5a9e8ca7ea5c78b591eae3d52e5320ed77c389dfe8bbce33f6c13b6af0c4a452e9c69d56671510d6f2845e8656a5132db4f77cdff683b5d2a487b0345ad92040c2991cd9123492d090ab73703f7d315ba688ca03c26759fe763d64b3f80f097dc4286e61bcd45baf7e88491581409c7335723c4f29ae0dbb621e5e5942bf7a7b153dc5781bbb799175d9cbbb6a881e0b95a3d8cd64651ff00f554d03099ce229805f19aca8955682dc1d859b875783fb5fc3cb55039aed2f4a87ad763dd1f81fcd8f638c0e6afe57afe58eeb98954cee752447c980ed9e905939ba14d71392f7425b89b7d399c0e4e3b12c6befecaab599c147101a3aa41baf6c40f98537f661ec9a325b9de05d14560bef17b205085b1f6cc1f64d59761a5d04e86316ab975fae4cfadb71697cc0480d0f26e1f4e084ca4d4e06bae7a68a475e4a82a6a4c30cb79516e98f1e1e95b08fc35bbda70ba10a86c3ffcbe885af5c1f071584a2739febb215168399db92977eee289a93d207c6f283275143883281604aaa6011ec488bb628b3c78e56e91b8bf05f73499e8f514a1a9f7df31a4eff69d8a1e68c3682b536064c23b8f23dac86e62ca7b608a2c80ba09aca1415784114d414b502088ac405af1ef6211e7130ce75bb285a7ec5d2aa43f8740690c4f2f8f6a52427878c928b1bff4d2ba10b8b10ea3f9b5044e568dfcf0c94c96e578ec2d5df39e224ada2c6eac8ed066dac2039dc1620ddbc868d232c9d9b13763f0e443dfd93548cef268f68b45c77a720a6b569dc18c5bd066822b8eae979a8e298e201830a9a756a946df948510c5b40bd2499554b4576aeb48e61e44bf7e92f026936c8a0ec42b93c3c188002b059e8f3589f1e7c07ca11332d8d70506ec700b86340d2b7f28128b4402493969b2a24548b89da95cb0180c1da6435fb63052fa3505b735124700bd3162f62e9c9fb4970e7844ad87654e623dc28b74c21695548f304dbf2c061dc804bd26baeab0b3c3aae8347bc1fb5e596338ddff0bdad163e7126a73d9d049a71cab87b0e8dd57e49e886581cddcb2eda8459df4e2e73837f64dfe8cadf2f8a962ab2328ee1546841418aa012da4dc809dbd2f356648f21eb928130883a281adc6da11957fe2f1ad386ae39df5806d94e097ad4cfd1a390b14a782fe985e66439527ca4eab102e0e8281292b500925ea202efe9dad08f39772708a6fcf9a97aa99f8e51d8a8bc9023daaeb43d5a591d583b4ce5e13e3252d1cf0fa1363f42adb5879e71c4888d6277873ec42dce94e7d8d209dd5aa2233fcc4a704acb4dfb7c17720e84a98b0d6914cc0bfb4cf28d05f4d5be34859d007fe524f4c58d24f9f69c96041ba4fa3fa9b24386e7f99fe976f951884a5c880f6e3dfb1abd48bec11ef6630cc74afb1a920dae12396890a6f978db6f6f3a17b19ec8db1e486a9bc7bae68b289e6eaac46b6afcb5de935c9a9238c5f9afdd7f04c637b0ec802590d2feef6ad838765790a130eca2f33ccd68c28201d4d463395ae56557a730eef4da8021d24f234bbd04a2d2502d9ff1f35cf1bb1f82f3bcabe0740e5d28498d5025ed96f8d0d14c2b9af1513fe2f974159e12359f702e097be067abda08f1375ae54b03727307fa7008d4d0537cfb936e625e1efc6f99bd9fc5a65b2f70bbe8a2e411dc1006293f7a8ea10769454e32c6ef961d7a5c9d2a99084ff6b0ae540ce8406ecd7485ad028ea2535625ae90049837e0aa5587a1f527198164765dafb10ffd6f41ed862cbb131d54c9e6f252ecc258fd83914809bffb6bf050f3c0169bf37ffe9d924fef8694edec6c1a669e3d22938c9bccb4127879367777ee73764f0a31cb639520e2d08e2c1f9aac9a320921453638e4847acaf33c40820db9854df549d8d8de9a2a8b33aa86d68bf9be7009ca3897c6a0512aa56776eaa7f4974c438e406b58cfca70135416fa2574168769515950a701e08e337068ed4a5b8b7f367db4425d4d7546d87d40d941ae1a0d95955e592f86418a7bebd481a361bf60d0bbbf537237afa930493709493233e66d4d20a01214d4ebc78f0c28926c53f68c0d353e2640384a1ac00db5b414779cb7cd1c3b1b0d296d19a18c5d7a695be4c309cbf558e5347036e5293e5dc0f9edb201dddefcbbdfd7b844cfba342e293125ff7b5461f4dde974299c443f4e5f4eafe8e1ea35c6f1313bf57b70bc4fe19852637feb8a719cb02ed4a7baf1be804f817a9c51fb670b9cbc352162cf9cc949e0f03ea7fe555356c673a4d8ef8cd726e64e288c85d54eb5436bb6cade46058ccec96d485e673e4174ae251a73cdaff140c7eb54efa8238cee680cfb1a4f9bfc516f99b1a263211b008db4fa6610481f53d7efb5119446aa7d160eb76f3124ab7b6ef35781b704e2f3e73f71cadb75","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
