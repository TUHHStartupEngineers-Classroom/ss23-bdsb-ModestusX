<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"762cb5fa1619277cf325a29dd45659cc9cb7bb53f8a24be4d5cd6af741d02f7d51425db2df873fd95f8fc4b1565a57e017852a65e8bdecf106fc12c0a808062ef11586b3f9b53eccdc17df51d93a9228883865e89d3e210441fa41abfd78f5e47a90d407d6adaf19b6d35fbf431f35113d07a98c919ca7c505e4a3cd5782646cdbd11804de044440dfe55d4f85a9b95a180031e12f2e51c1aaadfd0f475c32077adeee126eec1c1a89c01f024d127c33ed1095f63491307ffe23ff78954eb1c2bf8ba83bbd6727bc1875b783f9915b12c0e35e36f118d2d333a2296e63fe148bb327be16de8cce1c0467743c9bda163802a4932bd4983a5d0034e03aaaa10f5e69ee745b937ebb293b70966d6412e41565884c9d973f7115c71e6f91db9ae38aa0bab8fb9149124f53ca4491baf87acb4cc842d844ef62598921c407fe69f6eb92b0eb13005193cacd8b849d80dfd1f32b41acfee2cbd16b098ac0ce5b60d3ab2629039305f556e0a2cd6d7c27439fd4df3ef533f40aa866cf8d3d6764f5c0c4a7dde6b100c327cfc2589cc928115d9c2cb553c4a3f7cb8d35c8ed45064879dd2889b9838ddaafa55e593f99b957a7e4b46e027c7dbcbd8358b6b7edc12109c8f56be480ba6b891f6d0c9cd72322129c094ecadaef1bf6d620b0e1242c916d5e5583ae29aa05b72c8a46c69dd3cc529022e06bda0c6b9301d3cdffe082fc917add55e6c58353a0e65b46130b90cfd255f0d635763ada9776381e89f81448bfb33f108d9a5298fd2d0417f693f78445961491300aa3eb6c5a0aa48a452a268ef69af7a378b535b99069e0c92f7193ae563fd03732182effedc1ec279bbe24eaf50f7f639f1c97f2c4df75318d434cad9c0228ed7d939cff6c530dfbef80ba0d60210d5e6b7d6351512911c3d376f47ff83de7684c31d5a183a97fbfb44c6d8d4ce254a1796ce9bf1a1c3e7cc9d096848af9b816ab3e942bc4c7bf7cf115f4d98eff68c5d4142672d62efe06c9bbdbff9aca2759d8953fb9714cfa78d25d7ce9bc5f5d305a0c154700fb1b32bd6b9a4056fa4d4b8887511db5b1f452f812afa12069e919211c35757e98165c00daee5a393cafa974dc9131048ae8447098ff1e9b924debb56c45044936deb6f9d8899dc19072974e56ca5c98529cf77265d13ea415b5a3b305ed5007732cab1f3bf709e7d2113f2945e0045c2efccb17c42efb9ed5ea20cb4c485b87d494c39f9d05ab042bbdceb92ad154c9c7089e1bcb18af828b324cd3673ca43c3b6e64dbadc06a0ba3888818dc16cf4c26bd655c634f18d4985f886e41f41308db172f1cc2d1f6589fa3b8f74273822f2ad5da0e104c032c995813c4cd06e70d7d19b1173e8b7b0d61ee4308ee7794c103094ca4315ae912be25fe2fa018bb4adea99639f475f970de8134fdbd2ff2b2a5b10de3212e482e41efd4e3ed4cb32109f3c9851d6a7784644897cbf8878f22379ba1591465659846482c686aeb2be1e0be332500a87654976a6ac81b0e64d49fb75b076ad57cf6c637f29e289bb3125738c3df02507dbe16b7d8cbc34245bff55ca4712b7e158c5c5ff57e75715d58baab63d9039e73522309d4615f70ac23f2691793216a9402f87c658816c1cbdc937680d8e744d1799a4da1b24ca12ee0a598320c8712e29e6c5d95507dc6e75dd9a112a5baf8f7269a00479946a3263b87f8b48d2da7e8d6b725180e644b5e65ca1e04917a4232eebc1132a055fd0676a39bb98ce5b267e20863fe9205a5a7375083d49462a6bb46c8bd9895c7de9447ff3508f8a3a711e834e1c5abc449d001a4d6af3c96730f9b20e4c36a5635778813bf342650a7130e244d0c509b60e61dcd4c39b15a619bb4d37da91832e91465843058505139e80dec93dc7d27315b20b6209929a5a00cb84bad9437c18db2519eae709a2ecb2d7a755928271ea703880daaa1e702a02501b5bdbfb975e5523d78285e90d6af603d27b66aa1a9aadaf3517d20049145835d062882c5505b656440a1a0d4b0bdf67d8e9e4ece6190a78e4a1ab5834ea13df9979c5a22d5448bb2d896890eb75830de4eef8e54f511dd4d40843ce7363475409ffa107623e4869bb11ebbd9e7ccb55424c2a24902f2b855681a4cbd259575b5a906d65c91edeac13faae082a6598ad7a5576ad7658ab5c90c9db83bba2bc114af8725c8c35ced11a36fee4e89416485d371a2eb5270bb0fd789263c9e39b24ea96fe6d946e38868fbc0d9d1369bc6d9ff50008bafdf04a8db154d7c2ead1cdf7556ae10fdddc13cb906f16681b90f9600641a3f4d0808a29da34f78879fa2c067c0d5894282085529f21f655cabadef5b2f7cf9bd36ec2b93861f0d461a6cdd1941ad1d7061b0cf83c85f1aa7859f10a6c7a8585b8d6386b26358065c2447bf9d13f212a1e209ffaf0f43c2c982fa53da201eb27f500372433689eb26a0f6d7f95088b74b4084c7fbd2c2ca1deaf7a512f2beb1e112c399856a164f62cc0ba227b3c3093c69793b0683b76f2ba75fbac7c5f59fd88bc8bd60918bdfceac322e6f427330d923110954563e444c231bebfa78567ec6fbc9356f35447e0de67686caf16d8604094d26d253f3744c272b0fd0e9c9d36a39748082ef427e65cf9f5b8d0ef17f1eaa88251787acdf399b5045f4a8b49ecc94756933f7858b6fc4071a1961ec6064eb5d7c91a634a5cfc675fd0aad1e339a5a826ff2e9e74b6ab9436e3f5ceb3a21cc9a4413b39901a4ab27a42b826755be615e40e7e03573f706671dcafee0294892b8d9bb92f0e36a2eebdf17c8261eeb88bf863643b5fc59887d4f31598aa07c0b7765cccdaa0b5e07491a5867dfc91855691351ff1db747621c7aa6f78c037113df661979793809feeb947ec6cf9fcd49d48a34e6f9cf8ee8cd1614e057b79f4bc9975b9ea967155fe7fc8aae663c498bdda9f85178f90a7b265594898d4c7e32b4ed0711beebe0ec6c082bdcdacf3677727681ca6d321521ac0c271537b08a58b532168d71984a8198fd62aa160806ab0e575775c8eae87d4270313670b7c895409e15d54c60f2ef8b32c81f3acc9b650f3d42c8e39cf9d17f50fd89f20518f622f142baab2e280ea74417d1d571dcdc0755e7c35477f4a616fb6a1c85a0684e868f3142784a76edb18d9e8d2af5b2ff42fb933796964c73826857dc261b38f66f7690e83e3fedf19e6651658502ae1fd4dcdfef6dd8ec13eb1e7c727062a0b51bbed83c669fb743e681b7881db633baa8b9e530c167f6afc17fd694bd3a90d0c19216402e6b319bc81e18f93108e08c4d9e60223234e28cbbbd2813c7de98371012f90ea2802f807b09bb676909293418e4a3daeae27a2582761a751c8dadca995f1206325dbd2570a8cf6c2cb1279acffca53775311b4a9a359377b67d37e900445cb191fe2b967eee6921b8ce454191d95017502c55a4bf34272d519fe424a97cc739b0ff1ea978342e7b0ee58cfd2aff924e10f0dabdcaaa7b471911a3e6a35ad733d00f3a07a581e51f0df1520d77a349020a863ae36c3e83c129fbe9508bd0c56a181bc03c10a40cc43e7a4b080e73f9a34d5ead972e5023bee0894590fdfa2d6343cebb452b15132469d6708eb8630f10e10fc6ddf9ffea8a41ee9d9294a586ac9cd54c7d026511a1bb2cff702401ab089a25e59d27b217a9fd171598b5a3357797d487bba7a79de3773571d9491b940b64766ce3dc42848702eb70b152ed2c2cb3da22741979bed1cbb7f05a0660557abc9bbc33ffb7be3bc6f961f8d360aeb76577eaadb40e57654c14a1676489fc399fc973e6ddab7e17094d02407c2b64cd002df121106ea4f3808d262b509ad9c985281a35d4c0f59de88c21591ad0e5cca1a9a3d9a02a5bdb4e708157a94d9947eeb74dc3de0e4049d395a0960a5351dc449fa8b95b8fe98896c78c8c3e2a4fa199cfc33ca224880f177c8b73b7cf145074572176b8adcfd489d8dedcd4af539453b506010de5ffddb7ff2e3927fcf24161c19f670f4990ecad4b44c6f787cd051254628c8530740ea7ab81c60b168f081e27eaace45415e4a59a07382e4f3d07f8608d74b05775733fc585a52a3a4ed8d65562d11b27e91f8f847e48e6a3ed796c73ce31f1b767e211c95ad5bafc3c88d42dd11b90173393e703dad857dca4aa0e6bc85b16f40147587881612142732cf16f5f1a38119619a21401446db7a2d889eb6dea01f199c484b8b62f647eaf295443879217885fff303d7f8c45af4ad809613acf3bfed094101e9b8aa8d188285e69b8fb27d01d50b8f500dc02180389800f5c2bdc76876b870741dfc6517c4c548c64b30c2635db726fe75ff60597feb19e32e7223b8b87c08231c86373955cc2cf4754733de74e2424fa0543c640705cd8aca43800b9c15585d139cc60b282e390d7c2473e54d94316b364227bf9d2b78e4225e3f5a44ddfb4ebfd70858a58ff6a1a26e4e34bbfbd0ace14b530df9bc85302a0e62c4be512b56a686c830d3d469be03362df4dd05865a7edd9095205c21f3fdaacc28fa766517082a22f9a8704697072e96a06f43374e164343befed76ce1218aa213d0dea217d1632027a64e37da3789842467622cbc482c3bbca7580f763e0ca6c175c5fe6351c2343c3b93781db758f629592cb5ac3340d355094b56f1f269524856b06488b685260e54cc60b977571ae57884053f5212128fcef08ddd5875695d0510f0ce28260aaae1f72613e8f732fcebd9dfea07d9d6ec8d4fe46bbaa0dfe855482952b88c197d0b73e455adda20767232c57f318456a6c1fc5a041dc3daa6a848f9e8b1b9cb0ba19237d6eb3664b71f87dc3822b721dc14c054bcf71a474a126310ea4d50df91a467c19b96fa943dc0e24e5afb5abbcf43d4b173a0d98126dca87c245d890b81b411d8eff93cf172901b7db2a4e15c91ce991aed9c8171a439986775775fe7b624a2f510354081a2715b27ffb23712820765df58672c48f05062a7bf192463328da98e2243472ab227a57b79d075dffd7089b32f288f005e00907cc7a3c263081610f28fecddb63a7714e9db2de833edd047ba24f0efc485b3313cee945bbc3e5c6dbc184b1d8db3d65c7267ced28c818fa1d3b81346d50258645fa88870891130dbca258a766352334bc8e0de30d0ea199d6f0aa067ad0e01aea1fb6bfc460aaaba8768f7545ce48a45dcfd97383be1c1636b8d5fe81396117c4a2366b32e5a60c6c30e7e6e188b59b118f7e664125d527538d1311a178726426cf82785715963fa041d93d36334deda519623c954acfc63869df8fd72feb3a3458c39ce942d403cf35e0ddc670efbf03513191911fb15d20524a2c424cb4eb9e9274bda62189237d54de429ea7fe5a20dad3aee76c0ab162a0345944257ff687f1bd9c23cb281a66995b5042721103de78feaf4801febe5ccadd3d7ebb901c3f885f8b871771e9d91debe4323b6f1d931d2afbcddf9ef91b8d5066a18eb4e976d21379433e03bdfd6bcd9dc8df22e53ac548af2b1082e4eb52bd6c8aad6c41f59d0a95493290ff623ed1a4e28e20b4e187f2696f10d434d1683eb906ce59fd9fe0c07136a7850e86ac17708e4b62b736dc16a1e1d10e3e17ff207b4cfb350ae6ef182cbfe7e41cb10879224f5ec107a2feebb8543d1fa15b12f5608d9aa12a8c208a2753ba7ab13c667eced46b4dd7c8cbe8f5e6fd17e74a591959e3bcb03fd6df514cb0a2668b41db94842c0ef67ddcad71e0c42be6273283a45df5e19dae199367a1a3cc9f77c680542b731e04da200deb78d0ab5010e76c813c467e82854d7d9a33b9257942509703f4c14dafbc48755fb2c1989778c7d31f1f7e51c75788a66af53f964ceb11881d67cb4efc1405bd8dbd9b982721763ebd74733f125499ca3289de2c30a8ca49a3b24c3cc5d5852a67c365902df8d2026fe6c6f6a001f331bd5eab5064e45bf61f70361866961fcf11705f01391a4ec0f529adff20aa52273f97d0ec2d7cd49efa322a60129d55406cd0301c2c34b42aa094bb94ad9f7df608304e2dd19d98bdbe3dd7654e1310f4af3a9f81e8185d6f3f062c707bb4fbc1f276494c13f9ad93c95ffc753f0d11ab9b5302e0e187dc29338ed96144cec9e0f710b902e6f8cd8893798c9a857a816384d355a20c722dbbc44a849103eddcaebf3df527d664c1f2cfae28b59615f72ff0b73a18aabe7760b09601269267c57ece0d7e42e16ecf93d68f5ca50e43da563acb7187a2772d919cd149d47747982d2e0d4553d916deb85b7e9cdf325ac52a04baf11bc66a4dd2003173029dbca59bf9d4116453fe3dbd73d428905fc2de9d618e07613b06cba92f4431d4a4b08feaa241853fc7826f6fb39ce3dbb1878fd5e172288c3f32f550c67bba6dbbe42bc3d10e70d2f04cad7a770ce7700ff97f652335e08db4281b517147ded538d3b5a44d09bb149fed26d898d22886ae1ac86e0b48a09e7dbec48f7e0e0088fb1264b42e3d24eeba100349e881974fe6e1153c6ec2c3aa921bdd81e5a623f27e0df0a394a29124579f1d2c4728540b02b54c1df2ff13e4d6374089870429bc60fe1ee831b3a7622e49fa734fd8092632a2fd63c1056e33f853416f3a90ba47a8a3da04f47ba2f5be02a2b5ade2bb4c4d92fcb9c9733a02513fb88fc6668696c82abada8fc5f59df582c86721e9ef795eb461f9a3433053df211232c89800915c7be1631117bedfbb7d70c2113cfa4e82f63aac5efd6372bb0406e04fcdfffe0775087f8550f9add80e7817689094aa840819cd3a8249e67b302a8c8e94b5581c4a58fdee6042f29ce0a3c67e2947997ff43cd73d62728413ef81822d064b2094ef378b9512e261ac87f76b8dc72da2fdcc06707c805e115239ced4c326e26188cd8024128ad53d25f6cdff6d8dd4c5a933768844c6d116af45b9b533a15d6a937951af1674a09b9aaaccb79432a81558a43feab74406a9324c7da85f6a6cdc8762ef48729afa6719cbe01d135274e4e300b519d0740e9cb41ecf4bc261356dde413e2dd4c5b3e947fccc7191cab1cd5d86c6a11ac6611b30b5205cdecdd29e9329a94406035f9d05901aed080e2700bd75e7e32bec7eca8ec2186b2523e419754c67dbefcb5ca01c327ba46605e0bd21ff616a3038b6bd789ae592673a478100df75c181ee5f0da8e78415b570055b9a426bb4c9bae7aefb7b028b1f45ae63c0dcbbd84c2df56a1e1d2888b7cb2ad99398bfb3ad8078f29af5013ebdf0defbd385147471a631a04e74c6c456f66c089a3c270cd8503d67f9107c9780b77cee6066a19f2ef30428655d0436bbc8c761e0153a157dc5eada630d6267f2a56f3250e66836caf4aa5e3beff5dd9bfff29552c182fefa520a0787227e842a54d2685e2c33eab211b71a140c5f9602f9c9b1de338e765437dd9fd63f3f4e8632ecd4bee3a7162225a9a4b422f1b34e0641f461ae8770e3bb0c41e12edb0dc03b4e5b896c1427823c119348d1dbf35ba50a50b392188e720b920d996718b9f998f1ddf5519859822f02d4480db604ddd2a59400560d2becf7a0d9d11ce21b6b243b214ae6309614e5d4192909ed8f09552e64478ecf0255a516e0540cb6e21a06106547dce96f18a146fa6dafb00d0a4ffbcadcad8592d12a7ba7e846fa7d7bfa1e6aeb528a5270451461ab02a2f2fd3e61208be1b04f5e7c5da73713142ec62e9b49f2a0336c99a9e39ce392351fcd88ba76b89b77bc5ee19e47327925d6d1271298e72af8fee5ed61fb7a62b2e9ec840e5c2fbc91bd7101e45b66480029fd3c5f41603b5a08b64dde939bb38300e1269f6d49cf627e3c9dad8caa2fa10098207b4d4b9ed273618323ae82460c79ec2828d464933cb32085394133364ab5566d3d8d2dbeeb712f24e416d9f8e4f13dbbad25615d4bd0973b2ba1512b4fced2f7236621e1756e735ea432a29bdf86ecc7b1f743fea94770bfa9dfcf60e0cf852b77af6cec7fac28825049ba9f7ca964c82c7bf6eba1fbaa9b32419ac85de410c1db1b8f7d8088e735b2fc77d233434486acbf4b4fa7cff515d8adc617152f5fe526c0d384ffc073dbdbb8daee3cad951c72024c64a5f18664ee2e67803e8402ebecf1e5fb47cadab43ccfedf9726341d088023612a33d48010be07ddf7c1a5c8d7cf12c824a651b61d78d98a6b3819f665b7847ea5704d0e7bf93315478dbb58c00fbb8195867fae0380ba45d3aa91ae03d0270dea47aca5f5e7f690f9164b602a68194cdf82dbbdb21b00aed787df407805ea52dbd2b890f7da7d8c7c7e6623f7c61914cf87d91b4a0d5aa4778e3993c20d554b247ea359d10bfc52d8abf8824ffef224c32772ac0984028b578d61342163741c93654509bf4c09e37e2b5129d363f287a965903d62df00aea446b351b5e728617c2ed4bef5abfe1555bef404d48dd6b67d938cc7641d30788a7604c1d9d939134da8efacedc87f2e947842a5f364ab4c6ff513732dd6a3ae1206e0421d44dc104352e8fb8c3f09da27924729361d5e3c387979344ecdaeab6fcc5a7580ff9e872f972b25db64c2eb6613f2f01c8a1dd28ba4637c926a357bf4a3f18d0130e82726a3614143714141ef85992bc240addc1ef40614088bde24f1776d120ed055e8fb54742adb265ea311d0217ce11ef647fa9fe537133c7eb89bec58bd2569dcab7f72505ccdf63031eeb950b0df9970f1519bcb63b648d3886c63a0befde86aead36423d844404530c44fa25f9c101373b2fa9196fdf6b92bcd7aa62efca79ff2b94022eaa22e04b18736e7c5d3e1eedf1eb96df7886342b50ac6c0ece0d993c02015e3c19815af72fb444b352c16c0179047fa2d7fe7c3028a41fd030f9dc80689900d86ca244cade512a93399c592640594d4abc43db81e6f4e1c1b14e012bd961e281e72c11dec0fe82a0233c3d6bddf31114a30143b91fac95bd11814bf1916e2de77c8f1e232006fa57a0ef53b55ed7a55223fc766a67d1dd321bf67f18e5e28b0f6de86a2ac88fd1ffc0696f52d1a960c4f50d739b398d0804d169180c99623da4bd9e34b2b46257bfde015009346b88e37f7be7138d6a9e7d0929dd12436d91766b5c292c6bb4d1e158f502f7247e0a481a2c2e02ef63add5a82ed82e2408274095b5a7da64a170e2979084ee0f71a419582fff7c43386ad98b05bbc08f11b1336a17faff72d055161554399ce2989de96568fa04d4fbcc35d4fa5418ecb3b774bf069cae861ce1ba9263271de36b39fd2f72f639388fe54075d7ff85518f6c5303e09f0686aafb0218eb8c88ce38a24538ff6d1b18cc32b7579795b1c62ef9996bccf7a53675570415195ef4771baba16c7eefc1b1af53abfe24e6df8498b27fe64149248de970cb5092a3470619d1bac0fb0ce56e7413b7a0137b893bde018e36582eca73175d1a3423d8e737c9783f206e1026e916c4d41c089b269a4f3e36768dd1b8bf2ed54cbaacbd40c0c205fae1b0a3f889615ef88f3277d84c9958ae092dcf472bf4526842b3c1d225038b1feb6e07e116fea5b545c24f10a4dcc5089e45208153e7cc646c237f6df8168e63a4f9d360d85da5fb1dbdd933187a0ee4f31214cb2427fc32f19921f748aff02b26f725d5755ece9aa9a49292d5ec0e4f8f9aaee86c98151ecfec87dfecb54cc723e9d61356f4a2b3e4d42e6f0edc89819ff39d587ee28a0c6e2b236e91472f012e5ad3e184cc6c26a28831767cdff2bf6dd6a1282b2089f21925eafca0a54595193896d17d39d7f3477d8d7de0116e4d373e234e54d6ea845f479e077ca5a1280ccdf79cd0068da3b5fe5d975c03727ca0108e1de123986ac7857bb12f5402b53ff8590b3510cbb560305c60f881db5353849a4f6d42100b85d3f67f38f8666f5b8162d400fa9c034c83d11d6f9da498450c1c1a6d440087151972b011c4a7048b188115d970c4895196659769cff46ee3f2d4e76ab9299edb835b2d576593ab130dc9aafa1d3dc1399bc3ad0a7cb3e8387a48c5b72ddcb966817b17552f26156f929480f9b0eacd18093c6aaa78ff3f5d506e6444e2e28c3013d991f44a9b280c2353d9097e281451c752a2766326f1f71247245bcaddce1e19111452d7567b8fd3da664d9fef3e1ecfe6f0cdd18ff84a7a0d1865dfeba671f1f474fcf0a5d26da7e726ec298f378b38fb4e0b34e2bacc57a58a87aa58b8a32cce4086865faa1b3f052d9db5bf82603fb508a1c4011416e55d5f62ef1cf35f408dcf2ab19a52ed0bb6f1569771fa49809c8f5842720b4b32eb94e241818183d349f6c7e6ef601852d4e322aed178db6deabf61ce12649fb619a7d43fdc922863ac982ed2beef784be486a1cbb5f31fa20cff0b808316c4b120512fafb958e305c5bc60d53bd6c4688225ea6bc3c7cf07efa30be4d34f77cec94d400e39edf2ee3477527e8d1882a1bcbf1b8b351209c7789306beca04c310ff8df2bc4475230dea522133d045779c62f7629841141529785b53a916ccc13d6353db8518212405f3e32c9c0c10a241b4dd3295c13acef7ca95aee2ad2311c67d87921b3c4bb390d711933cacc457c74c3bc9f7a6ec4cadf4f155623302b991da3db2a64071256345ebeb029e3fffb69e51073bbb8c3b29758614c3927803e25eea3a6404fccf768a33651f916ad15ccc65694325d249e1e11962276a47f12e932e30ef0bc1002e4ee802b161a92b4f8cfe2ee5be8b63f8e4085f2b87c309c394d78e08427e724d6b498e128188d9fd37a02c0aa0b8ddc4a51782fd5490b585b4c68e351b430d61accd512b28eabbee5985e5c447a25b2a96b8b3591fb9f6507c14f07fc241fc8f2c45305982f90679d7113960f79c09064a34d711422fe73a875351f953c15dad3f0d5d62abc9f75d7cc6e1ee94b90e664362beffa1363aabac690fea28f5636b19a2faa4a1a44046a32e903887702172014e67e205ca30076544756fccece423104ff9ff48cd3e51dff3e0e559e23b2eb7da4505f10f603bcd84a74e5e20c9d7be2c6000dd97e9bc894f51ed9425ce141dd4e874219dfdd49174f8d49dd221bbb53edc8b66270ddf7f3443a5ec6f798c10b47250624d119b74b5a3e284527a07962a9aadf9034fb17c158ce0c3463ea39450f8f4255f7f60411b27b4d2bda1bcf0f93d5fb4b2b69fae1de92927de4a268c1c831de145a5780027d8756e8147d5f5ed96659c739d61a036925e1ccbf943e709477e8930182dd0995b977ea871f47c3522da12e32e16dd772044600c489a8990368b141060d57546a8cf81bd283d28af08b4d297f1f1410a195738bd820eefe95e7853d4900ba22fdf93e0ee71151da1a1ca6de73e1051fc3fc5ec977aabece436ded92fd16b4d352aeaa894384a072acc3048e6952f95b05dea5d2444592c3e20e819fc9011459a4d2c7b682abff0ac9ecc4ff70f04217925ddf6aab3834729bd2e49ead52bc00ea8bf429d767e79fb6d448945d5d767d4cee849492e6c9c68f52f067cf619672eaaab57d8278b2ca333b428dc362287b29c41e7f90d86751f3606adbc804e6c91135fa9402537c25515debfdea52cd45ff4d6fd1c3dd5706df32da4520943c83dcdcb979ce13437b83b760937993c1bb928a2b1045522e749e2edd52b480b02cb05b51dbf6a5c26ff9a6152f5b98a7e195c50a71c5ebdafbfd005954106ca58baccc4981f165bb00937d21a1fd421ee96e37a1a046d833062661fd21dbd9c834ebea3ab9c35cdfdbfbd375b05ca06b7c36da8279050c9a79f7c710fac5f94d74266970a689603a62fd6bfdd7f14871b336bcffacd0c8f7f8a5f8a2e2bda2f7f1b80151494c259726d411093d3cfc933483261ab952e96fb50664eeaaf3b488d83e93b9c2056fef1a19412372dbabe0379de2494cc3938e387e779da00c95ccd22c51276d0ee142eb31efcdaad45b80d71f89b459d50333e10006830601b31c3c747d0886c4023545a4a26cb276ff4161f4a035937574818cac2149ef6f2fb9cd2db7ae63c63e681716be9a134ee23aa51d4589868bc3672c953f829ed5689ed8f0e0d9c10d1c96c662ab3fca088acedc5b91c28a601b80b165266ac1da748aa7396e06b8845b45e668804dfdf4f7319c31af120caf41d8ef44a3e6faa763129e274a718f2dc1f45a8fb207b3fb7e2fbc46734fdda52446aa961ad82d80687dcc16c47354632b9fd32f7850268fa5dab1792798c460bcc667a9fcc0027437e2922a445cb21c5d4afe1b3eb846442cc920b826edcb645ca1f49f0f4a5166f63081d55c38a4d2c926a969cf6147b22d14908816e95633ffb37f4a07dc8521e5cac06fa877168792adf890e9576eded1aaaf48da3174ad61a74fb72a12c952bde106f7faf6544eed2e827073ffb379691193bae726271da7422fb06ca0d5730c8a6e909def3415760468e5635947aa3156cdc346e9515014e05191e9fdd73d782366a8c205e2476808d96dd3359109918e29be3d1d058d793287f974b6b46388665e923004e78998cd6e875a533781de5f74ac120865053db64cbb390421f8ed04e3979d091ab411b6892880246c78c35f7fd956639b19a8f44c2c704f5908cd1b1184a09926cb3d8fcea5dd74f5cd618bf6923464721cce022ecd0d1c8f968ecddf0c6cd90f8a7c024f9255a476bd7d26358c395c1b3cbb7f2d44d53ce9dc2753e6458dfe140cf83238593fcaf32e28d56c150fcd4f5b7572aaa7a977c9f5825fdc21950eb79d151858d7c103a633c3ec956e0e1691fde85c0097da01e789e344f400c3639dc08d1fde53d60b2ba3aee72c64ad4fc5697c4d906e7ce1aa8acbb1be3a3a854cb7588aefb0eb82b8c095f6a13153c20a083ae8b15151d7c7dc29378ab36c499894aa983b43855a01d28385b7f73c8529391a3a14d089adb0c4ed6a34a3e080d7b52e70bb0145c46e2301943973427d803b2a73f6bddb90d5c2531e480d103d89d46e22b7ccc979bc66ddf88d7fc73728db44837db668c346c8195f331f40003d6c247d1976b0cdf465c4e8137aac9dd96f5178218ecbdf29e48f454aa7055ae4aeb09edfbda84a6ab6d2781de49e84b8c84e39cb8a2da4fd9afb2130af27476352f4684ab64238ff592f3c4544406e72c3e5cd0c7e3a1f79506e7f9fb0a00380e4d94b4e6dcacf9d40d1bc5117a6aab9aaae775ab28d0e727e07fdd769db3d5bee48fda23e6adeb5e5e2a30e172dd3fb478b3e72ecb12c4c5cf311500e3675cf91c81514075ecfa1f8d60b589fe7af979aa38de232b12e3f7a67ba68f2b0642f697c6cb385040b6681900321f44ba90896ca86c029e49da14a7b51f90a3bc96f11ea38120afb76b230c6e5dd558c0d59c37fd86e4cd5a2ab07a14cc6312e84452d30091076188300643b9182df4fa5407462b508def85179173b313f1c100b3bb4e33a93f045dfb4c3a2b27016d74fc90bb2629a64c4dc2f9368d92e69565c7e7dc52a6b5ea31f3fb9eb2fc6032b4ffd8c6423288aef32d5090857df2f0b65870db101f733bfc71f40459c3964224d0ba2fffbcb2ae7c48a43f90871ddb338fae4bb95a69602f375a7ba56654c19fe6f793205df2aba9b0f4262c13e062ec3f3a24e118fbbd54eb9403eb7b4d4c39757f00975dd17504e8c08969e1f7b2ed719bc1d5ce30fcced7cab24b4cc075bc01c4c5d4b17c2d9a2023ab2021909165a55797641649276ce1442422adbdefd90d6bfddb879770ba8fa1c5de523df7753942257cc6e582e31f4b40928714a30c293a78ea598690c5bbc37ae280f9b318520ae7544b074c5001e561926a69f30a1ffbf63325b309c70ee15be7129e56fb8fcba6f080f9a1c5e111ed4b74b634a55a2df051f5d1f4454bf69485e936ff084c7b9eb393939b20e66dfd6f97325d557e0cdd78a90e11c40eaa7eab52ccf23162bfe667e0831cbda831e56e67b6b9cf013228877376caab11e6a26e4b9de2843f6474162ec680e4b6e9cfffa3c11e74f1ede7451f899308d91cf78773e769cfc49fbe860b56952dcd96a8ec3bf2d845a75c71bbc7f470fc9c53d2741ce2fe0151661c2dfef9c9b1d500db85071c4e88ce5cc6e15ef19c3f0cfeff003c912a72ba440a67f103f5bb9a88d69e1d70583ca6673b161ee676168d050752ba39f50271b76800420f24f5be0d8de9f0af758ad9e154a222588766196446eafdf31be1ce4118e8e790df689b2817f68f94f37003f1501f44ee1f1f07babea13284a025e5a85acd032ec62b60ec1a4b7e98cb7568191b6eb7b0aa87c20692d609e89c12d3d2765ef4d4ac1918cddbdd7bc9c67ee49d010f9d39fa95ffbc83fde8d1a43ed26a921e2b7497e93f778ceac782eaf985ba301eb5eccefb42ca82ada0f3969e085535a8a81c07c68375b63c518b048b184c79aa28f3a4a5ef3f14cf7a14189ffd3f27f762f532497dd33add716ab44fc5ae18343368b7a1d80ac7828863178f1f5e9476e8eee644beb835671d3c2b9d129dad9178674460beea903faee67f15226ebca22e9e93d18af7b079ec4e80bc59a3aa319a4961db7dd4b9ebedcd53a225d6a36d38676e017a2091e70f25f33d07bd1c6932d3a7f349c63e2860b6db4af78bd24a27815bc259012e265bc9660bb295ae5be652bcd61c519ebfeefb7803834dbdbfbb90eb73e99c1aa55471fdf0e720d3063087c469a5725675820e4fa5188a1b855e825a52cf81d4d8973971b554072a81e2509e8d4b9deb4ec9e4a124c1f870e3831c5fb7ae3458585454dd4bdd99b6a62a00e087abe0d320bf6723fe52bb3c672ad4371d21f91f5404d4897f1af44d08c7a12d4127aaed1b0df24284bf9d28bd391d3d857e403981cd8f8e67ac42f540578fc281ee8188c4e52bcf6f0800d94cffe81828d9682425ca72d1688a17d7cce503f4205aaa1be1bb40030619107d702c9c08cd95187f0cf12f7f3cf4cdeeed63cc61e0ddca712cfe4336f61cf99637e320664e3678b3884348bbbdff78400282eb859a9d428e32268829e920fb928987efbec90652fc1f10a8ce6f12e5e663bb98ae014ae3063da70aa4580558d032194ed75a0fa1900326fb3fda52f81cc6576e5f87d2ce9b33361eee647651adb1af98aee0f821c675706a790350aadbecd2d7175b0bd7e68d1f2dc0eb6ec0e2ec2771bb25a4a2ef9f09c1a15a330a0fca10af843b70cbd53a36e0ed9397b18b05397b34a87c78b922df76521d61ba12e587c792d5215f64087d2156e31d52ae5a90ab8f6a83491a7977dfca1f1336176cd1b7c2e2e93439ea3de2576eddd4d6cf85241f93f69dcdba8331e668eb5c9180226d3308cb88c57bef97c492ef4ecadc66384c8a622aa653000a86967b797e2b7ea5abd412d1343185ef5341869d109179269846aca8715d749f8604afebe90d9ee689dfb8659fecca3258c92da9bad608661bb88c05ce7a77d58c60a4c96a75c69c2b73542ed4642c9392215405048729740656979802f3e33b56ab603232afd5d51d1fa8c08344b163a7209bc5e8dc0a680444c9eca691fb24ac576a77e60f72143015a36796b4d116eb2d7ba6e564235cf8187fef2c883242f38cba44c339f0b0216ee84f6d98fd49a75d0d88379ecf0c90b10479f6fb63a87c0fdeab6344fc0b319eba4ba3be0d32ce655176bf54cb4144859366becef130d35f66c3e437343da59bcad73fbb67103d1c6120ed3a6074b9477bdc493d7e9de765d3ec6afedb336295e8420208a2de4f80440f960a6faeba8501af5aaa2eea738889bfd65a9bd7c0a81a01699de16749e7c43932c40650fc9963dfe7aa7de0702166517ee5a066c63dff81349b294876ef8fe6f746a6d9a68836c9591eb53d3fddd101e30f5f4e43d375f55c9fc2cc00be65360e0cba536728e917e544a679ca43f2ba90d89be1f8dcad160cbea957ac4c0bce8791c5b2a0af9193e651032d8acf96bbe0194caacd29d6486cf1e76c4e07176a8879c96c25a96868218afd542ae8777267510eb8c0616d2b9f521a0e72a71ff8d18aec2884d4792eff40a38a276f8e32de848dd0c92cd777f1923c2997d31547d7b2f82fd293fd56b2a3e1b44167f2fe99941bb9d648dd4f2d414eb8f5f4e899775cc54c111a168cbfa2105b340d36c83665893e42ecfeae47f52a9c4a23ce86e75a970e4d58057c5e42dc0eba1cdde2f889750841bf5e3f848e0588049e8bdcbfaa932ac605605989452fe627e50bd53befde55edbec99c7c3f3a31b39d84c1d0cae3a3a00e98b005e352b8e167dcc6417e397ea4a9cf550c1225c6758a3966e612ca50767e69a1d0dde6bc94c3fe3f5f1b4358b261e9eafdb72f93c3df5953a874535d634b30df5fd3308ae5a3ce62bf1c6042185107e3d4b8eaf01389c6ee069fcb4dd828e7e7ef9c35a11e5981f69b227f6cecbf0f84ffcd14007fcb5bb3a8c9f77ce8c3fb9701a2ef5311f65f8a85a63d1b0f8a2378bda733775ccf3ac8823458425754efff6345d6c32dda7928088c690b9e5ddbe8fb46b712b068df344e014b4480efcb6f86d74a35b932fecf20cb95ef04330be268eb6c5a02e3edb4e736a61702d29d6b7e4e1d874b12beac0371ac9009a9731c362b6ae3be0e0477d19e2325042732b24ae6b518c7d3ff88ad57bfad7210c5748cba6082241bcb55acc9d9900427aec4bd7dc96102a1e91916b004549c5e3efb86c9480e9975c11100010ddebd0576997a78fc264a76d3571ce8c79e2562185367d6fb12be6069f3808bc76eeb11a34c4d6bd5081b587a8897f201de2d6cfa6b7890c2e53368884fbc1d90b673b168b632288329c44ba7f1e8f96b967598d052887a256b75427e34049d3e96304ddc49d6c76c080fe91f6980eeb1d33daa643a3c07260d0bdc26c80ee3b0ac9bdb00a10df98b04a4f2b526c2dee9b23fb8c3b73578a663be2e1ffc50c3805b28721945b6513096ae1c4b2e82fd611caf24304c7933141e67e530c7bad252b2a2fdadb8e06336271d3d49ee528e5fdd224a25618812511619fae54e1fdd17f118580010b4319bc3deacdfe4b87a27c0eb004f6158a56575b4a7da9f122d0100e2e910eafec078498cbb0ea6192770d83621f6b0c75d49e4983f6347902fcbc673935b4601fe62f4161f9c197a8eff932e36fd4f353854f93e90d2a9ba021d47a7f73a43feef81c61922ea0fe9c67a4b1c824cf7ec8036df1f1165475bda490000ae376c0f871d578366b4aa212b62bd23945a415876283a4581194eebd442685bb686beb7c6b053f326eb9910a787b928295562ea9aba6cd77356535da6c9bf5d675fbeb425fd4ca6030c737af2033601d82a7775b53aba7eca467a164fb95f74ac341a7996ae8b04a41c4ccc6d54490529278e45345c1141cdd3057f518d4db1129e8adb5a50cb9e5ab961cbd9aad46b4c006cc7bb76b2ac1e17eba2a980c14ab54a40627e895b6e23c154f0e8b3e8be786c40a0fdc87227a365eba868706a815dcadad673502b498a19f83a1bfba6c2572a792f2f5ee511cec47fdfb49df7d2c3bdacd75e4de094dbc0e750f0629a3e0b8668d00f8fabeaffcf29b2744ea0d8d808f8b5f72f1ac036891847d01628b9db0ef08168305d7767b2cb9aab226c57058053d6d88f24572c4ff3c8eaa146cc78977d7a52ff3b20384b768b178c3ac865aee6443012320717f9af5f7df9934290afbc7d10e9427d0a89bda03b79be566472139b43f10a81e0135e0b7e4de2a270a88f2d53e0966ec33895bb111af4752a0e223d05e9deef35fe4f546d067b81c56ade1cea310725054e879bbe7e76062edf24dee9f4d88127f5866d25d75e1ff5679b41f3a3d8d63d491009ca56df4ab157e376bd301d71598a965d6f1c5827065d800960800aab7d34c4f987a885cbc871c8a3ec8518e853390246e732f59fa88b252d0f72fdc6f761954ab1f197f25039a15d960ffb3829e48c74e713748a533efe29a5413d9aacfb3829eea339b6dd725f6954bb29d9a8dd58cc4ea62aeab5f2a3b666fdaa98e126ecb054b1a52331514a73d0fa669a630164876b1bbdf44772a0a3e85687d24da6f0b7add4c6eeede42b2e6b5f476ab4d4f8fe01e6b575db3699c34d9948643e2ef7cc2dd55d6287d0c26dc70c1506892a8d5b6edac8981d13c5799da2962a709ca01e4b766153c766e939c38144e1e22b5bb07495fa2c3ae7df97e20aea8af66da9dee66e1e6dc2fdfe741cab66b13b01172b7d8ca383112c9fd0c4d838f2f8682cfb96469ecf66c2bdda1d28dd2fbf5f420ab9564de59fa399ceb156fb4f93dbd660ab95d3f5363d3b171ff66f839c9d7627b42a1ea81e57cf5cb9d8529b65c51755549e3be35b760bba320aa1b530b39def158ae91b3f06a3bf8a9529da588a86037715bce2be9403a6b3f8378e46c9501bd930a04e108548d9050f9a04dde149ada0c829f731452c36bb0874aed2b7ab50168d4a9e7b9d4b40ac3b7e6fbe5c3d1002e861d87b97e453b806a3c3b7f2401f8295c80b4f38d891d50500f3f40f972170d2d69a9192dde710c6006dae0ffa5affceb4bad36764f9faa6635e6c5300bd85e1bfe46f2a904e00f3bc1347d274ae75502ab05f9d328065208366068ca7dd251052d453adc25b0fc03d491e5540ac47dac546c7526c0863fded3202f1bec3a98297196c0ad7dbc2494e7fc6cbf544d24834ac4155520a47130ff8de12eb7c9102f5e54af2ab04e9b51b96f3aa335503fbf8e76170a987bbb4940b4b27d25723dc22daa03c24471d59113eedeeb41f887ca97d7bb9186d0e445b5a07d593d9862e642968d2a52ea4b6bb97f4ea06147a4736f9abe38831daef8b4d5c8dfda5c79d8b49f8837a6aae3cc7525aaf54130d80835bb16355583cf2e0f879fe175f4ab6d8de56b74cf764433d4eceec13ec9338b6586d1bca4c5926e229950a4891f6c90c999bce99151fcd916f8a472e8e123edaf564e797eb37b3e3b88f581ffdde95df7babec838f5cac26fabde886f96f7641f34ca8a315bb44040b4c6b7605aba50ccea39d2a14554a05ebecc47762fb7e1a18cc0ae575be6af1ae788cd91af0240d6ed78a4912c1dec1de4bc9bdfceadd6e19088ea2e18548fdd7e8285f8a3f4aaf8558dd66c04f21a2eb05f8dc831ab142d7981c328a8f4bd2e492c340fd246558c15f0bfb66c6e99d9463b5c1323b3a2702883959cd71ac4f900b2d32f2b691724be01b5a8d228bcb4baae7ab2d6169cafc95b0506f7f609203d260113d0525a3703d5361c51bf07bbadca5e088db0e4787488ab214a276bf6c4e8e01809e97b9fbe75d713b05e11440175d11251b63d2b79edd300049d3383251dbc16b5844258464fa612dfaabb0cddef460e11e253b93823a127eb14b6d41615129653729737b614c70d9cceead321a6e02bcb3a17366a55d2a5a15b35d172cf28a198d58da7643a6d4724ca67cda9508cf876d267cc31de2bcb4b7b5832b597ba0c29c4a277d52006b9d73f621fc6ad3030e383854da6d05b6ed0aeaa31dee5a00cd4fc4c05af5af9fe11b4d694d99461e56bf99044e547244eb2f1f43394cc9efac02c76499a9d403fe6a1b7eb6bc652e25060571bc5c662eedbafbeb7610d080b0170e497589077cb6004e9fb6453fab182ed900e5611f49f102b3c7002c4bd0070803d716af35164d4028d824abae301e571d1f2f2a7e7913f2e21aa356c1cb167e3ca2056a016f9d0d68445b365f081c0b2bd1b7a87b321824bdce6b4fb8f1e8013a48602c6440090adeb226cfe5806b9d2a998fb0b5e3f6bca4c9a8d64d272fe67642c87cbb14b45a0a7e8ebc7af72b455d25b7033f8f9e5397f0f3873d4a1cd500bdcc6d66b59ae48bda1c88d66970a1deb5590c3e2fe8c636998dc4fb73935bfbc773b75f545f6e4d1a32fee69ce907e44b2cab361eb8df2bbca389c925e10b30ece6e94c673999e427c47df2631df7bede4ab706e761a2c4ccd6b773214c481cfd1fe1ab2acb3f068c17b89ac25f1819ac8d533c9b6d268067858c57a8f40000f1bd7a559ae6cfaacfe2c7500c61d8d154f956f08381c47df30d4a07df1dec6185506654c2cf47604c38f185d9ae88d51fa4e87a4315382d8cb968d2bbf4ec191d5d168d690e0fc13d5266368419bd0f4102a6c62e1945830851fef43a27da94f66ab1dde96596b60a2b91fe22b6c9d2e9c7c9cda5ed556d8c94f386a4cc9171a5b17d01f1d0b737b61e5b42fb0e4ad01e7042355f123dbe5f6459b961f879ab8ee9cbce265f61f38296301c9d049750e292a9819e04c34864ac932dfbae0d6e557c5688bdf3ccc46431f8036279f4b2292ca224dde354b94242c30a1775a7835bc99bf781814b7259e28142db012517be032b63234a9a0a21fd6b8bb08a95736926f223c2838665b8387641f61ac378c405d9f9e54d2bcb0921dbe0412951d3ae609765a78c396aa072e94f0df287a092367f94e6b2594fcd5a8841a59fcb5d89b86f2c94946b1ea83d1e8d562743e1a853045a5a8639b6f5a35d5c973160b13b5c71248adf04ab81410f1ed6a47fd3ab3281d64a3026bee93a926081ea9ac2f9e72c9ec8331e07b13cf649bccf455047dc0315258b3982f2758f14f7b89f8b7c4b8ffc8f5e437ec04d20af441deed75d56c0475f3d1e93779df31bf47e526a58913b5e6978df2a107b653faf8a5f36022c5373dc277f3a45e6444b69908c36dd43f2bbcd5063128e196c58d2f8b815728f1b18a8bb0a162b00216a31666861fdedeb859e7d4e0a1a2a4c95f87aab4e54d5ed3ebb972a6300a9f7f47dcf1a0c90d5442de92c7d86acbd8beafefa63eb7235977cbc3325d1db80351fa7573f723340ee597ed2c88f54a71946487480a1b66168b31b30519fa754fb2c573571493a72af1efac78ea52ef2dd1fc39a13b113c2126c10ea651d06ded77bf0d768b658c94dcdf64297e13cd81886d6c51aa7f19199fe98e1fe27c05bc921739057b9e6c7dbefe9514f842bb6a9f5369981f53ba4e30a6540bc5ad49b7260901677026d852f0c207656e74a04bafe4fb5c6d95882b0af43e9356185688bb132de269b1d6906c831cad260ac9942de58fe521246c40eacec4590ce3b745e5f0c833d938f9ecff975707951f30a23e3298255706a67b7fc3c53403e6764a254598a3517f5215e84dd292d212f98a671f85220128d36206ba1ceca620fcb1bece20da2cc78377d0dae65948ae6bb3e9a3e7b18089f3d901f48719a46c27bea5267b49d289e33979c2a96534a5cfe879605a791a2c11b176b7683230753994d51cc21b613e1b05edf273877598d3725d31878d80b721fbc6080ff6e6770f5bf5c87116a0f004062f2f325b8ac3508e05e46b7f056c18a86e022ecfa50eff05db637dc7cb3c9a827d03fb50d0ddb51b7aaaff99444bd12d9e54834c0501d96091064761aa44a12e151903deffc36c93c0f17e1efc56c1088569f095cf443120d0b942c2aa2db8fb6926790de58875ac9b5439bd65b","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
