<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"0b47bf42232480b15184c13ba72f46d9612bf950147151115d1301ce1078330c6b6deedc9f8dcdad97682055439d02a843b65952064ebc7568b588c1a4f4d504fcf888aca4efa88d04044841a0a141e0e1a5a2aa8c7800b7545105eca541354679242cba8ccbd74141cf664b19babe2234ac883eb569774c6dc9bc09f128d67f315fb132a80a872236393071fa26ece76fc1a248c177fb2ab00e60177844994a4d7075328956bd7bac54cfac067acf8c39131ad8635965469610356d404f02dc59c4f3f7517cf4a809133a638302a33c508e99003ceb0ba3d8e62a8009c0962ca27c20a8e7addb2f5579f6602b795282d64815e3d2e35b66f6abc0a077e3779cd835e5c6ce7bf5a67fad4c8bf237fe4c719ba5ef8569a01e9d367190cd33279d3c2149458cbedc38ec67279bbb48ff59849d49aef74af7c7e63ddc14334ef998e7bfb1a0bd03c13702edb8c33520e031cf767b4119e36dda8bb81feb9a05bcd840b996e879a0ff723ea6e9115086848d3438674dc51904155bd80630306dcc348f4932120f4f4ed4d832a74498fe5e6b6f055886bdb30462121a1791f5e73dcb1b545fd5040a0d63803c6669f14840432775857461b6d29017a9def9b6fa04253de25a68ccb5d22624d7739175e6342727eba8bb3e8714d6ae1b4588aa83686e28476d503b3538902144f5ded1e14bc51e2ea1c930dccd74eb32188cd5ab81b7ad542e6802ebe45421aa583a483b22a9378e37f1590a26f670793ef8c925840b58a19f56d2b4b9967a20c1237c397dad8bb16cf32a5c184d0504a217c1601fd61208e8c28c04f261953ba647bc5cf2946c8a3c572f9612540c974e6f05156fd4bed886163644132e215095fde2b557f9c3da16a3d4067a2586d1310842ff4ae4660473211bfe94b85f78f4eece2e946d1a58552968e9e94b53a0ae587b3c64f74fbef15198a0b9fc543b7a175d7e200feeaadb50daeabd9a53ccf581860954465083738d4a016c4b735ccfe228c46b6cfb579de06b29408b9339c87812ef9e4d122b9d718aa116d762311417b24880f967639cc208e16b569b21faf4320cf30aad88f2b77a0df4fbca30e1d1967db3722696c206c79cb401b0cbea480b34efa9c07f70eafe4a7d83dd1c544d25da5b0be0d32ee9ba9c4e2817eaf3f2cc6784c21b7abbdc4ee8ca29279d4bdb641f57db3517dbf0da784b6e97db62d6fbdccf67b6269bb873217cad5d1a24a59c6c37d457983b7e7631003c5018a53294459ff86942d37500c44684a8cf937a34b9432def24561fc408b0a98b114286df9406e39ce0fe71c32811da91d393c0c5d181165e93e4c26a0f39d66494d8e05913c03fafb94a2be7d4ae3ffe71c53d2f075b77b2ae4e61b2a07c2812f192593f848601ee60cb02479ad6140f0e3c338f35eda6c9cadfcc82455532c4573a9418435355d1dc967e533b441b301c5072d1d40dbd7db5fbbffa45a8b24ac6b160c173515e1b44157e52a812cc10e851d25d3386349c3ea8bf5834addb16af995625191c27ac33d4da13db2cff35a239fab07035ecfc8b1eb49e09fa3e214a72b49a794239dce17121fa852a77a47f20840f60cfe93a28eadaa8f1dfe8da5e5febc0fbe56c293ac6ddd44d74bb5758074c69475d2a982d3a5749d49d8cda5ae6c6305e4a12b80757874ab4471b7f475b5aea18d0e77bdd922c8bac3c261a59630774d5121ad55eafc218dff385b506986003290cbe6c36d852ab510661aac0e8e1186efcc9b258173a2363a9203987d8a893b3159b27bbfbafbbe22ea921632f86b4e617084448b57eec57d440afa967f444258c56052058a3dff9284e4c8839e24ffab4bb2b24d7b71226d6b4597eee33aa88fef3317bbc7f75ec199adf78da7113fe8b0d0c92133085ea595d373aa7dc7b0e713b4eda788b9b2a1c7fa690d2f951ac729dc5df340f365f730f228a9d60a48b4a6c12aa3954753ca580f9e5bb35514c54b943603d49973818a63d83e8dc80ca873d9032b484f08eae83d238aa58a030c14c409a4d7c0ca231beed5ef45eed458096fe9bd4e2cbc0f4f88d05e259d3c6a1b4af84ee844feef4fa1fbb2c9080570f9176af5e1c1239d713ccf368a75b928d2775b1c57559586ca1efcfa9119e1b8a4c0fe5f04977798f1798aee8876d388ffea2c5d10c24bcdfdc7f1859e34d42a98f13b28296e2db915bf1fd313bd767ae63c691cd497dd4c3dc1c38e612d0582ca35e9ca5eb8ce7cb4ce04c43a337199598c045dbaef12f658747937458b2b7c4b5c365a81ed7fa73aa194cd4df45f80bb87d391666a195cf81ef8bc8bce76ad180d390006aadd9c051f1ffce773a294a09061932d5e77a382d069fc45eba23c4bf89440e4bd83e2e42d822a86910fc5fcc4b5a559aff5edb444caa16fe3f978c82ce7e5a87e699ce07875b77b37596b16d55cf91be46a64d91b1763c296f6bb82c701e1155460801d3647eb1fe66a0dbba5c9fa1162144434b9d4d3e5d10cc905bb48d073d51dca4ab3f833790749cf448da00747aef1bfd483efea5b60f0782c8f1125f40e539785260298efd82f93f5a5d744b2fa5c64001717055b7890bce312b95ffe3a894ccfa2326ac36373a9e3b9dc1fa786d6ed262a7abbbd88b35fd73f903b4a1c4be437f7981cc9d3682ef411fecd7048a1d656a5f1f9d56d0266e3f355750fae663959e057b2668937b343a317a33f964d5f795861ba64f26186ee46bc6ef898286c6866bc241588dcb9f88b59a72cca10c1f80dc009aaba019a22f77516556a3e7c367081df156fc828a75030397c3e7f56c24f5cb1061e54651c38a82189a1e3109f4466f8ed76908b8af4c2eb529e4d18ba4aa42cd501e4df97a3bae22cb5f281d6c33721d519d918d1907d866e2e334ea665d3c6839b35858a3922bd0f93cd588b42552b06dc9f904b764bc20366eb5efaa8585ed56d610e99068e39f713a5ef121bdb1d538e65dd9a341fa7e117006e1d33b1eef7eb8a89d2bb1a062ec56e53d1056faba2cdc181c711acacde7b5ed441e640b46d08381fdf22116d1fdf02d111db8f8513e86cf37c7f0a8f34206c78352971422f5cbb28fff9cf3b752921b2d96a7fd1e8c54f8b837422101da859b77756dede3a829534ace3a1f6554c94f8e2f3d316db2a57ad89b766176b6868d3efc9ac9cc5a6fab0fc8e8fae7e1cb097e0c5f2e02a9a08005e907ed142f27e34ce161523c345982e9b266977e569953e904ad112b32e8fc0b625302832d8e3a7ce501bffe52997a2d99d76dcb597545abd85a0150aa574afafc8fe4c03e880879076e8166c631a53a22372ed693081f23da066f2381728b4c135523535da735c26610e0e654ba6bc5d78848178ffefe8405b42a94dd1dbd9cc770b43f5a8b6377209ddeb0445dbbd1227ec08ee5780f2e96c1e5c457d8bb50357afb70228a192ffbed3123fbf49962cc29b0889d964c1fdf48ef830b347f04ccdfabded1102d85920b664b0d08b0cc25bbeb93c35f4a9c85a3200b093a778cdc25bf1100dfae29a3281eebad50bc7d3e3b4252d8f905cdce9703bb46a9403f6fcc1d1604a7f8a786e2dad3949e032c92140eaad153b73f9c5f7367b7f83e399995f503df868a4cfad89c89aae2e27981732a86b07ab9f437cbae832017ead479fe31ef2c475aadddb631c8a311feb29aa7b3d9f6e2a22e657e6dfbd6e74585a63955b59a1cdf9a89756889ab93f8732e0bca4765fe4b8201bf52759dfe8b66bf744d803648c3c0a8263caa715aa4c8011c93a84553bec197f98858a43723a59c5788b5b8395f6be4f81df42201880d047c9189cf5ca6215e1b49e1810c0ddac240d32914297a0a96d0517c3e356e1c545aa4dd39f37135d9ff312acefbdf7ef7c921b0464e3abdc9f9cd2eeeb9e75ac8333e37c53a888fb8ab8755f31e4ace01c03b2e0341182984343852b08226a757a56216e16d319aa381c284edc8026b357a581443a8a2f7696687836bb2c4f5f318044d17496ff3447ed70152f6c6bbe05bcfeb34f07624c1953841b3abc7777758fe285dbc916130d01ce3f06fce1cc63e6767cbddb1c055e09ad23b566adff56397eada5d5fbd310dc4e46db0c55fcdf04f20901ba77650d135ca4262a2414d2671d9a470e8a0b49f54697617e0e1025303f28467ad2bc08ae1c9a926f34e48ff0d1b6c71d53d06967335e90b597da8fccd9bb42fa3bd5bba52b06f0658aac22eac0678eefc52adfa46f399380b68e53620e6a3dc3168fae71b0509f8b5ffab8042954d831ec4f784eec2e6146d54921215549ea009c82d72c7b951e32a401cf83bc0fd21b3167a55b3b0c4b87358a3aaa4632812df2d0512b56cc88fd2ef55cddb484f9e7297790b4336e41be68982c94411cdb27eb8501f24a84ef584c208ae3b2d15b13bdc7c8aa591520949a18b33d08f53c2a33641495c98c245ee9a8975195048e497c461f1290b7e2ca3ca50f134aefb19829d6141da6a594d94965b035999957418c9ed3a790726cdb41952a302abccf3eca06b49ab2ce7e9568d59262ca3961fbd83302412d8ffdb9f42820947c025ac588bbdfaa39c4bb146155621f3b5531c3de4a4cd11bbf556b90f8836e3142010e6d4f196f22ae382836bb11b637f3c1beff81f020ddd635f3354acf3147bee1f7ed1e703851befbb38da92e1b3a5d91fc6f8b347bd96136bb78b6e299daabb6cf875a6204dd1939a7234c878508f1564e8d5ecc9dc9342ba7d99d706cd5c713d070ace8522eb2e1d008ffff57aae34a6d1f14681fb8634804a2c0001a06053210aebdcc57c1d64db38cd99c3bc2f0069298a20c6636746bc78d38139389abfb49ae3f1cea4fadb27c51acb02010264068df2c31a80865993d14df796d39a6ff235925efb514464c05acc99afa08f0857d9357cf75e4da7c399bb8b3b3796582f916807ca20f301ba8e9783a906d995436f2510e5aed1b5d8342d5efd440846010285d945d9d74df38014eaec39ddee788adb066167b76c09b05b24c73770ded3001cfd07852a3e13c95bf4ae213e013a708cfeb91d9f45305cf9eb095ceac2bbccec686950dac425a50b9965a1479f3e9adfae8d0cf2f477d2bc1f6dcd30a47649c0e49281aae11d031a2355e305a3462fa9f4513821764386cf93a315d233318a6c4e4519cd0476a789d1fac907fe294e981cf308aa7fe016c4033a44e11f9a4a1d1208adbe53ad3ac446107cdd2d852045b0c1e715ec95518a9a568890310a0a000cc09e3e962b21e35d77efa44485e31e0a44c63519a3797f148d74be7d01a8395e9030bf99fb0aa13b3a33daa7ae73f89c1b12c7ad4e163319edf10f24b8c0adfe7d8bc29c46669e9738f849f12351a4bf2d5ddf5f799c9fe94422bc2cf94ee0fd51787c6a8d94216a2b405a5a8d53febcc705786fcabe47c6de7d0f2febb902a9aa7fe8406d2cb47c66570e9f927e269304c13d1c899c9649eb69d51fbbb77990c5fadfe3dbdff659e3b1b28da4bd9584379cb97e4017e3f17e313bb9a881950c5b72fe45f7ffa52fc304fc616217a3001a79d1fbdca76aa9472027985db6d5acec4c1ca4e04afaaf724fea5ebec2563ce28554684ebb3684200aff96e8d37e39824dec095349e1686f8dabfa50ef5fdfdcc2340d5c862a1bdb923aa76d23ae21d7b3d16f594c3b5884e634f3f1714d4ed17ded7a15ae31d282aa29fe8d4b5542eecac4392ca681629715966fa456e66b82548b09dfae6b48961f852f467bf31f63dc6076ae04dbdb2cc5cd6132fe7ba2b0eaaff4e6370b79dc60181b30d582c68897a38f2fc1b00ea43a936fb4837df25ca4064cc6af226e76288948cc351f57365df0386b6ff5fd905d15852b506a033167169e707aa32f7a9d0a72d3fc37acef849d28fefb9c9b9c612eb852033768e9a97259d5d27c3fa1f295a8be4426a3eb305843a904b73f655ce47259a4b892d1ab1fbedf1126348743bfc8b86f67b174dc5a94800705213f40723f2eadb4b80a797c38217c2980ee146f3b78689c0a3a1556da5f9f025900deca47f70761a956d50be738d6438d871a2f536f16d92b698f8036076c6a9075c34b86bec22ac22502aa75bf23015c2458247d128a75587313cab93eb5839eacaf704046356b40a064c472d3398e5bcd3f2cadce3c8e056ff9b02d8fa44dfb7c9d4055e7077973856ef554c9c73abd9d7be0d5f39cacc75c5f4a785872791b25eb484d2da0d8b26a3cbb3846bb03b68e6216bfed43ec01612c19b5c592dce689efb5969d9d8729a69b7aceae05fa4274e4934567811a5548544c6c17ca1dc794b2f679b14db09b3d896129937c2adb53cb627174981fcc2ccdd4d713fd7150e6b2fd97ddea1ce9a8fe6fd1e8ef5a33bee49aab2b8316ec2d05fcf16ce41dec5efb6e361a499b0065f929738fa7a988fa1d8f974fd68fb1d6e6cae244ef3e40cfa59d6793348f8a6924161d6a0a36aee787c6793baced398a492ba77cd93e2787854f2fa9641e0f2ba9823589af7822fe5fbc38f2c5caf22ecbd627e247210ae6de83ec3c89f776ce92d68912e60fc303d21a7736bebde06a036f29cececc2cae4b5cacc9f14fb132f4c2506215eec699d69457ddc1d74a59f73d77675d7dd7a360e3478ec18ddcfef4c72d5011bc4ff9b37b157262b263fd5a97c13d853fa761ba16f15264d1b972aa929ac6613067617d73af9dcee6f3792da347bb7f91e1baed283d660a427d77f2db08b290e9a7f664e1af397d53992c5f89d146e62ab81c68273aaafdab54aa112030a3308d82d8dad282b68a261d4524f373af74d4d62fc954a5fd6aacdd7c91936bb515853780e115d4ea82d5a3e7ba9df91ff1d31c364a56a2938f6722b823237a703cd1dce67b1b5246e9bfbaed2def016e750f456aeb53e586bea8096213d26dffc3467a4524c650fecde009afcfbad48248ef201d247dab1bfa0a077a9eabcb3b1b1d0ea5a0ce8427b823ff8ccdd0dcc944d9876366d71647df6d056aba07f10a8fdec237a8f9fb68f03119496fa164478be3103da0dac4f8cb976b17adc5aafd9f0f89d162ecd8658b8e91971c20e2844f03534a83f8ed45af5bcffb54676017f99053acb48250d0dc5aff97ed51c222ac93c59d3afa41c25ffe79deb73a0f6f8a8e029f2ba40ff7b0ead1fdb30ded92d1d24a59c3aa7575dcd7da30fadb6659b7854126fd02b784d5a46636d08ad71174c2d16925c81125fe4a2423008724bffae6e4457c140dde6b9cbb45e239dc5f616f32239ed0484ca3d6fc1664e78fd5fc9380c468f05eeefd4b0e31b890a94d30419b7316ac4b2c0249ed5b60a83f4c4683668a1dcdff4388d0824fa8c981b0055b00f2e4c95740ef550d6b8ef70a412658e48c76e4e4702dc0f06ff0539c3c2682454814e4d26115f7006caee76374f05f5508b5e438fa774864677f84829d3b1cf0d9572b9376a2b7a8d0cb8f1ddccb82a3d1ed3788858f4b796639e97f65b5d25c4dc8a5b4b06e7216abf624604987c35a6a0439f032dcde04b5a934fd95a5a2420795bab440cc96ef070ef3a2768c8250f07e01c055256fc14acc5f08c3b2688125ef405fe31f031bbf01b9f9d53aa8732d29964a38209a3561a28a20037cae2451cb5f3935fdc3c19e2d30a118021f7e9d073d440eac8dbe6ebd46d487900378ca9f0d3ac354786d6a182aca1b0b6d8c8e82229f27752b2640121d3f7d027955dc376e2906cd92a34c0fdb94924c0348835a457051ee7bd24523aef8bb404453f7ef34e28ddb9dc55796abd4d356754ea3463b750c4db7dfff28a8fe14f5022857a9925de8736c03f23830e3dffb0231a8343f6ceb6464f906f7aac1853baadf8f0411145988d09deec693fe270debeb13726ee50c10591861126842f9144c40fa10f04f41cd5d94c97dc4aa4bb6e8bc3be609c8d2e233f2f3a870d465f69a717105e92e0a67fe445053e0e60db04886856a447f8e00c6f7c1e068daa2470670544f78897971178f27a2beba38ea789e9782db201da21f214bc16cad2f936442f227e9f1a8b161cf06537180f801bb6e7ca5b544a87654347b2586c15c186bb293215fd1d7d9a11819aded0b6b9e01f1863ee51726adf6bd525f60360848b7a8b7bb43b84e6ffab5245c8837c141816c835355eb3427531ecf8651c534a6f2a1a5e98c567da3e64ec78f6c221c508848eac78d3dca6735a3037adc7bc4dcbd48772cf5e69fbf2e178269bb93d9b4ff94fb054e8fa484ea1a392a7645e7e4d636af99d7f84a7515abfd1b1eb38d47baa3476f387f913d4c371b7072ff1b1cb94b11cb379b37c3f3fea28e30f374883285bff405e0d3aa43326896f4fb2bf27db6f38c1a057f89b1e32e9b8d59efee0b4cb734ee4c2ade59b63075ba0944680f1b929bca87d8683c8bb1663c9a98081d0ed569ec3f34050e1fe06ade9edaae7478c61f6fe9aee139e02338efedf67fce1d43c491a373f67e8342498c212be73e18a873f6cec5a7fa4eed14cd6acefcb18f30467d33021b97ff03874ba89946db34a8f7ec65381c16248cd29a90cdb6ad02d254edfbcf489e9448425d92129ea4f24f94e8aa3460e75ccac3056a58098757bf4393548c1a31480565d4b649599fd77a14680f0057a3e719dabc8061bb11f76de048e1024732fbc9cda249feca6ecf56b667a69ad3b4b8e3b78e36da9214e953f2ed8992c7588ea8d9aed50699a1eef74d552a7301acee2539ff1e8005f0ac34c8dc9a59795930d1e1c3f39f1a170a079b7b9b748bd77005d64fa5ca9220848b52193aac7f5a117c3247459d39199b1357e847f1485cebe3dd47b235f53a4280e803ba230578177523bf9ef5b6fade8bb5c7596b8a16413552ffaee05ce50acae01f260370af7ebd8e0c09f662ed55eb5c0fb6452a37de5f664e080ae50835b37d6b1d90f42af753a069738eb0655b7d43126f0ff2512487f128cc5fb24800f73ea998b532d27e812a291f8db9bb144f0fe0634e9723d0074562ca26cec7bb1786e4a2e4c4932420bf338a708cc3382057b236571c84615dd23b0eba8b842d91401ee000198fc6f0c91fd4f2e902fe62e82c8f7f76709d842c05d98b9cd88bf5aa989c4059693f6559309d4b532795a9c239ff15f56b20d856dd6906adc1c4a65df36635514b4b35d00018e2d93021a2c34757c266227d8364308121539efd3b19dab0211bf10f07d474b545fb0805da39575e5457266f7178ff3918818ac438aea541decb8d64c64d264327c38b1dc4f054cfa22300d7e861e92024ee7f8e43e7b00aa7b9f2919d2b75d49eecec76dd7ee0eef792cd218e3b3af6ebdcc39fcc4358403dd8b9ab34d869609fb6c97c9b13be1ca0fa76977d98bd772c5a51b2d8c608ab80be3ecd33a8f9d011b925eda444b287f89878fe6d21aa676c0c8034047eb905cc7df616abd8d2ce89ebdf9c1202ba86c51ec466b0c3cdb58a53a2e805a6915a3dcdcd2ef646d48a654c89177d216d7426791d951ac3a723d59c93e372d63742f37b57101374db184fede39afa796eaef6ceb413bf37a533cb0aff9f10fb9a0aba93c6ee005ed875879854f6af714dd1d768b39474c980155211deaaf5e7ed967b9dcd2485e610ca05d80a2805c123277a92b76c168293f2b414730a68692690732acff6cfe8ba401c613110c9b03f49af5727e7afc3650578b2bb6d6861ff7049b212d5e23dbac8980b425b26e3ba8028266987120f875445e25a9d0d29727c3de0c3c8bb53e67d45a8bbed687cbb083397c6424b44574f07402b71a51c926edb627758641679aa0f5e37bc7ebcf4c70f221c868b31fc8334a8d8f2d7b3abc017530a769a546e708fae214b12a517462c01cc26991f078e8222378070514c6463ba774e374d182990250ebff6e3aa6fb5ed5438e1d7f664a2480c79017b04a0706c748746f6086483080dbe61d00b72931554a90d60567009269515df2283e02e66819466b260896cc565acca10348b59c824d31925f9ac5e95e4563d7f106e9347585ad81e054b2afd95359457528d191b9bcded8ff7f9047c8064872b32996ac0db2d326dc66c874757c17fef1fa1d212a1e38955fba4e3c7404e4c0c0a4b992bdae6b27dbcf4b00a2217de143b0d9cda9a7674a1d0e6e03f4159528ded195a9a8daa2fa1906b4569e0b80f3a2367aa5dbf70b2075861649dad40220dcc5badeeeb2423ef8daec60c3058dbbb3425b9542bb0b387e66eca11b94ec9aebfad46f8aba283e6ca1bbe2126cfd8b134cf1ca94a1667ce1d82803bf273c2a127b398cfc7248ca4cd314d4d309f112da8ae45ff5a79b36c351c8e064e3b108fe391b3381106f39f746bca06ceb2166b4fae04c3619a85b7d525b23cf743cd60b7a4ee163cac01fd75777183ef9c109ba25154c9a029818ea3942d2ce992aa0546a01aa0a8c9005f509e6c6938525f3cb98a84ba87ac0b887e956caa33336d447d136936615d4467f355ad880f3472fa16a24d3139db08a7d8aec4bb9667e2f09f2cb838099a712f9a0ae4147bcbb5f64a6882dd509b3411520c20491db24afa18e27a9998001811748be9634ee97aae60886543e9d7260810dfa901a65b298becc9b0505bb67351f9b6075737957bc1488fa9d3abcd880d6407d1469999f8aa450fc56579503cd33805f049153ba148acd82a818d28b601ead57d1594405c224108ae240e8e568a912d8bc649c642e9e2cb87a7f6cfd647392ce869ba97e375aecb2a97d34af1c2b8d8cc73171bcf583eddf24b39cf5e96150515aecb3b8ec3665ec82686bc47202de93c04f7451f8bd9ab3c7bbd749fe36e1b83502dcade6c11273accd0b524f14976f0676b40a2db5f9116f505cf61818a5a74ea606a67a8530e83a3acd842461aa55feeb52ed4b10ffaaa36448932dffd0afeb9fff0f0ad42e540f66b98eb9f2a71c737016e31cd3920ca092421c4c8538e9de090237a440b55c49c1a57ed8e581925ac31b04017f050390ca881811bbc551420dad190f3c9c1dd75921b3c1c662af5c4ae07fc01e5630469d6ff567999ad9a4a947584d391b93f90af7a710804983890f50027e862218ef4102c22e9f26efa92f1a699f294de39148d229ad1bb2416ed70a08cba49c3296d441a37aab4fc5dd9d687b80e3d3db9a5bb7b5edae73b5bc4e78411d13a6951ce62564292b410381b8294dfd7188d8e05b893b8e3b4f54ba536173f5c568ce43790ea5f81384088e59c82dc9d5ea5aba4574bfac79e1cf7fa9df5a0d595f852b4c9d6dd8dca99b3ad57f213829478f56e2aabd62f4f97c204bbb45627955babf6d675555b59d93f3ee08bb67b8b2d24c29ef1dcb623f3e0786c48166afa596fcd25101d6df7af7f9271c3ecc8aac305b54334700bb229e655b37b8226558afc3689f5120442d4c6236a35924fbd19b6ba6344fc8a3bbae0d54f01dc1af85d0fe54141d0f2094944cf2790504bf460a41bfdad7d77c33a3aff90729d61be09fe316757368de86c70dbb8e5a5aaffceb064d7b78c1327383ef693893585c97693e8d1565c5adf35557823ca91366e472c11e3eb8df44f304453d45d3893c91e32615e3ede5538316542cbbe2fa4024466369f6f2b7421b40968adc7f4f52059b546edb96fede892e57052b0ba26274dac754b5b1b82f2266569e6f6a2d46be95d1bf545a59306c224b45152937b5ba37fc610f7536268b9b5514ea56716bc80718eed8afb90ebf094938232be4f5a37b552ea09bf8dd902b7230bf84cd33d8f44de584571de77d5500c26bf837413a6ddffadcada348a23a4a7ded6ceb287bc5daaf0f07557a319f1fa535f5a4d31e3089ec9936cb3bf867d5e0cfa39d190970a0e49441f32757f8b3eae5b1008d030cb15a634ea145124cddcd745e6067ea87884df80dc3c1e521fe3f3e31afe451c009922dc0f7e1a575a8354b7fa3c1a1738ace7a25f96664da4cd13a7d01ffdbe73812c88f3b792b1fee27c0e20112528388b5439372b06284943867df90e1ffabbbb23416422d97a77cf2a2119e140e562c1a02691176cc846ede56ea5dd7621593939fbb551071fdb2cb53f75f325fd2a816e479545ab55c459a8deab02e3d3a3ecd76018220222df365124e8c1a54c596ab595a424c8e5a75df8c8d38f96bf103fe0fb88cf945d29558b4906ecd3667e222df63e36753b53d50c0dc4afd9635b3f16bf888768515bda103845437203457d14fb1a331b6b4086bde910573d542d5c390680cc425085a551aa2da82f22863c910de415cf1c0d6381c45a728dadbd056ae276cd37944d4078a85ed369e0306248c87f7cf6911d7650f0e124963d4c6ed0a7cf9081ba3faa61c9189fe5c61d95f66d655a0d25808db5f358b34bd3e053fdf8ccb9b14241b8cd93bfe650bfbc99e3aaac27398ad82f466294452d96f2825b3a889ee702b963d68c67934444513fb5089906d5a9f83889dab5229000c9ea42d784f4040e860989becd6f441e173343e540273803b587f2581dce3ba8a907b35e70aba660d389b6039162952c745ad6a277829a6666b58a9d1859e6e8c4026c64b8c5f1d3dc1a0ec94d4504b4187d0246f0809f068e683f12cdd638cd1244b74f9286ae5d2722efd4d05d52a59de4ba0db5073dc8370fe0fd4631d725bb4eb7dd753e4281035d7f624c72cdb1f663048f89b353efe2e6fe429a42eb764d8f9728e13f3da1b064ac3bab4c90496f7e08215be9061d2d29976a4ad7c32b5e86f0ec40737639a6202c685492f5dc7aae633b4385056928b00b5c8842c48bbffd77dc6f4f12df2b2c44d9d6c4b40a93c7b3d66637491fddff9ba7ebd5475fa66caf7c69283ba5ace54d18286e185ce457d4a9fe092635d1a6a19529b892bba7294e954a7d115876028c2ffa4df2d57246cc3e62b752fb0144bb902b14e69bddeafac92a7cf0418080eef36362458adc38ff0fc54f35606d662e4264b90a9733c18d1b1f693754e93bfea62f1d39ab76ce8b0f6433f2adc2dd62b857c8a53322eade3f4ff774b08c58d43bd8441782613bb6bf3a97f6ecf0836f66402de55de3ed81a8b963182c34a8d9eb57ff69c4ee88928916a4d1f0cae6fd417f1fa309b535ac5e5784046f88d47727d60dce5c18222815bfb86dc5e393fc53a148df2224ed3e4ba44094e1d849781ec0b9123c83717c6be2d6bbff96e3e5c3797101202670299578e51868b67f400b0e86e6f4425295fead42e44784177f17c66defa3c71b821c5c5b0725494f1a29f5331c6ae0aa4f2ec770c16d5c7bb4065889d5a0291e6dcee3ef307709293b31259690afd79831545846bcb5fd2b3101be836496a618d4ca82cb14853b6de07a808373a8c82af1d26b0ade6247953036f31e90033dbad82d247fd2b412e5128fb79a42c09843601e498517442accdb962edd943f79639122f64ec7226b23ad22de32bc7a79bc5a37af107cf126826e8121d399096aae5681bac24601aa2d6213bd49e8b4a1d47257a004d4b37cf8e4afd27d3c88f25295d71c4692da985c8a9a57b0ee7ea55c3b2f6962a1e9a67061e1c8106f0340711db2cc45a22ff2f62ce3fc27c0040ac625e11b70443c59b8ce3b3e466ddb95d60c2a0225274970eec614b65972bc69bdb783b0440b77be8565611af1887e4ceacc095c75be9fff3ce05a2fef1023667ac2c762042dd9d333a083a13c122ec7d18f7a6b30a287c2be3a1241b16d9a9ff183faf793572eaf48214057ee6aa9a9ccaa8117b38bab7dd2b591b8bce00290c26f4e80dc15625d342c4bc1040e23a2658b605d7600d33f6ff6224eb9d7b8823655c3e79e62dc57a60d030136e23399be0c602e114245e872405d2af7c54b288ba44a64d45f474ca338342239a83d9c2882a2281efdb3d00c8e5b1080f684d10042772377704c6c2b2529c4fecee862c25040479d4d3c9ed559f302073810c78b57fbb561f817ae2349f0ca41ae4845f457926efe6ecb2bd66528fe96a781a948b8dbaf95c859d162e6200abce4aea4cc0880897b12e9c4036b8be8665ac457c34b406286fc98975ccddb2d222db57b08ea74f5cab278c4c3d744fa95115c3ace3e5856280b99570f2b198145598944798b1797b4e07613a1c2bb877c6c8c6b0f05fa6dd250df343b6b41ac428c5e08fbad57de84129da66f2aa75972105a30597071e57e0f1b204d1ca1dd0a3622d8475522a7db0a881468859194a5cbd809034a01467981b7ceade0072a7449d11330e23cea7d236e272dbf6d28f3b2574cc85dfa912fca305eabfe1a21f76719430b620195021ec5a35c931ce97f98db0d2d8d7469e413a17d4008f8e05d8c1cc875f84f3beb1cbf117fb62248a99bcde41e0d3488e0aec2f564e078ff5d74dcf4b315641a8506f23060f7995d24ed90c45cba44a50478bbdf69fac05e645e507870e2df3f457d419fa68df810a13828ceed4cf0fdb78b6ad38a479891cbec9bbbca1b9b0154a3ba06ca15dd8d5bc26afe01c325ef5e02023536c7435a1319f7802f27b4890ac4cee89f2f561ba18edd789a520f10b83b8203026284924bc12e08d4c2bfb20af45294e2ae02efc02a89efb8792541f5302255741fa551410bc380ebefb96b8af43bca485bbfdb0640ff1351d9bb26e98e194142683e7d38c135ff9d3a6bf7c860693036a48eb6afc850dca69adc51f40e916250f036df6aadc77f71b4bdd9a35ef133256b61096badcbc61a87e186ebb115841c99b78c1c27156e6f7a57e2a3cba2aeeafe3fb6be16e573b8a595b788ee214a4dcb0b8339e5bfd6374a235df5d9209b4f716c403d727e930e928256ea71c74575778f44ec56ede4309278c46b92e6d469cdab6682a4eef0587c59998102b89ead89232cf470e6b60ff1cecbe97bfe94ac86941d765f7a53fd84227996d2ab84f5d025d4d4fb11bfe01548b7e1e83fbdc77fa565e1a62c24264c8baa2ea70b382fa8c0a8bd68f9de03a13971aa7310f57cf1d2c0b84a5a8059a249450ce978c6ab6bb8d85704e68b6afba29f71956cfd971fb3471d751684e39c0b740fe008ca7fdee878b0f1b95aa7cb42c52cbae7b2995de705a3194bb310ded7c89894a3ec73978c4355610d88b4ca3046b96b3f5ee225efa4bda4cced86786b9ee90e54972dc102540f523fd9b124ca3a1ad6e374e257f1513d0a563f62fa2ec97a32c7a63fc8ac9385644ad485cc6922be1b67a02875f83470bd817082a445c1df8d7ed685bfbce7c6bb9ae63b296d432a11174c8ded9b25610142a6d9415195bdc35fd623d0acac19029e328fd218738dbb68a0786a8dd51571052e3b638ee640119fd978182bda8aea607db79f225ac3287040ee459d5b66deb1e9928d1f3f4dff710443b7ada691358189e1bdde5f871bfb58c05d5b596cfeee84d61932fc6b577a7b8728406dc176d4b040346a32044d50037b2869393545531e8aa88da132d650032f76c0b000d2a28da8060a691d3ac3400263febde95141844d6c3fb49d9fdfa06210ee117231da23c08a40579c88906876671049fa6f211f58bcdea0fe735d15af8e93ea83ba7820f2f20c14424c2e2844eee2ce34257203ef2a8a631a1587ffde105ebae87004a57b929f7d9aaf8c9e0df945e50d26dd89692d72e219a84ca23636859125d8b33ea233dd5f03d2a2081b5eff30e42e8d28ee07c8bcd96683fd0b958b98eabb00e30953d3dcf38ba1f7ebc8c6deb2b8ed7f084988dba0dda4851b1f7e5990edaf67c465cd005adcf0767c4aaa115160ec87cca9ec6882d2b0a1cb545cb6669593b4a68f771a6f6a5917d23470473ef67ad0e8cf1486d84207d081261c4a646e46abd9ce120b50d6cc0021d704e7ddd3aced37aff448e6ffa853928bfdcb5c03811478d09c75212c3fe6ad37d9502a02591003729feadfa2222b6e65185caa1e366b058dcaae60553ef527c7970113efa3f7c57fc9fa61b526ef6975855909a5af2b09cff14884bd7dc0298d3b682aef2f691d5a63776af9e56ede28ff87f7e9aeeec5fafdc895dbe9606230f678a1e4affd784efd33c9b7cb2cc76136c71d676e89d3724bf21bf3ce66ded91f59dce9c99625008e4f1f06d2acbcb270c1f71328b2dbba6f3095d560c998c323a350586f6ab09259a103f557a5cac4dc4f77422003db288dabed7fceb0b3837f5146d643c1923efbd2d68d015ebf3e35952ca6778ff1e8cff20691fa5a6e19b7576760195ff7013816861f0bb47ad1a48dafe7f7906780ae287402d099e2ca01e3a3d62909f4d5433bab147963f06415943e5013d2a8c38d758ac325ea04eb65529c88196a1075d91067461ee8021e959f91428931f473df845e71aae34b9219836c751adccd4246a80a29dedbb3d5ebe7933c7cea633f166f6a47cf68d31295ab9ceadbe0f5660688b7132f4851b49e29c27e7ff478cdd49b31a7bc6a3b1531c6a7e5bef0c4946e3290e913d5f2117caa7fb8acf25e2b75b2530da88bfc57430965ba0cec23eac60d89ee46904843bdb981173761408989ebccd5fd37639d7d5458d7487bdc6f8be41dff8456d6803031c22d08af961097e9bcb027b5994f4e76bd6feacf3c13c3b6b9790ce00750069291fd277f49eda82130575192e807908ca332403e2ae16d426e994a5b0662ff86e2982fb4f411d4c437cebc13e3af436c4d65931f1722a797cbcfd0e6c64dbc9bceadd36e86e74aa2a86992482921dc53f55b9bdd1834073d03bcb73fcdeea634eed511286340099acf2719b8a1234e67d1b43d8b053227f4c430094984f4d25a5a3a427002003ab19c224817cfe14892c6d21f2d0fca2fbe89c68809e751185e60cd3ed68f9e674519b7d4f09a7dc6a3b1caf1b52d8914226ac3fe73184df1f899204a541ae7b6bd2720dd68632fdd488de8a37eff89811ff0915047f07a8e42a4e47c3de8cefe13007a254af0f64c2901b1a6d5a7f38edef0030f317e5c2517edc373e848abd0be3638754b1714c629d94f61c7dfa60028cb44680a2a3acb2c534ab1fce5ef50a7230fbcdb97d769b98f144e9580b89ea8e3dd768dcf3b87de235f26a08376a7b7f256904e365d898cf8c2cf29b63e90a8b4bc708eb76a1de44c39c5f7dcea702bbf971cee20b24e416734aa5df1a89add0d6692cdecc6ebccbbfc3a628fad4929c71392afdc5b9c5e2b33da077cde2f3dfb16f125d2123d0fbbc89a3403461d14cdaa290a2b3dbcfd78e7beca564bf1660f2a402ea4e01dd1d0dd866b78cf5db8108299fb98e1914e05e81f6222efa92cc6776dab778e879af9c0ce7e477440c5fe5f0af9c3e97c346b4933b29ff426079eb7b0f66b9cf62c3a090df3ef3b4aa8bceebf1cb2d426fc34fd80e76e0a74bc903aec4c8648b8aec2fc17c981818f3d962a11415260fa8269c8ff897ce166404384f81ba1350eed8a41079a10dd2e9e013d961878292e94694e231f6ab9c855bae7f082007f5c319fb8530604e874e61901064e4b97d9f3538e63c185c594ecfdd92b5df159c6de1fdb25e7fdb8857842f3e87d18ea5cda54201c62d12f742eea960b125daf15ea22cbbd66884102444734fb5e079eb751423e9606310784ceffd7377ea0336f4d6f5d3f6c494e03fca1113406a8c07942baea9d7a24acc2764e1808069573ce33ba39f3afa99bd05bdecfc157db0d072fa92ea8c076b7e69157ba53d75a2c534a7c9b067b3e9de56f9d23f912455f9fb98fb137972ac15a336cc207ec010686d523dae236813d24708522d5e1e0c60e9e564e9b242b19f48840a0e03113c8110e38f8fbde573130548ed270ca62b0ba7bceb5586158b64d753b7a9830db83878d77b2de0c76ebb75f321e139bcf7d3ac270bd00e5fc16d33464118142159f2fcbe4a9600a4c64e79090a3f59a14000489c70e14cc30a7b18db41ff893a21b2b998637c03239bcae2059655736fc2fc6e73e56a46404e99a1555750f08a71b7d5dc7ec815fa84bf292cbf7512ead5055900472e44195f797082df4610b68ce9cff5a920fb5d0d50dae8495f125d87a8de90e3fa97ee8250e1eff4244a3dea11e9f99dbe46ab9abdd48e5aaa6476b607b229cfbc948046a5a773c508e6b3e6cd06bf69cfbdf0eb55088b8cc59557c727f3b3860aa69cb3f543bbbed87f1d0cb97bc3641bd6aa010bbf4419f7699fa32413e33805458ca4da344db32888f13978c6e142073f9d5d6130e9112312cd9d2a45002d4a85f326008b566b439dcb1586e26c9f2afa7ead227977c0d718cc89eaf013a698d5b324a5605556e8dd6b05eca67faa9e5dc77429711006f132fb232aeba476d20bb437f4d022578acb1ea53e268280de3a6f65d5a2e59f1406c590baf932f78b02f04b2c2ba23e40484e85205cce3bf40182925fc0a45fe9bdff2abeba7ef86b6a1608ddfd8f8e28c2c0494a926889726cb6ead9985ca8cbbb08d3b7326f585fcb46c1441fa6f578003ad77b234e263529938131366e053cc6db00153f54a8a01aabda3bb6a30bee8e71874168f300ee0eed1230804090d6ed620a2a0c1ef52de0639116c8a25875ee8caa12da64af313e43bcf5191e16974bb1d3ff463fe56220f24151587edce627136cbc6a4979118191af9303b75d2ab4ccb9810a17d6ad4d578a08c918830230a488cad536d3c61e5a3a9eafc1cb2a401169320f914c6f7fdd75cb02c0ad907218134600c7dcb09dd068a784f603f14a08387dd4ede689183eae81b58eabf775f69ee00e8245aa7010f43f2674a95278bf73de860bf8834c0a1d2f11ccbbbb632c8e8fc4a6ebf462b66a7f0b2c842873f5b3159f154187de5a21112272df2671f0639b811f4f4ce5e1babfa90dc5c1d6f5ca53563e48dc2f41c79f8dbe4bffbad479fba317aaa54253b1bb60416807d68f5006b41dba4b51c6c0874610c1fb5953522b9d4a6105d4fc29402cb00500a0b86068f88f77b99d06d83544871a556a363978c0fab554823ec260e2b7f98d05c3fd93d19670341a3d4abde3fcfc3ea03c9f8dec29066bc225612b651f09f9ac77cc6767f2d11685cde4274e2a0f7a7a1ee2784b5d570e7a9e4ce548bed8cd1c088fd786416ca7568444f485897fb1e0bfee75a3e305708377b83e35fa5dbd6811139c4b83a1038349b8abe20be9d4f786c7a44b60088655731f9d0aedc31953cd329d3412c954fd965a18cb084d6c3b20507b1b0211754c7b0c6b751aed8b3424f286e94ad61687cf6d37f42aefdbf9daab542cef2df7224de6cedbd7e7670340f6e7f4170daa091445c94f9d1bb752b04ff300ad5c500a300c85e8c03075bb8e83e882367d51205f95094042b482daf1509e6b7f3f27c5cf76b45f298e58d4948d3d04e59db926c0e43dab91eaaee88b2d6758926783ea679d6f69ad09a2424858508d3aa46e8fe7a27bedef1eced7d0c79428307873467a49a11e430928bcf872d64018ab64e9432c1ed33802d044fd71df2518fd217377c56da5cc193fd942d29b88c4a660f56df9bdfdcee484926d52f139173d9f16ef3e6099e7d89653ba7372f30e5184b7f96f62e9160c62602795c8b76129730309596971854e1eecb7057b300272694c08eedcefcfdf556a6e162441ec930c0854b92806f8a513849cd5130113638aa549f66e870145d4a5ef08093c26750f9c26604bc893a22bf2dc85a521790f144e0639b0316733510018cc3fdc7ee76b408148251b0009fb3fe1bcdf7d5fa3199c20964231f73d029e09413daef54323332dfac7976feca530f2e7c4558dad61cc732896fefc1e9fb14f8a0c05d1752603a8e5d0fc597b78d7ec4ab630a209822f3dc83bd3d9b5b9da66a962cf45a576bca83270c91668d5924421d255fb13f075972c4b8811f261487010217bb3a8648a6e6c93d429fae8d460f36cdc47291c967c862e556718970ef5f3d59c8b9e0425e479b7dc960abc9ed90cecdf2f776b87bbf104417a6dbd9dbd2594cea6f2b42d4f14138aeb88cc3b9e213d8535e18f99f9472a06c9bda3b4e061f587b7b5f31eee7a74a8b68b655c8a2dd28126f38a26f6eacce27b25897232005de18c7d640d14d9bd1182fbb5315a790fa563f32bc43f52d37dfb7a85048dc00f64f00e8d73799eb6ae8dfa2b56f8f0ade579cd2c100e1512acbfbb251bbb92ea4b53ef33e5a91c1baf9f0171081250aa455d68ffc0867fb4b975dc39edc562db289190b19a12e3748e9277b8748494125b84f5111f9de2030a6c77fd2bb30b9ba4cb1aa691a0814856e038b841131ac5f059e1187389a95013775c5e2dd413743cf8e47252d4a6364269630f49fa8fed5444fb633a276c8f8b7f6e3b60b01ae8cb7e653f6cf9ff6c77896ae1d90953e7efc67ee162221e4dfccbb3dfdb7cd3ee380d3af9929ceb924b58c6673bcbe465d50f2299e6da4eec38dcf7c3444dda136eb9ea45aaa2efec57a8e23dd6b16a04942ef3c5d8295deef8f40406591d12b8ebcb0a39942d6a5b3ca5b04435b7258aaf4d854ac2249f02dcff91f4f04be8cb85bfcd870c333e81be5fd6a375eee6e20849d7f7c1eb6a5599d31fc7be17731cd5404826b627c6709fd9c766e7e042398e4c8e6d971643f5c766ba93293a04da5a29b8022fad0a907dfab14bfb6daf49be863995e3ad871c180c37ce726cf53d3173b93b4f64a183cadc3072888c9311292f078857b6550f74ef7af393e005e7adabc6a5833cabc7b896e01a7d2e10df8e9641934cb99657d5a3de2a137431cfd65eae8d5de9f24cb0cd9e84f0883a45a5781ba24bc494c47bce8ec217b97599c719176d29f041ee39e48fc92d0d9cca30ac1fa6c143ba0afcc3fe62db6de47d876cef34921b721598c409b6146313716a381e1069b998b57596ece33d1cf4c6b70325b8d79150d3a587535dab200789debaec15cefe5f24fba9ee570f0e310978c4c1b71546a14f57e264919fb8fd570f57d91e8ab0f07b590be4e6b5e0690ca52c7de1e891e76b6dd35932949c76a641902226f5bfda1026085a586bfcd9abb72243fff6da79e0d146b1c9d3a155eb2fecb19955e34222ec9a6c2913e594b8c35964b41c0b4dee80c2ebbae8ed1f6da63650c7afcbf64726401b1346c15a55c8bf262e7021687aa497f078d763a45a5e7f6cd7eb36028af07386f4516604919f5417994d7792a4c4c0a683bb305be4622ce43d228da7769644c0d1e7904955c2b9988f0f517aecac2881f000133ed43f981971c276e98de537c444f1dce56b413e1ae70aa42079e32409f0be660abf0ce9f7b92ebefc22fbaf59ac66022a3888c157161ce6ecf203fc965e5183bd93b1bd4167357eca3000b2ab75ddc94ca5b5d518b109a4343551f4ddcf2b34996aa70bacb27b3baad27363603f6dd9e62027f753f7f7614d928e30acaa0415dd152154806259d49ae8ccedc4918663a6bb2fe2739adb78f7e5aef2b8cb69305af604ecfe199e0f378352798ede34b8643abf93f9a2a9d07b898380081f29363d8a4ecbe51afca44515dfd9d841956d8be1e","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
