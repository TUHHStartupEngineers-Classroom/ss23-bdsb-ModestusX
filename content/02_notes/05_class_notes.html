<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"0a862dfc9900804617fe092c702406cc60024e1e4890f0b08da107d94be876b493e7387955968379e216d3f148bf05584382ebe506832d3bb31e4f26ac06bf638400360023d50a566a195f7b848dea982f151e7568e4a6209d36383b693c4f62a1364730471773d09a3025f0fc24eaf2680cbe5761f626a981889f85343f28c6b43a59ce44e6cbee66f8be9a322062afe678811e5e4be355bb27374ecc39c7758ec3d329ed203c627bfd2a874bc5d6bfe8516a0d4284e2eae33bc85ff6fa6bfc0ed11b7e5d9c311cccb689637b550ab1e5e50b31182ae5c1af7e9e767f58b2f11855a3f5d9aee3fcb9748ed2d76ef3b2175064eddbdc732ad823298a0bd638e22a1ab0de749cf21d287d241955dbdcbcef1ce39185a95086f0f7e748804c5cd7174386d345247c1fb733bdb46e0e33b2d814576ae4be1ac5360b9491723446c4010b71c1b118eacf6cab8f7fdc87335e88ff0b26297dc44dfb3c1dea1b862f9dbe1fab618d5b70d172ee18bb452d1bd7ab79eb5eab054797ac700e168792d61c89ba9a0d65df5bf521e5209cae17b73a04b3762c5c27be6feb1029fe4c56e523ff5d41d19e56bcdfad1951d729c2aa222fdae9c3025d0ccbb94b14f63af1a27c2f14eb73b3dc7052f11ad1324219a3169cad21f716a4b1b54a4cf41377e5a71171cd74ac98f1dc0fc5129818e220c4ee1b63e282d1b53f84e88b15843b9ed5a9248e6e3f58b8f474c67960c3fdfb1c7292246bd4cc5e1e153a1b6bd86163b6124618358ece48646eda345269187d3c8d9f480f373c37d423569f1d5c9c4d78b3c32555f03837eaacef7230f5c4d0d6f402d9b996b648ea3727817a3a3282d6da1f4b3cdfa8c1942628531c24d93da39873e82511c76a16fe0e474d6b1b7ca95b62b32c5b769c7f5d367d74fa55aeb047fd2e29500daaf2e0ecd93b2723fe9c75dddaf8fd30bfb6665965c2da02df9116a10deecde47c7390e2921b9cafe85fa7a44fa9260909d8b91e6b4cfbdb3850be7723121879e109444ffddef1abb7ee9ec7ffc5e7b04f94e09b0b3c268a86057a02dda7c89e0303521e2feb86e3d07f151ef6335ee7f68037476d433cb28373b10e4a245a534bf523b31327706430b678f6f6ed9d2c1182267818247610aa313d92c8c9a56637ec281714f3b3b1bbb00f2a2c6f7ed39543c9ce2b9d1006202af75c622967dcf4939ea68850abfe594debe7f063ca38af83906fee9307f20064904de946abcd492dceed9ce4c10123a988056faa90815c4e16223fc31d234dc3005d72121bdefafadc7ece35d1718704149ccfe7afe6c1449a9aeac270a4ef4c24308c595e355985028fdc0141333ed173121c9fa8b3154d70760cf3a7513f250027e9d491405ee9295fd083b8b4ef0023b989a630d7cc0fbb77a358273275c3a7ac478e5ab72e975c1226819cfb6589eeb36ee7ad0e601879e0b1d678ac4975ca71332f0b6598e3d4c75712f2ce679133bb2c40bc3e7cc71ed2fdc43a2efda47225e9b7d8be9a902853370a90892672337dbc45b145301c991d9a0f44cc1486bd4942f1043a3c4f853ca036156b672eaf23b4b9b27870f6868301a8195825899ed866311b501ac93f73dd1dc70bd630b4c8cd050a2d892045c49c0e293eb3b807e1260f4b6f4ad243d6adc66f4ca7cbfe98365e0710858c17dbc9661bbe3d962cb849e3b71da65e3e3c87d5dbbda4d689a79f026eaad60e4bd6ea17b6827ce93cf3e143f93fd6dc8276af09bc0b18e9e56c6a384b679918d1075c084d36629b0a61fc3c8420da4eb37af6064dc7002dcbf5295fc1c6ee7dce31f22942864decf14f08635483b9f66085d30940880ecc030b39c0f898a42ebf4a5a5a2725e6a594bac11c02c711be78a830e622efa83f3da591e2f2bf567794dea795cddefd5799c9601ddcb137886de179d975a18517a1932d7b5edd0366c1c04f29b2e74952ca39dbc9113a7db884b70609a63cf9c46ca14c29f3281d7830be5156dd11ff96866ec4b0a0f9ba044968555cb9916878f5cdc1dbf623497518d64d9266564a85890914d15230331d1ee63385fe399b1d4475ac5e6e26245a48a83e459b1ddebefe32bdeb32fd136a3774a85cbe84384d515506c5d85def97cf830fae372ae94eadd5ca51f0d9481707ff203c70f1b57c2935ba80ebfb8150159bada1fd8455c97d1de5d709dc478475ee4b33dd338f7211b5d6a46298ee29a3d5e5a6eb1c4a51ceced6cb9d99aa3454a58dd28ab9bc143a8df94c97cb6eb2b81734ee8f6588b0fb9f3de474a519416a5737139ea1d313912660d00e6d850dd370d8ac4223e736c99294c2c46fec4f2bda9f7228941a9d4cf667d2e40e522a85a4b515ed98e90590da4d634c5e869b022cb9fe36bee1455562084faae5bb4d0d2cfa904d54e38e35cd2dd0e60dcddba60c37eea4e77053cb385a2826a1c87a8126e00568aa8c79d034144c2c8bbcdbada85b8e04ba06c1b88bcb76bec0ab9b55036de874ab60ee5298b594662b8670c9d17594e8a3eb43b9d3a25a1882572c257a1b192deac8bdc078daa6f0726c4317f17719e6b5f9380865b82b4137ecb9b07c01d975cf5134f6123081e76a6e129929bf20679566b2541e7392433d09ed1693f4191dfe894506e886aa1b6503d80ce5e3b1a898885487fc98caa17e1709102d9c0ce48b2ef549b5b01a95db13406d9400f676a1c0609ea42de0d2a02c53144ea6e1f7c7e541dc1174da8c93a6aaa60459cdfef02db62998754da2cf409f7b50e1c4ffe21d483c6e7795b0938d5b61322ad0677886d0060b85b80376ed7f938d4c4a574199b55f0c2ac539979c7892dbe3868dfcc1a0608e8daf5aa076a301222ec2587b3898169c17574fdd0fc238f43220fa9bc5ab9f113179b0b1f532ccfd31518a020c6654da6d6ef55c414017902cc27eddee87d6f9b1044e1ca2c0a9b626e5df89b3339ce780e1e47c5b69910f4e5f8b47e0c6328e289408d2b6e159a81b8a09d567260041c9f12561b6d4dab6e9fb60606e5332df893d5f02c2d659fd7acc9ba15f31eb0c4a02aefbe321a21966bbc5f6495e9f4495e4b6d185726248a8554b11059c6e7f9256e4572dd9279143bc191929043093b98fb02e69e482c54782480ba042f97eac4afc15b974075e16635e9d4c90e9b8c27557b1481f8672b1fbb0ade06560607310d4b9189b1c73c1b30361341834e7864524e79a6532d15fa5fefb87030e4581b9645d1b576ee75eefd9f145f8261f3b7ff18df68aacbd5e9d83e88df03877fa79e8682925d70e8b7fdaaae1d51b19f22e486477f36b6847a7243d4e8e26288391f89fc58d7816b7b87c4ec58b2ae0d63a755120eff1628181a62ab1681cd7967622961ed3345fa9b6e7e281bdbf23b2eb3486dfcbfd8e79a0cbe7c19ee1d0741c2c615b54fd8a59f1747baef3c45303eb007d3d3cde5ca352091dfa5b4472ba82f28c950a61ef72ed129d083024486c9c1b100e842fe4ae06850919c52d981a33906ef52be56f229b4199b146744f41b03910fd232acc9d97eef5f95b6fc90179a62e66555ec4dc6b42b84bc30898aab47ad49e12e5ac7c8c904f06836c536e568140a10fce742192d1e210b56faa66d7774b3fb6509cdf2a4b57044d381a1beb40f5f72cf6229e5fc68a7b58cdd8124568e97cab89eceb2cce70c46804aa3b3e710085255db9e9d9ccc13352e70977be7e2a078a7ff901c1128c53b6e4ec66a5ac7ca8858d4331cc4da99227ef5ff7d7bb0fccde29850256555495e3816d9845f1df5958b39e19e3b472e62b98fdeb2023a05e50695a32ba4a6328eb67bc9b10a753acde05a395e5dcf91a0ec8d1876caf7e934ff9e84dc53b68d11ceab0e7eb21d5f3d5f85868a74a634f1fbab86c555c270b16539260ce3f65abc22f0909be715b7b4ee9d8f3c6ec268432ed6a6562b48dcb0e37fd648e911c9becfa57e736cefbea874f7a4f2dc5798ef624aac6d669a829e7996718ca36e348816d64166de7224ee1755d234b7c98e3d03270b71c941290a2d8f69a627c0c672a78603bd8caf7d3e1274e72993461fc1cfe54ca5554fad4f55af156eb3fbbd22f80134199f097de24bc2a0039c8359f0a0640a0637e095dda9daed0ea9f73c609478d8fb1ca67589248e3b30efa67ea420485f1f462800b062084bb1df3542c7288e8355a11549f423a35bb9060d989280a4aec5ce9c07d5e18c2c52b0bc767982761c907e8006ce233dde80bfcb896870ceabb3df9644001d85fd117726b1b203fab8b29ed96dc5f23afe4189309f903bead266036af941981fd64862c4668a6ddd960ff277d817232662a0ede9bddc888e9493ec312ef76dc68b7b27027e84cdbdbf845cd1f4af089cdbb84c6d85a56a71f0015b42424bb22af35b3a0e9f92ef2c3e055da1a45aff9e3d19d84710f00b5d75c16193a3f17f9c8b60bd77623fd5ddceb15fcef442c5a85c06774542ecf5579e9f2cc06c66e89093c987eec55c8b2f2a1b359f332d8ebdf1d256f9b239562c92c37f5e4c832737f803a0b3c3c06699d43d10159d6913e8fcab5a3807fa662fd1f16a97e17ee510befb8375c35376f9a4b8224ea1555ccf9666b5098879afc36e5eb20265a51996113aab79350560e3e1b6b8bb6895b85d6989a6d70048f8d75417ed61d0ef9af7d2afc6ae69d574d0fa2758527daf67016b85942a84027a970e73886c2977015472692f61b7a7d241802905c48d16ca8fa79c1e30fa50a63d5ba205f711329a35844964be9139d212defe6f990e9aaf39d28a08dbb80ba7ed8723fb23fc4c0d147587797c64f8484c991cac8bbb5eacd71f30ac627743a3057a6bd4b275c435eebb948b3018ac8130c691a30e859d9b99a3e60525b359d69f047379d5b4ead9dad1cb5720bbd833dea17cf37e2685ecae4235fd5cb52d8f8890b273109f9ff792fb221ed1e2328030f9cfe40542450c5eb7e59e480c8c51a3b96b3488227f5d39015a0c8ac6d8010b75d61f04c867876a5073a6b3cd73770df392738936857c24a6d4492ae3bcc47f76370eb3a4ac5c2e1340c81b34d10421c5958de63c63dd7531666d977667f25473d3e140a04bd04bd6a28b70751fd5e593727efeba01e208fcc2dcafe7dda90c1649a7d456b01d139c8bed19173dc8947c745de00526cf43a5d5103eed665f44c4638f7f25fe706473ef3b379b6ee7ee0b49faa4cbaef3d512a7f896b6c264fc91af88fc48599aca588f192637f4581bb03d55bb7d788f73f6745bced955aad4bae74ef6f96831dfaa58c0b3e7f1451d49e23e2633f7aaf609c3897c59f272678ea1c1856ca8f614d3cb343dd2b66f596c907daaded505b4b004ca1e6325e1fc8c1fcadbb2c5fb3a8cc0f36845decf7eceb7ecf9d15daa8426ef9b6d4257c6baec37d5363b2bc1e81abe235882ce997d51480d5d4c690f563bb3fc2335c6412476ddcfd150186ad358c5582d6c7306300ad330c72bc03201aeb730058a4d4e448a61d120df8eeffd9e230f085fad322b61560520cb1ba5dac98f22e45abd2b5dda48b812e398f03aab6f543709102aaf2b2e0582ec779701e6c94685c9fc24f3638df8e3a1ff44437100190d2e1d82bd54c86ddaf840eb5e2e1eaa02784317074c0fb09b2193386298adaad68e1ad9f181ca598e55a7ef311e4041958fd83e9d8b9546eeb1c207ccf1742d52812bac41c6c2f020400e823dd1e09c5b1e8965060807173627c58cf620a1063a00d1a0b6b6d2a05c803a2a2c8c81d0af3189c890d2008e382a5122f4eee580cfcb2f609dfab9e68224bfb6d15526713ab9b18fae75154ae15c53553d3ab7e8b08fa18e898accbfee627822618b4ce890df45ab2bd5c9e33f89d45d61facae9fd809bc7101733d553b08a117728108c801cc58b1c0a4fe4be9c249ddae5f374434cc89c2febacfcb2629fd0ffa90b98497d30c9ff18f88bc77141494523369eb28bf8f1ae7a1f1685902df1aed7d0147cad68e547dfe045ee65104cf9d271042836901ae583eb760fcfb23bbc8aa267b7897f30a73844ea1e76c3e8dc2661f9965e546b44d0fac2d02fffb5f277a725f7907cced7784e3d2695f57e01fcc77b34658f5af8c701212ac17cc0a3fe88ee5afedcb313df67c3684a73e55698c144b866d38b3b130c69fe4e239c7d61f56810e6f223da4bdd5b658d944cbe0c29ba63efaf76f6eb115ec2b825aaecea6238e20789ef1fa5cab0bd1094ec7319222cd00a3795a44e3462c0f809c6ce5e40663c7a6d14383c792461fc5f98f5305560aa778d6cc9336b991a26584548577695a664e54d9f116847919e665da6576aa0bf989d480180c7aae9f0a97bfc7dfa79ec5845ad92507eb99b0ffb58f7b9311e7778f0ab17696605affe3a535607b2a5d4d486364acd7628f01a2fd607a53c8e46bb948dcd542872a1eb165b902328655712094c95f6bd1b006f54da84a2bcaf3c8eef9816921e8d7b33cbf381e957cc661f80dd389aa967390bf2c19eef3d2f4723ae159b7e98db79994b35ac12cac1e2a5915c9b9532cb35d6dc6b5ed1d10f230627f16e13e6b2a193d77642cb15f08c7818fa6e6990bf23170b88d84e85d90beebbba68741d4a38a6e770e6bf714382c873ff8760db64abccafad8eee2c841f114c2c01028fea55e5b21f932e9851b0dc55dda6a09f62ad036590892d47821e3131adbe788a2b112fe8d37479b65ce4bd339397780a80eaf5e308aaaf74041156d5066200abbc5979bb183531e76a6bdd02d9bb75ac2483edeeec93c35fac883285d498b6cc02267b624b968978e6a7fad2e5174ba9d76ae1f7cfef1ef36e47dce18e44083553bf92437b6c75dcf5ba0905fd038984c2bdd89585a91bb187b7b07d36bc013f17e9040ffb1c6f0817c33be47c49ce643920ef2ec28bebfdead3df1cbcd8cb2982d0bca93382047c82eaa533d2cd001d3391b9a463554c5051c053f8d3c56de0055a47867c9fa2cda6237796b52322bce9923422ccf3d7da095b06b57fe52eca66a260dfb4e9fd801883b56baec3000b6f1d644ed5ab6d17bd0327ebddda36b28cad5800d555c8138d573b3c06b1e541cff62de2a2d257c50b5ec780ec8d07845302e609e939aae97c29d488d8908701b3eeb1e6b567f2e491da1ad4e050fc0c3988e969bd4926d6b170081f4c97ebb9950895e59de78b540c7c5a425b05e5efe7b6387dfd618117b7f339da013a339692b30b5ed444858003acab81d5f997b14d32206716b1d8f254414d575c0b4f1e69a8bdf1c4d4b0efd6fa09e6f8fbefd4deb96ca6da994c0b95a758cc14f00e07cf9d23aceef514792dbbdfaba87de3b086d2f86137078d2591d056a386e9f7ed8fa9245fddd1cfee1a3adaa1d60265939d4256cf3cf75c4efe6a77c7551378312abfedba404fae57e6300608d37500aba6c84552fcb3b104d22207b9b89fca4d45b3c0478d552f51e6349d5fe3620d6108c284ba914e03b491ce76663e5603689e900ba1d343305f11525a92782727d7aff9f18627d7b1dec759e880d6722fbb4fe9f2a765448f3331e9a7a5599c23152eff63174a115f32396b127731e0bd9b13d0960b7101bad604280905ba7dbd473f29f58d4d9d6c19072ba3826409a6b358eb966f77cccffba740050605f350c17a5877e7c79680610fd7abd45ab1a88331b008b1b17f6e84b017b504d3891170ca157c40c753375695a2ae7731a0e4da53054390a066bad02605982c1b56ba500370cc5f4a4849f07a87ab66f7082096a11bf2c4bde4ab5f696318f99677da9401e4cbc914166d32f7d4e65e222211e76525eb11c048fad43f66a29cc9258427f03d3a18f90131621cd2ff229cf98c93eaaf8f6636b973abc3568d73a7b9fe1f4e22a044a63116242ee647c06d0a2cb9d7dd35c02d0c79d000e955a27efa8e7f48a3f0d65eae2fe1f1a5be5759dd7dfb0219ae2c74eb70819ed50c8e7b5bb45a13c433384cec84e09f627e86b5089f965b0b1362732e3110b17b93ef04363d2c54a38f4ae299660e7ffbca0f6a94421c24dba3fa2440b3f60ef83f9d3f6246778ed26f1de49413360f9ba6fd4a2590c94c54aa2e56c25ec6748b12a60ccb8f1638752bd1d8655d44fc23a32ea0497777d0f343afc94d981223a89f80640b5275c07dd26d6ab917be9c383c77bdd6c3752f5f16a00582885eed4a7d8d2e81ce02d7cc214c026c74fb9b4c28dce81eacb59831254349af81cc2d658c23b902f7c9b3d660df70459ea44659cd0732a111d9cf5c088df6d900da6574fda892d70ed83116e748304f96d6a08df16d8282bc18e5e67f4dd2769bf6baca5b5d17f3db11fb67054e1a45ec3e84113619551f150232190d79f4448d21e50a94f3ec52ec27ae7b17811f3543b4d2c9c6d63164d5c4f9991bb2a504c20a95c53c6d53ec5af87730e4e36be3c68f63e7f8a0cc7626e7a7c7905a4996ceae529790353ec6c37f125fe02a2134323fd2019cfe038e953eae00ad3f8399ecdbd6aea94ec094d1d25e8e0654d044b06fcd44424343198c3af6ec300d6e451f6a8f45e9a23ffddc35cf176ab725065a7c69d85ba92d18a80631e483fbe00efde5386abe0d628e51acf46dfeada4494ff24bbf35f785cbab51ef8f6750170217cf8d828c8117dc3752e615851e2441af71c539ab48a2914beb84b6e5922f288c4d6504a4ef07f46ed5e65fc59afccde98f722747bb623e7fc94dd03535ef57a4ecec8358178657931db45bc117613ae778d052dffdaf315ed5f98eb40937499dc4c8a1a6b81b1b127ea2f7545d3f052a4c2526e727f8ab7c6de720cec905682a7f609baa62730e9a48fda73200757aababd7bb8095bbf874b9206904ce5fb58975e8d6a15b591c149a74635a9d6dbf101b01a361b5815e10ee54eb0448993b6f48f79153fe5b9d9da5093be3aec85387eee599723333147ef67c3d77439dd021bc6d2b857284ce8a1170ebb63c185a4d8ada149f929fb8439957a1ae0323f0155b46d3b467ee1dfed8e32f0f94b1deb2fa92c29142dc91a0b197bc7707e2ab439d8fa68b6a359d8f574a1762b898b42740805342e3c2953b6f34db67896820968c661f094d218d71dbf3a262d4d1d234f40761c28d53dc4a8666410fa4cb093a0c3328b1171628ca23588ec3dd2965a652a17dc03b11e459a8a54fa9c3d97a3f4dfa31e4135dbb8ed4ae15fd5123c86cc28b8b28ba6168bed1bec16e544043dc3090c6ec728f8607f08af3c8d411e5ce7119c3db8ca26777d2b3ddcc554b8e29ef83fff7c2d69f1b68d1ee25eb989ab4e7397a59d96f1ebcf2e4e241db310d7a0c480ec6fce1d533af2eeafaf5f5e5dd2a07ae0b8c59bf2270aed1ab944315c62dc1cef1d5716ac98b24af3281f95332ab41aac6035a2bb93abedfc734c40bbe72513b04b6aca25d5ec78746512caacc42859fbf542c8019b4139626f378695daf53b3ab085a215222ec690f44b9217baeecfa72a623f51f585fa4c477ae83c6c03cde28d179532ba9032dd6481bd360592d84fd15fb1a49439b87d841f503f814fdf7b523674c77fb21ed70f5ea406c4b29de3f293380f4c444e5a99c66cfa5d857d17135c550b9c57bc38d018ea5aa757455a9995653e0eb069ee5107472e60e7b924ae8bca742e063960d65f5dceede3de63fcd685bc111a5234eb98c44a3b80994755532d8c6c8ff08fc6a9a92cf516519fc3b015c112accde6b292089df29c1edec15c9133e72a2fbd021a0a56ead6e84be5bc0998b688dacb73aae979aed9c16ab119e194f05d258fe9f07e5a9db91bbc8aea157f0dda811877c6a6abad4d56bdda75592028dbdd28ab8e59303a9359fee3ec8b549cb9f4dac084477eaf72adccfc7fc7be3e6edd70cafc7b2f9dcbb4d8a7bd90f6ca63bc6be62468c6278d867e155c54bef17a8889d7f965df2630e0fb96f33a439e9cb459a2b44bf0d0c49c4fb4bf8183478a9078360adc40e896c327dd8e333b3d335a5a730ce911ce6756229c8283cde0270b0b42cc94897a9e56f41a737da03aaca1e703e2d165ef54460432494e0fd4c271a845d43f6832f74779fced76263718e6fd0abe996bcf4401dbe7e8e19b79e8cde26f0c98d49f6025d4893e04571b75df304625a415404db5a116fad439a2b62daaa8c12a95f6cc8b37da87c968f0f8badf9d209abc6a0e3d61244d6194b73b6ba1c3dc63b25df02ad6e8a012b7d88016d58b26df4e70ff7040ca834ffec0532b37615d5203c30c924a0a23d366be168445127d8b4ff8c0026492a611a0f904d67337021de9c412fc68057082f252917414fd3b571c7b58cb3f6eb5d7fceb2f163104be4449b059fd92e2385d46af6caece80b0b0ecfc297a58ff4c64137609eb2bbefdff6d374abf7c6612056637ebc13aa0f954da9a168179432eb1c8281c1125f860da1620187d8c9bf9e923b50e94b425d4c95f03d4166704bc6e04601654b7159c6affc50d4db3b0826e58f34d4efc84d0162652402092ac104a6b2ba6048765c12640ed4f3dab04ca3e1a89404097157253a65bf09d0c9d75303fa436bfc4f26e2f7315fba84ae1ecfad34160cc3670a6d7020df2dfad99d7b705e8db6cb70e566e00b54e44fc021ac4171602053b5011dcce2d1f143a12c21eb3392d66929143ce676783bb8b5d4cfcaca21f46784cb147e36786f6696b12a81f0188ff259c7a5bd391bba35ae28b6a6816444ca8d990db3f6ebf2eef92c86000523b6bbf3be4252357fbc8059e236300daf04b7cb869ec3d07c830e23ed6db9568f0497967650c8745ca0cdd5c09e09ebde6bc9401b8794bf36e29f166c208b80cc3689f99fe2ca72525fcf03ba1405ff21a4ebbb729f3d94bf4fc68c5eff7e113a0601cd9139a58dccce0bd680a69a976f5c6c6774a013536d0b2508472ba00725c109503ce2504ce3353eca6e00bb06b2b43afd03f153149f9f84e39ba109b18fa4f87d18763f666b5841324ce4d0fea377c7ef44ffd49071d784cd107943860d0f4613be861cdc388d1d4f81c15d8781ae8843e37b7c487f42b2e4383301a4d8b42d38184943acaf7c8c0b709f5c78b40e719f91c9539601aeee633ecf46612197d9ac6a9eb1aaa3b89cb820fb1dc0ed141d701538b06d0b19105f7e00ff29f572f9763ff73364f166c02c7d9662bfa1f0bf0dd631d75f720682ce357af199106ba36108bf1a780e2c197363d59e169ef3c84dae853bf5b6677e5289db2376d457122f2ecb559fb3f7c3fa59d401b4a5208facc4d2569d4eebd0c3861440fcaac42bac5c11de52738291efaa1e06a4119a51c70dc41012595fd2e9d9b047e45313334c00cc4950eb8951b62d31d95477a20b67ab4cf07640da754fbb8cd69258afba4a877cbe035c2768125c2fd1ddd255818390236ca7fc0d6991b1146efaaa4f6398e0a56b50eaea131b6de20b99ac5cca1134a35f9c90f9687bc2df9360db62bce4ad651654c022dfc80c4fa83748c00985b7cedc2f2e7794567f82f4c232f343e2b6f11ca074b009aae496540064d519daa1caa9feafa11d09100cc7a4ae1815c8f35f2e5eafbc3978a4840153f26f8cac22111f5b0b5d7123ddb256e24c07c3a02d163511f124c4f8b82dadf49c35669507a5563c69bc7c92cfbe94d5a49c3708d6e8b34ab0bccbcd249edb4ba564c7fb2a8fd88572b0a9d352d491a0b971abe5fb64658cd225859c15473c87ef6adf84313e62ee7ebb3b7e95986ce5997d90116494027f7e8e9fb57fa2b6d0d038fd9b4ccd9b60c3b76af12a4d454645f27a1dadefec3f64349de683986b6f61f3552111763ff91e566b4029533e3a6db5eec430ab8dd8cf2ed4a4cea8b1e7e9ffd87919f5883002219e72d67d8e90b930631d8f79f25d4a61cf34d68d592d9a460f54612ae357f15b977c3072b9dc02cac376c2f7fb2c9c379eef50686403de579038736a54417b27bc37533cfa03c0cb0b47d1c235aaa8b8512093fdeb9b2437e74a8bb6a0e0bbf57956490bb3f9f5a2f31b8c184798305fd81b1e394718d5a33f7f30481aefee7b484d6f35581b01e9d9ef931ea8bf7b7e9e7ec7b8e7a2689f43acb98e89fbd79b7bbccd59e6501d2636c0489d3aad998828a847b445c9cfc95e494caa534567d81ecd6cf5e429a6fd6fbf931c5bea6ca8d74df63128adc6f8406bf8dd4f3083af5be364a8bd95920b76a0aab5e27ac6b8660bb428a8c02f674733a0b853a82281f85a4a3e1ae439f613fd65ad62845fcb964f905641e7bdf2c2d31d2a1ee8e45f972c05b574d8b92712bdfa3317905eba2a078d05e84449a7d4443514c7a221e8d658755f5790b9f5fa5551eb1017ef58651a5812cbf13476343f9ba810fa8185a6b28db9ba460383487ccb36ac8c6e087c9a5e9454eb3e73f6356893bc5b3d4f1f4cf0475ebf3263f7a8a7a29ae8a0f01e54ba554575c9ea3a679d60d9b3bd9cb0540e6313898c9e50ea604bda813fd221df5784edd28d05f36a9801f244767944d009d1e45e0e053861441f093c76327c2ddf8257eb520f86780b1c6d3d5fd1487ff64a6c555e0ecb5cafe472c0f02e3e55054bb6e546c58b48d83550291d516a65a61bf1bd6cb39e8cdae0ad0ae5b0cc114db50ee0ab9a65d31c981817b8b1e641d015a633f3b3aff86691dc48adce93140956b788e9ab16dc76c64a2409eaafd54f670125b6600a9b1d08fc8f291aeb26a5765770efc2200760d2dd71cb79c2bbdba3760b42aab4421a6fd277bd745ffdb69496ab2e333eb9f775777f573725b0fe92a9f69d692ae6dbb7d74aed48bd16996b71dfa0777145eda47ac1a574b5c5f4920d20359a97ad9f6b5d8ae715d8959396f6802158473bcae181b2e2c517c081cddc9f3b02d272588099c552eb0a7b682adec6040f0ae0ac7ae9313497e86b04cc5c808fe63ccea7efdc361f03f8b42e0c8d98706e3438d216f99f080231abebb211cbce80380c6a938e1d7f924ad408975ff3fd8f04802d5b19ca4ccf0efa2f445f7593f7c2a5c4a080cfd1c66b5449a1f076857c241d3977bd8bd0a60a1054c8032a696a94f17624c28e75aa075c64875ddbf06147f6656095dd02b926088a18311266c4e92b0db8c01bcb93648c0ee5d1898d31419a66d87895bbc831c22122de30a95a336f0f49803493585e745a81a2526b05dca892133922c9d3567b1b5e9720e28283985102f2a9b070da38331f712564291c4a16373b70a848cf70dfe92daf40995e7084a1d229d1c5361846aab3dc237bdd8f25a252421c026a83f3ebcae01a6845617a1a6c6643fe9e384b15bb6c0de0f0cca340573fecc1ddeafbab3b5e2b4cb9273637e7422d0215459395b7b3d57742a72b393b637cf432a79dbf18dab57cce22e5ee93fb4e328ad3bc5fe8a069731384681b869e3a7c1e74823ac8df0912c1203a3082b6099ab511fd3981fec4c0bc995b5eed2b2a94b85fe465ca3de18e8cd3e235c1da4fe5f99075508f080beb092dd04de372f460dcf89be52b816d7fd132f9898eebe5d4ebe4e85048be1776add12792d09456e68d1ae5fcef24805ce7172ecdadbc38954270638e1f964472ff4c12b9f207823bbb958f2f99db5c3d566612476e945175d9949249ad17b3c4d694dd1a0bf72e1d3794ac1032502b6899143ca16b1d48095ec30776b6c953676e44423c3458a204cafc4962eb3e623fe86688a19c8c608fea57e1291ea5bc1787e8510baeab6be89a7e2c707211b6c6996284ab75897b51dfb7adbbf6dbad66d4b9db12746cbff64d5690e140c83ab7555292ab9366d72ccdbef31430139e40a84e60c2f5f17ced8a83d15e8469bbd315704f90c41f4eab75dbf1af120c4006934a1afd8de34113208f99750cc24aba5b1ab8c5dde59c00d7875dd366270e8565ebac9fa2d372533268735f0fd241dde6fe8e895fb0d5bf3a400dc2c40649d165510e40b4c83a920b00be6343f7e89d2b22eaa78eebb5e164cad63799d4af667b52f22d8218bb78b8c024bb9de570a80634ccc13a5ed5196baae60c52d77c83b65f1967566b537662e633949376ab163816645a2add90d625b4d4ec532c6bc6bb5c73ef801f0c06532f2d83ecafb23e1713b3967522684aba386343195806510ead789d92fe910c2445ce45343208e373c948843211728302fc87e8968c064ff8eb8f2501cc91e3ec36c83a4c47158e18a8000a48d22cd8402c2bdd78edff99ce5edb4970640908c2758906059f553b1d340ac21424264c977dc055c67bfd1759d62f4b109daf99dedda477c9b73a028a56fbb3360787156a69dd800f763f64c355a260560bedb3b1c8fadaf9ae5a4db24cb8778043532f6fbea022fea0ba5a12e8a3b8be685b8866f3349d4c021e8c6c5f89cc61d91c6e70d52bb0f920edfbd74e15b6758cab881f155dc516d0a61ca988cb0d7659a8b4701901688b91ef589345631ec82fdab58eea578fa397af03658c2e5ff0b8b6751bf469bb51cfaea883f61c653a834abc21c70764814b2163ec24f741f61b4f801d73e78bfdaf6efe38d41120ff9e13ec6e4a59bd61d121cdbaa1e8b44d6065cadce76f097b1a1fdbbec153bc0c42d26f3e58ed19990d79e05b59b95cb2567b92f2d3491e03cad87202600d38d3e2f5778f794c5dac7f380e8f399dc1a64dde596807cd89d6cd980e90374fa7ff791b6f622316251d294081fcf92f92846148da96dbefbc396f7a83c6f9c7d17c3e9afcd89f9062f8de42362a9721c494b4ecca9b35784e562248f2405795deb71644a09abe316694958675149e2d84e532161f33e964825f64b6e157ae43bd61070bc0c1cb9f250d7fc969e64abebffbf9718adedacc1e78c3be04e570b331c7c50fe4408256089a4d28fe312dfef4cf2b2d0ef1690c072e673da56cf2ae55b8c6835a052fa157e2813e65f2ae9a5ded964d62b21dc5ef74b0a3fd1c2b2e7e0f7f0d470e1bbdf0cfe2272612df2970c3f7cf671a4ff66e3ea897f81aef62e62bd0e0621f274279667271928e0be656132d7eadd416989f64a7bd8d838dc0b6e04865dc93e927b5e3930706338ea6e4099789d421338177de21c6e5af668f22fd9d9a6ad5968c316e548ac758a3dd91cabd1f19324c8e845d91d8af2653d6e72bc39c3e29a245bcb76f33bac6124125694131186d1810ac82b25e05add65e897bdd179faa1a10b979b314ecffdb18b8751654f025ea890e15318741f33417dfb5dd7736c2f2a245aef77714fd8dc4b6a009a984e557396407b933ad6d33b9039037930832c01c785a0964d80fd7a3999b819310d0e4091016dbda7d962385c91ea9cf5d374c82c2bf3408cb6736c12034499a32f552d7d399414de9919214b6ceee040e76456daa5f2388df26590db66d1ae3f5cf6513440542e9bf5669cde937f06b73e97c38e5564c7e316846c93d16f428630a76c13672d7f1af217c13f3bf215c0cf9ab34ef1b0e740796314ff5e64b78ac62935bc9162484a1a7167bc8b2639d9880f85b2b1511711903f4d1e25d18d4828693d17ee961307f40864ed3c2e357ecad52f0fc78813830b3ba366e444ee8743a57f35253687fbedbdaa84f68fde4d7b21e3acaf76a625742a611fae1f7aebd64e9f1c89ddc0784229c34f4b0685d9eb77cffdc10ff3b60fd5bde9e637d844d75313aecd7ccfc1f519ef1b115667b50ce02213024f12a8b680b4034f5f52931b4111442c025bb647fafdb4cdfd59f351a0feabd9356cfa852c4f14c7fcfebf649fb1297823902eb46f1cfcd34dd13e040fead18fff8bff4b1fd162630bdf9863c1a825605d91b9f857d47ff61f65d15f7da8880c44066637a14404acd09f81040ba36c674a122f236ddc271bf308430d5cb847e9b86400b84b54627622da500ab3bb2784837895ab7b9dc364e3332b9c70c36b993b44a48260cd7a50f781f65a3eda6703f0ec4a7c191ef755ba458795da8799daf02536860a80b0880b6c876bcd3a7294685e727150d8ecfe4f4e8e5c6de6eb129617c8697936a2a28f8b9c65fc9e024274c2fa8a4fb7bc0fa8cf6b59827202033f4703df8018b30867e7b69637e6e5efd81d5a687fc617fdbbdda02ca4adc8bc4615b3082b8a3a77cba947d305aff25a267b5611e4d41baa50df1c010d16644cb01605efdd7d0514cb46a491dc845b1b140a9312732ae81f70baefb89364ca07dd1f43585fb7825142ed203a70598cab2d40032b7103de04e9462accf52e523c1ca7826594be1d55c56f3f1c0792732292113ed623c8d7893249c31b40243abd7c3645b5cd636454f8bfffd10ced4b9a18785728bcd96ccb6a579cb894501bc7879441ac19f89de4bde9d8d75083eef45d83bf23ec03a0f4ca667bf0e83281f484f7470ea8422852b9e5192fc08e118b8a87fc8b8fe62c12c34cfae1838c81eef6a3cebfe33879dc5c36ea5f8b291ddbe6fb2550a0cf1b86f8ac9e210afae6fd1f0e11c8a632da4291010d06a5a3afc8d1a7e8a33b0286569e8638e312d6df7d7cfc19f0a7b4463914f1233399263691182f055cf95c3d24e9a1db4e5bed4683ef57bbec5624a5668f46ecedeaacedb8408c1bad10d52013738221ae16059feed478b10666d7375461218afd367c859794c795fd8d9c590a33dbe7db8271155c4cdd5685093adea8bc41dd187eaf0375abfe136285555592455c0647b7873ca5e15093f19daeefb70216df324f245c41c2dbce64523ec286167b16988703f85b5aebf81fe1eb3b8be50ab359a4c9ab33e6da7a200d1ed461cf8ac4274d3f443b7412e80544a8bdca832169540159a604daf20664b1d990a927e230281d5db9b90f6c57929553797dc91aff4aaf00c023d245e02d7bf88800141f51607007295e7807ff1ea387c2a5d56757845569e282a101263078cf8ec40f51ba3712182f345e4f6a51b4de9d65120598061244570da58333a3a95ed8cb8b961d49ac117d1beaf5b5c3c9fcee9101373535eaad9555749addfae55abcea4dc4981cd7a01e884f9140be0888bacb5a79b7c160667d5387a0ad64372d22dd115c0b3bb7559f81a95ccdef5e901022f78dbcd61b1c121886c4733ec0f4aa0b72154646f93692c0bf69740a79e70a57fddf6352fef42b0efc5bf8b0e9040b339e50a033162ed019b50c6b4d416c235824187fdbaac3cbb54f1e2f0e11172a4aca5e076cac5a16b8cb625b075c33d82ff666fae165a3e62c08b2608b0190773f7b08ada3440e30910dd273f581512d2106466c8f4dd8a26085b53a18bbf50b44e35cf89c6f1d670b87ded387df06b93125626936b4ffadab95fde6789887b4e1d2928cde4bb36d22be418ddc001c5620ea1990e547f8ae4cc1b3aa6ee9717aaa4896513ce02ce75e9892dfa53b463a1303682a91d54a4e4148614d6032fd9bb4e2c111066ba169441cb37a7abe973dfbe68c108ffc3cb2dedf226f983fb35ac67711b612b5b5130281e00c6c05ea69e7fe39c1fbcaabd17a8e49f5369ad06ec1235f41b8fbf4c8561a2963c9628bfc9a9a01000f3052aa726c2be48f6ea99af59c30c90eb1597116a1ed234e95a0a2214d51b3406cb8abf1221e821ecac60a20e3ea19fa695a1eb089dc0902f3595c188f248ec79d8ff931af72dcb7c9b8926a2d90d5c262d4649fc8a931e87666dd968b487a65bc1151d31a1413b74e84739b97521b8d3f4a83d3096e7526ca56c26a855cd63be5eb3428611e9e8366ad66a0555e2b0c53558420e3524f13d3d7fa2b6fb3ba2df4fe04b93a957ee58f1dc40fcea3b97c27e99954cb135a0309ac580c4d881c811465f580e30ba099ccc0f52aa95c9ef2724711995c895031c054bc698a138e780930e5ec01e6fcb4df7204e6ed7e42c40be860470ec722d91c984a323ae29356c53d1dc4f443064a8e1d7fd8a62bb7aee3de472cfd2f2bff5aaf8ba921ef7951622eb9319eb0f7d1dae5307e01c6476120617a4c74ccfb50085ddb57dd34fdb3af14ce61933564b37a9039091496098f895a5d6da1b246d38c5633152650336773cf31baed92bab68aacb65cd80fc52abbb4dd10cc2f92c69ceae25539e79656ea97ec1edeae489f6e973f052c190df94718c0e7566cae8cecd0f4f80a97c493e2b971b42b3aa4a093ca622c5d0b8278356e2caad151d47201dc2d674de2c5b49a1b7bdaa8c972e04803069b57b1c330845bc39b1418218105723db18f857e645e7760902918621e74e89715287c229a8e13e3ed63aff43dd79c350c3858aa6450e898367911eb3b6526afbe03f97d6d8c43cbb393d9e00fce1bd4f4ff24c877954e3bd07246cc7f754a21bd4843ac6a8200fa88cef11c95baed615c830c3ca2c731fe6b6f96b7c240664a1d5ea44f83f0eb5d15541e8a23507b9a425d57b9eee2621f5d2cdecfe7c6c5d18a62240b1299ec573ab2e248c32b8c005b836eba78882bbb75f1c3fcdade1c8803f0a05be051622be3935db904654b17d306fc648fc56756ff1bd0702f37f85c4067572e4babca766775a5c0ce1917f996c18c77aedf6413fad9fbddb412abad3ee058f903a36e7612dfaf1539e640db8de56d77257ed803d02bbf7aa95b10032222488e8180abcc6e1ee25602a161b6088d1dccbbf251f7b8d7ed405cc62acd91c88c12fb52291460540c1a67bb986b3b42ea24bbbc553c2c330b87bbda2cd2051a7af8fd4a4721955a7e611aa2acb7ac09d2bf7f291c11019d9bcf67077fb1f231f859ee0b8974f4a621e16724f593e1dcf4e1a509edd6c19bc3d9a7bfaa94dc86a286e5ccac908892a6cadb1ca330c55be525c47a1f5a665a3e010427d79cbf5fb7180a2639283ecc380ee137bd0f045632a0d688ccd09ceb06982dc9f1c0782b04ad9a393cb230cebd356e5c93b8b8acbd9b152c6a88b8f57af911ea3fafc64f9f7d5e77c278d28f57df176a9146ad61551e45f040c83289efad83758b2498ed73826006be557c6774c56b63e7e9282a248fb5c5db9c765e90902296497597bd30fc1b0e8592aa7d6226ff559145c6cb7cb97273d58b7178175f58efbfc0a466d29875355dd907b93a31c772c998935783fdba045558fb5583c41edadc7810e1235ea67d97e59ca840aee1104c81472c4709bc5e9180430d628bf78f9b34eb458dd67fa78ae4c53656bb5fb558d2f7bd2c668bdc6d84c25015d5aba293314ae4ea67adbd1d41307ae5ca78f71d82b31647efdadb762c189f46d460a46ea545b5dc94babca838135446ee8347060e01aaddd4be506985cca89a0a5f7d11d78017a35a0fcafd718666d1058ecaaf6beb917c816a7d9e41e29677859e031eff455554740fc8a3511636a70656a89279723fab635c4a724e6b66ed7a749e67cf8df97af4aca3ba3e5ee8024b1b242189d6f4fb188736f5ec5b6c16fe32fee412a12396367d2797d7da149ff63c4ae37d95e5f44515011f0353bd4821107cd2393d0cdce8a1f68271c53d10c203dc746e8c7c7bcaaeee12673194bfdf89455e91aae2d66f7e4178a3010f6996d1b6b5943142eccd22aae1e3fbbc40495a381f925fb598c8310af139433c8ddfad939b0f0d7cbea0f285d3876fd273e8f52382d9cd68a851ff88fea3edef8a808686f1df6d5db5763e08bd8568a3e9c4eff9726ae8ee90d939d7f6071c3da7751d67a4e50d6f45c7936fa9b1729b63a40e8282a08806ff42d70d7e7756455f48801e7ac2e246a41c8d025628e4565b3689fd0845e1bccc2408b374209195e812423d8b8a98dda73287f16824560a7acb62f6589a6bd616bb25b1f29b7b5f1ac469a7ef15f03c40b547f99e184295febec9ffb9fe6936b0053f98e09d2e7ecbdf0479985f5512c19334f0064cb36de8beee666c942b68bc301b0ff9cd4e3ec955c7f84535e2fb21a07e17262c926f40125b84c0a2bd9655d07d737306bcfc89f66d45afa38e36c73bfe8f81f21c6e7555d0a5c512fa080856d832d42d58e86da59054f5ed7f0dcf28c9ccfc970323a3173376de09b29750ffce59e94e66e7c2edf8f0cd14013d79e81c58e1854d9f7e7555167a564a0c31131b3c95a233231f04bbfe1630486e6653db28d14edabb36627014128feca17a6a19fb8863776270b8eb1cf7413a61f0f45b20cfcf085b35f2375b968a3d5cb809ce83bb7188e46e805cf6ec251b56f2b72d3ea0e8e3f1c8e52dd6782ce24e7b3ffbba6630efda149ecd6ecb334aa0dcf276252d50d7094e1727c61ef5c80f7fb4ddc8315a42a34bc366ac39e63334ab4f500e307d61dce0b7d1fb82e4bc3f29d7accd3bb4273290a3fdcc1cb4184988eeebcb9af8bbbad3e9f28292efcdfc93a447d45281f74782a100a524e094b6b128f0bcd974242a455ed533d2556ca748fe434e1c67931cacc3080b3cda9954d8ebc2f8754def494e243ff04e4788ad6f46dab560e24af6175a36681f82c12c589e4c7fae0bfbae37be0f03703b04628b24e457ca4266c83895c4231597adfffba178985421d11e94d72fb12f3b21862b47de28164b3d1ab65748d46099be255114fc5a32026856fdb4076645281e6b3926b3bd9be02116514ef0a42e5d4db82435a1ec2672d7944b97d10acab943560ce9da6c904fbe21d3d584fea7c5a19a879a5d07d616d35138e7a47c22ae2510c8b5143ba588147e64d359266200acb22b2b5245e3a458ec8db3f108a95073720fd8e7cae298ac309d921832690db75228cc3a74bd1cdec9f18d8fde4906c4a05734723d65c6b3a2ce3bc4db7b74c0e5f287e7a536e883fec3f96411296001819580ee9911500fea72fc85d876cf3d84906f564d71be18b202d32d7dac883ba360f7d230574076730ade8a0ad1876b8f6accb7f6a297d939f44d71cb4852b74b39a5e7556c2699de544f3f81cc505ecdd21286a5848db2e6e5fafddae98c81e3d56f0a9b7c171e1135c2b64571241484a65a148c45eef15d52d32e6999660158f8ef820f3927decc290fad907f83a0ed3c1a7cd3cc5d9ec0e5a4686a698e083e5ee46ffc06629648989a2c0872e7d0d83e36e87ab80aaa0b91b072973fd1f940ad668e80b79f98dfb9a03307984d126b3b71f235b19270f49f2b227e9eda5bfdecaf3a7a939950045f35b8ed3dbbba1ae56ab8e3feb31411d360041c760c793f230450dc5fb15023a6ece4144c998e87c544513b94294e441de811ce13c8d99d54ed407ad4892d3002b4293a41b9cf55c2c1473314e26ebf2330a4e679d0330b98412e5dddce0335cb2c62aa3b26ace82fee5d21253ffa8731cf37dba3fda831375c8a59546507d52b15a4d4dbdc780015023ae43662e21ff6bfb03981d3f134d6f9b536e909772306dbe382bf22c0076ea03054313417a913015dde965acdd8bf5548a781233284b77d158e45782945add01dbb077801dcca5266a197315857adacb62c5378df871e2e5ebdf08beef5f392e2b2c2e4ccad1d028f45251c7ae26b5eaef9d75d37dd1f42cb8a6bdab6ee7082aab8183a6ecfc034ebc29b3b204f1c1146e80f4344","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
