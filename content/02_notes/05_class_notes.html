<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"30f256e968383b836f892814150e733a63e5f4e3d99378cc45408c7551fa3ef45ab88fc7ea4915cd5fbc3ba8133ffbec27582f91e2fa7ef73c252212e21f7158af26fb1bf121e20ad80815120ddf1c4d3dc3264aee130a0119d5220dc503ed50013c397ae1f41259d8c73a55068f941e683c4946eaeb978e90c82ad959049a7051c96c9070ea277ebe2071217dc5c34e90d1f11fd2926084dd7f66971a8131b82176956c8e7fd982d76b66f6b5fb05ed3b5474cc5610e1d972c4a4b7726f850e0d7cb26ee3d8aa1d34e1ad701e78333bd7371f20667d0356b5fc5d62c000b1f1c171c12b5debea5aa871e9b9833a20bb1804fb0d43aca6f1bd37c8b3bb37c49e071d1053f56cb25d4e9ed0f43e789557731dc6343e599b7f38f58eff8a0b1a366175c5303121635c6666eb17a0ef262bf6e705ec94a71b4ffc6f1ae9a990747114e9c9af00106eafaed8ddb43de3d0951bfa29bbe20246e00cae6a476a075e55140fb35940be7a8b57b60a51d156b5736541a5d49f9374925bd0c673594273fb854aa2351b962e352434d053f3eff7b652add98d9d3aeac21251d520a05c5de1945cd3498c67681c6b153ea5049146d055376b70f4aaad9b80200be4985deef99b62d8b113f1e147dc604deb40cb226b94523c964df437571d5eb8a35b905ab5e151d8dc7135918159969e567535a8e034418b463edbb78354c0cf635deb16d3a634b992c463d3aa10d138a7bbab12fe2bd17fefad12cc10cc7151b47400d9b5b61f2ea48a92e4485073e049b78f56b726c86ded31b09643856e8d3699a79d28babf61b6fc880194d0c4fcabef995af7131dca64abf5ba0dffd1e551e85f78d1318b49a361b5a8d4350ac623671ae3e18992b016528f82b12cb2462774d96554924557b7476c1245197022e66dfd46b71e05b479d0750378f72351c29a58a80416b57c95ec8020f3959d747aba872c7bcfaab149e358907fd5915b022dcbb1e0ba503bac1d4bd15a97d023a6a74fce5e8f95c83f11b174639634a05b076f120c7c4820b9d344a8ba6703ebdf1a79301a9cae9178ffd9b895af88a9b032f07b038e636cdb7ee6584ae902d7b44d214a73828eaa655b7ece2e9a624b4a7877b1cd784f5856ab33fa926823d8b5147995c01ba3a9049b6139183b5091f6c3599086aa144cb6cbbea175601de7da8944c1a4fa375a94b8c4d912e50fcc16954be01ca887c07a10aaf0c52f29b38885805c38449920ce1312fe2ed3b472626dfbfe9fd2d161ab3847cf13f74a1661e7cbc1e67ab3b29a10cf949e643dbcda461fa007f156657003d9b810609c157a16fe5fddbf9a109ec8a8c5c81d4827c9072a820aecc3593c0899199268354f83c71ae8f29334af650ad584e76f203d709ba5baf2b36dd34a10d2c26c58a7ca20c403ee83a2cc746588a36d237aa098502f9afeb16ac27cd02c5d1fc3bcc9781d378509927ddeed440c29cd46e73523cdb2132662865aa1a92b4a50f934a0947288e5ce52ae81dcf48eff8f3cc0e013bbf5572ded22785a7d183470bc603baa0b9b4ebf2940e5a4728e155f70013babda86db1c372eb8ecfa1226a238bab9dce9f66d56a29de01b19e43c6e31ad78e74656bd370de8b3340f287487894ee3a38850f582dff4a25e7257df2b9a3306a66205d249a3bc19212aba3e007573136e55d87c2f2e322daa65979f4ddb8a6d36f94d132c86fba0d113c48ae11105d7cc6ba87fd636db4182fc120e63d9dec3a7029ee089580fc25f053ed789668b1c77dd47e96413fd1d157d6e6b0200fc8414a699200aa46c25788ea78ff6e6f28446311f9905e5b25bf78fa512366651dd1e087d98127db85974e0ff474f1099785fae7a82320b26e26aa0c1dae76e80938823484f3d0ed6ee45fe755fb352991623bd95dd318c9cc54999a38db3246e2d2eebdc832b2fb8359d16795d24a5e795455cc42d008a70ae9a210884b8ec242f00945b7b7e4ae22f2d0a5d6a1be0b03ecddc9809b514574e06d4a68cea1bc72fccb7aad8d03f6087eb5d466a9629ef549bce0b950920720f15d7db29eb6a9e59000b5816fc257f6f32daa090c3a271385688567957a77fe7577dfd35fe75d6d43dade065c657298f98a930b2ec9b63a4c43bdbd8f1527187629f960147d5face7dae1b29f3764f86d7794099f6daf43a0b0e4b371c0a0e4f5c708a7217eb75b5e87797cb4374811d4f67c46fb1f4cd179d9b9ded57f0dc01365348c27634623203faf9186db0b3e151fe6832f3881bebeda074059cac73481763dcebc79d376b3408b8b846de285617e677a6b0ecae0f6b83851fcec39c7975e392e3643b912858cd12a9dac10f77ec8147fec5fdbcc1d1d4f0f36c20400ada3f1bd846db080eb0e5a6a779affbf3bd780e0358435681c4ad4ebeda9c7da422ea617267fb5726cf9c9588c81693b5b659b7f2278daf6c61cb427e496f6cd5801ff9286967973047e7872c6efcf7a4d507966f0428aeb3ac758e6d66be634abc20681a170beb1a8f67041c82f68ea51c24515d70aa3d1bbbb118e3e0688ff6421921723f4d7ceea0c543e43da0a18b499cfb46eb205b82a9637699bd6d35ee53a5ca83d577cfcdb5fe9a19b7fca3da66bd36083256e373f85cdede358fdd86f752d30aea639975f49e2d58e195e9ca8bdad5089c8560d6d9b455705523e6bec88fa4a219561367041517cbe0a452c44adaadaa99f238e8c55a279294c32ddefad197b95e64117343f1623fb2ea6d18e8f5b56a1b08dc80fb2e59cf967fbfe9c70f80f139672b85e89aa56dc8ef72bcf4df3dae5a4365163381a4e031f0ae49a8b516d7aa396f6cf942ff406ea6cb16dda4f3e7ccf05ffd0f1e28bd76f7ab05ff153d414e55876dcbadfb3f10ff9215a7bf4bfbe5dfc13d0f71f965803929a8fcc1593139763a390423d1f078071e66eb8f41961bd9e4f9ed030359f278f4f5c55ae3cf4e8d2572975b3eec596718c99622577ebf7a97b545fb9b5608e52a11d2abc4a40371326849b57a58374ce5053a09444a82ee169facae7515accea32eb04c7b565ea8aa8826c1adfe8e2c88e4ed2a9166ac0450c5581d86c6e1b25c0632c72fd5d3b6b897bd69f6eefc04b6d87a8691de05c6349b946fa9e07913ab0c4cc310aaf3cbf30f5554bd7317d065064975a1d25d3538f9427a45ee222b412c21a22a20f87815de91b20789a5848703f0cad4b5a9b4ae09b4f71d1710960a511f3b03567a6e3a8cf65ac1c3aed72a01d7a07b3cda9e4fdc0fdded95f2914e0ab22265a216feb06fd9febbfbdc10ce9d696fc142f53e8b2cf38d870a798dcb493f7321a7d50255221f4087ecd767c8fb9c20a41b5e218180f6043de2d4c6a075831ffcc7f09b710b831dfc5043b37e2eda30ef6376729626e335a38226552d50db3e73a993d5a8a6a564927cae2d725b5159276702c8921e11957c8a0f1afeb77e5ae8ca4beacac4c8fc9b9c14cfe4f1508e058d0b9a058bdcdd3c7f89543080157955cd32ccbe8d297f1781172e9433f02a33892036dca521610316b2d02713cfc11a64998f68428b404bd3ede94af5e79c1c23d70d2e7a7888c1cda9f1f74acc55b14611efd5388445a6c73289631140338ccbac883dfd46c9bb42ea61c7452a823a0468f532e884f721f91eb5be645059d9b93beca3e6c0a23d65d72887bb01ad18c6e2ceffa2f0b2e728127eac91c732811b4706655a4e892e4c6f61cae07b96e1a54d093366bc66e1040c2941135218b93efab20f973f4be9aef2eef6441f20b3feae7187c1b5fb290ddf6965a204b17467efc36a9fb373928fcb0031db895903924c045a5be4b35438072554ccf17217a4fa5d33ebcbbd3c9902bf73ad495978113172f82d8cec5fd041e146aa2a0c7510e7f7d86ed4a985beed740f8a2d508abfc378112b2e325af82a4855ce7ca220efb694a722fc251d60d4153d5e9e759281287cd9207f32675d3b491610916589ecc61e9912b8791c1802301c20182e6ae7125284a385fe16271779661c1e76bd42215cdee79d31f3961d194de81f654af5d87ac1485c190527f4867eedc40e04ab1bb3a32cd75f7e4e804a203d43863adec6f15fec88c97d41d00d3235db2a5cf603b680e76193a6a0d050add160bc5bbe8365a7f3dfcf0f1a834744fa9c0f41726d3eb8e6c34e9d07de3f7a2b2d2ef7707fc4e85bad22186c9724e15a3f5adeace9060fc7ff9cd95103cd7d73aac80259623180642d830dfee868fa1c89a30887f02f082978dbe754543bb48908f6787e97854145dcb24557ea14201a8a47f220405c85ba34fde7e2cb9e62036e02bf6b0dbd26ae73d049e76966816d69432400c00e8d648d2b1551ab241988466f7d40b8b1afb6786c439d8c8265e63d2c4bbccec48508ddee0bc44450ac6dec311889b896d4b9cf3771fc6c303b61cfb203b7e755a64e62ef2a481ada5be6d15e2fa9f6abaf153fd9fb089758ffbe1eae7653080435b391731981f9bf79351c5e7fcd6c169c19e96f49641247ef88c8507b5f904751c464a8db67867b5368f3f89ed346e8677c0ef5483a9166c9f33db025dd5735b005e1b85d2db41c47544d76e4c12f9c5f8e6ed0853995dc9616d7da34b2f8f373f998ccf280e6d89a16fea791500adb6653149385546363d534b0361619d2899a230fc667b282944aaacae138ab9edea549dd9367d461f4936734ebdbf89dd5738293a56daa37075146c4b6096257717b74a92854cc69faeaa87f591b6fbb95d4c399d07a54bcaf5220a442a91e56846b4bc498ea625f52302eb8402dbd693470d12a5bdad5de662cf5ceaed5570384563588849251141db3a8b574d43cb9fd9f5edd9adb9d67cea92aa71ac43acc18d8cdff60ba662208869772fdc070232026d66e8db11b594017d5e7c0ed78324cb672909825152c8e8cda7394ebd072f457c45799e9775db8881ff55402cc01e38cc540b3420ca268cf01327629bd327caf3d1bcaa3fad1ae0003a8a417b59257eff3977f0e24fc5370f01796eaac4a484f49cb83ef3b491f4f60d100e2789b53c3b8b6566ca7c6b487580525e50d400bce3354d17e3090a7549ba397f0f243c5ecbd7cc982012e5bae4e2f60b3452a733da709aab6097525bc1f1c80f42aadb5f875cecba0f3c7f49a0290166a5540f40c8720e53de052e6ae8a5de574860f4282b78132461e0ba6d99150ee988d1e89eebfa84fea8f829d3014343aa6e873eefa5e17b976d17650b32bc95d510e9c76165e6d27cd568abbdfd20cd8b5f2cf9a151955ba4624c700ec2afa80b735a64d399b570af2d72cfad062808fa899d3343d3ab9ef58505d1cf76a4846addf360a329d8a4f10cc907bd41553f1070e7812f14363f5856423dcc755fd9490cc5f4bd2a67d0c9e388aa037612079a8937c215cc833b368d596bdba8fc13a4b92965357ecc1fb9266065b63032f542d09f5e883e662f0dc394479e96a403082047a03feabba70468c271b4db29ae8967cfd0eb4dbb6a36e036f9173ba335f3111bcb3f09a0c663c2af0dd261312d37e3fad16c9048ced9cf81d01e21a3ca10bdeb5d56898e74d3ec8f7d61b5dbfe4983966c9ce09fdded30c78380de446e86f9a504a33e1f21d84338a99fe0979532b2e975c75ee3bcb1070af7b6dac67abf0c5a5781649c216d2ddbe049b4ad8fd741bda7f023cb197584d53e8aa2f9a51810d5267d7f4ffad1a5b0cff07fdd84cf25d13a978faaac18a19d293a185f5ef9cfc58569b27adcd5ca172040d6721719cb26622acaf2fa65c2b4b277987124c93921ad7acf7146ead1e9b39c1f67fdfdf909ebd2995e0c40452932a313767be778a235c97e97f07f9febd27723a403fe34334b3017c82a8573202e4e7b2dc6bc2cadfaa8d6ea8e227d69438acf753709a22d950fdd4eb1c13b8e959d3d65161a5cc19a06062dbe2932004b666742627f84973016387a389340ca0687b43978bee2d0165828f8ec6b8261b94bffdb471599ac5fc0bc071e3d2136f89878fcd1fbf09aaa6640c733ed1b1167df7a021e65fada19a55176a289ea0da4a5e8396425b97421a97cdc1d9d84866c986c55cad5364f3ecc54a22c3a1797b4f086676bec9a8b5c1b6967c49912858357f3c604e3f865072cc783e9c69bc307eef82fdd9a2e2c83c47fa97417fdf836c44627d11ac1ecea38d87c79b317f8b0a25165ecd8a72b04ca93f8c033652a6dca8bb6f88a8048a2fc93b3419c79f0ebd04d01cb078c070542c2d33de96bb608f7ca3e125b4770dc05f1cc5a52030056161a50b7314cecb13064a9c72cda6d45de661fc27d57cec424bf69dc014077dd7f69175c034494217055a211a103786aa1dadf38a0364e95a86090c07247ecf1543c4d7ab1dd8cb02607d1d6caae781c533310cb45763777e2e86a7457076cff0509614a79b01cd68c2be46da2885e9bad6c13923e645b1d51465cd1d76cd77de291edede2382277b5fa43d73c3d4d46f548886674ef5b4cf39734fe4d304d772769c24186df9fc068267f2a7f40656ea68fa0a0e20529b578b07646c5ed72c64d8966c21d07fc8640d6568ad12992804c58b744c92dcfb7633ab9a75ff14333d4290db78a308dd878cd48c3054cff12c16bf0aad849c68804aa44bdb5cda89cddfdd3ae1b192812344951fb8794508c48a421306d684125603b078278e22467a18812813c699c92b9ea6db22828eb573a1c4228ddf97d0fa81cdf5cb2f902d77f0cad8541569e63d0a477966ec924842d4a1925ce43f91fa88478ac83c0e1da734d014e5c5eb27e8719e2621b4a8510576781afed4a6cb0152c317ffb9819bff7df2c715004fe78a3626d1f05e4c56a578cb32b198baa7af19a46d931757574ddc6fe41067b3b7c045031def99fa25527e61591642639357041b3ce3d412583eeaa1b253613516dc728d042eaa67b6eac00a6ebaf7212eae6513528d137363359fc43574754ddb1e2c6c6aeec03e24e8145d87729da866cc9f87490da6d54d805f11a46a314970aa4db1fd217db67c12fa7ee9fc6420e21437974cca12d9163c27abd816650fc7b533558234c46fab01c099483fc2876caef43fa95e29de53386a5bc8cd9528dfae4fb854dc3f8cf4fa9d64de626da8f9f00dd4f7cfca87d3f1ace47bd78f5dadea309b39e510a497d690ba7315b335b6873627b96379bb0fbe29a23a48c05463e00806038049e6ed210d2005103cd9b354e042e4f4fb2d3c19d6af43e4dede8890fcc177ed2cdd80f79d394c273700f62cd49e69bc147222d2a5dae6682ba0a8b711be99a0dfbd15b30607695e1afe7ecb910bcff1ae8eb4ac131d17c9282303f95edb9d2d7901115b4f75c3a4c70857cde6de9f521353bd5e74b0ac0605a40d53248c0d1e28df447284ee75671dceaab4acd8e891c706550e1d08b544b1b577624409e4f23bc65c06493e4bf75ee276f84fe6484382a989b92c733e930733a3263a0e828f10ee44139b48dccc39ae601622c7b56e50cd58aab360c7dff7e6f48788956cc34a6f011a9a21645456d642075f09ed74aef9b7989baf3ce0fa590a058d4a7c0c03d45569f13028956a3280cb998e32611460590442e8e31e065d217aaa4a2216d0f1c7525d1207bcb060436bf10120515913ff0179c86e017a063e290336d02baab49652846a09f070cf262fc911b915b3cffb42089053cbd3616b88c74ac40327ef2806f1cd0377af489749b949f99bec886ff720f4b8978049dcb69c0c2b1cbd76ad94b11e3d80e5b1c569b595b5c0fbcbac68f8d7b6af93e0af4711705268fce6587dae50ab8b39d8755210cfbeebd50c98c27a7833e4463df0c6087fa60509ce0ad13c4ee88e8bfb89f690d016a773cf4d9541a90b5fba82af92b8fc005ba5c342132469110ce016ba4ca17b7076cb9b3b68182694aa60d6d7e9a75072ce8dd56ed98af2fb0badad88cb841cc0056627bb048f7d1f06d785378fe405b85f41293a7ac2dea358dcf89af142724d59c566540579929c2b18158d98108d05e1518e3f27267878df14f65226703e2fae4c780c1d23477fd41c074b28bcd395195978859abd4dc520b031f441119a9dfe71303cbfb6ac989df402de4e284ad818c0487da852d0572eb487ba3d1a351bc2057f00fb954a863d954d3ea7c23b99a1a5214d9a2191d5eb646d60d3f19d4f169fceab309251cd096d8572bf9e566c88232b486f4aa8cb36155f8bbc0d50aeb4da1fe521dfebd009fe2ef44c67dd93f522324072ad44525521632a84d66a45f7ccc5bbe3d439f5d89c9e6ca2188a760defc95c79890f49909ef256382aa4ed9499937a7852294205646000a83370435eb20340f227ca772581278e93e89ad768db4e52538f91e2a3101a92f4f3b36e3ea5d689385847ba8b39fba96e5adceab7fdcb037b96bc166e081e5d0c1697e936018c1860c1b34c8195103225cb303a22a2cb7713bd7d40309f2f7772901dcaa3e62a2792f9eb2c9e8da240546c106d4554eb88d6f5228220de8430cd44c7c0066a11ca3d28ae446fef9c1ec383602745cb8b924a02cb2d79e88cb65b7c81b770e3778d7a9e5102b139f0b9d106432eee60b10be3317717dad02bfb5f99f45fd9dcec8ce0cc971a7ace9d3713c2881c2586009a1fc50b147f454dbd9b842414bfbbe466bf991de58f09e5fc0eba6d34bffdc696161498984b3898aa4c84600d255d3219949ca4fb40f5a187f08d84b70f071565c63a028646e41f986cacd811bef65db61252cce7ef06e10904fc0a9a835f2e9f50f7eef08ac9c11072be2550eb88e6b1946f51292e66f305b07520cdef3f54a10126fafaaa8d80cd159c61392d395bdd841b9f165ca8c54eaeaa2d2ad62debee06cd4f3422fa3322d3b72065fb22d23862036d43bf887f68976d881550b220849dea8d17a3680c21c3012229743cf54ad78461124e211a911206fad69e379ed69f41e8868313b70194d87b83a26d59d128edb818f4a81cd887a213b4ff1576bea85c57a02d093197f297773e37fa7229ae1b5791469c70dc59366b2530209e595ce8ae61d16afb0e940f02ef73927ead0a99cea663b4779d3a74509b5c3bd6ea4208a996e992779541651924f8c0e62c04b8877369b824779ef304417c60d812489e1033e9e5304d017cac20dd3eb4c5b1e3bb85182b5a1e2e589b2a909d4f237d49fb455b287cc3e17661f5b1dd7ff1afc60b0db516cbbba07ce5c0d72c354675d4e3d7bad0144ce85d8bc05ff95da21604e3d7f76faf7d8a0b215f215f3763f5a82b907b2ee42204cf0e4999b4c28842187a8813dea1c2fc6fedf1a0abc39b6b4dfaaeae24b6642150922d26b0cd949c71ffa663d5ce087576dbd4937ae59d4302a6397ffec1a17f7fbcd8f9818baa7e68d05a61a4117ad29740c2d188cd26898db59242c0950f0e250f22e5c36e094f5ed63560b5ce3a0696d4632ffd6d27cc0b7b546154a4dcaf176788d32b64900664e001316361605c933077a064d4f3fde0a31c82121f17546aabde231386458d878d1c7cca16858dc325bbab82819836936edd3e23e2902ac226d2845cfc7913ac94604f8d3f61854ceb1f86cdbcc375b53c6cbe457f4fb6f51d2bd0c692467e4118ebfd61536a54f4b5c84ddd7ac27967d7356486389dd2489e4d8fb9380ae0509e95e3bece13ec25fd59a5e0491ad74a4c58bea589fc71cb972fed318e730caa5f48deef2b5ce81b69ebd5cb7b845dda5ab30abdb165ad1cf24de74bdcaf8916c95d151d6ce431f543396fc6c5ec334688394b0fb83f176877aefc69c7fae8f02ee774480d81c9fd0723832ceaf128ade8fd22c8627da2c5d3877a04a782303292953868d1de65c350e934194b6d6175f653ff88e741111a24bf2cc09ac70e639da3bf39c4c048936e8bf3dbaeda3f258f3baf1ae261f3b8534337dc92910eba8ef12cf36eb8ec0493de3e6f3cd0444591a773caa58acc268d9c8bbbffe968510999e2946a63139c892983aea9b3306dfa768d749437c77a126dab27f1e551a670686f06d2b68628a57b8d0f68cab470dee781881abae126b308a30302d445f841facef04096ced6f047ebd50e45341782c8ed0971e75e9e12bc6a0c0c4d44e251a73addedd57489944a47437a56d3911a79d82997e268a8df3ad62c22dd7fa25f25b887a02d8bd1a20884c45af9473f22ec3e270a37248f8f7cde6602ad82a81aa7642afcfcc5e11b9613d1c86ac61a3154cb9dcd9ce05e3ce94d19d58c784a5810622ccdac55e3ee78251f58f09272357f3067e1577d6c640325a84aa9abf07dfe71545563352231cf09d5c9e01093b77ba8cdddf6607c269db6711e9cdbf77c4c7a7d78bcf45ac0beae54537da5c5fd0c1de7cc3ea746b2373fb46c06ea35c64f0e457a8e5ed4fb50845c96c5984e1993551fbdbbc3a8e54a45807673c728a15177e4f8149e7bc4e947462c108084e41bd6f87b92fe5ad04e1466dccd3e999ad09b25fa508e009db8e2d1d62b4501a9434daa0f5a456d3e330e63596f1de2b7ea551cd74127cd801186698fed27aa047b7a5aeede1a118998683db1098c9f08b7cef0715c476a305067d3a94c9af1fc2f7c9679b5b8b79bcafe8cf87dd26c547921dbdd5b2f57a0c3145116ef8a04a8b22a2ed2d545f0c0a7b699d91f453b8d6f69a53cad09715bd6fbcc36edcfa773be76c210c3fb742117d9407ea6e48231dd29e2cee33b2add2a8b026a68b49df2f2df53f3cb9be49e46fb1d3493c761e128cb072088db9bb673dd86d75001cd85e5591aee2e5548201e8c314e090948cb362d4c3aa7a1feaee8950f39172a060c9f8fa0c33a4b10e76a03cbd1864fff6715e2830fa35204eefa42115528f430d32750b94bb2c5a8577959845f6b25266dd0b707ff130579152a793347260058a12718638ae6ce8dc04bc93da2aca79f2d18f8213bafbffcc4a3ac3d0190ba4dc00a9aadc77b3be4ee108843fa06315b41f068389cbd4014d27e27342c944432c062df877e649c8c5cbddfa553fc26ab757fcd3e2e7f2fabcf420d84b19287aff464ef6dffaa43da643307ef13648de83cae91a126e7bf86a6f2a37428afe747430713d760232b0268084ecb36e5e7a8aa1e0fa14b6cbe4855bafa64bfad18599f771d9cc7ba04b5f8ded07f29c947b90b6ea6b86aac927b99d8b44c1004f1967e9329bf1c10f54a02f74234aebb071ecf1b12a5950f1f277e2dadef14cdf53346e006fafb6b90fe0096cbb02ee5ae87c8519c726f1d74756973498407f447c463a8890c0b693094999743f7342918c14d787b412b3874c363f820517df689be33fa9c662f0252e7b15f4ad2b0039360600cc51b176287b66b5dea79d62d35055c0af5166d548ba30748f210e4ba81f73ce0ca58a9ef4fc9261c22e3eea7e468f13f177d77b135376c006d318412de8600a86153bb782e4bd23414ba3055deb4478561a05c731984e0a5a522f9678437ada85b0a7a43cf63a4517fc3c52c8e18e37e1206b41d679b09956d6a9858dcfc4b0123653796d663a20557ec6e0bb29ee0add39a2147fef22d02b25c2e8e97cde087d41c00cd211434f3e5df750d3ad1ae4aaf6ceddb46cea048d2158a76c9a8d13cead8d0c1fd861b7dfbf388ea52513f3d7eaa433ca581445d1c68729b9a4f89f81b84cc886fbf3fe0fe38f7faa8a0d9c3a6aba6601a8237a03b972a1bdc2154b491deef3799867ffc53d515a82ef78b48484bc5cb7e6883a90457b625631743848a5dfa980c5bfa16dde4e83715c099ba4f7b1f2d92092ed9c160db308ed6c219a85c018b6890389a84f70d61b52b42cf93c9467c81bb087191af840e2e28c062aa056559550346bccbcaf13de5597482fc876196c00ca0c0e91352e12db279818f6b790882829629d4b094d4c31263d8f38232993ebe108f367d4545d66d5dfe3ed7936e8168fc9d3e2cf9d9a85ab2bf2606a18b68b5e6fc84345b1c90a6c46ae9ece6e6c173c6222929ff8305b9a7577bafad435b8508edba3d09a4294a9fdd731d8146b20fab15cba8af38bdf46065a7f013ecdd593f2ea38462a6a9b51e471d74be786325f09bbdb4b47dd99fa8420faacbbe5dbd5ec031a8c26f689d0273500bd15c99f64a5aa986bb0568e2ecc5f20982fc1ecf30f79cd859be0055b24be516d7c84788912bcded5f43747c47c1da36ae1ef8fe0807ef50d82e09d0ecb2899e0fbb5f0456661e4aab97c12fc00cdfb570440cd772e06905507a9a4f6fb3d00b7f32793b0fb8594f411b32cdf7d20ffad65ba86307d6d50766cf03eecc7eaecbb37d55ec5f60027fbae3a938108fb5fe3852b27c001b47886f756d3e65a81ee20403d45fd02746a76d8bdd385cf2975cfd9d3ec297d44e0474246bd4d9c6d6a37d9016b6f1355e61859e92d84c9341133c7109ea9fc7079d59bf6036830a7b38e044be77dd1f21d64fede29031f5d3db642d28fce421f908ee12af7faa6230aaf1cb3e3e3646275f9279bb4102802dee3967403fca6c755ff301e10ba835e5e6b46158b925276fae1b939e122fe5e98a569d4c741b4c2c25cbd2b4e09af167e1d4e48dbcef91101f024c83f3af9b25166a40a9b9da411e30cf4d964695fe52869220c35e71c0d5537e630e92b5803a2b615dbd0079d0e5a2c62ccca04e946bce97afa5da149e93573949d7fcf3458a437e35226cd43b8a569a89d0469fe28dbe83b6754b36f83a6c3f64acde6e2046e1b392c509365dfaf2ed855c7f4fe3e6511aac5536ed456c3731666e7487f123ce9df495c19d9effca8160ee18551aced81ddd1090267f1951543aa9f18acf8d5769f685da74deba04ae5fc5e8b0c4a5e6b2a9a1da71cd32eae3fc7eb0899eb7910a8b9650f7b3e378053f2464be144ab87040ee4b2c68fcbe58d1f307dabfa53a97bb2cc99daf12db6c98cdb08ad1ac25b95bf8653dd8b0bba9d2944e458e8522f14d9155434d9361066f46cf6f28a784644b3d362d6ee4b4894a712d5ffd7a7535ce689fcbbe67055036610906211a758627906f0dec6d8e5c9616b748df7bdfd6e88c167878a9713b48016569a571d91dedcc90f7a8b417821e942489299adc0b5ae168a026dca960f4d1d3ce301f0e7b1b15b987ca061a23a5d17974d6d90999e930a11729b88a8c03577be5641f5580485d1914c3895d9275c1e3a248e37dd9b7f5097a75aa0c1f120aa724fc4573604bea87c24ec35f524d6c5b385bde00c8d2ee1ed97d4dfb776b623b448c52220f6bef8be7705aef53aa0fa5273eebb4e83fb8c735ca1870fb667f2f0f667a6591bdef49d1da9fe2085ba75371a4fcdef6b11f70059df621000032e78d478621af4e63f02444b6824fd25cb2342a5d87af43ba8a18f0d2042cfb3e0923f1cec7096a8b9931b6083d1cb02ee4ee04cf2078759f8c7770df054c242505344086a60a11b79fe0bdece471725eb27e503cd7628c6e6ffd4ac340e32c93eb9949e63fb6926299a6e6d4fe9723797b311721e2d11c7f13430f9bd331188dbdf129e07d22d4a045e8d16e44830a8f1c6f65ca573f4822d0a077b793ad886809802daf61485eefdacfd0ab945a200cc6da58eafe50a0cac447b1d46baceed04aedc9168bd123023a23de080109ec361b5913f0d3705f59ef20f4a5f7362cdc46a7ea56f824057810ce62835d025722d533d93077a05dfbdfbb9503b96d39725ead4106b8e3974c55b31b6d5ef89abf9b68c95ac8d849a4947bb066a04dcb2596c406f43a4e5bef1fda27ec22174cd75f72ac3a083e981bd5355c9074ea3b8347fbf0313603379be5a85fbcdda12b77abb790dca25ad83121199c384f311629068826af23e7261f0ccd6bcd38918516da73f156f6f3fb72498aed8db8e8653cf2af050df0178a28705cfb5ee247634dc84930aefbe7e1f0b2bc63a1b40c99c0eb3a108941ccf355757a830502ece74b1b687e472be154d414e81527afc914554f2cf36e96e55acdb58073c79b3a5039e05584e252eb85c9b5b478bb19b3c0d81ac79d9037a715b23433f69fe6d8bdaacc8b4ef6ff5b3a08fc380986ba15a232d6261d3772fcf42fb5549e84b07af816768b09e5b6ea99643ac108c0c323c64366b1df6c8256ae870f6406492808e7238ffdf20d6f6e4072e3a5d56790028a5d3b8ffcf0d75b843515844119f176c31ab9379c5e5b1976beb29b0e67727074191d0739b70b9f8faa722dbc5917e54fbff6e2852ecaf1ada095df897ab85c88470852b5e7087cc690b980d1d1bd9dcc29b285ad28e602934a210ac62cf769fccfd305ed628c38437c10085927c4d1e2ff3410cd5c4b3787ad250e2378d3f84914dd661ef9807f9ced17c33b4604eaceace2a894f4884f79f6b33e31a864dcb022919c9acbb6195892520ed81d7714b2ff5a9bf3d5c20324ce7774f8427de78e724a82179356949bc51c40c56d154d51dd655c37c730547aa0d9dc8d0715439a1c4fb1d8e86b400690c89fedbe58bcc6394735525c8c242b9e737b3ab5ba2d211f9721feb4680479188f9932d8bdadfcced18bfb17e6b008b26100b70d16791a4c914ccc656667b9c85f692cafa22566b76c0f299f1b4441e0a6387e5c26cf9ee30cea41778f43557a5ae221124e739d493f812e75867e515eebb4ae6b6a83d5b3e41221078fa5c7560b6d19ddd8e929298b2f2f915cf88b4edd8ed58d0f241a79928ca0fec18a4ea5e12d8b902c792e937df81e18e90730821ffa67801718bd44cba28ed458f7e44c49a9e2133d6209c10bb82c9fee7246835c6fbcd83e2c9a056fdd4800425f623871fcaec09fd2242879efb07527f4b23f47859d852345e23edee7f9fe0d50cf3c5bf2be19f72f87efcf8cc6da02da84fa1a45f538c31727e3f4a5e5d988be8a1c10b9ecfe82a51e98bd0b5664d387b2c1faff2a4930cc6c49bedb8a0e51de6922fdca3088c089c02142f16d24aca7a2fed1f46a80ae3e7d646fdbba7216fa950186ccf3b310e73f2f41407f286b54744c5d244c4a3151574eea3fd74fb98afb3d464fbe969d7bcef9f3fa9fb0b7346c6ceb660d24809921119f564adac028ea9f7026ebff9429a8f6087d4871f3c5b73bf4f25593018425598d024ef89348f973cc096c0c5a0c3aa9e878840fc5dd3c1742d6ddc1fb81854c189090a5db346aee9845eb027b073de66269f15bcae18b1d32ad7c3d776187fcccbff04c83184a32f6fd76765af421f827a96bfa73fb5e6c7e31c94c94e4bcd8b82e270493efabfc6718b2cd926a5f3ae22558fff68f5dfaa44b49fb4378f382091fd9b4662b9b6f20b637c38c68ba577c6e88c99a530467fbffc10ee5d573d6b810730e91aae92f5fd8b11674b01c743cdbde20ab9ffc3a1e7227640d133ecdbe12b08249f86ae02c7e783923ea0155ceb370ab0fe9f6f7a29e394a42f9da1c0ed2fc1c4bc346f36e25996eb370d6faae05d66c97391ff9d58197bf9a25d8f915493ffb094eef625bb0063b0acea985d1f6650a4750836833f08deafba34875fecc0dd8e97223fba7256aa78fbab7f9cce40d09c5958286adc24c32a36c6f50e9840c41fd98197a36004f7b0c56c9e25549b7f8302677256fe793383926bc223c41abd05e4e8f7b3a55ae79fc9a9e39a254c39b9477481d14918c5ab1e29c64e843abe529d2edf27984d3d5b06fe97cabc42be545cd3fd624c8341a69bdfd750852c2b8095c7b2815ab74c8eb86714795b0997cd02846b8b9cbb3b374e69b5a15ffc77c80db23d72322e625f36b47c6dd5f4cbc8efdfbdfc45b5015a8f9351ee54fc45b38ffa3e06bdd2f1186df93368905589855754d644c0eccd478b2a81313107df8fea857e5ff3b545001ca26d158725eca7f4aac643f7b54a7b3fdd0b6e0ec0e1ab8d45402ed535a4a577cd333638f17464f3a39873b48cd86c3c18d992ca1a3f7685d9f5752bdbd419d65a740af3cabc2bb12a91c3d2a3c2cdcd8c5a955c85046649b8bcb070f9b0b5b0b956be0bcce471a8b3fde676b88907ca9e7e35b55c71fef039c1f658bef6d294651f129890d2c776db3dea26d54196e5ff6717a593c82cced9d3089bd772f64c236fe0935caf1db5ec83495565f8f5901854b2dd82ce66fdd883c36fe1ca5b3abc229fc82df9e50eb8ad22d6cbc7c2b76e8a6548106213801a2390fde5feea40e67a2b9aee267cb306589b779087828e403af53021e3f1f2f8e2114cbd1a28192afb496f729e4ea15877b7fe724c1e3420e4299b4ba563aa7af17b7dee78fd1993445d1685f05f9d954826fa772c2ed34533842e70ca7c306f8564524a8ab9511088432b802c3ec9a2956c9293194232b86f699ddfb42005e6cb521b0277a94825195992d4573a966d99d62391d2951e34bfaf145d2f5f49e50f65b9f05e9847b267f1b2ab599153ffe6d7425558f02fece4390cec77f327b86ab66b9b5c91de3c332e74be28bb7567a4615dd8ade7d6d62c178808c6f42e34d5eccbbf6e150b98715e714af47543b542886f77d120ce890f8bfb7e5bbb51745417ddc19a3b93fc2af03c73f49bf8886ac9e6496290f5e3107d37d0ff66d60ca992941850d153d80f7fe6c192c966bb3cd9150434eb544a158bac2985b88222b84c93499e40bf894cf854a8d69320fc0bede7da3795542d24a5823f661bfc85687d007f4b5fda25550bc24dd3a6e1233d6e4b58343afbb6b2146bec99fc91edcecd841af9e3d06207b94779a6884d61ac5108d7fbf0952c4fd0f64637483cde7772c7c1637e32037bd1186ced8571ffa06b209e78d18b5d4e593a471577678522200bb3b02f0c9ff5e73d34bb8186a090fa85b0b8f7596c6a882c613e54abfdaffdab867b1cd88432e6d03d2d49fc4a4ffba638881b13765d122cb864024e09a0aa3d835327d8aede4d0ac63c2c30583e5bd20d2c20fa779f945f44ae226562ad575533714aa6edebe3e42ae14433f84a00523733e0a68cc044808451fb948803f5cea162ade901c8ce70890e33086e9b679fa22eabcb50fc536076fe18adfb3ac9a680eb812c2e81a0c17066e393f97b473f4cbd165962f19f470dc4e9f7afc210222cf525d76764817e7a6018862ad0cd6c9314d2442fb752d01d3f188d6e8711f6d05e07a5a01ba825d998f245028c8e1f49c3edaabfe30c10c516b300e78b01db5007e17e0f3e99435601d3504cb7afd2e6a96fae20ca62b4d0114244edca9049eeab7149a007f61cbf726a3863f39b1ebd82e29ceb4c106f293b6adfdd889ab8aa76b8840fd9ed21523595edc90455bcbb21f7af26a02e8364c2b931d6fb33ad4bdd5be4e2eda8e3c5fc854051d2ef1ddc4cd8ca357b2ab32bf80fe3e0612c081bf461143523bc2dd9de24e804baee94a48b0671a6c8f27f3d71c1176ece2dec2cd4e125ea7902cd5ec48c625d4a07b7e5184cdbe975f7097ad9c10cb9241da8b0b6d64f15282fa291f2addd539a0076c309d33b36ad1cce1ec8296fe06dc03f1519ff0c583b97a6eba814ee4158b2bd0086feaea2fbff719471337c18c52502e3b923827a5560202bed0775c493e6a07fc02fc7446462a762e1e9fff79ee7c0ad3a061b4f2a475be29548a11ba3646a64c7cfb3236c2c4a0a40eaec87c84cff1fe6146224453c8fb6f0c2962c12d402864dfeffd2fd02c02b9a9ddb77db844d233ee5007fc42fe6aab998b339b845ef1b525d6be97939bee69670b10290b60f14676dab4232d5e5244f05614a78a12766742d59a31df361b5dcaaa4db74663174a913139da8114a80b1e4a3a354c93073b8751ce4974e15fe125715dfb70b9f75cb2260bb238917a7571bc41f63129c122e0541310347b60cab42c5ada883fa15c876939c516684004d8dd16aa5141f780d70d5335c02d21e72d63537cace8fe50b3466f72b606e2a50f5a62c1aa60e2cd5872ff75b0d60c25e3df87151274a357abda6a9f4807f747a233d884e0c62b6cc66956ddef8d1d4f17734e759dfb0ea5ae27ab5c2f739e4236f27e39411ea260e524049c75e3800998bd5d0a9910300101997609a16980d8b8205cd627471f5797b2192a2e3a427179c3ec2ce7db0b7b896b90e0e3baf1fc92dfeb08573b44673b84dcf59873c0bf50fefb2c4d6f0c23f257ea3d87eb6c5d170983d33a677fb64268b01e256ac4d12093dc123ddbb6cecd87d747412c5a8e3caf43bd8977286742fd14ae81bce62020d73e3451c8f3581c576f660b05c683a0c6e9f4bf24265e80133d6336083aa18b8bab2709fda4b3dd386acc9d9d044de950671084df544c86563b82fdf55f35063c3362dcd76163b95e1253127202adccfbe1796625d3273fa8ee57a12ed158bb549ff505b7ac9bb66caf83b707839287b97198ad826bf5e8bf922bbc08efa8be702a111c40e15ca75808fb3997612c1221f088d4a9aa26f7cc8544c1e3d0f623a490fb6bd6c9d7f89cd7f63881e84d52f28a32a63c9a7a5eece9a0e4cfe6ef47810b5b4af4b06437b8bfde0a633e636a179cdc6ed75a07a652233b61c683f09a696c20f1d1d86d913b3ae521cecbf3cf59b5b5a7246943cf3acdb90ddab5b644ebf5c5aa618ed846ad949ffdc7cc5c4384a52709455bd4adbd75e0140814a8649e05d5ee56506b9152a10aa6a4da6778d012030978ea6f8092724b0f7ec217ad7fdcd159365dc39d412b9f3b23e654e79be5917db08a9f9ed10c92a4d35e11a2f4e5d39931cab1569c781207aa12f1215e1d78910b9aa42ae6ef78ddd4d2064447e997f678fe72866dea9029bdd6023b528aabf9f8d30606018dfab623e6aa2006fe067d966959f5ce855941109e7795c896c88792699029b27377fb4e84c2a3ea2c69d92d28488c195363fc99671c6c3b9b0edbc4e3d95dbaf3d9615a5ab54d7bc2b2adc542b1410ae5d57b2e1fee1f9711d4096ca32978f85d5c0493c7e32fe9c050fe3ab74b7949d71f086ddb2dab939a84b206a059e1e7b5c8c35038794bad25a61b01f7a688c9675ec96b41848032fd8e01459f42b814ddc3527c762606003bd84b30ac946a8191448f2fca9e75fe8680784e49f8071ea784b3a1be47588f9645f990bc2a65902413658ca58026a137e81ef2bd6c01e3cd0b05509df6828cdbef8c6c0a9d2fa713db4b924a9a26202d06550529c96dbdfc0352beaafc5bff02c3cd000a5eaa0ec37385a047bc05c77b04c9c8693b0d6bc73da9ca489039432401f06e0e2546fa4f2fdfba4f0d2ffb29655963c482d30557b48d309d87b3589ad337fe1d58341ed988e451135c098a14c35f9561d4f63cca0bec6ff767f3954a644dede210aae500fe330bcf400a75e8f9c5cc51563131b02a7f16456aae7163f39ccbb8f524a8977dd5f727e2ce6f63e481dce311e5e93c4699d82af053b048b78d20b1974b5549fb3b4b183d60a389eccc1c667fa718eabaee8ab00b0970cb03f94f14cde450ee0a414b40783e61e845dbdb0ecd49b1371b5bcceb0cd807450d305019798eff63cfa85159c85a00e9d26ca46371d626b897cc4c9b436eb2925917a823ec0ecaefc17af542ade1e1ae3f43cae412857259f9dd84f8e5d72304f02f7872756d8b8df6c68d1aea561afb4a3aec9990d95a02ddd929be6d4fa91cc1fa6b3bef4f0d05f10e2152797737a833b292f2222ce52d8c8f3279755eda19f412c4a399688616ab2840ecd06a9f0f1445c3ea30595616ebd1257865b07381f0244d35b75e2bba1dbc2c9c9e807f6137437078c9e46b50842f76b75569eab09792dd5b8c7a901ef931a0b3eba649fcaa357ab0638a3dc9cad1e9774d97c923be5e9aa98b169fbf604aa4a95db38a4dff23bf70af5279f33a8c9fd361c1890670cded4d81317ec27fd3783d5819f65c014670b2659cd53ff5972226d97dabe5488fdabb3b78ff68b10244a9b162993a88c6bae0b395deb08e644404ecdae25c13470700b91e20fc048501567ef6d4b99333e7763a393de5792768ff008f8ffb28db6ec9b2e8eb43749dfb483d54d5abbe21e8949999137963dba3058b80c68c9a2cd12a29779f0aa9c55b3d4b654e863125e5028c4075091180550d930193f46eeed28d94f3f1f3894ed256f6dcabb8d2b3043884547dac78b6812e48eca78f83c671929a3c42476710c3a5bf31abd7661ba9a9934c8ef32da8a4ee0c0f96d034488900df09be170f30f4d95873c454ed77fa5d7bff904ff1094283e82ae40b6b8f11f7db72b1e447f283261dbfa53ccda0ce639a713e4b6e42758fba9b56c0cab5d8b6379da246099307e7cb5c6fbd3510d53679f71b5938f0dbf1c2d50f57927820f09956884c9d050c8d621b7a07207364749c425e8b364cf1fd995d3e551bf6a5b21df49bd15e54bcd59154a0d604ded7649439c090d431020b5715ff0c3fea93495ce7d95830095b3a4abbe7a9b3690c18d67575af3e80897e2b07ba759066ca2becd5018c12d19dd341e556acfbcc260c20a2ccb9eca469c30694a8ab599f66ff367d55d39dd214dbf89271de6e1e5deceabfd5d61212978ed346e7abad71b2d74bb085566d1c3ccceab4639a11038378f6a580511e8047c4730323c70f974ca359f0e51c40c666610fd3e0417bf5a0edeb521b5032143c026cf5463153673241b950aefc1ac59824d52f3c14109165f4c82f533e56a46637cc9a01539b6bb2ad6fe1b7345f01dbd1a662d075708a8dc9a9aa8a8cd8488bf5077dfb67d925bd347846cea100827de9ddbf7b0c50b3bed028b6ad662da7e8c7cce51a6b937a0b57e7196270041af7c733897a0ed7f6c410cfd7558df301fcc7857af38db6a9fcda8b7cdce3c8cf8306d4ed83e79cf343df316d7ed36cec0a85c28b0f2fe0c9381c05260a668aee6d79066dea63e213ec1b885578282e266fe5401280134e1b026d24246c01168339d8475b952047ddf034f4f94f406de36cba4e080304e6e6ef2205ff4fe7067f6f2ca1c2cd7a8079bda7207a85fb775ea4f7c8b9b95e319d0a2cbbc457a0c4fdeffabc15cf14c87aa0c7e16f0423b397f7acfeb79a80858e11cc505e25ec0a16bb696b747d94da123acd95b8714afc68fc298e03aa146da1a005d35f82552922bc5a2b449231248acc6e4dc4950cc913b2bba1487809d0c7eb118339fffcf1cf1ba80cb431de0b224b469aeee8bfca3075cb812eea0abb0796173171558e08dd1e10d88a47cef59bd27d8e9d8c1c53a5b3d2398f851fd398b21852a14372141a6be2ca76951c1957ae6d5f0697180742efbdb3f64838afe6712e77cabd14f1f272802aeea0f32b4f3ca466ec5bfa4eb970b5db60b0b935764b8b86546a5054c377f126618ac8bcece1c1a3d482683681188d62706ce616f4a1abaca4175dc5c4ecf6842db6f4a7920c3c2b5356c6820d065b683dcc7d35818583163a7d685e48b7fa5680377792dea6549947506a4aa83142a24a90610ff9a99a195ecfb2895b55916cf03adea79ec96207e7781eabe44a03b65cf9c007d97a8951e387b2917f","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
