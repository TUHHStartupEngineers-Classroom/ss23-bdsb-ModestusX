<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"cc2f3531bb94158d4952aba20e58336034d553e3d46b5a67d0e9a8c212c07fc8b33b3107ae28f3a6b1cbc1d302a0f041728102412d0db49b5c3104640f8a24d2326310ca4ac155acafce78645d5107b5530a2998478a5c3ac784003194892db62880809dc3f880c24033fa25c654a4400a698d0d96767010bf1bb6d7a33989aa7a91318cf898dcea8e62b2b27009678fe12ed25c14c13544f54d75f48b7429a329166c301c841244c758e4e4daa9e728f231bc89472b914af3b9477432246e7f87ce0c84454029e8c2f1c7b5ac64c40e2404ed34e2bc08fc5df35faf68554dc2dee2bcacaa3f78bcad0b1dc80070b3e4f1a56971a756b1fa4015a0d50efefbe0b413b1b8b7ab28d6898d4de1d496335b7c2b3ccbe1d1a0700642c0c2891a3b20a8619eb65f79396077d59fa5f5efadbd004fd2183f5e16807a8398c9aec1087244658116100aa4f85840d98a75c3e0f9092564d82eca0a6ff70b82e94e5fa42774af6ddcf2b562f09e2ea1e8cb4b9ea4b5b3501e590cd917c2d8c8d4cb26b85c40029fb2f27f26ec6969cd0b369f7e6f5a58a6abc860572679d1b28c4854cb26639e6de5098a696622c9a3c78c989694d5f5678d957132c717d8c17e35779e2dd40e329e6839d5aa4514c545ede1ada6ffd33aeeafd6f2d67c19b683eccfdc5a635d09f64d1c52f1fdc79b2507c551920e096dc46859f937435e9ef825160d4640199b55b2856d88543846a3faacebeda11f3d7b2e17d162fbc6235214a4de27a32bba4be3ba3197c6e727ef6b579d3240c61cf34b98705d3672742a34572c3a582a2eda45c3bf1fadfe3d16659f6b2a30e45af4375885082d6335f693ab84a278bda5145e8a743ea14f14c2a0f01c7f27ea81d2a832ea91a6e0ea0220881e0d6e0ae15871e61dd8dbc78639d0cb875a088bd0c85762bef81d1e156af85acf0dd1fad40bcb291bcc2b7b42808ca52b234c2de2c2ad1aff0e3a7023ab10e734b90b0e462831e8b3987c0b77e9b86279fcc9646ec78ccdae9a8a2c7a15fef358ed623f12d7ea7bf88d3c6bd64a721d25d8e0930f451532cd702230c501d911f871dab8026a91ac99b6084bc233f758df3d3ee2bdc8873855f912106aaf58a8d42501875bbd57bc713a6e4ce5a47ee1d0af2c27dbd1d36fc4f06752e68642f4560e15fcab8a3c164d36aa193ed911b73b778459d5c6c5ee7b5e19f23a3b451c5f357e4fdc164ff0f4f7d2fac560bd93e43e0b69dffb7ec9f5df864fad0f7f2da13601e5a65f9e2f97c969a66c379961162600d2f85544b870bbc4d3c3c86a337fd72bb50cfb360f847641dfd21711340dbc64c7d1338a1b7914181440edff9642206ea5e9b053fa0511638ac12a0d07ada3404e967bfab8eee327476f69b0d05d44050de3f411de91bd9e0706a6390e4d4cc6e788fe09e7618f5a5205da85a692489f7920b0cdc286452712edcc7ae169b282580f7039721552bcbf07a5b0fea36d370fdd13cd99a2e69788118dc571c0e1cfb467fbe2cd8af12bc618a4f3457379cbdb08ccc46ae0aa9a73e9e72ab6b4533be3577545d70c9763da00a32c517db463f75fdcfb6a8731b16f6b8d41c565b82bdbcd86d641e8c49d38fe3b428fdd00257945e9a2232be987c78184da3c7becf19794f40940ee85367c33754c26f4afb83fb70755f5bdeee67aa4f501b3e8eb321f1076adf0a228ca435ed6e99305b5c77930958e585abed3754694db8ffeea293fd61d38f3fc10052cd45e03005c5545539133671d87591c6db4ca2bdb2d3065c487aaad49fe8b12bdfb502fe7c89f7d64ac0c5807fc559cf580c6369be0c1f8fba0e638196f0c3ae39805fafad7451f4a802f897a73c33e55986c639ea32dfb6182d8fc88b496c4c4972054338475cdbd3b3e15c9d0ac1b1eb1326323de372c59c53b5c0716755e328e8d215e3a1e6330c3165ef8f6add0c43ab38fd8688e8d86a1b71bd5229ccd3d53a21a9642c63ef6f55a3c6ad6d7aebcd86075d45d92d10e34e7849986939bce7164108f435d65a167d22132e3e5a75fcdb78247fa5a65ca7083d853074e7ddde68aed33877eec934a3429261b9128122d9f8f23a421f5f326bdcafca0372727a9a39cf186b56c4ee702292620bcbd4aca1262ebbc77c870aa5d4e4f038b9ceba9e67681624099eca5fc05ab6b2f8ff0b39f97f30c66946651729e4f10a44bdb087e427f4600afebd652dbdb86b3abbc2901c4f7625c3fa84c0cc8b39b19383e71cb48c2de3b318b71a4e737e8d7b14ff9d18a376af092f24e6819ffbcbb3c7bef00a112385debca7a2130dfada8a6aaa4265ba39dbbb8388923b8d68990a7d63155169d76880c68dd1cdfae3c4e30cb9ee059cce9daf689da987939d25099f3ee1e94fcab2a1f862a44049f9594736c9070b60c34c52cecbebffd325223aa7555632c7793d54ac18ce512389b2c4525215dc7636384bb035e63bd2202166c00adee0c5d3782fcd0861534ae416e069c5660c94f2dd27946d43d045f391494e135c701c02be94442c18bad4b08acaacb09cb910eb360c9305452e98fb9251ceb67899cf93211bc342c930257fd2c4dd2c51be5f90842976e164c8dfede6532e8de8558d5fad8e5f465e4932450080e87c75b5b5e68467bc0b10ebe20c97954e36253e34e74c1fcfe526d681fbb772bbeb05c095cb1d1f01fe6f66f296faa6d45e78dac06374542bc679f0e6efd3ef3f1061f014add4b80daa3f3315eb89c966c62742b65843a130c348fef5419b5ad33513c79c8f2c7d429e650b239a73549ca7a84a12e09a3159cd671816ba9ffb9e46c2d5812d4fad9e2a2689a4a7ca68012f72f304c83be6aec99cb5b276c3ddbe9f5684366d3e3c3d90c8f8ee20c66f1137af39966606473c4f1dc4284185aee699f6551f06d8acec9d8a2dfe35c994d531a620557ef9ea496b92f1b32064a62e043dd3b22667f450fb5e34eb779175f833eb8e2db57210e2c232b6e23a6e0f7008f80e5eb6fc945f0b3edb27fe2cc55c11016269a68d730b951c655fd3242db5a915621448e164d2c5182f3874cb1acd5b64c8976eadd61b388013caf188bd785d32e4b7cfcd65796f50ffe13f55d08128cda4990a3a5ff210347139e34bc5760b317dbbe2c0a96f2470bfc7a7db619e48f147a9bff237561da1a10a72320195557663860e160ebbf94e172bdd2ffcaf5657cf9c1f4e33bf10544858f88c8cbd6b3ceb45e59efbbde5702cee08349bbd72eeac75aeb89fdae16e3d3e64277976b14a7965552a5968113687b0d09f68511ad1f8d72fe1506bf852370f0201bc7e6c647271a2beb4a7cc509baf1fca5bfdcbf1570b4ed91b3533036a7c10be5ae23ed2ecd041ecf3faf81b997e685814655a2fcb3b7cad4d1acdbb00c4005f2a4a1fa5ffcf7a125d35e739ab31c68d683f0b1e7f804fd0b0d41c338bcec4bd9411f3a0d274a167a4021bf5eb9a84cdef4765a7c99699de9fc3338bcdc6a89146a8fb854e63ea5919789c20532ce5dd080426a9ba61dc193b5b0ad34827f196336bec0f937dc2855e11a167915ad329ce45852d58870d6236aab7ec56a8ea4f69cbcd6143fd1e01a35cf6e90de57b736eb0679104f4c9c0fa854a7712b3999c1611e2be77aebdf2dc3b7f5d639c7eab45fd5bde13ef4462035e162d0448a0e65793a2b8b590dc037cd0124177101ec28c45e1155f254b22df3f21701490e3a7bbaf9ae657015312d98ba046be62dbf2799f6ee708d0967d71122897600a563235ead212da32ff9429cc6dfc5b48a7a9607de3a825c97fd6f7618d04fe8fe8117f92df7d9f4cf383cdc210d2a95c3b5efe63ba8922fb20ef46d4a3e253bd65aa6063572f5848ea047b75d23cbe400e4424f4cd86f5319210179332888042ba4d4c4b1bcd4da75c8e3c2a914ade7add912668fc6c38a93a9477881fddcb7162b6e65f2c847d18593dfadf870a860f2cf6039ac47b97a59cc9567fada9d41b0e4e86153af38b7ff561fa7f554514689121080843bd0056d6152b5ea92fb24ac2593f747bbaf2d6acee2fd942900f42cef08d759375e077deaec3dd66fa9650ec8fd135a926b14c2136b3d1ffa9b6b7fc553da8844b9b54f4de8deaf6c2857c8e1535703d040320ec44df1bbea02545740936f8c5854e98dbbb937d5e9a7e658e526e8f91e42e5d1bf7be8d82c0814923e61a699b16ecc426eb7cc913b592395fbeac86d9cd5009b556bc2767842e0a99957b266fc82803da95800ba987e8e6c3c8244b2c0fa915269fa136651f24fbbde33e2f72ee1864bd3ee5745d6ec99b6f2e07ab51a0f7d75ef09f0b5f1f6834ac26e13d2d9c5e10df1ccc7e9a8f3985cb07142b7aed60ad8c4f365bcee2b909ee9cda30ab732bfc9f54b41fe86d4e2d5a1f8d501651e898de2a35f533b80b81cb9af92c36dbf435493d4f726454a1959f7a586d6ea1965da580af9d424df9aa33b938676aa9bdab99de3c55938b4ddb736ba17c508abd4bad2883d7a45583f6bc5a8479ef3ba8a53d68a95b2a03c969ccdf2879d8e60e3ed2ffe73f741c3593365265017dd45f8c3735fd3d09ee4785be58138b41998033f67d9871485ced77cbcd9139902407cbf14b82d1b760fb7467de55dd55fc1ce8413277402dc19a25fd4930c8b02dad9a2d5caf11a32b2b05a79d42f6640b250caeda7dbe04328ac84d1eeac3d27ccc2363419fc26a41af575a685c066af4bc349a5e27d5923c3f78dabeb60af4c3f7c4213c6e2394647e3e67de01b2ae1c86b0b7dea9fa0d3e5f1a32806fe4d74793c3460916932c6f688f0d21b81c19a1433f9ca6d28a98fd018da563501a4e9668ddd4e67b76d3f97655c73b6a8938c9afe7f0fd1a0f68904bc05facf17f3c5010964e0149d1e4da7bc4d049683ce23437b1df99eedfb359ccbf710084d5e81d99cfd6effebff3e03e24820d6ee61c2abaa69bf51d2b442fd35d6de69f0ee62f0733cdee373c49669a6767c5497b5a6c790aa3ae97f7e66d36875c600f471e20ee9eca461a40895bcfcb6f8c95e3255e2a37608b5dc8e7545243f7e772cecbea33309b2d43cf8166ac3a3aac4f18e336b211f26041d35fbb2b282aeb2361d9cc78a7861a26478022952b3b3af13bfed9d8d6e5532ddbab256ce76ab5c60e355913c43db11a5e8cd0aafa5ec80f597d14db2e6c6640dde28c88be766b1e93d77663be167e78d02976b9185ea09e94f0723558d61014e35b331c7188349ef00e360b8d1e21b58829de0f5f05f4ccc285b2929ab443c6e757a6e084ec4fb29ebdc88fe3f9da70d3aca637fbc141e6e3d6005b47603b415e18db10d81c56950dd892ad3aeeb8928cea9a961e9830349ac2ee2370d5b37447b9f747c07c70e2df659f20486265b6236fc0cde724d4f0655f1b12ea0944310f897ab5b69ed4b5d05c2e120f8b41845d11d0fdd14da28cdfb228dd5085a5ca075917634402a9f26f0145f4199438550e1508bd7e007af1d28485bff0622921c6051b0e2d278fa8670fe7be25765ee5b62f9060d49214b4a0818ff794b423998a2290218786ed3a2981058b768df5b50cf98a9500ebe16d13c288b96f8927cd91ca0dcc20988fae721b77c64f4634ffe13d851950e0100986fa4e83a5a2947cfade26fcca00611c9870b76415de1918c89bb1a96d72a85b1ce72f92fa13ba46f967ffc2cd902367c50cb1b23afa2105ae423b9eba115dcfe667372309f215c7cc9120b100daba7f70ca27d2127f8291ac0316951f1a58be62f380515ec14ffb107ecdc86319af01ce18511514fe369275db071f39cb37c681d690caa134f6ec745351fa2a09765ccabfbc020f4d2b10975845d1c46a5c9d8fb5924cbe7c9de4792eb523f0d84597367aa7ad3821a6edcddf5143cf775e1fc5b174e7f12467bcfa9fc48101bdf97c6e69f187c29f9ad973aaf5758da475ea974336ef8d6165d8deb9f225c785a192bebf8ead88050f9d227196bebcb42de8864d27380f114d504764e17956d2fd94e017c1945edb1c8161fe4586741f70bd3791c1e388eef177a7e120e8f619240dd370208dbeb1d1a44ec41757980471fc2ec66a7fac40a8b79de09970506df20438ec4b201728543dcb7a1fd623373f84c1e7596bdc39eaaa6c29a04bbe0e9e5485451b6de84d3965d290dac5df31881b93dbc7da4e644109f826381916f1383e0f7994d5b00c9647fd022286dcd4a98745b360ce241ec1436caa3910b28063a62c0c47fc5116ec47680d0791957bd733c3b1218b793dea3c7f56e63b37267fa21d8c94545bb16a4dd67754bb4e8b9213ac42bad41eaf035821478d7c2e9436bf18e9492f1f6ce28ad543d397934fed35e3ec850bb77a62f1e001ab49fe15e81cecbb283140fb69d3b2d44b6a0a71fab77755f5fceaf58f7a62be2656a821b88a573ac98ce3bebc86a6bf6763abf85e87f2f00e93f163b308fa0b27ea0bc379bb9720a12658cacba9908898d1ccdbc7bcfafe6380c3d25cc6f3698ca49659393fb7fe348b11bf7a58c7bbefb0eea15c9872534afb7fba673a84feab5f6800b2a1d18b4f07a68b8a9fa637859b6e0b0a8eb7db896e080a2b3ca08f1f365616f065ec9a45ba6a641c2d00791ea7bd6454f5e7d3f6434a0827d1124fad698464fee5a1ab46967dbcee5d746d40c19e343482ab30e097051b3cb121218a5ba3f568067df88dc96196261fc01c347ebdbf4157ca81de93393e5419dca4a6e19c2093cd1ad2e2d679adffc6983e2f89e0f0d65bb9dcb9c8c0b3b7a3bd60c994dbc17993ff36552bfa145a6bc47a52bc793c36db12e5735c3259e82312f8013091e763934a557f764d78c76713d0248dfbd3749f4ac0aed69d260148f39fece0c6b257fcdc08ea9226d54aa1eabe84db01b65a59615e9fbc16982b0b3fd272388200b1f8f1eaa6aae0cf1362354170cb03035d6b1ce669af5261959a4046e5d5139dd14ec2c66b66a03c77187031ac43fb7e9843802cb30e382b8b0981545a66a6d2538d5d1df11010df0d13b730c7e3cb8fd669589f421677426b062062c9c172afe21237b799839d2ff2f065f2416e29594229cbd9f97c4d647943c8d046a95ee0aef6c457bb52be4a7f4d7f65852db91171562a2a41ea5c808b874ce307350a9d856a4847741b221074abee52c0e3ec42a6bf6cfb9373c6d89c32786329bdf71a336036aeaaa8566839d2d32f2769b7a65938f35916434901dfff3e58a513d725006cafd94d55f238cc069cee41c4add9cd0976912828f573f5f237b67026550a587b43b41431ba220076ae247527962de50ec6d86f5439e13ba51aab15e8530fcd519a66d2090261b600baae7c57f63630f8b91b1cf36b79fbaf638b6b1ce35081b8361649b56567aa57b512158e395f4a466534aa16806924adc5347eeff251f586b29c0fd886c4296de5a55c8413f0b4b49321120856a99820306df9744dd1530c50499a2ceec6bf7848b2ccf6f165a76c3525def23c6d266df7bd276491026c3540d747604500814668f444bbf457b951e82d2e5e5e9724f670b4109b97732248fb630242ced50e7c4f07a8b373061bb42923c5d5c358a3fcd635f4409f5514234f7ebd4a6e59a4853f37655598818b134d627fbf79842979b84f6f532c1fbd06e234d6297ba599a45d6e381af7b9fc07f5768713df06385500d49122b9a3751f27018909ca4626a4f805b78a20e080b82b95fe7e03b254293e56a5ac5d9f864b55fa57f82aeaedcbdeba441baef8003aefff338e904b781d05422a1a503d7df5a084cfce19f90ac02cf51975ac76c59c1fe8ee1548955ed889c3c61479d93e5f20db82819867a6f0709c6fc8d8d2adb6b77d9d28eac5720cbf4e3f9f174dc05c7cfa50b8d55438223656b9a4d6654ede272a947240d54482da5e2cc83bab87d2a1d20f1ddc3bb8bd1b0cafd56fb665e4e4ba4f7427864f2ef87aea8c0249ef85e3bd7e23a24baaf14588e3126464ac22a23023b37be2b756195c7076b1f590a6fb8149c9fd1c77428a21c92104a3dafe121d64a5cc23f043644417b19f63812db9e4cd022170467175d2a2741cc8a075d7e8002d9a786ab2289cbf429874ca4be1940cc01cb44d678681433a5fcc3740e344d2bf6c88368674c84827e5b22348d4f100119b058c509b88746d7a7b9d85c3b4e3abe9bd55d01df431f7f007d434931146f78caf83f7572423ab77dda0fe56f728bcd536f48ba7f0158c79ba6286f85dfeab5fe3f1fc0502f8945ebe2529111eb0de2888fd4b650d1508f662f536e61be8e7ffea9d44c340a7b08f965851d0d7db74528797db2dd16e07dc86a270237df5ea9aa29b16567653550f6298644c7175220b20a780f1ef6e4003356f9c017f708b1c2f661208dc005f35f953e904d7e75993ec9ee8267116c26855858a7a78953f09d99c8f854696623c0caa6c0a976bdbca7e7f8cc4cf78fdc04002c92a93bd668d6e09bdf3cf4a3676cfdc68c955a04582585109ca9132e01bacc265fe01cca8948343be27891fb06d03b6ee0dc13b510822d4ddd27e7cc0e238fe1e3c14dafe729595284deb9ee047881b4a342bd023a8bf1faa951ef4baee8ca74eb2b59da73de3e2efe8fb92419675659490eb972487eee664c8387804064d818cf89135efd5cf5b46632d5417eaa2ecf2111be542415597229b773ee416eee7b0be67ad167c593f7befe82846daa6b48a7a0bd3b95c130523b60eb112ed21aa0ce28ec7f6258d78caa0bb139db1728f124d586b18fbd326f25168dcb225377433cbaed9c80ed8ee86dbdfd8751d71be51881f96d1fb1554505c3c5ecdfb21427098ad40a19dc80ebb4d09379225e18f793c4dbe82633ce101c76c041a06b5ac5829f62d5cc43488465c196af8df560dd0e371d174aa01567bddd80b975894b0b8fd920b743243f9798dcf68ec71ffecce9903237df4608fb5f309f19bfe2c25c1d19e93011491aa7b0ffc7ed9c310e1d663efda7ec308fa608a7274afc43ea5f6f0e32296d0788f9412829f365fd7f47158bec7577c7bfc800071ccd4f11b0272c15fb9a5a2735ca5f70dfbc4a93fbc66b4cd6d25bbc3c285b884c666d7ae99ae8183311ecd0ccd50f99740f1750afb7e290da834693947075bacbcd5a31f5a7ee22787f53fe03991c481a34850a40eaac7c3e5ed011ece64ac7766f97f4d8d2452fba4e3c51b9f0b98dcf15e67feff6e3440cc42bcf00b389c1b109e4f5c9790c148605c412656973420954346b3de3aba7272807380f94102a82f73529d20bc9a7ea1288cb1e5280fd9e67e844e816a4ec45a1004bbfea42b403a8307583ff35d05d0511c960c4f855ff64de5408d25491c3917fb7eed2b00444f85d6b7f86d4322bfe1545f6351cb0521ecb566644f96b3d3bfbfba9ca6b8768d58af0ef9a6a712087f0c63b1eb344d930d9d33da80920ec3338278b5408adc73cd463c5645166ddccfbc13673b716e01939ef65aa6b32aa9f96df5ff995c04cc177f10bee30b23cf7a8d1990597d0cdb3473aca9150776f4bf42e1af28e10d2ee89b748ce0cee60a4e2a5e0c7ebf37fa635d5b469c87d3a8e519fd6cbc226aee5a2ad9e601cacb0ec3a36739bfefe8d8e37671125981cd8ae457e28b5cc21504db1bb2c91ab5c6961797fa2e404cbc7990fea76ed7ea89f04d5146eecb579591e1f0b2c85cf1f892ed737e1e37312f02432245bdade2e2cccf27744ce795fd35b42d1768aa9f52f6357eeb726270c1e7bda3f6a31d1f13e1b0455f10e1531c3d04d46e7bda7479ea78ad7f7b64d40c1d50a2ae83db603171eb4773025d0d290fa1bee413d966b70096cec747a7f8a6bfef6aa3dea7d26d021c41860a464a80be8b56ac6d426c2f76f179724ebde82082d6ab3ffeffcc41dd98642f3a6e0da9e6304e6700027cca521a7effb496b39e4748355202feccf6261e888f793089abace86bd5bfddc4bf10024a64f5947c228e4835dd34f3c598a0a878658501d0ff54a8a01cdf974c14a10b85165c36e59634c22b8654fc114c772cf5c01a363883c7710d73254225a8bb84d7543d4a16e51f17bcda08f35744897d468a8f442c27ee08085b9dd2f93f838517356a1156909ddd9a36fb46a22b21da6222d0d9215676dc239e8ec3c3803f3a9a3f939385c2db265574c78c97443fa97623b1fdd779200e3bc908dbfaa985b8df203ba3bdf5e500e407510cd82140f7878f3e55e447f1754d44f7c1c8ee741a4c5a683dd55d5cc71b1510b97e7d04c7497f798b0d9fd129cd4594676a6b956138bed267bd411201cf372bb553140250b9194bbaf6094750b1b5f738aa0c54d8cd835139b791e1cfd6e37a837ff94e080d181a0d2d2f2396c5ba6b250d853d3034f71cf83b4f2db17a3849e29fa6ed6f60b8e76a2bc1b0d12ec322ac8fe52500ffbf88cbb48c8ed4b4d74de7e09de32c95bd80d0ce32e786d473445aaddc7c1817a6e1f4a28c5599858b969053106bffd8b74e5f6c922407364f4cb8d77bb6fb334a3b8e1c23ba97fa16451687784e164186ba4129a0feab4ffb28f26b724dd1386085aabf335a86815866cfac7794009b3228424ad67d772c0b1461136ab93e48ae984a74a679a4f6ee7a08e2de503752474ec5f58fa9791e0a488196f194a97db321a1394458bd9a60794d84e1936acca8abe318c09eeae75bef528a541d29fbdabcacb68655f1e527e65657646b487d7ce16babd9f3159641665df77974c4b968bf12eb431a6d68e9cb11bc2d72b21fa75c6e38daff2278fac5b81214568ffa6f03bc6cffd1271be28928b10506aedcf1a6d40e2beb1385945ef823e5da541fd799b3366eca91aea0f976a42323244adb8e285c51d35656b2802fe4754ea09870b15326b40b9e8ad7687370c37589f4d425a625e592136d408806f26d5148765ba63c0e2c91be67874d4553e6c288213766d4ca17b60042ea2eb6a7d8463fc8a196add1f13416ccb2b8bed7a33634259e511b8e1825d6954f2f9eea26c70a34cd6957092337a3f77ac54797d6fc8a30623dfe39818fbfaf42945e5c9b09ca6abcfa89f6907079b93fbd10b71007da2edbfb44dfa8702769bab5b080586815df693141e4bd493b6c9493b00aeea380d95cd717e601c1cbc9624e30a50604a1b7d6349a2662a22a4ee9f56942cf314220c469620133c17a16eb96637ef6b1ba2c3970946d886a300e6ed0ed10e6705fcf8d5d9812ba6942a924ead596cc73140bd709d36b459b428c340c3f368c5b23ededcf990f9bba40f2850c9c328e90785dba0d22f4d9439cadba8766099b4e245a03b72422040f2f35d5ea24ec06c97fbb73b39eb2475225d1d87fee13ba8558a35c80a75ea040357f6529de07f9819803699b7b3595b9eadf92fa669cb9a6f5f7796cb1dc71311a666752e6ca155dac862bf3ee16cdc886a12c8c721e567816994dd4d98a46fde46bbe27562b3e58cf6ec81bbd5a0e6024691876bff10b7724ea9fe5702ceea2e98053a67678352dd05df5f6d7825f73986fba36ff2d18e20b604dcb312eed9f38d3c4e8e2be68ff92b780bc3bf4e120e5e8894ef80666a2057888af3ecd363110911903069540afe50a5741139d7b6fbb84cd4232fcc81c39f8c3bfac3014c7c7230cbb7321a58965112bbb10a470c569e8ebe69d0fdf3da927b1d2c5cf0093c20263053d11c8a2fd663aad67cc0b44f50522dc86260d74f20cff1aa6b1b520c81d0b26ec08f4fa31101871df26c1de8c9fc4890bf535fac7ce7b781ddd792cba78390e8264137993d3ea66d6469eb4fb2ed6df0d53b15bbc24aab9bf334a37b4739f8fe9e937595dbe2ac684e172c12131a6652268484f0293712b5a4efca807f4ae49ef994a78e25143d7c3f8876785ae0bc3a5117c8eda92459e6821ace7c2e6fefca724f086e065900bb1264be8f8f233abad3afc8a05ac3df1d7e73b15beb00b992ac445df132da5cf32404d5aebfe8f35befe086107e19b310df796d638ec9b41810c4642f3fa35d6df9b3ca1e240492a25d354f324108a3ac6d19fd562c8353ded8aee8f8ca7f418469eb43c552cace6e9846723ba212526b0158bb3b579e6d09fe1426e300cff1253708a0402d5d4a419ff092502ff20416e3e7a09bd41b90c45d0cfc06d4d24909bb38705e3ad665773745f6bb0932d987b156dc3d6b7cd4abecc3bd3ae9e7ce280dbb51767483c5ef33d5a8ac4ead1e9829c83732fe819eb729e84186803c3ab376174d8b827995ff2f5afabc964f8e7ba528f2b71842149127f67147d935b774273d6340769590aec949fcd413056216289fbf4819de85802342f72a0d7bc0f533ed0591014f16cc8c38742cb56f05ec7797e1ae5bf2b1d8571e3cf94c7f226dce42fad180be67649c71e2bf84e2ca3af0c6c5473b89a6e8aef41e3177009ac6b1c70f88d6219a012804623f42617429f79f013dec9f5f361b45837e7770dfe836e6fe505828d2c91bc8eda38b39412108b90dd45e6d0171a50de8b6274cc1fe4405c7d08039c6b903d5184bf728466c6bc9244142af1a5dd4ce7c587fb2213169b68a2fae46b3c4af0d58d1dad1133a352f77d5fa3a57891c55d799f602039b885a0afe7e197e0d1b97a0f24641869c8ea1faec0833a8e39c7a35a3d019a275bd41073337a534d0483b1fbc4da8cb3be0baab6a007945a609a2d40a7cb5816cceace1a2673bbf9695902673b56027ae7ab79fb06f2bb6ed9b0491a2cdd8d43b3baee6d49ecaddd11a2cb561a5950bfbba093e29c187d127f2900a9e9744d1c1a9aed149e1abdbb4722cc7b043fa6bc9aa8f8444b230ecdda81ea5d68fc8a05d6cbaff5dd380192e536f2585e645f8fedca230b8fa0aa489a9303f619fbb2b721a239fc4de98f3e324879f4cd84d86493b5ad3728e8c35a44be4dc6a915546e636e788ea5894fb0baa02682e38a9154b9cd19ab45fe3f8c9fd0dd2b5e9f63402f456660325fd1d9d47a502a4a55bba8330ba915a49d48d918769118ced26056787d906d049fe8bef7700454148d8ae32ac2998df205b5ed1fa41c546372e293b096dc41746c81cae78b187034920a0f107da67ab94cc6003c60667d763f2a621d304a15307a5317a7c807cc791edfe0f97ec7f09d58d99a5e98c1c65eb35d1c168c83934eb6f853a7aa41e8225532fdb6f52a66f11fbd057189f0cc64f312634cc0e4fb9620a3ae7bc810aea8e1666ff43259d51254b301d3f12188aa1aec2b17b1e7294fc82ee9b47ced66ec341459be2b55b53da815aeef97d4835ead827f409ae2248bdca247e69ff49b6dd326bd1220b615f19c6add64264c70d3ffbfb5bb56b629d1d3b44c806ff9c456c29b3a8dd16fe9f2416f32337250585d130924c9d48ff10f482fd6a9da1e29737758ae92cb0344d7706376672229e91c5b35ad77516e97f9569cc2552a93ae4f36992ed9cd95a76f010332748bdd195a59a1e17a468262c9ef3180f17d3960c83e153fefede256051d2200767399ce874cda3d7d63b2bfe042bb26198cd1ee4340285161688a737baceaefcba627a4bcb0af65fe41578d56e866a24aa79596822abd1ec91ae820a3fb929a5ed473397722bde8716cae2c2f6e464e6d967f86f08577ee73b82d61865527d34b3cb79136e5e8bf9cc0d18d8b8f077f9b53d3f45394a888f6a866875819ced2e5ade5d915ed461587995d5fc3ebc7da3b54032b1d08272cc3b628b6f4dac94fd4d8e09997e99ee8b60892fb8415c5a2e4bee0bc220c010219e85682326b2d1e5b6d4dcd9aa02efcac17e66eae3f1b70f95ec971ab2a15fc054fde8196f526a0f2c337155ec50c3059740b919dc8cc5b55c0e3a24947c31e298649801ce6f9b5b87e54918efcaa7bd70d68e28a4699acbc9e474ca2f565adaff64a57548e874a642e9ad182b9cf89bdcc2446bc73948ab8993b3b076eb014f40456f1e4644be5d7800e1489127cd183a40ec076d54759bca55b0aad8465e23c4a3e570ddf7013faa5f1fd1953c283bfa2cff3d3abc1e8e87435eda00867db8f09bc3dc68e21d9f178d083639a9204327e9fbd66b3166e0f71eff69f4bf73838fc24a68ed3b5d3f4674407c1773d47c936df6e6fa3f99334b150f12eabb3cb9c7f6f0a230c0cdd15e5c3142592dda61855dffa1a107160de3c72fc261b44e6fa9b4beac3b850821c980f929ad3a8d37dc59fac84ce1b84bbefe5d4178d6e5204b893b9e056a8d71286efc08a93199757ba8ae67f77900e41135b5e8712d4f352dd4c818e89e4bec06ba762d564413a353ed6b17baf7ca01ccb59ed539beb732e98b688343e42106badc12aa91714ecdf396b6adf209018ebb46b633e2acf70326c41e71dac496fbc07a468e896a3973279bfde50f949836c537c36151e4b4ac95612c810d54cd1fb8231941ab5f53a84e89af17a85449ebb6c028bfc0592ce5b119ba68c5446ac0677d3d372281767131d4cd0a5ea773a29b957435d6f92a37731a39088aeeecd7fdfd77f10a709a0e8f27519892881e29ec8443f895657d306347133bdec245535260bd3413fe9cc601d84ac69a3fa4cd59f4b1f4d2f4b21d51dacca73c68f20fc9d74b6f652fb028755ba1a0445afbb57defc6abd00eb44f0609f6bdd9ac6598462e41c82494ee8f2819af12fee385e0f6d996d36608620f6c239bd9a1e48a2d4a29eac0fc74706069d4d326a96f928dcc61363d4b3294ed71aec245b2cff5376431550e952452092a0498273fb0971d168aabeb684af243873bc0521653341793081a0f4b5938b717b0037d3c301c22f8ea770ef69517a4d6849c3acfe1b04a62728097a0310c1facb7f9f74720cf743aa4e97555a71c877f4d2d4163b4b5758875185c405cd0b10f7b943599a06bb04daacb344fc4f322d6f36873a3e4c28fc2af4ee6cf5d142079b926663fe995a06d7f13aefdd6cb96664cb6d09b0920a12973b0d1ba7328fd7643222ff51959ea8f748738a618813a4651d0a9040a74ad113a0c392a1c124bb8289bbbc0448e5599fb56e0b50a4795357797c3584ac1f66457c2a399f4182c2051acfff08698cc51b3cc0a93cbacfab0e5515160150b847bdd605e5ae7b33866ccab745b9f80c5870dbbd9e44977895983f7a5e08a9fdb1af0c8d03a651b982c1692ecfbd5af430ca257c10b575215be264356ef8bb001f03eba32e7f18132001c334a1135a89399f8e5197b2038c1f72c28c2acee7a4ebcefce28ba9b9d95c581a05dabdcf5789544803ce19c4785519eb3be1052c1cce173f93fb835b0d9e0ffd103dbbdc6369f924edb9e4a37f6b789b6eb05a1038f92eb441466984bb073d16479a399ae5b3bbf10202f71e76c1f440212c32ebf74fab1a41ee8a1f6360df2df8ebfc94f151ee22ef5b876c0664b1a8f1e5344d074e60e092f1bb017a4b4bd1ef39ec6d841193fa363272367828edfaa7a41c5f657587c52ce56ff2d5856edb3f91234d39f510af764e030ebe60544eff32df1dfe907905886734e29a7575c5e2cf9150ea187687f51209d40d7faf1beb5e7d51c494ba70f4572033f54572d5047f8ad7f6cde3ce43b0383b4df4a15ab9d39faf3f96487a823bf9c9cc0da36760140f58e4950efdb2cd8305a2fe40280dd1335334c78e09590a366fdd26614f57a9c5820fdd2d18d31821e20db076f95b9f285e18d516f1d042a68f0df6affaf65775a3cc450473ea3cd000e0712685c0bf17be797f2650c513da17b0e13b99736ac37f47c4268668c79d11f72b439a99bf3aec19442338eb090dc4448c1e1075e697a5b0bf5d3e79ef6426e6076c2172d0e7cfeacdbeed5c85a766681f03c1f8eb703d21d6dd52b3d9cc35f574576465d425e63470c4208b59dfad53b983b04d1cdcb685479c55b79ff32825b6715c70131df8c4f3a189facddb32a10f02517f2bc2d80a1950159bce372a92a910bb8219f0e73b5d2841ea8bccc27da5dc0e65b44f7e9e8a70c2d8980e010c441a6b688562762468929a03eec52020b54b9c4f14b545cd8c4a1a0da636711f50ab0b6cea00b38a64faf094b577727a458422a01f1320b40aff5164656191f8dc5faa04ff06fd8062f570e43e3fc6a788ca8a7a5ee4dff29bee8815bdc8b04d8d3f4f52bdce651f2b20ca4cbceac73950154aaf45ec4abf1c218a009d79319ba73f394fca8d0d9068f01888c21488d535fe31f15026ec820800bbcf0cd3a5dbffde1520603a4d0876ab403b36a46381eae3886ea94683902d3bf68b308af14c48cd4e0d91a4857cf1ce141468d695d5b9b5d6ee808542bdd35979938a426ba242e5c7aad5068d3396bbb69324a9d6c9175fcc4570d5cb14e1679ccdd59477d5d295215c26ac029ec3029aa510c157b6b6c634ece4f4ed0978178682c216dc9d10c9cb210fd1399b04846f54674e75b110d4bddec9aae100cfe23b19132a73aab7ca3ab6bf97754caebeefef718e98102374653ca7d1cbc9c5b9f588ec4c074ed430e02df19f3de8c44489401b5f16664dc54751543130fd296dc1ba0dc4c3c20ab39222b6b7cdbc0fb47cbe27ebd0b9b969843f185053fe56a19fd437de691ca2a8d91e752d3ac14ae9de350af67f1a619e07a6bebf4aa186e1ac2646e7ecda19d735ff61e084d6d8938fe65aa956426c4fbe56fa0d62ba43004c70d49b7d81774a4a6597fea9ba91c815ef3748a67ce4c7b72da221b33a72faca3918c73b781e265a4148a18d5f40d49a457be703cb49e151bb1530107b28d96011ad242dfcf8eaaeb2de263e9d56b0f34d76cef6065520da6554cda104e22720fc8785fa52b104296d24eee10fdbe821597bae1ac1d109d3afaf37330ef0a25073a9fc50eecf24918a88ad6e18150c5d9bc51b05bc942d6a735e67cbd3533767e8ae3245aaada6220f71f6b221554cc5bba1124f1d32f43fa40e015f9e2976fb7c490c24406e530019531b232d66d1b8cb53f13b4b2311d18932db65771aed52cd6f685747f7b5b5e834096783e9825806e38ade1015262dc0642dd127a9fffeff947efcf65e1514808271a15bf160f5b3412e78f9a6771e71ff5d9a24fb3bb6e30377c5b740dbe1e0ff49bd30ac5db07eec7a5f887f16c39b6ecaa5c4549c5e869dd986935104639d2ac011946fa5773dabe7005f49586af6353d799bea2d461b2df53b65e5f404773aab776fef618a6a4e1eca1dd47fe5e074f00b1a94129d1860b406e9a9f910af8393a01b36124878f0a63705feb733386f5e183fc9111a42c6b82b466337b59149f605e842a72f51c267d53e1de2d9cb48d9fc6f5928898fe4baa421a3d9a46f7a651ba5fb39db4324a6be692cfc2d1cf8db3faf7e258118f8c963777392a392d439b0a6731189921e05fb8f4705e5216c7e02aa6bb157f300361d13c9eade81855be137ee0f0d2efe943d6bb92f0fcb3ce4995a3cbe226bb9057aec0322c2e068c1dae94bef36ab1e631fe20797c5b728a36a5ca1d75bdf321b11e88e98dd21ce0c090fb1376a08edee521aea0154cc43a92ac1f75ea5e6eb9822ba2a4c1b440783bf2314b88d8a5f20f75bf9fb96859be5acdf09522228e808dc5defb9366ae9af12fd57bd2a16914c1c4fc14094bcaa17f3854ff52b9483f8ad835bff7c7b5e7e157a83901f581216f41ac94df6360f6f98c1f819374f8cf6b7d15d6222314dffef41e8a4de599f9ca0145e16d71cf94a779c0e9aa77b547aa7f351723f515f60544c4c3865a5f12027dcebabbe363bbc154cf2440d0104db63c1cdcd9bd23b8ef12f8139c751064cd3c9bf93cfee24e055ef9b89c4c8f0235ea975d871a8e6bdcc80ff95a087dec636c7bac1ed1497f64f6158ea323c289048fc196bcea9b70a5af7060b29ee0cd3a27267b7e2e6b43fabe55f2211c1a648101c7884ca6193c6f27ebcff2674bf1c9321c90dfd3354bab8a5e2c5e091fce9da3d5fc3de4224110092f5df64e46b7d034b38140f551b6931c2c52308e807b97b37c8d6c5ec4c679baf376511f0767dc12ee03554d590f966c151616fca2c3f7d81cac45652c8fb853b7aea63360b2c7af46368ee82986d6bab77e8dd4690ac43118b9a7c79d3b13be2d412210a9450825cbeb5ecf891da3ec7561885bb61142589fd78b9195ac646899259f571b90f5ab4939df7c1a4abe317e6f1361bbe6446a0ec06d278343e0a2e5760efce377c6f9fe2c8e80cb2ddf195e86f48d8253556b91590702c2368937a52029fb2d9de7e45418dcc0e7f76b60f0318d3b58e8e5360a6f1c1d9b90153ae8956b3866ce6d524566380ec99683803e03b3938e02b1af1455819649f789b9e34d4567956a11ba39d2bbaaab04763ead6ead7eefe8c2f1e1de041bf3b29c207a4d3295b09577fe36be678c44227b406366ef34759eec81a6e4cb76574765fe8da52047007774ffa5c58c0262d13957c9ad34842ae29695c16cb45b51608f2677552a0cb2212880ef073678b4adf1d43a48ac9baf5f5b2b6b5a0ff83b53444b29a008e18b60c2c76427c7cce14826d1f5f3aec5fa551038b2af9781feee9b5948f7adf463c0e2d688fb8a9a7da3e44055bde85ad425e8f421e8f74dc04e429920cab5b4f58e07d8767725538a03f9128fd57e755a63d33c2e05be60a6c90b6eedc4ceb24cf304e825e96901f32876f8fd1c93991d888a0366e0da5c69f9a6230eab7236e175c4f0dd6280afc78e061a0004e863c0fd2f48d55cddadb95ab289687cd74e65112d70870d1d97524862c606b777bc5cf0eed7f0071ed59bf09af1d31da17d98f4bad98e827540619c3c131185b88f2a410c856f9f670bef78919c53739b330d75a36051733379cf69acbb0ab2b726403297d1a77b8aab8c6151d6d3628b0faf85f12109c1e33aab2cf72f274b8058db4c0ee005b1004908a35c8880c613795322ad24435999a99e6df6dc33f5b5244ae6eb337f4ea07ae74df77a00b7bb732ccab4ec376ff13373436b375d714e52fdd47e133500bd441a6bb37ac99ee2c5e0332e0f2d132de2829f615ff19fcb6c226d829bc841a5da7b90030c7bab9f664395e41b3a7ef2c65706462e8cfaa32c0970c3e27d28f75f94b2cc912f865c6e77ff3eef7f59fa701db4d0624f37f4d6e555cf47c9be065bb6e5ef85fe5766c836d456519e532ab3ab5098782d5f71f3c645629f22b4d6b12fdb7cbe2177258117a379dad1d0691fa0e0c3f3bebca49e47a699e31afac2c58394067e3d21c903416f313806b1f4f6714c20d7a28e1f40a37e1846328aa74ab7225d2d4ce4fbc604bf7ac8bf5fa1835b14aaaaefc91daa96b6fc422d3e61c3ddf1442853956166062b1a3e2700f593b8242d41d553f7787d8490652bf7d5da51dfb65882c1533bb8660e229c9b4a51f4dea5e2741863ea8488e58b64677fef352222372379fbab9e74339e16f36aa41b68669790139244ca25bf0c5ef152a06a890ae50abbeff5076a041a497d64dbc819af1da29505116daa1bc256941e3188a37096baf95318529e13d743d0f316da13fa33ea1d8fdd69c39567df1fd6d4c34bc68d265d7efd4374ffa83525e842e220f302eeaa8720fc59cd5a1b313cece7f9a7ae4d8d3e303e9ff7bb57021c082102c4eb654f1a31e8bf9aa40152a810edbdb180d6470214afa0f3c70cf9bb3a0a044be44c128afbbb2d39e65247a790bae899054a973d9829a9ac7efca96bc568f6970ef4852ca08c41e77a3b82fb35a96045c1d8a828e3fa1f247585f083fa6abcba6ef17afc0d36cc0e9a816d532bee8127e86655e3a969944bf7c71fdf4480f360e0feed00ef49429b6301e11b6f13a572e50782f3339c1e638f1f99f40898561491408ff881fda2ddb70a250ab44e385d8003b3077ca1581a3694b12822db8c791e7410a4d5baf7e29e08ad43a6b5a1320c08e6b558b2e5bf975c45fca2261ba4adc2117fd5512588ad07d0882f95ea08fb73898b4d01d58a1377ca272a7b7dd42f49cc05b10ed85b37445bd33824f78ac7772268baae4cdc5028c7bfde1ed795a4029bae51c583d47771ca3741154d016050ee9867776c079bbe3fe2be135c6276cd727133c15537f5afc351cd8919fdc624bdc48a297810af5f6fa469cf48c6c77ead842c2320cbecf9f23a9d4ff1cd501efd961fdcb0f131f95edf275c34da71a15e0295789aaa325250a3e48c384b3350e2c7de33812a5ac77e3c528912112469f9ae6cd2cbad522856b42f0b37c462f8aacaa1e62ad0c34ac4541e41eb662b495e96cf8fbfc7a4a910414664e9c1d3ecd16cef781bb9cf2610a6f15ad99201378d2f826cc9de771f01cb50d279e59ae90824bb6a203730b1ed6c61b7c8dcfa201855d47d94879e02ccebe23d1c09eb0263995c6a3dffdd1aff5adc13918e7470fc2825251aa8650d9d3f6d66a6411e48c39f5c7b5e69ce05c6e1cb4663182822bac851d1e91438e6f4917b94a623ec8a6bf598bdc5551474da1d98e9f814a4704fa600a7817448318fbdf3d40957e4612e587b37f1012fab093f5e1f41a8bce9213a09da6cf67b0a1794cc5f09ea25bb6006f84eb2a29c5cd01ce95d157c8a8b0266d0ce1fd0cb718db34e41dc91347027e0c85aa376c65545105b8750b4c5aa26bbc66b51e206b0bad1ee7dae6c787c7a01ed347f546f47f94cc3ef8183886e82ccd4f0dc076c95f25dfc8f30ca19bda8846e329d6116d7f0dd8bc5484812defd389b29804a064eb8e10146b462c9d374aa72c4ccfea319ba09323bfc9ff2b5186b70d9f84d50da68e8ddf1af8c7efde544365167205fce06469ff8afafd5ba33e0a2551b0b1eddcaa186ca1d757d6684566af704af0272f84a636a9d6068e817ae06151a4b54b8cb24313bd7fcec79c94a459c4dc11af38388542de47322e749217f289ec54b9b66cb7d3ef816f960714481f6591718d7d4f8fa23ccbd748dee49c691b1a5fe83a4f7e9147db7c851e11208e79a06b532b3c9987c59d5fa937127056af6688bd5e44ad28ee378f069842725a738e13854e94afcb99d9849054813d0e2ca4f5174c68ec206ad7480ceaf1934d4fdfe73213b971d50a1fb1cd9feddc4ba84017118f6b28bc12d010cbe8fee24e234eb703e4a4f1a047efe2c13e759c907d789ccf1d2247d7fd827a2e36d4b6f8773fc48570e2a0d75a3f2a66e1b0ece818079ff4656046d87bb90dbc7aef0d6388adef4cc4ba86cf547298ae42252236031467834d235cd5b3dc8ec88aed1c9778daeef3630d48a71be0bf9fda1030fd2dc20f588e9af766c943c8084490bab7a4a0da89ccb41105cdcafcf86139fc08e8cc45b3dd72981f5bca1a7f113c12b7b19e238434d0feb39ee662b5bb705d0df45550e51f689405556ee7ded139c28b8bf0bba768ea73472b5e64d8429d455789854d87b69b63a7aab13a47f969029470eff1d5654b64b68bc9a8176cfd0db2be12ca9bf72667ee3f3058d237752fcd96425d5e3299cb236a489450652dbb2271c8384f6835d94a68d4e87b2ccd3be12f4275beb5981efe96df853b94cf351aa5bbc324d852f77c63dd0309b974b0cf7869e16e684315c95afe53cadb3bdc18491739e131dc6225f926978a099e7504d56d462e69815ca18b4f5b4eeea92063afbe91ed52b1bb6d8b261fe71d66cd9706989d5398693469de98a41b5580afe3b871348c37f56944a734c7aab7a395afb12785b6797a3675dcfc3f6bfa3fc12796c946488805c7849ffe37f1e2308550de5f92bcc9b3480ddf1e22717e50b17a864ce0124c08d22a233ebf4b4762026e5bbd35ff68d64e737930300b9a8aba7cd7dcc205f6674b0a9bf2f80aba0da83cb613e29dfc72d0404e3339258c3e3a20d7ebf677da1acc38605a2553d76d6f92f7bfd1d316c018b863612db2bfe562c32a5eb048caf65e97265568d28c0a82313d7f18538ae77fbe6a458e3fc38392fb397a2eaa847dcb92572875b63f22cca33395dc0bd39e9719eb93b3879c40b64ce18d3386f004be4ce20da8e7a7b52b871aa91bcee44b085fe4d4093eee1dfba3288a9214efbdbb0678aa897da66b5f549854b76ed6e0f013d5ecf1e20124d99bcb3c0b72630006c14efdbd95cd4837b31931f9109062b938014ab4e39a139c1eeebde3b08bc62af43ee792549c36294a9490844feaf8fb3f99c96d0cf037106b12263e0679e6fdbbc5a7afebd2e45aef15c8ef4c0266fd604e613b82bdcf7fc6ac3c89e63e0f5e1e2c0d1ddcf24920b3b5e8dcb53ef6cb10dfe2b86b955802531df13f05db37fb37a4033c27332d568ed6b81ec35347139557e17e83e702272845f8a844204b6232db7de7d53c574da95f3d507b9757656930e8a580fc15ced6091fc74e468360347b3cb3356435feedf679038786680352364f6dedba10f447e6d38241ac957967debfde8f55028033ad8463c4efb037b4b36c4d0631e3fa9aea04b8744947c6a0a72eaa960ffa29c1de4196a846d4d058b40fe682e05b9c7d55b6fccc9baf59dc5b4a15b997214d44ba101642e73175a4ef094e8f436cf214368bd9f3d2e5d49c26b7fafacb7d02bc3daa00aa907a1f81e3468fbd29cb6d198332522233ce8c19293a1f8f28ea176526db43fbf84a001de1c4a0b590ac0c24f60e5106c9aff05a2cf4c56fe774fa2122f14214b26fbeb07aabe0d123b8490c256058f6c087a2c54240919d7340c97a6d5505bb9472a6790e27d06b907fced0c6c62056fc9b66514e722e9301331c54e72f49833902ce045d3969677611ea48f9305f1157fdc9ba44086d38bca223281f8b555b8178e7799dfc49e2825bce33e8eb7096864d46295efbbfba5b7331ed8d447fc45c8abc44439d4312f65f369f7e93d8fd398e7f113b71f1b8adc135821401fc6392ff8850923e69ad8e9ec0d12706c90f5ba4bb395c9bef9b95e6633f1c406aaab","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
