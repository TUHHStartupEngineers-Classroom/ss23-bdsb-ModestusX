<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"18bad93dc47c632fe6bfbd3ed7b9ed8d282f568873b45e8370059fb943125a8a30b53b61d3de5501c8cfcc9d969f8c2a61ef8fc795e162a60161652bea7002908b36d85dbdf9a7b4721bbc6e1bc6cc6ded9c108c4ca540bfeb5ec3ebb8a0b69039c894c76b3360518e1e2a6b37fa673ca837b99791a91c4ed661151649752327fda73c20cbfb9a761d7e5fb6ab17164b8a16311ef36d345c82368591e6850406e64264d64ea15721bd5e7b4763c9a72d9e8372ffd4c957b21d83c829f33dc506c09162f3be89d5f2c7552968a45f02bd356325be39299ed313378c7320197c560509c67c7439f2947adf79c27e52a55764db8cff31b19d43fc9cd8f150decde4e4f072b770e8f7d62a572e5e27295acc48beb1b3f9f2e8b15b152499934284aaf921849dacf4c7178432c4b35784e7cf28cc13d4eac27951cb8c5cee906f653622848d99bd3b8fa96e8fd6c46eca41b811ef307cdf64634cd1edf41b8936c857b5273e137b3b7d95e47318965b2c91092fa9e7e817ac59a81dd712cbfb7d6bf9035d4afa9fd4bb024ed2fcbe5fdb6cd0a9cd57cde02f27101dfec73cc41667ebce6dbbef17959d4f5c5fadcf92c432849c46090f2b1093d5f36a51a8a98d39819af6bae18b8473fb2a665ff94ac32383b1204aa4602c206ae3881bca73ba35e2116cc395344bc437d737c0fcfd5f0cb2306a25c1d4099ea76b4ae9a9867635de2041fa255cee434367d0c3ab349df7b7f9ec68838e1eceeddf7ec24c932f51ac487c48c9848438266818b753a9fc0e5548598d25d02d4372104e232affc5a8fabca354ae09ecaec9f3383b366615a5d1b31a9beb30fca85e320f4bcf45eb411f13a15f6322d9c5d6742eb6e3510673dcefe2d4673bee1d0e81b62adbc053a8a8c71009766933afdb4f548fcdce8cd277155738fcdeed27e9abdb3f032a1e870ae8f58c95610f927683086ed34eea1ea30da1828411b6448861e91a1c9cf3cf64715600d4394fc596f4abe99f77cd1f0071c253c19d0e1c542e388e00a4f3c10958672462d2da415432498adaf1061aa75a19eaa27e1c00b9ea8dbc13e0e7e0a456418a2226b629cff95df1372f51cc4113aa7fa77ceb052b93b63ec268d204466c5a87d5e766da854c33ef1845b36aee3f2d772ca7befe86a06c5adf4fe14fd7907bc8bf3b867caaffd38b82914c430d4cef8d8bf7158f8f3baa9ac23222fc0f2ff1dad066eea26bc0db21a27a53b43354f7419b69af11db074249d2fe7344efd08a047bdcedee9e56d999da29dcdb142a15ec8d70a03e666a73d41cfe80b514a22dad3e75c1a97e4e46b182e75588dcccf201e6ab4cb0e5195539a9ab7f685e85bcba95eb041388b3d79ba12b8348f29c43f6d6292e4ecfa82e79f78332e8fc978577cfece9831461817a5136c39ce39bdfe934a20eabc26e379773c37b6baa9edd80f927918db325b17999001825b6cf827fde2ac69fc674a146f8335056f6a4abd74c81624acf6c829c116fc10ed5a81fda5dcf4e4893a9a62821210cf981170bcc32b7ede1ad3546bdbdfd205af16e93fb41a58396cd25632d150032432cbeb0813510b00aa85e2f58e247fe4bc91f20104521aa74e151d504cb424eefe0a534a0227fc783604675870b5e5ca80033eedbae699da47e7af6920fe8dfaea333681df0537c79f005d1c524d01bf4a76a342ac7330605f52d8486479dbafe7c190d14310f1995af5a7b05d37c16ecbd1a4ea71062141076cae55083be2d624a76e53786b623bf6d02dc6093c6c46541b9f858d1ae6e6608b30dbbede629800f862dda384929aad2d8e974abd750b6f21bb4aa26a0f472e61a9333afc8c0e48f19a098c9f3a8c6fba65563478535c83d7bc0d33ce380c287d49422fd9629b763b23c0b66539f7862cd5a6b7faa1107dc83bfe12ee3a355d412ee1b0403be7a4b5b59ba42f19dc1ef6425559d0cba43f79b014daafcb79a762e32a6eb1436a7be1a9f0094dd719b4d209ad968c0080a41f25b05d987445c7f99542fe45a67137befcbe5a367fa03631a79423eeb210bc833f653f14b1bdd29e36718845a24ccef2ceab3428786dd7f497741ac8f507c524d4d8564f929c805b5e3845c327f130d2c1b7b74012bceda24b2e16281f5e132c4b37aeef4551df12d25f0993e912d1226ef0858f7804684002355017c6c1c8ee69d862fe19e8a8ee73aebcfb244105c36b49d133db8233727aef3537c869d18a6adb2c58a1a678f458ed99443733887c108697c04c1f87636ed04b91d4f37bbbb9ef577b3fc93b8647c702bff97286a9fa67f6c1b10edc0d1cb63084ea2f166528a088d6b1d4e6687ab19de9a435c9f43821646ae6197eaa470c2003517681f2d3b206da8f5c7955cdd877015dd64d0ac5bd842e2ed03841ce75a10366c319997375ef1126d1cddd56d41f984b956b6d560582a4256ea022797421db29dd717c91e60e83b9ac6d9aa2868ddc456be0ccd8f69dbadd5c39fddb605692a6ae2a453f176691a5e91e2db17fe5d72800aaddc05229e5ed32271e9fdb815d213d1d169d0c58739163b956364af452f3f58672b97cae59c14a915e5e44687f6e6fec912a23c6505e44ef43c00ce69d477b757c266733d56502208c7cdab95621427ba002f8db419615b053eb2c7a04d510c155438001a3dc771b0be3daa384f305d72957ca734b95683f0ce948eef78e8d6421d4ea59b936eaacc30cac236148b6ff7e9c8d511393b8709401eb4fc1cc002eb09a2211d4d245880e5297e05ac808d099d673701ceaf19ea409e33d37ca3ce65c6e5f9fc40a514655aa7b89116ecedcf8cc685c08fc4606b87c4fb14aaa0355c3be37b3d8b2eecadbc1c941e67aaf334c4de340dffbac9cc226246b7d75ed09a049c76eb43a88e8976bc82bb56f797712044ee13d1a19ff6ed27088d54c94bbba5683d887ef0cae63b70016142124ccfe2c0d1a6b0ffd585d78bc685120c0041c960620beaa2c1367fd9e4e4d32ef60736a7ef5aaed61d2098f54e0ca69903f84456d17c2acde45d5f61ffea2fa2a7a5a2e7aade01927771dd330339bb697c701caa68dc97bbe4bfcf44184f3ae7657ad2115f459a7642d1e57aa42d97a78a0e23d81108dcbe121d954b42914e35ce0cba462a98e722df8c11a181080ae91c28f87f1e9976234b271e924946f3c27dddcec2935c28f4633a9660dc6bd2b9328d181cc574c9685abfdc045b8d77be9fd49acc2ec211588999b285f865eaf7eb93d479a7fe56483eb5643c0979c81d68776442a954acf1cf9f3bdedc6782bc736fdbe2644abc8dcf98d755440093929b09868c94cf116466f854201dcf9378d60bc8f04df276b55657fbf631a920ed3539460007e62989667642a02e6576fd6efa7b89bcb9e50139b2730e7108cefd8857d23016e7f36c54103ad2c054bdbab4da7eef4f1b126d0e0646ca56e632bd2f793912bcb1566018dc9e936b7866a937d115a477c63d26f0942d8d8e5a52cfc248cacee24aff49f0979e73a0c26bf0040b0c106518c31d00b9a174aefcd35bab39fbbe8151764fe547bbc544d8f717349402c6c7be66ecba09a0015ccb5a4322a25c471ad996cf77cc6b8e76d81e5bc2a13e3b6e9caafd1175d36d10222675a9470cbd37971761e92978051cdc51bd7f8cae6cb02c5f0007ac5da036ee9538714f27de4d9d5ef84e788ffee6cd7d94de908c62575e653830eca1e75b4eec1d1fb7aefdc21c0ce11097a680ee41deca02ac68e4eebe6c7858428a73e7d6588b9f0ee31d648d734e05a513bcd92e002a77b9ee72848a1f291c9c04fe679d2dd34848968e5a02c05fe16663b0a949391b6d49de2c0a4f2dc06d2ef00066792e1df51caafc02be8f8a259a945a37fd5aa949b90c975148f435eb3273f187fd2dc67157802df892694cb508fda256dc371cb712937bd22124dcfa9040839a8efe855edd01fb547d40aaab05f632338edbfbacf8e4e95afc3a60ca3b18b638eec14fb5ffbbb3be1061039184129ec454c9cc142965ef183abbf19950116952ef0596bd8559e7c617a32012754fd34b3b523589049cf98c071ce4e09052229c006fe4e8dbba08ca3116a626ac1ed65a604176267240feb2b26642c70fee58b9fb1e42de2effff2d878a9d3a885b8f4f9cad5839360d1684d67c555f7b7bb3ec119370d7cf5da58dddbe0842a3851ff0c75d23db1130ae44b50bf860ba75174460937755ccdce8f69af67e709efba84cfb64b451bb3e8a48111938c8d0084214d48f882c537a1dc3b523707dfc58565eb246a20649efa9fb195e8e51fccf4683a1cd0b48d453116e47801bcf821f4baf001ef517be976b0c964ef9db566ddfd3e5c38be8d4e94c105b06fc02091699651422e4a7906ea4b737a35b3daf968cf61e8ad72e4671c5db5f4ece3c8fe7a518b42ba7ef4cda185dff4410e1e0d62f31a7cc14eacf75818f06674777224a61900f5678fea7e969939c83bcf18c02d3984a38b128608473ff8e815d43f6586a663fef43d6eaea979a3a9fdcf1a6907f5a51e1efd344f03fd9f02b34e8ad01dc0a7306aea6d0714c717de48ff672c3960e73b3835214e48e49a2abc9573e88e766b9e288519e2ada627cce903ddc2c3948b804c612b89d7c131fbd734452b7913ace0b902ea64a0564dd6e4640fdf60134db3e17c6f9ece58c229be1b59df8e2f37b356da9931ddd7e01ee5719bed3e42dfceebee1b07d355b49cf49e69941ff7694c625ee8e33527b40ac0d83aada88f485f9845e78d9c44ce9f9ae804f88e5167b443460af2b8b029a098c5f69cdc8e2c84e318dda8fd80e120af7ad35e3fbf8820592c99f742c950d3eaa0797f438d44190ebd29c82c05bae8091697e8ab4f7de9cc819986bf8d6ceec70a6a01ac61ef5acf3b881dce1aff75b36b701248ee7f7953000bba0b93945ba662e880d71379e3360872ff9caf9466345b68a7eda17b11825f168908ea3e1a9898ce7b7b40ba79717d1bee9611428cb59199baf866fdabc7d521c584259647a82745601aa4a98981495bc94eea984c1fe4b9d3fb453954b751ec783a61eb4581abf3a8088a800da02a928122f1bdfcc6649ec02a94d141671fafffe4222a7e734f88150d68a4d5c8b13c2326bb5290b6405287d735737b48ee86c285ab98938aa711978729102e7cae206832fc699e2269158998188ffe9bb57026edd100c33fa5de7f50b3b1e82b73aefbb9f672fc119cea8f4cd9b2702d70efc78697b0e224fc1d701205d0c2a1325141a7702ea3ca5797a57dca55db8389fa18a1d30041a5ef0bb04b9131622f748bd40a9acb1bc51782af4670ceded85c9a93c8eae348e399f1b2bcecc220dc885968212559ca050f124d002fe6c3a5d093f48fcf152eff4e5b03cec4bf88ccb905e01bf74e9480da1a7af0eb97fa167c3459db02766fe42ef1593e08634bfcd7ffb9532ecb12b687c0c8997d3c9d2e990746add21b04879f3b825f63293b93832bee5dc3294a8dcdcfb7edacaa16ed9a9acc0cdcc1b9cceb78971281a6295383b36244e63d83debdee3ff13101d80c17b61b8c3df1f05ca7cd641fa0bc49e8e836297bf3add64bf00e42620332dbf0f897558e98c4059865739152efb8497b8c4c0847c314af7c36431b2fe62caba3f50910bf53e7e7d0d11178d7fd8e950841b3dd54ee694651e514e584929ec0abc66f8838471ac671f194846ec9785e4e183097a97705f901dfb6be2ea11c35d1308d8f487b77af598d4226c62cddc71bcf1ee56fd501f24625101ab132dede818859b9c7032d2fa0798d27950711d00efa0e09ced4b52704f3c585c79d50cc5b4c02023fc9c78367a5aa332102f58326f289a1027da17de0b23233dce1701377070e66c2dfbbc0d3a911b2e8e3523de66c31d64187ce62c8c0e0776355681739b785a24ab4b7901c6fdf92f8bc48f6fa12eebf9a3cf7f3ea0bce4aa7564f476ea6d96a7be02fdd7fa26762f15b85df06b49f83dcff54fdf296c305978b6ea79e971134cc1cda21575202a92e5b6c35103787513367bdf2b0816cd09d6423873df038abf40a570f00f5fa2b13660f2a5bd4d04aaadd9e2bdad598de8a240a3a9509830034b8c2e2b504d2f354a4c651fe40276ad7cbc6d6459f2716d1d3ff30e795e53854390f9e6cafdbb64eefeb02f4945bcca5771580b00efc34499b440c535a20ede6e480334c11bed958f2e119d0829d676fd398b4676c21a1cb5eda9a93601909a1e6f3c55a2fc0046ea3b463ece213ee98938fa66d07ef1c6d2a3ffa7084b295b9106f481503a8fd60ac83b29a6a8a4f23b73f4acc3a9888db34fc54a9866364395c2f280b8c844603924c43f93aa78b813fa50f6eef714dfe304e3142fa6fc2315239a341287e9cc8cb8da395eea1f46bd8e330ae0b0d65a911b2313cbc36a88c7e709b81f6ffe473a09b441005d7d48a837d1e045c4d2eea31b5f413339b13a96732d8ae0966d4ea6c1920540f03666076f1111831aa4a64159e83d02fc4d969955e085b8006a8247d357483470af468375182084b11b4015cce6023d337deda270d84e2a7ee5557b034f83505ffd0ff578bc892f69cc2b5f15d764b32c5f9b078bef27221adbf52b5868a21f34a9076aa2d3a95348773cb34d172ba5ba67a8e23e7ff2e20beb6fc8f6b6dc21f83fea6626e1585b39a5877f7c91ffc4d7733d0cbed4eea22aaba16de30f3197672fb1f03c1f224e498fc46832223d1a048ad44e94a661e7d4b5fa8a7417d4b3ddd55d31e22bbdcab25cac437a0b3135c0cd1855be5378d414cf1edf7cb96cc5f0ea8288711d05012b0043609c3ca74c890f7326b771c81d147d128fd77095ec4a0a857a49a015f63b5dae3cd723f4651d13ab62b78a68e0847a1d37adb1da8f93238ab5efad10de69dd8a22741570a5426ed77bd8d6086364b19b7ba11f379cd8b80b601cf94bf44c3ef85ef44f0461cfe1c7abc3e7fc770bbf4e39f6863503359cddc0f78dd607a46d19cf7f898df5d963993b740d391f99670b8f08333716096fe61fda2eec290b03d72b8daa620825e9c409c15973dde57946e84beb0f59532cf72db43533bf6ec40e92a231ced96882ac32e21f49af44fafb2af429e5cbb6cff7f91f2574728bc69e057f399a1b5be1cb534fa9eb5c019e0feee0ec5283ba286a1bf2434fe7a5979593abb628081e95fac6a5dac082c0ca58aaa538ba775378991c4acd4ec4995f41042810682f040e6b62d9957e82ebdb679d873b3abff2bdb6da136eac1fb822eeeefec79249442cd920f7feb9d437792caca871f002691edbef8a8898f36b3e39bbb5a8c5874e3c0822069ca7ae00a82f725d2d0b0eea3cdf2172e3238fd4da77ce6b4b1df19bacaa9c4d9a5bd3b73a95830c512d0f96954fc5daf5392f891c5e94100b588eaf447a2060c224e1fc69f2af9d6b0810c5e920821a05d9e6771e9a4f264b029c83c9b61465157bf9149652bae3c92214503c0f20b46500ab20a446dfcf37b54e7d669e0cca19775bd245a68e4cbbabdb8ccb9e9a91a71f8b472df36c6ab422f0de028d74958c37ca1f9022ca1865fa809578f945c01b979dd1254f7b52e84dc3660c74f43ec19375e322ed553bdeea4ad543f66367492b7244729534c4cfeb602280e7c46c4d03e2bab84a41b59c13592e83d971118243dcbb24ee4d11faacebc6d9c9c0328cb0d333da9a8ee5a19b97a6838242b846cb077495f13d90b7a79da8a344420a20232f68eeec86fe9fad30c0fd479661b42ac7782dc35f1221e7c55c5ddf08e4678a79a407b436b3dea191e0ca9f3ed94d8200a9ca53d50b74b6435ff91a92f84948c85f684657c02b69c95e34d34cde94abb58911fb598ac6df0fc00c3554612f3257ade855aaff8be9fe1262505b5b0aae7ddb7a0104b845bb4b6b7652f790bced0fbe410710bae148f115d540ff9c8eac6668e43c01c79a610f83ad4f84c27769851d83204bc1b446e4b7b7855997e8ec1a276a07a8f4f193de1ecfa8e9d97a50acf8d3c1e4afc4ff858b37fad52afb8cd7e3388f3881b28e33038a3e1300db6578ac3ff900ebef3e9449c5a3077f57f516cfdebb609b9ba4da2f4b61cf7b04a1919562ee20663429b46d4762e8bb350e36cb31e25c8a5fa9103dc1aa399c9b99e363feb3ce33175deac943a5ed028623821d8211c52e36a83622adeb83cddbba964a0a2e6ed0bfc595bc8d64855c2dd57d791f83673022b8cc46c78053fa2ce0ba3531d1012cae80ed88131dfc1dcd6937422fe1acb92954da9e031f54782c9467906c34bff754cd3e1a4cab65b2b6fd93d4bde4f16531f06f3ccf87b3ab55601176152f684603b4c9942420027ef153ee8be5588aeda6517c534d41fb49e8325655666c92822fe380348e598f625305a26f5f9210b5dc9bfc3dba2617a900949b1d1a0e8e75c19fe8f90b5e67da75a01c9eebae3a4b799cf5b896c77f0c952fe5f716611d47546236183f29ccb8e5dbe7ae76916271931191f888825d620fbb17a6d3636d162b8e17d751ea37a352a1dac7b03bb615e5e5a9eb46c3b7eaf6f3285b3addf68c44ba7502d08400e0387fdbd47f910b810b777487fbc23b32cd439d83ce0133c3c485205600ddd7a1acae77514a0140aceac5be320d9ee13ff7b105efd01c548cbe0b03cc3e9a7d21ff418b8d41d6f17d728414890b366a4516c4cb847500c44689933370417908bea382b5967c43dd5fdcbf49c5a93d6f8a770acb17a7bffd9ecd476318e21b960e4f1e39230beff3ca719d64f349789ca67b0415be17b33e2e10ce4bc50d7e1812154b179c8a10f6753599c3e89875566cba392e40091b64ec762af0814650fcc7fe8e479e10f42d9ecd5f757ec8c3f68c5b5f0410afce3950684c29125e35b8a6607fcc94f5d0b189b0392ea0c9b14fc721487dd1a019223d28c45afc7255790e9638af3ed338d1af7d390df512c37e1b607b85a0bea0609408097d5a61cfb65a7ab4deda648b4d6114a46f93b9ca2283ecc6b183bd45beaa9e1ab3f7d7e015cf811ea5a1f8fa43ebc723fcc36b475c306146d2ef35852ffe77e784685ad956766cfa485221599d82b39e7133fb4390f01a2d13a5170aec6cc1c93b7f58d6af52caef354a051b198dc5f6b6bdc6cc3b5a9e40dd23a8caade8dd9d4a004910d90bbf19f63874b50a49b73ed05c3278c498dd3d67d0e9fed0bdfbda25b24d3a58247a5fe97ccff188ca2d1babda6e98fe27be3c46f9be28f9fcf6b9e2857fbbfbc55e0757b6eb249ad94f8d65b693d350eeb0002e799651ed78a3ab2bb1d0b55544f107b7dde6400b9f4c195deb5671b3f52141b5c767c04ec2ae68f2c117d63a4529c8c2a2ea40dff321840d62c5d1f2a1f9bee787863ac95a35cf47402623c19bb64d667ee4cbc8311f128ed2d55720190f59026e6aabdad914c34e5a761d1bc7f2daeda641580fbf02eee0d5f880b981e72e9b2e2da899d6fd6b1a7fbcd2a571ad56a8d547794cc78f8f44817c1c13dbbb94e59b89aec8c8188c25102c7be8981622e87cc77d2137a0c1729cae4c3f91b06caf1d48d2d12660e8882399ef400ed75410db76c24c65641b5385af6c95e1e8fda9feee2fbe9ecd517f04533a3de957bfd601fffee06c3523b77864d69651e1d1cb24c65b2c32c0b149ee9f60ba9471b2903ddfe62ecccac7b663ad7dba3515932fe4930e2d8d931921007211b425c9b2be001c48d3765e7abce5d51ea85ca3fb76dacf4afe7755697131b0fa4a1a2c0e8ee8b69f213f53803bfacad6270e8dfdd5e9cf4faea8a3cd4b136512ff0634e7b6d2c107757ff66fa3b1fb370380e9ada62028396ce2ac3ad24046f5d69197dde33d676f52b5886c07ba57a9a57cce19a316348fa13ad829c3cf11a58cc6bcbca3056dbc9763464466766276d492fa21215c58d3b6d9dda964d6bd224caa076561d152bf8834b1cba19aec1c5620d68e544a02a6594e813832b85a34ca7103919921ebfdb807f3871636724dc6fb9494865878aaed4b0e88122cb57f83ec4f3062f7bf0ee0aa170a91b8dd3decbf5c020dc128a5b8a2251e6a7f1ed9666a69ca7103dc74585c18d160ca6a5696e7e416ecad7e8044a0ff62caa9dfc9e6bdc40eb0d7436175423b7b3aae5f2ed29203c9adf75e1099eb50df7292a7274f5d3da2fbe2fe5a5f7e4ad168bacc284c0b759f463817463f0c996774ba590a8512a320dbbd4cb2ff17edfbb6c1981e89278b2bac4a09da51efa1deeaec63277cd861b7b117d1572abaf96747c113086d13e450e617d9d16ed812f02582b117e2ca2838f59e4bfef7dd9cc89e38d089bcd53c536e7e9824c30850ab1e4a7ca689ac652a81bb6077bc1b59902dc9934c4180b680ca228b32c3f7d7dceb19837cc3bdd55bc611f596108c7d482f70e2f9e618d9be17809d60316fef4d0224d2608598396469b3f2a80bef69e8898676582687e37393d3237cbeebdf459efa172e2c85db970b13dc1a386d3d178eeeedfa2616aa0d339cfed7503054367ac5a53d259fc1e366e5cfbf70c35129934e9850892e195d9d40e7de44d0b191b45797eed50e986505183fdc094f830c242ad538c9e31043202987763b5e76718cb9503e8fcd572a34a24b48b81207047cfdeb4ca71092ee784560b0a3bc0e1365433e620ba5d5e2683a6886c3e3a5715d5c1623e3b1478d878945e20a9ed0ec7ecf982154572c78a28b06296b17228ac5be85ca66bfa1819b004b47140bc079933e8f069bda9e57a1d12feea5859a5661b81503de246b8c334325735f7473ce5d47cf560e491c97e621068af15c22629e35a9f5e9af9ca44de9909e2cb4c0ea4050db3287cf8d43facb6227a83784ecc019a0c3320b9f991cf5f12c0244926cc6795201801d52e8ed1de082ccba0927138e534b140184945fbc0c0aaa5621ef563cb4f45b3fcc9cb621b6c9cd6fdcb4de6c4fb6e7aceb2a87a811d74e4588f1e443a42278589907d6d48036f3c3b2615b8776f370a146ff4c6afe46fb994d4208fa555160694b383c128ca820029bfdeb37d755e0abb01c98147906104bd373a5ae9fb1de93be841c5fce12c37f62ddd0a89fb7c381371d512ac599c771d17384a96b440b5dec7da7e9b660e0854ba06af26637f7e4da5873137b42375f9f5e626861cf4e3c6c6dc8596e926529aa50dec1af0f126c98bd8950f4b0dc4c90394b03bd879dad35cd9591527bf2668a501c1f9f70d2884f3794f8760ce7789abe50205f7498096b4c7131bd0f74e23498f27dba8a4f7ce3dbc2d5635b111f0cf05972cd7ada188fa7ed80bcd95ba1032160d9b09521674382eca067df3ad4cfb358f95b995a52bb9010d70068350835f3471a4546a1e43d9d9c12e40a89fe5a35de9b725d43bb03b612c548bbd2171049c85b139abc94e0bf20aa483012068d21a9316ad605dfff93294c2526fe2300f8a2bdd3e4888dd6333b8ffdec7b271ff473d108f453aa037f04971d0e52ea90df225b0b40951a05921234b78f6a4626e1d7e0e60a8de8d165cccf619ba58d2e773b5db268304a549b99dddfd96ae2bd8c4342c64ecf8612f7b49f810c18c05d8b08d505e8f18cb8bc1a4454bc8330b73f0a610be7d3611b4f78acfc67f6d05f67e6c771e446efc55f4b005a4a04b32c169cb52e889b05e00082ca4f058c57621d5a895dba6f27d65a6c8692fcf2fe410511c282db7efe0c8325e6d95a78513e7992543c59319b37b3e532176486f14c2a2c5e0d3a118b1da1f99cacbd59687655473385a8dbc5116dec0a16a3a7ca8c2b1a2c48b666389ee8671e695c4b077435cf8421a1631c53ec3134a2f67639165da9ade0ca2d07d2c0aa1d38081b76e0eb7b43f152ed26937ef741b89025d67aa814bd4cf42aaac09c056372fd8b703c129f10a02bb85010ec8c1710b4b22a2e937327ce3f43e26bde3d20624a2b65fd8e570d2ee0d6c98c22c3fe2304fbedd8728efe9fbf919f28632a496fa45b0a9e22796d548d1c158ebe226507ab1188bfcf4fe16435b276ee8b9fc79b21f890dfe739a8ae08a62f61c4688fd7dbb5481e30dd8da4df48c421e37453086a6ff73879a27d3b20049d94dfd1a9a32ea47a9694e07cc6f22cc987d1d1401d0b5d6a04a8c5cf9b976865dae2098b57afbfdce2cf9b10b7c10191576353d67f08f6b5a10a126320bd51f1d728533af5c6ecb224afe4cde1d37f9b7691048c8dd8d683f5a05efd26ff80c604b8ca154415cfa5df9327d38e0f1df7a83943c566878c81675dcbbb2a0646f6ce2616a26fa902ee2d22f55f2d95cade788959d2622fe83fbc80a9ce7231e574013216e97e614ae3f51cb05c316464d9f1636b829b574629cd594ca740ebef2c36d003e1b2d1b765d15ac72690da06877e6bbc71031f3001de34a68de5e9b7499e6994217d22164f37b53d9cdc3d6c11b1a96dade7940601dee7ddbc0cf2d424d539a902953eced1269dd0b19996848753e0a8470453b96bcb878cac25bd6398a22ca767718be84ac61b11ba688d339e44d985eafba685213d933bd438c68ec00277aad1ace7a8a411311d2bd9d819546fc446ee191477301ebe1d346d98c73c37c6e7f3cd8205dc02c3f19e079a5cf427d0bf3f187fd7750ba05502a348b3cf5957c52bef171c4d2cb5d1ea58e92c9199a0709dee422ce4d36194f2254fea292593a1532bfd0fddab0dbff38b9bbb5790ae1d15c1d5276e7015057e2d2d1d48fb43552f461dabbcccea9aeacc32fd1d00c062d160adfd7b6776d284a9d3d11d6ed4d3a68f88343b8d2d178e1bf173b89c84843775537eb2f39670c7aa217ae349b766ca7c43355bf966128e85ccd30795f7ba7cf17eb0b87bb16a1ee0953e6829e33b0c48ffd9a30491cd696a44b9815a0e42ba4e433887e03623abf81917d898142cad6b08193f453a03a600cf4a71d9ef7fd39c8fb67d194d6a6504013aa75c9c683f421e22a5692473ee8bec8944fbc76f9b12275ed9b491ffcf4079e11eb060adcec9c6444a9bf5207552068ccf5dd552d94a7df4310058a0d5536e7d917b19f49862c3d096131d22c31dbe0866aed847072a44bdb539ccee99990808204666a007144483dc7935f94121fc96d0cd82182ca4d4cf7ed97ceec5e634dccbdbcca20270e35e4ea61c0a6fedbd7c7a1fe53d77eb271ff5cdb2e225071aa6d8d7af64427a8e85baab23bfed2e89a94ea3f3b6e066e017f46ccd3b77e6f24a28b18a6f3c58cf0ba4c3d3e379cc862ec1a8964b5f16cb560b5b2028e68b94d269962f6d1d311c829fc4c91f31476d7350cd09d52b098b42ab802d7e89ae570501c4bcf631eb2c6f065d080d9ba65b77210bc70e9dbe1d0e665a9dc80f75985bd8266e3bda0f56964d93c6eaae408a8c3373891b38baf36f7302a7ab1e089810bf0d30a9e749845c4dfa446db44fd2f93f26b2d805a62bea58c126b094b55ba876f3e9258cc94741045c9f7c95ebe78cd1ef043a0bd9e29feee2fabdb4c55d73ce7c7a5b6c599deb3a981baab4f3e784cd80697f01021c0361ce66a7e93fc2ffb47a895de76880fbc3be4fac1280a7535a66e21fb233da65573af43edc417bd6bd2b77cd0fde0bdd0bed96c37b6dfd15612f100b7ffa19419a4db4e205f2d5131effccddc834ef50040cb3953e183d102c74a61076be372cf5bd03b77de847617253569f364a64e74b835a944a0aa84a08b162bc6f78dcf33954bfebaaf812140703008605839951d9f2ca0e73fc0a6fe69bfea0d8f4faa9dbb3fda7cdcca5ad59e9d27682ed970295f8ac4541c6e5e0d8e117040d55855de8a6c05529c1ef8d1fa73fe2e7a6e7c109552ba1b208d8a02a811bef185e73a7a6cf6280d5a9f47e005dd9d5ee8da696a7ce64b175fadecb434325fbd23a5d27eccb4dd7f59045727469465efc177d930fb54a3ed2de97a537f161f763280440cbfec067ab3ec2c73f79ca3fdfe97c92e45008470982f3e6438d6c58453a39515c8e7c339844c8f36ae9a67336c20618e59833ccc1cb7eb05ee3128bd696cf4396aad6450d7e955a43e32aa58ffd295a78a1ad3ffe3135670083fd281b7c4aacd3267cafc889ffa6a848f47e9100bc59ad90ed861bbdfe64d7c1f6a89fbc802a9e7c284f47075b42a8128e373311c4a531efd6924dbb5fc1bb7b81abdaa5763454a41d0500b880fdb80f66cb0276f8512a5502fc0e5cebd9a4b67fe2d7c93d87a18b9ec811998bf42eee8eb4b2e18c4113f22b67efb7257661b58abe3e0cdc1f13de46174bd8b49c1a31c49f9bc5980eaabdde5939d4e6032874bc5e019b1ef0957ec5220e2cc4f7827ca26696028aefd948183c031c2baafb4e585dc5c0310850b1afbb883ebc5e5ca104a264343a595678852f4465def59881a55d4eaabe31ccc7dd999b19ab5f855bbe7e11d9a2dee9731c94d8edc41f1c128f879fa3cfa997d9bbb0e5aed9fd3cfa61a3bc2a2bbfffa25c9177575dbd6ef244f383f33127b7ef5602b97075bb87aeef0c63641b7d3d5db9943c07da34c2ab9297bf656e90d1e906d2a12512f344b633be62a5f60ae054a37001fd77fb4a92aab55cfe19592e7d39cbecbaab72359332ada1af1e25e6aa6e34e18b09ce3944b4e4f6ca848aece52716b62ad84d62acdd8756a0e2a7f30812b7e93284bf4f3897df63b1303168b6e87338d947b72a82299ecacb7c63dd789d0fe865c0d1bb20d29e08300a22f106d188e880cb57a9149c37d0adb4d9b7a8eca310440cf081214b04ab594eaaa18cb6fb56c860b00f756852055e4c38ba9fcf99b1e5d59893a1d48bdcb8e6ccacc499664f1a3e76f967c7c322ce5561d80356ecf46cedde6adc4e5064bf00f59af7a6399f922a561f0a6b20ef5cc9ae1d2ff3b23997f50267685d5bfa28da7c872775993f8d711f9e624465ba242b3c051a297a92fed4cc88861c2b1ac28ed5b25033141beefb7c6313c6234f56666e247a18e67a07cdf6b71518b4142cc76f870745e55ec9458a9dfc31c0bce9f537bead7f1b6ce99f0b562c55d50c247324558da232446a823be7b442ccd5e705545e643fc6cb0d1f0d6d6c70e972b43c1d61ab38b0b6fb0f66a1c8273b6c6164b04b46182b58cbcf5aaf2fed2903847cc2a08655b4e5dd6c29e4907386cf645267fe4fcb3f60f260e82eb5509d90ad2de5350cdfbbea3a929579c207b4346e5d5df80c78503550036c0b68ec7067af27b015728efc28163f651f0046e44cc739888af18a572058d867c44ecee7fa8138a96f5b062ecf01755c007f8af7d067fabf05ff2fd9890c5cc09fe3dde1e0034e5af3603be511e9e152bb64f4bab4bcf68d79cedb4d0905a3bb2001630ce2ae953c346fa64d475dcb37d0058049a937f4557dd16ec33c4c559f33e8f26c6c002ef4e8550975bc4db15c24e17e8e6f389d20b8172fbc39b8f47d80ebb1454e39e86cf4a294e97161a910e238aad5e3675189553bffa0366fbdebccb52d12f5118d01f347966209e6a693a2be379b9580bd4808cc8f8773918f12c0b19ffd307674340f14b1cba80f9528baab1bc8dcac2f3ff4bccc87fefd320aa57b29bff1a82279e980f4a075a44f5028d06e120b46f4d280d1a7287f5c9bb403e5d8530f5e5063f9bd5fae8153a6dabbf49510c931bc0e685154654733c32ca4030770fae7a0f9fdfb75cb5fdb713680c1f4d4281dd7d6dabeee12ebce3c4e4cd24c04ccdaeca6a7bb58c07e2f8d8cabe1b024143ae4e20eff37b27b52dd8e6eb21e0497067e48b42d3a6b544aea913648da933059d46164156e1b267de25acd794d392f89be9b4a7cb0f1589d85bcd588ea8ccdf0733ac7ffc42dd4d9ba158f00e3d0d4416fedab2484f168f6b000fb517e1da734f60172161aa919cb0993a59281bc34ad52043d203d292dc3226b11ef8564a7f9b7b35ee230149e22993d3317504a72764c89c2dad2bc37370b7364e3dd3e951512827732470ad8d140aa77bd8a5704fa6bb918e65e2f2cf93f86b1d96d90c6b10fd9e903c0b8bb66520384f1ac19702ff9d9d0c9ee7c486c32ab9afb083b4234f6189995d18b8cf5d8a8f35d1a37d1abe203cc79fe624d15151b23d43cddb618b5deef586a7b0c9b495b39c956859b1aefaaf499c683dcb992fabab9990c11bebe99627e53277107877ae7629abb0ba6a44364bcf2120947e5cda66a8a69a1f6521be371439859d055afb2da40d5544cf8899c7c1d641a72799b45a0922a507744eb7ac8622ed27ebaea1553c9c96b807a7627ec067d770b84c0d17bc5e711fd7350bc453925db648f50b988bd7a203c19793e33a202c005bd559ce94ef1e0abf77848a49f4a5796212dbf958349d35dc4ab16527c73bfc2947df31d6501791dcfbcf6167e6f9a1c64715dcf12dd9f641904ae1a917bd6e393903b2eafcfd4d4a186e8526f3646d95b2bc5d282a0ca37d8db28c62664b969cc2cc34dc74ca6a27ccd4762185af002a36e374c47346831335ba9009dcfdf8444f34a67103d778c9e33ddc22ae752fd952be1e64a1db448ca207bdea3a2f0998323f0bd6b5144eea49617e1b8e4880b29de77a50b7e38f069efdad13ea165e581101b06d7e2e2181cda42265c78bb0ddf217506e22c3c5e7ffd41a0594d3204d1219df181e992b85656e4ca17f4bb5c046721ad4bbf3374e2a6b83b9d92f950eb1fe712e3e8616a327f6aa810e93bb61e2a6093d15b118609da22042fb187904b6a44f20acb20f78f37af0aaaec9611a7a8ce6e0b07b97060121b8d03c8eae254a576bce5993107201ed7559e22c14f0af195320d8c33903d0071a1f03b138db583a5ea0543cf7e0b8f6538e36eb35f61f14f9c4e97da0672058c8c53c1c308dff6e4982c68350180cc0714bf9c134e3aabdbb6f93409d2fd886b46a8e5f35b123c25b5286eff56eec5ac8cf8e5322266cdc7c129aff4dfae42f116621101e784609ded2a07679bea9c5c135d453949107d70bcdcaa71d3ddc747b24f450f57f5cb89075786cdc5e55cd214eb5e7413deccec61c0de1bb27455547a8609c31b6ad371bd4d924b9f845774787aca8da6c3ed81eb7d0de67abf70ec63e9977ee6e83da2f57706d12e794cbc38f1ad56aa3bc41ccac97d8cbfe9bb420d400f5d4599a54d5744d7e783ab66799c5d3cd9f60fd4e7df90a4363507957d2a24372f3879afb094d6e8478a0e66a9a726aceb416a54a5f5ab6eb1b42ff7bb63f521d16e11458cb40ba3ba5a8e27e0a9f8426ceba2450d804a0b95f2f7f801d7075c2c60e1214f70fb614c6cdbe7ba9b07bb625cdfc4c13b2a13854f7ae528dcb5c14cef4b1ed0e07a1169ba498e15b92298d5102e88c74a925ae3ce27c8076135c8b4ab629755f04d52ba8a0631cf14db9281710d51f7773721249d207ae795d2dde66790931b63b6b59b98b2e9204d8fb817869975ea113630b3e14f3ec0c8994293b4dafe301988ae97f1dcfdc561d31ed1a32e880f8e2fdfe43628e74fc8d5acd6ebaeb9ebdaa621c91be9af6c3b6dc0cf00afa4d9516c11894aaa77cfa3084a02b551c9c8f8641eeca51983525b739bd9d22ad1f66154910e3a8de8ab761f1a37129b6aff4a617d3eced9cb0ee0d1728b833a790eceadb943a90b7f684e4737667584e5d85067a3310d0fd1499397c9a39620e1017a2a917fd71e4b0e6874b869f63b27ff8d693c262ea4a4aa60c5d7ff18afe6b9da324bb4690c9d4901b26c07b23902a4c588fa67709411cf3e4068ef0b00b9f6e5dca7fb7c80979ed3c15cf615b7e64bbf6969e60f493a986e0016eb9100e3035fa09f424ad949d965fcf34d88f2c67998924d8933676b2a04d8337305c55fd3ffa094240efe7855cd32f484fd8fd142fcdcb803819f8c3a23f1cb160a2eab51005b5685f849a6f577c8029803cb4887cd1e44cb767d3cc765a4ee49e1f9aca9a151df3672ae778cb7f07992b547a9319a4af4913edf7aa6ee28d1fafb4c6a734f5d8969619a768cc2842febfad9472532ca87ebf4c7783e35aa26122fa7d713d125ffa6e47be59b28f0c6a93313756bec1e6520f614f90cf8378f39c13ad571d5f1ad6802590fc8acc03a390996ee1c86fc44513a356ffca7e7870ac3cabe43a33efa0ee0353b5bc937def7958dcf3d79c43e07599ac70f8da0c312e4a2ebb87a0cc90cf5694058866ef5b107e37db8423601e535c86f4a71e2c9fb4ad9061e4e3d487825df7d951c79d65b4c485bd67126c0d93fdbe1ed2c6af01c8f332c767d9f30a6b9b34d2f147773997089069c8c94510bc02ebf88a7bff6b93b7525eba50db3eb0a111706c302c080c29eafd239157789bbef8bb244982196a6200d4db262f595da1642fddad383b19fb4857aecc4e34e3da8c460a66edb11ff10bc57d0df262e710bb4b88f0276a5694f01f903144fc48021ea2251e93215f970e2fbf216844d7343b7e4e75256eeb99710b9345cdf2c0d03441e606189b7c957c9b7795828f43a63ae59c376c2ddb09290757e792aff4005bde858618055008c74f714f504d8ac04248a90fa32afdadce448ab84ccdcbce7a17ddbb4f3019ad679aee3d698d34f28da1b4376bec078a03f247af656b43b10b25d84b431496820e6c9ece8f40146967031db5e546f6c1fcf606ddc61ef160f94255178af852a33bf45083aad1422a015dfa0ab3289e7956c56d61fac917061a0aef1d8a13fb7b0a28556581303e610759513d4161e53a100bf95b1a18ca2a7be3385234383addd9a4532003c3f30643244d1b15468c4d2207fbba08d3b0d8a1d68157fe7bc2ab0f99feaaf3a2daec7dcfc0f8b1162deb27604558139e4f72532bf2f41d354d1d69b01059f469db654ee6a3f8e39be09e0ebc0849ead0fc4e8fd415e139787bac482d1a441ee6a36da6ab416de59df4ee3a438c21ed3ea9785e343ca4f0f490d904fbf2494885357ccb3a378c56d4e7f0753af9fee1f928476b6da80c74e4004f3e466a4428801f74c8ded1263716bb7705fdc9cb8920d5e77b97aa82e21cf9ce3ea66bdc35b418ae03a78deb6d6df855c48c24f2cbcd606e9b4fe14f8b496cec51c36cc503214234be8de7fc610acd93db7910696fbb564f0a8e139aaa5ce03c5a5be857b0741681edc0f4e5701c2a042ed4d5944ec24f89c336571d4736f208c538eb034fdfa1031de1fbfd90a284d90936b73ed351acdb4f5582dfb01067a38718a5c97bd799f08bce03739255133912d2615a1701836a9e185a41c9b1085e34aeadfc050f570970435a1ac71af3232b3cb48390e6dd9c319ea689bbd89d5b5191517535740b984bfe8ad0bc37d0ff35b4b67ea90975cdb218f25605a924db2e7e2666bfe11577e42685260f43fd483aec9530afa5c73b94386f3e9d4a27d270b43c802d0a1a4eb956a11f6c590783be73e8840d4bd5d7051fe7ef7a11599956677bb01a35c7e196da05e67b089700e2a0a90fb3e1f378f5965907fe3a5a2cf285a56104f905edf12e5e3b2fa41502d7a23338a78691de25c36b85467600b7ec030b4ac44eece237b6cc2f44921d7dd47a6164377d8dcc6016f6608f4eb5633807948d350a7844f66e5ad1293fa36359d118747e31cb9f18c20de3f2d216440bd6f2d8bfe604f1f825847fbb96ac00f79a46bb34226607cd7ae52c0c610bc43860af3f4f6556db4c5b3e30a306226af09e1cde1b0b3bbbbc139d1f755c53864bf9e54e9f107c4fdc9693bad3af3d9c0fc41a6b1e04ea0dc5b82897528b26628758f2252bccda3b84730b30f52b63f9d55a2b5a4dfed8d60aa8466df28aed18aa873e24fb1dcffe2f7b67bf13488fdcbc76c656e2597aa612c5f5915390cd36541bd9cee60d23f2a789545573e1e3656a9d1b06f050fc9955bff425b82e57621a69fd63435fb36c1c3ffe9ceba0de157fbe8ed6f6ab029d690a976f636daa0c7108574552acb8efda8e67900546d015ed1c27005c1913df77af237c78efbbc0e7882a1ce2008365a634693d8ac9a00f83b25e2c8ee7503341d405cf5a3526f2afad0c26fb68eb6a052cb753c6e89ba7fd3580e5e0545ac6e7d76b3fe1c8d2699010c9a834b0c89fe86f67e99d7ba3dce25c832e4aa41e858834d06e1f8ba2b6dc37960f286c2c8438a7ea40c6a74c8e1b92ba71ea2b47ea45e2e40c1b5df865062310074234aeb263ad67ec2a482ad7c099a8bb9c7927b50b570e3ed4b991d586de63da53b06558c060d8fc9b8a45698c4d4d134525c82bfe8df20dda3156ef898569d6dee36869de6c751bb7884c62ab65058dd400f8eb414a4cf114eace88e773c954998508c23b8b2b2d533bfb8223cc6085d01f9e1d076cd4fcd412407ce6125d6f963e532c9c85a12e7ba330715c512ec36a1e656c77c282b9b3990906e3c402d82bbabab013da23350a45fca56493783fe09e15e134b7f5dcaf6f9f80630b5bf8483b34d0575dd7b90fd60872e1c76961efa4ae595a5b2ea7689f93c0ac85a9a4199e7984a01112cb51cacb78e46373bc63cd49f0534a0eda823d76a654fd41e35fea4cd10ab083b4fdcca96a17df271b1e5e2743cb0327605a06134ca6d81679e31680349bcfc2c00cc4ae235136df0f0ab2b4827150f2a0151c9c193c4380c828bf7dcbc055c278975421acaf75294d38d7638127b6d59c174da97f43897ab9e2b1f25cb83c0ace0131eb82c54ce997b5cf9a1aeae31a5108ae2bd157ac12fb52650ce6420e4f84475671f30a1f8894d51b5c30dfea22b397814c4650cbf85f2ff0fe759331a7726ced6e5e424f79500f86972e3a853f3e5aa78b9085e8db0882d1cc533dc4a915dbfbd4e8ca96ac0548e7174cc2dc15518e06027169c13a45787367176a02b562de747d5747988e3ab38f3c1cc4088bcf5041d76aa32d48b516252db44f3f123dc8fa61de64c692f9a72ed37160df1d2eea778493f1b56fb7516294fde8f88be85dfe7cbc65fa4dc3a9370d89b8eb384afb40033de4d12dc773f05fb19cc8045eab7f4a6ac604f67e2f9bacf21d18ffe232c6e67a9dce3e86851e495a92e4b2180cc492adabf12963d9f4e1245dce6b29515f699fb818faf828d1557f5f339467382d7bfbec54278659a3426fdf3bc193e00aa8c61dafa478e48c7df9b920323d4eb27c6b3c360eed2a8b330e0fe6ce68f53d6d3cf65881c718475f170ebe621b769d9038c1ee6f5acdf816cdc2edf561b568411ac56e8edd2a46c05945242891dcc1b98b77b09958477a42f4393ddbe96fe98d20705b6c21bcd25028bf4480cd21a6e8d3035ac35afe517174e7d242743758037337737543f3f4249c60b7d49e76a4a99664ac3f8a64da07f0054f36d63e382552994771f1e8665efea9a0f39ea8887cc1efcf3b95e5bdc2fb6442779ee9d7cfcc2a0b54c27e1d0f58e2c8fe2f4eb2f848ad70898b33e1e55c6317e1ba55abf1ffd248704c6338590e2d8cf640d5f37a5c81c2d13180459c932b26113f3ed6d514438772f7c9e0d362f9bf6b6299a4c03c9addc0194b0444d87300a4a2e030e7c256b68ac57a8462baf3f40f5e66b80a4ba9a11dbca492c04f3c4f2bab1bd2c6aefd1f24e68b91c59e51906458fa1854e4a7476461f85a78490beaea5bddb44f3b0f4abb8e61a82facf4a4f11f972705cc9572be41b7af65facb64eec92834fb6698f1d42e460bbb35ab319b81bccc41c081839906749418b31faf9cee84b741e99339e5cceecfeea372d02834593fbfdf291a5c9630170fb1006a28248f946323a8cc8e67e2b3eb872b0c758c6128d96d586bc2d5fe3764889dfcd8cc06c10ae653bb4a558d938d89ef1248c462813f69494d685036083ba9b38f482259c392fab84288499621eed098436f37412fa06ae5a45841281de13e7d234b9b8e0733dca52be01764fa7a41b33788032cf78ba812c48e470321bff2c4d93c36e56081f7dc25617f811d1ec491236069a9b222da6891b3ed824b6963ef1eb65a7965ce28e8a0a6a9876a1df444f79bc4bfe46ad5463ba7cf48ec567792bc2f66a45489582e8aba8ab7a691c394304cd267a15a3a62120d239eee4b29d18662300885f0e97ddcf7fb9547f62b429322f5202b4c61f52012d7d89052f69bdef1da21640c772fbffcc2b19a796ac4ca22126bd5f12d6b88b2a345bf3f05f945bca3d963f69c2f37bb58717fe65d1dc72782096dcba36a1cd18bd5866643236638ffe7b1723d8ba8942031aba88cae932e8944a617390dbe5fbaec3c92dd544101997355d36644a0af178d45d4ecf971210471300c8ade3877b7d54972ba2082474a7e83c9f411decc4c6bb7b6806df266feb174da66fa430676954925dc465cee0638af77a8442f3a4346517d850606af3afe3543013a254de4b9fddccb59f2b672afcfcee3f5555b24eaf390618b2d40f4e12f2fac6d49f14926fd0278b8b39edfad09711797f885f0e8630e120635e5d276ad2a05064194958af6ed558bc060040bac0eca1a0739a676c60bdda882e85902b78eba729318d607f26f13206c4736391e4a347338ec41946430ef973a6a1d9518a214e3f14f5dde89dd1d2140f9c54f22b527becacebb32f8b58430f9f224cb0c52afebf9f10685ae458ae3c91197f5eaede0f5311de43afdfdf04be0c2fbce9550ca52bc998059d601936325bc452d2a3efb19eb90e84f18b3c86e99e30b73ec798d2ae141b357c3ad853dfe790b334a043f5e8eeba8d8383455026f931116e9e7818c0f75c05cc744ee540bc5c627ea448bf2a8290041ac1ec35a8ddc29ecee93c038caa6f367756a220d4f3f14610636f88254f9ef53f1e774d7ca942ec04c05eeb74570f15a2933f4d683262f07ecad0df99b28c1065621a64b247e4eaba52037df62a8fb29493d2946b59f4729d3ebc04b578674992b7c0cc190afde3ec8475","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
