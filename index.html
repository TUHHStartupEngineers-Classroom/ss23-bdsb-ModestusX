<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"6d2e5bc6882ad6ce3f44079f31de18ef930b385280a2c07dbd72ee013ca748e3101f5fe9c46d799a2fa38cbd29c1fd41423ad6b54f1121c9054d08eced0f74180c7a24ea8da3479bcffc245a6479a4b07d722e9444e55f9c406073cd59bae0ac1587134931c5aa5d8548929dedf3976b38b8424e9f636c479b146a2ccc4ea0ebdc835f48479636e16c6daabbb662cd681df6836c7fe61adc4911402578a4daa8d840f31b1deda4ee087640ed0b078cd5b9f9885e187b5a810e92b7bede3af39d4e488fb29765c14b0934879a1a09f21bfe15023c4fe0db6804b67bf216b2331763b9acc851f620c2824988e571f9abaf7b7a7dae4bb54198f47db7acfc10d0ca7b6ca12aaf39572f31bfe5aa832cc09a3dcfae482635a1e06b7c9e8256ca07ae59cbd6213d7f7bec1413aabeb89df5a778603d12fdf8c9be83458f086ffa4b3ddc8b88b81eeb719b133ada641e9d3c99a88150aacd7480fdaa60ccb5958cf4412a2f100b4b8ee0a90d1cab10e54fd6ab0f81f595b28b839752261ea6770dbc8dfd568e6aaa4fc628501ac31ba9c4921b76281add99c27c27ee53eae2d71cc881d58630fba0308cd4037cd4c6c77d4b1745ea0cc6e37d5d3cf1a4ca715bf9d94061a79d0701fd3831124700a221c3c7da68b941e250e7640e9b49bc42d05d7f1319706db38b79f1fb2613f4a616f4ae21edcce1aedd576e7cd88f691b22163af41a70e09706eb2af86951fb1f3fd4456f26fcdcab816d7093259fe5c3e5cc94da3f02402451e9524ff3a63c75d51e30fcc2ce59f98bfc4558b1a1cb0e14bfe7f2e91491a7f8478e99e523600de0bc0dbdebe9f2e8de28cb45a7556210250324cedb698f61c081f877433aca368449d3ae26ca4837b53972d45b0a129dfeec081552a2379d504cc1c6a7c49ee48e3aa6d0f0a23d703be4b75ffaaf8c44142c3ad2e2f6434266dbb17c36f036546a7c8483ee96304cbe3e6440705bd4a1289877c04c444749cafc86543ce5061253b4ffa96ce4118b49bfe5bbfd981e1830c12eefe7f7118b00702ec59fea0a6d0e2d6f13a7921abc225858de420991524dd3ff0131c1d72326ac12aaa80766762c5496dc97ec28fb8ce53f6ebf1b21952680d0a511f3a188c31f6859ec2ceb90b8b11f6d8fbbd0e349bfe4ecc182f1433710f1c2dc8499d71ba5c4bfa2dd0dc1abf3408660a1807cfeebddf0d65cd9922012310df542e03162b45931918fa43a13d2fee5433bed54b1dc427f5d98165a37756d73c315e9201754d99937f40223be063f5580ca5264bb7bbd5a2e2de584778b448c3fcafcfa093e5fafcc7ca5e2892aa8e637c858fdd684b6b968a1375b3817663127f5bc0906bda8408e9384fc150762e3824ee2313d024a3133b0ce7b884653be5982a66dd73fb5adc227edec8a93550ed0379e54cde009d75f6c9dd8303db7685fe21a5a41201aeeb0a00a3d8843acbf6d55cfd926c7fc054e1e88115f122f022104bdb4bc8859b2694c19cff9d99f942f4fcfcb57adf866f1f0669740416fa1332dd835761c48f7930a607c75fd376a74131e5e20ad6835727420c309c0129bd795b6654a601f204c8ecab42142af9f5b4364e88f28f71999a57b3ad0fb7d811495d891f525cce8b3dc8bc94ecf93d85ea3f3fe37950ac37de15b16875f7d257fbee124e8dcec4ce40b4559c44d7f4aa2e6163c37741e40b8ea34463292fa51748ba2e54d357d332ced179f1bbb8e133a378cae70ba647c552938aa2303746f5a9a5e1a6505728b4e555cc6bec4efc88c8995d6cc53299e51c591b73810e87d7982fe72c90f5531fdf18ca727d580685fbe3b9a96e7996cf612d50dcaea7846ef9580f2d8f2db46ec132f4df559af966a88552f4cffa2d6120ba8ec072e384e3130c0f699d936a6ee7fbe9f990d12baf1df8425e318499f68560ea4ead0a8e0210a017056c36aa64274708b8321391c334199583fdd7c060250f42f423f407cbe56d8cc76958098af9258244a0d21cb824850724415dcb8d76f47114b19b194b62e53d779d20870a118633e3faba0e4f81a73a086e6217a5f8d0ea89ae23a406265fd16b82cd5fcc8e47c50195034151ba11b575bf898e34dbef11dd49d63365026eee87e0d5412a9c0dd10bdb2bf15a136ccf33c85bbf725811e977cf23f6c9ecf461166ff8a31992e3cdf98738b2c97294dba182b0c9c7a04563952a2317cfb39678879f8dbe40a1a2718471d2f5467f62b436846ff525223794cc1c9915d1f7d555c370ca5d5247c6f46b43d733a2c3f753b6b1e2beedbf7fb814056f411e8cd3991afd197fb3283ed85e67f59755a03c212b37329a6e69e53953b70eb6a4cfc13628862415a4ca56e3ef661b470f2e006d96da7d385f581f81cd7ad7dd847805c84a0a219ff63e9c27e0484f0d9ea0525ea979714d0c083f83bd9104d9810a2ef3e3ca61c501b8ef5b0005c203cba0bfa9e3788eaf35758e158e2ecd40ac47b3679a833ffb0b6abc44ed57843c2599b9968f5985cf28926e754dc7fd0fa5c6fa93bc9effad23dab62a184a4b7ea30bdcb564e2a4eba7bf8670c9f13bdcfaf3a72033f7aa36694c01f2657012de588253a0cb521191fc02e998b2889cd5815bf0ddfa0547c44a64f992b103b7877c65516c8835ab5a36d30959c07379c9cd2bb1d5c3f5205d3407c1f5b17808993e08227ada66dd88fc4f6b018e6a664dd24bccfac6ba2b6fea97e494198fe97bce68ef1d91371e3c6eadd72a9ca2f3f14ac9e4464e1accf04f1b0bea99c289b1ef520e94b481050cec52d8c9ddccf5894521aa8ee9626961d11b3dc077fe00a04dfa8ae2a99b0e0c4cc588e3d418bc52a447fa8400d9036ff373b88e03e1d0ddfd3c29feb9289de5555e9127102918f963877c36b4cab6cc32d965fb27f7dde22f2c3ba463fd42520888eef8b3fb744b1273c74a482d47e61beb0578c9924ccb1a1aac17fce0f78c161f636f25f4660013902746c63f0f43fe84ad54ca3d7d7ec418517e261071bf8ace911b14715d03101e0ffad6199877e4f5e859cf1d83f2fd6875f384aa7d3a5e6ce1adba506404461a4436a91d5cbc01aa7ec2eaa9c401d416e5194ddaa2c2fb1b9c67a879f45cfba3a3098d18ed351531e38873cebc1c0a30c27c5376b36ced332d777d8b6c7b90608d499b6980f11bc6f8d3c470d5aa81120e040dfecde71e7be94aefa69ae4b679f79f747f83c3b21ae787de5a0304d690a584c4ba20132f08f2cd2efe423af9372ba76df4f07dc6dc1e84e8ab1c943335b23fc6b83407757686d3e12460d172b53f3aae615596e89b6a50d463f559330852661223a69e7203f4d6feb3bd34685f70a6910a95bf676b83e98097be7c650c72cc162d2424cf6907069db1064977b9a24cb45f7919d9049ea9a79be3541cfbeb87129c21af4316c5cd61d32435adbdc9bd3095989e73f9bb25b62bd53773fdc4f3c40e922e677c2543d28d02917cfbe2556c15703ba0fd209609d3a7417c52164c3cee90e3e9800b9e100f2b09e04568cf52ca1a4218964bc5dfdf303f881f2dc505101ac82affc13c679bc0720846ead2704efa3cfa11f832e3da14e4f792ff507f01cbd6936d1543d18c65b6d40d0ba3a162de8fc018f4a7cafdc19abdcad59b5a7824964cd2ee25798144a3ac2ac54b756dd288e4157039a860d211d872fc98523b2c297d2ab012ff5f76e3e77471bb2c261b2fa93c741a1373ba39b0472ccada2a2a176effcea9dd5cfe61249da7cbad3504c7141ee14c199483d3605fa71af14892b0d62994e6a679b97c105f8a03f6be3b19e97832dd547ce72f54bfafc3a67d055ca29c7bc8a839e13fe834c9816cf268d13ed9c45a8db6cf87b138a74112596c69adc685a38415042e9c773ce18ba3b86ab4a25646a319b6a79cb860e00309b5fb9665003b39ce6cc2a8dc531e01a6d06e29de33c0d8e883f8b194148dd4bcb73f87bf813788d3c0c8e2c8c71461cc1df5165d86c374bbcd6677ea4ede694edc140bd968fa41f0acc65abc40fcdc5306321ce232056027cb305d6de363ad6765abfb295e07f8a609a5185503e18ddf99702ec420a42a7418605028d0ef4d89ee81c04ea8cfe79c8a139612d4e1cd5da2f355e62338e6058608680e4b40686ea26b202560ad647b94de4d5ea33cfacbd5a49aeccd909da09e25dfa99ce7ada46e5cd1000ff4f75d1a7a5b8071822d2ca5a16afd56ea86dc0203c07ccf1e5f009ffc65b9c4f49b69abcd5ff9e225cf4d6550ceb4f28bc131be346385cea2cfed7028f5a4dd48f1a333284da8c7868dfaef75c7ec5fdad51848427d842003757c73b1177c019b8acc916cec5e539424c5df7cfcc7b3c8760e5b5721c363b892dce9db3cc41543a786bec61b1cae3bc28e15152d5a6c21c67db8266627ef5a3da310f36093d3e1c9364ade81b5e55e79633b46d19109564699132ba451f70b6df007a936d07e21bfbd933f08fabb6fc1b926fb1730b50fd08fbb4680ff6aa2b7c2abf2a7a137e42524f97e8412d1819325216839893c787707ba38d865c48977c457d2e954ca33b417de49ca8d135a99fae9202c365e75fafe1184183322016ee78a5da217298f5e5bd26810c3b94807b092f6240b200356659dd8137a153ab75eb36a736b6bd78d0b2fdae18557a9c98185181ce17a8f994c1634c4c4f314bdfcabd3289c3aaf1937ce45d4679c229555d1e43166648e17ae8a7b969edb20bf29116392d6a6dbe2a050d19f7ca3b8512c0de383d0640f39d2651436814ea967a635946fedd69b3663df3f44a735baed708f12c0e2cbdbfb525e023272d644f74335502e4193596583dd4f5d900773fbaeca3dcfca26b2e5b6828abdfd93e49cf139ba2763e7588263f171aaf9684ae01095f2c840ec083c7328b2c90e969a5152904c88d11521d439588d7625b0dd26f25d7fa2ed5bd741ac2135f7454e4123a03cd243f0e76d07dd82a64af1506d59abeffdb1bc425a141fbe5d092cf2bee72d0815d20be26f465191a2958b1ec6d01a2bbfd826fa6fd4804e13bba4e03b23f5bc9716a59feeda9fbd0afa6f8669c47ad956ba3b64811708fd6bf97284b6030134c41e7272bf94bf82835c6b71e7fb1bd6d6506cde772d6c3aeabdf4aeb5f659867054302a6995c74bbe6a401a8495862197f557c94cc678de9559add7b6b810f9918d50827cb44b5d0f560c666ee0741ee718d5aa2b5fe313d6b023bc100cd45d49709fabece68cdefbdc988eb1a7bcfcbd3756b0488f046296e47d12137ebb31d29bfb609d4f1cd84fd7848d3fd0c7abc1b2acef96aaf918a66bd634299537618a8eb43910be2c6d9034536427c4fb434077b70f80a6b5c5e1d8f2025b6c9093a8272917e9ff85d78283f202fd0267fb23c8b282a5c4629bb3cd3fbd528228f0b46b4556f5e892d90f8a768d0924cc1e6f9bbd06bbeac2a3927239172cf24a041869ceedb5570195e08ba4f25785db7f4b7f6b9811d22a14307d365ece42d981f8d0efbea9f040be4b4aafc8ff0bf8595763c8cb525dc198b755800064690fc845c1d1d34601a210b2bb26e7259286da881605ccb753d53d7c106eb79d9a646668293751a96fb0bc28578496b637692a7b74b57a32b4ef8adb8775ddadbd3312f8e784838caf3f983d8351e478a2798fefd421406cdfb66c4fc16b90165d15c6290476a6054dc101ed17c61af65422ddabcc03604e2779fd2e7529ef76f150d1b1fabe4f021f84d52aa4c86844833e1078dfc4543b5781da289d4b195cc3641dded226fd312b8062310376caacb12ab7aa33602ac2d186bc0d898d388c4638660c6268c75e3460fc58c7d5f24f342ce7b538fca3b172b82a972bed239c5a7f3f648ce49e88b7d5debc0fbe48b59f5f75310df593910b896e746d89f1aaf07e7aae478e95385b971b45377cc07b4825af871eec9fe67643df53ecd0a64128cf74b67fa6ad76dae29ee69faad562dbf179d110415add0fe0a3c9ef331f383ea0abe4286eb657147052802a66f77f98f44b912e40d442b190f2df01d0f2a6e3de178bad50c6a4facaec0139c749aa0d4c00ad007afaef555d1844fb324f83ee64e0c4295b561e97479fcb669008b7fd8273ad5a671d76816564d4749b93a982f084fab809cdbb958dbece86512563e62d5fbfd9830f46ce0ed470232c792925b4280bbe913b1c6f87f091128af8154ef2832b9ecc40a1ce3037d3ec9839c29444e9923a1acee3d06b25222441e7d2dbd89398c04aec612eebde5e8cde8338da744d3074b9af1099ff080258dd808e4ec5ab0fb07955a8d692cd95332883a1c77487ac7bd1573294224a1db19bc203255d5fce4a1e867483a45ccce9ddd211ad2400717a869a9103d87f1fb2b919c7832a53f0addfb074b73783d06bb6caba86f05a59bc8a73ab3ff659cf4abead7d2cf322a942387640031692c0e20731320e5f2e22dc2fd384ed5aceabf7e94ddc1a4fa6f582fc1fbadefb5a628b7fa68002d14d0c1e05d784e08890e10a7be11ca9c0ff1481f1238781e965207c171503f4bcfc1465a448a7dd73a377a794d99d7669b5096c568ac8e97ab851365a8fcdef7022d00dc14142f26d41bbeecd5eb5d01b3e97dae5189372be8766cc936564be05dd4a99999fab292d4ec3f46f45826e9c00b4c7fb91724737ac2b84e695970958a671a3e3731d0cc847ba651662130c338fa5c0ca47f5476303af785a195f6c618676d305978f70ee681359f4310ff5529aa0faea33ab0bfb61829d828952b8390c8d9260d01eb6351e1b0789dd4c3ff74c2c21725a0aa904a2ac5ec02e5d2f4ec6697254d95e6cf3a4ccfd4720c2722728e60c709b52081df47649d1715213af317d97dfdef3208d85f867d31b65f9cd245f41336b4cd92013e642206ed564a953230655f4aec89cb2ceb145c045145d7cd4dbd62bfd2c5335a6fb4de55f90bf0062d7435a9f51e1cbe81d9c1cfcd8eccd9bf73fb3742c210072e4b2bd3f3a8bec1a2eb4efd5ed1a38aa2f06eaae3785846a2fd43517f405a53d94b1f66c1fad04dbe6ca82322adb52ab00086891b14dbf9ccced2fd43cefc3c7a7f7ec8e917339abda5f33d7dbdfb2b7f7be5a0bcedef414bc3f169490635c7685b50093246711f69fe49c814839953881b1b88f17a8fdca0903d66754c35fea091c681d17534ab0773af0f2f3ab12e49e7214551683714d996441a5bde4335256ca36039efb2609d902f133002ad4980e644b886d74cbced40d02215bc03749c19d19af40808cf0f9849435e38e50fc622d6c14eb16bc7e6ce84f7b3b45fa4f1141f2ee806318fcaa8ede9458be8ecf9de1deaa7d7a551cb9fce21a6421ed81b67e5d2b015bc99bbe7a26350cbd0f0631918a6204a561e46c52c0442551f5350a08692df55c4406c0906f1359c3b44f598d1b3db62004843c4bbdf168aee8ee8600384fa12a3aebe85e4d79c35536b4caaac9371e72234f6bd06fa33c8f99926d84a9715bafd2853b125ad9177ace2789f0ca28f47b9fe7ede601075c16b9364155f7e8b0469405732e92c724fc0c24cc9100cfe2c223074b65eb1a91503daf68a10170b5a70329701acaa01706de5ec17b6fa8d33293324f0412f9688066df4e03221bb41d59a937d5616ee866f885d2a565d531190ddd87613f24c2d4d49846d2b66d4ac926997679a987012d8bf546ad46cd963824fc202e880ed478b3043610446dbd9ba138fd0fa5c6535fb64adb6899a5f6bb723ba2270ca9d6b134f4448c5b5e5fc8a08beec587c2379ac7609042134bb1c05b1aa8021a1be6cd1b9f3e126b08e5d49012ed02803cf5d627bec6e4845ec4385c72bfb9fbde2357fdc2303ddb950744c46ac9388c137220af9ba0049d7173fc90767d14d5df270634690bd2dcdb1bfe3469978c401b4ecc02a110cff67620286539d82e6480d28b416da434892ea07b0ab6a06db79604693953fdff83cf1843262c49d4fc3d071a1bd822df88e818db0fff8a9c39e00d9dd0a0788d2b2b3469412a6b9430029073dca23433a73ee40fcb88035d0eef7461622f3a6af8960695e467bf6620d1b9da8d35a2c4326dba22749a1356625122949692841f025b9f8fd4a36796b2dc07dcfbd23f8bd21ec70e3dcc39a76e6c8c3bd851a45f9d3c7a7e57b34f94fc4994125692586452f41187600111faac0a134f785161dfe36ef66ce47c7d8826674bd5abed6523e80e6419e07f924e9397b38b6bb1714269b8baec2c351e528e7453a3d045cfbaec0b9e01967a65c344411d1448c544e2f26f8e41d146e86c309fd07aa9d795958fe01e2b6c7140b8605ce12dfd9cc3b9fabbe90a71a0c8b1edddcf79cb82d16da772f569c549a61db9653388b13ce429d98be799012d70b2c436672b5fcf7096ae1b37735d96639e4190587a2910935ac3cc4b09b6913c27d1fa5b5855e6be90cff0c9e78874116aea8abc793d1c9cffd534df42af24f0d713997898fc0978133c1a10e158c3743c88a85deca266d24ae43b8df104d3b696e543fd573a05d5a6c5f98c55d0e0c2eac57d4ab32e0ff0b2507dbc46454acb275f5701c7fc713bffd5fd7e7e053814ad741d2817ad50841f50e2215fd30faf703a805ad2a8c56e97e519cca9663de2980fd28f581c918a0ced909651b2a9b03815fea0622ae9f121b165b4510d21100a5d43ad5867bbf6d3a63a7e4e732226e78eba5cec2574a7a479f72b7a52c59717750081cd7f7485d4937935530c0a84f2408be582248863ca0694cfdd94cb02b109d185ebedc54f0e7e5f09ca35b58e77644485761a46df8fd4bd0468b73af273a31fa3ee97bd612f9dc178a6b359a51a0c849a7ffa201ca1601255f41832c8bc7ccd56c79d8baeadd1ae59ecaff2d405f3a6609c2ac39c38a24e9461d5615cbaa46b04394a2d32be7b2a391cf9c6bc03d71cb79e7d61d6c131fd12cbe07c4ec97e15b92b54d221ef969c93986c64be7a491206de07b16913cd31533f08a8f5da8a2c8463b6b396b54f1add53e377abf00615c4c07d6630476e04d91b82bccae81120ed281918ffc80d1d2deb60e0dd4d83a91ad3245b274da527221a3c538715deac446b225f12baaa875d01f650bd45abd0c80346378aed5b78a2ebaaf65eb5e9ad3b94f4c8e3bfc235cb3f26fe6fbc233935655493fd38f3a1e9d7fbbf1394ccd8e0576c12d26b1cdae59307fcecf55ff473be0be7b2264dad9503c7c7f823eb68b4fdf1f5a66a42ff0492e20c46a6daa36eb0c171402f3c4030cb99c1687888d1848277f5cd5b3ea316e72af12d8d05ae4ef33df473f18bda329c43b35e8daa54a6ce87a3dfb3c76dfbc53114d55801c7058ba7ae6ed59b4c872c0cdd8cc4139153cb10f0cd2f377ce584d9b47ac5b3d95579a7c4d32c1e7c7650b655017c4ed8b039e5fe799ae97d25df7ec1d724ac36f017c2d54656f08bb0278dc70235f8338907d805db1c281fba58fae578d30b3d71804dd3729cb0967836bc8074ac85ea3453b5e1f5c7430b51aa75fb927d15131333f9b9d7dfdecf45b21b81718cc450b366b0a39a5629bd69ba6963ef3446e4693a2a7c6ac37d518d75a579048e255c7d10dcee76df180e075249ce6d4c7b1b76a34a28e30bbf051c1ed51f832cacf02105beab75f0a80cfb229ea9e575444762e11d589feb81bc0165f80a5cbae81d654e8a20e30c5c75a8e0e0d84d10a3fa5d974ee67abf7868439c837279f55c01a5ce124fac108d6f4f1ad0bc3f6ae63a02702c2e3430e7bba885ed6f7f8acd1ae31147af56c474daea5d81bcf294c53aa2243c4f9ee15a617c5b6e24dc834b94e9c7d819054548db6531038f183eb317e80551a3a6268918fc58e9f1e9e7da72569b12193bc2749b3e5fa5b85ccfe0ad36f6f3f576c4ebd73dc4f9578afca4e1ce2921ef5d5eb579828f57c6cc4c2846bacbbe4c8cec014a5a969a1630546f3368913d8786ff5328c44b8133847e9017003d66364befd4a7066beb1fb2fa585f4abe8a7f64b787dc6af280fd97099bb4d14eaee83fa91f5a9809124f4bde7324d293cb26a46197c09a774fffc1573ead79bef35ae6af5230c89876f990b7d88838b37d0b93accf097f07335cfa882c9b37e9449819561e567259245c641a07cbfc5684dba85b06a7f8315ad06b0a29cbaee73980835e75cdd3df8d55aa12ba12d13e929eef56ecf1befbfe9881b0d8116a62e854f2a27a214f3006b6bf01a255b44287cdbcd97757827ea8eaa332f56cfe65c01d7db3799089d91fadf84468b49a902082bdad3a653da64b3a176f1ff4c8d54308768bfe181ac50b342314b7390f298c821e8e262f8af7032427bcb8b253dcb69a67c12935a1b8626e22919b90ab3c682511333a1a794aab46c409d5b0f86042ea3cbc60ab3de31878381e415c405c8c77e97186defed6d0916e4ae9f7511493defcaa418349fd4e60ecf04f78460591137ded6055ca61183aa6289bbd353131e26e06fd0e76370776a7938d807555308a2c1b583e189bf8804ef536a4c449b870199ee123826630dd0b8026813b7b33e6a2b8ff0b9cfdf3cd617f69b8c1a570b0c93f2a6ebbc9c0bbd065e66b363f449e0b0a978225d3ff0406ac438226b29a470876b67888b689f9c3f9e7dc962018ec80485d44f287712bac264c34b64b189de667b603f9bcb46678fdccbf5011d22e7e93d088b2933f811d2572604afff92f87d62a4e538dc7a0473ef7c9eeea936b3eb3302f1f987801e86fe05c8156b607188bbba3b3b6688f36b61aa2bb0db91692b2a3cb1930fe065427ae739eb6cbd34b256cbeb8229c2af7a1d0f282a72d92b6399d9bc740fdfaddb407a1dde8873eff29c789478d11a3c77947f056303b337f41d85e8a086a7c4fe7403bb908fb8070764e09ef70a147a9b0e10773f48aa2f17e852b9d57bcc54489cf944e7290ec47d47f47ba7a517c8e943b2e1c9e264c25135d30c9d3b02f0445ec287f0284c0ff5ce736ae918987c30fb8f223db7a61079fe4083a853666a63293d4a91f9ed7d940ef86dcac0e5856f980fe7c158b3990b83b5fb200f933611fe779dc056ca6b0b46145f419dcbf9982f0ac813d0661660d03780ceaf3c66e0b1ba45428a21ec5156efafef011c0e386a7e4c21524be4b10107674ce9ea980cf9cbdb1f02db4b1db031fad60bcc5536a487f263fb3e0116fdc4cfb163659040cec620b27f46e6bc41c2c11cd158c7391093c08184a7c11281d1ec64d345baf2b3d3df379c32e4c85ad46e5e616ba3706998cd8b4cc49ee1383c92bedbdb778e23cf4d6cec0ab4e29b885326ac4bec76e41b03d89e0911f582c48d505f71571f1c436d3a08055e4439ab414062dd0c6d25c13651a17c6ed6f767bba2da7007d104285128703fd88223dd307639aa8657d250b60d1a35af5e8dde9dbc75bed1bf7cdc6f8b8b26595bbe33d8464e52028bb8b94b35bbd001b5b881abad7eb0ad46ede080cea469770cdd3e5436c1cd94c0d74812b138de69445195a700ec885c1b6ce04e03c1f1c66b0bd924a193a366e0f525a893b04466c42f5478dcd0b9c448f3d98e1adcf5a215cd71a7210b743aa5a03b707d8addd51df2ed53cdc78c06a58fcfd62e374a4f1f67a7e5ca82fdf8b4667b73ad76d00f12943c17503f539b708978f1a5cd0dc36ccb23791c1c8184b20a970f2936d943fd16e22d62626061673dcc4bad29b03752960ea4c8d023bbe3b5105382a1413df2093d47f1e8ff34122093a21ce6c5f2a717f5a9f6cf903d5a43e836cebfef335cbff24acb96af52f8a1f9646d07299f77481b1a16c903e94a249677c016f43708f42cf8c6d32c77749d8e99d58da6aa5dfaec41264f92dac61b25fdf7f40be55f0b36be40fe613b8dc12d8fec38d2071134a1b7b1685087407508125a9f682b6c39afdb382a9445ea2f28dfafe2748ddf6252d9a0496978ca325c91655b0af67b6c7086b76098bb345d2b5794fe21dfdd8b9ec4e38b196d50adc7eb241a3c06fd346e875aa3de443d7ccd5d6357ecdf9a4a6d05c369be16783e87463fe424796216f08f8aae3327eef222f478c951873f323be012abcc9b8624571a576b2f805b4b3e6264161cdcc9579e4c19450462a7889cabd7d9286519b7f2f6a6895120635ec4cb871e6a4d4794755d55fb4bcbaf685b9cd738ab295bfe2b91a9a1d84425af340f8b7a47e3f02a6de867946de162913e1a125182db57c91bac06ccbd70fd9931c8f7ca7bf2d492f2f3ca6b1df8be00c7c4e11144d14458b1be9422c14083e18ab1b8cf4bf98dc2c1ef3a18898119dde2b150fe46939c453da1b66c6d73b3e91ad859cef553972f4935e64494faf9e233c896be0312439cfb65b16f5624ab8d92ec8e0cf873cb3ce28f053952b377d3133d46729e169ea65bf1f13f30d71d4237826243212f72e4b2874d7545a6aac3e1867bef5c6c006a775f13969211e9ddcf91acac7e71c30aa533eaba0b0b5c2bc99dfc29951f33a7fcc89fc1cf38f6757f01d8829735cce18087282f3c8070d9ee6b05890b65f2bbf18f38b098020d8099b8995f57b67772be8815a91cfbf2c8288b3ae57e8f5ecc94c5fba840abcb6a3207c1b16fe64be86beea425d854da0997a1aef44babf08888131a9636b7489c58ed32404c8f103ab8ca91d3770d07e158505d056ef4e6f97cd78961e68d835eaf8e21076c61a187077886b1b6eb2e18ba8c74c1e59168b1d99711b18ddb338d802c23d44ce505799c1e402479b1a9a0035eda2baaedb265bc96f0afd74933a70aa3965759b072c21a72c7d929c2772d7fca338139c5428dec4adfed56465ec16d4d406cafea4cf1dbb9e977f7e9d768e17555602de2430323832a0766ee3c2d5f12aa8a95bccc0affa646271f78a9d98434992374c774af05aa00bb6e8b5381522f80b48aa050eca83a511b046c836fe2c75ccdc56490aa1c85d20eabb73dc1c15505e9853163fac84d5a3d5dadda3ece0dacc1ad4986b78056b3f75089418e1310dd905bffb249b8a00a4c8c53c32d6a85ab7093ead884477ca1f568e2e4a13a8a574b2751b539d82e29d272ab6bb133e2fb0cb7bfbcf58ef214815176a3e7763514e306c78571278d7eb64e64c9674111f8b3cdb780c611fd6551d9873bf026e789fe1bcc677d0860c56207abc1dac7c5e9b880e3191000c37538342bb039e1e5f02746ba6d2b7ff4288b2c39356c8c6401fac236d15c452cf4016b91ad58215ee4004a6ac5cd4eca0961ca2a1fb42d8c744da369b9f2ee4f26e1eea7903dd1b6e9cf3a8005e838f3f852e2cb559e9da51683669893ffc7eed81e0795229e8442a7082dae5386185e64783ce4191ed2cf1f5f386c5450cee35115613a0e5f71d7465aa89dc92053f95f276358894f03644b53f5d9c41669f9c44a733ad76bb7eb4c8f93fca1073e146d0459938eb7cef0b11730ee716f6ee21a618a12f956cb7deb828d26791f285412ab82bb042202547ded2c6f42e94f0e555d81772be8fba2fea0b723757e91b367b2f5c30afd7df9c68eec1a7a683825ab7182f061d3b21e24f3c0a1b1d3c707a6f6a5e16d4fcea0420fa468d373d4d832fa79c6b24de80cba42a43ffc2317c619f47549dac7921fdf3ef96fcd01094dc32d10ee426ebf5c7eb42e109aed41dd92113ebe46ebf33478c7b6d95e091dca553165567533ccd9d629f23fc4690ef841dc37eb402a526d0da492168397bf86471ddab1ab0d91db85a856d9d28139a2beaf752232df5fb5c123e254e5eb3c17978b1ad4ac1159b47fc15e045d1e092f6ee49c60266006f175ee5321ecc7b9ddc21d14909ae08624500db3929ac5f35322385bbf930fe5949c5ba25dc91ea6ac313d6ffe8c1d82aeb25e16db6b2b7168e6ebca468926d1ebb43d0709d5758a64e1a5443a5703a53538c795743c1d875afba3d3c4983d13905a556aa4bf0ec5c19d793ba58930133cf255d7ed494e4fb69de1a6cac6e89923634cfef69accedc4d52f31c5014152c2ebee94bb899a137f7dc530629225079cd7645fe641ba27437303ec522ead535dab0847fece060b7dcfeac9d3b5e94c2360cfcff22f2970bafe4b991fc596a5ea17533901bda543dbdfde79b64e4456806c73ec3775c56c45e68611a8505370b0e8d779798c04004566c088e59f0d104bf131598df571ecb2cde228dcbd44e2bde894ab77aa5b29ced62f15d40131de9d7a7f62112b91132608cbba009e6f6bb3cf4ef84bff336c9a7de9ea6dfb3dbf6efadd9c7d75415c2e9e3f51ad2d54d8e4428b05c82d96038d6ca824b82571c9d33db6b5753db13d8e53cba3eeb74e140e826b05ceae0cebe33db8c5e76c80efb944f6d25e09535d031c57e9dccb601afa79323c377eb0f2a759738898055c6c19733742799c0a266d6bf79dd8beb769ffaf4d88709960fa6372aea4d27f6e5ab4db7d8825139e935f8e97197a010e00fe8e6424b52d3f23d8d123b7b266f9c6dc1a404ccf530b207998ec9cf84e8b31f5eabb4be602ca2496af624a3daa221d1e55d0bcf3181e6c0f1ea5d88a24d0653a079ade34dcb3bb45ac5bd8dc4025153ab6529c135ebc0ee24e6f883feec66c280645886b7f5af9b1b2c6c190c47764f0b199709fa4b0fe8f5e4a75488abe71fcb99f50cd839d8cb3cf87b89c6182a96c0fc911e2f095c61a5e6485a736778201ea9ac0b8492eeb6290093cd887f9cdc2a7ff8c06b2204b0b7f28baa71af79aa65d5b5df7a39d82c9aca136858b6c77db76b245d519973446453a82d408d9c31c39548512b55c6398064b169749e448222d3d27f2986751f25cd8df961cb44e6c85792e555968c541ab89e687d538bcf398d99aabfc00c494ed519cbd70a8f0b83d5249bd93b08fca3b4776cc699a9ed9363beefc2cc5b569f399dc28d79cb9b92a1bc874f27ca0ba0c5d2f9c6198b3a9f03eb4b085815a8546410af384979fac9de72276bd32caf8a9d64fe214eecd72666d1751fe8dbcfeb4b21d16d62bc4d62f5663e7e308c42f0b08ed2e6a66750bd5c4727bbc7b3be2be7d665a01e738142750bcec9ceb4a052f5d0643ea784dfd8657b44551b450b2fa6152e871c74b3224d63cb29ca132fc913881417ad92c13c86f0899e40d1eefaff2ff2a057b9f61d1d2aaaf95c08d3ff4c6caacb5ad668c862f06cd50e8d79775a4c11da0f04a88191aaa3f99fd20961600f0bd13f8094486b5a7c3e8230feec2242f81c6bfec5ac29f700f19d67e8c74c0c02d8c43221ab1aa3baac77cb045f6879b6b17b7b1d75c1eda0cd4dcfb6c5f9bedef1703f192128e06f4bd4e86a0332270314736d0d9639c4f6bd1bb7b6fb33e8ea82b521b52192c1bb967078fe5c6f21b9be90d50542fe3d7de61ca7d1a8435434df28ce42cfc9b0d95234302e137bb3c1d7b0d750a6b6a7bcfc7e624bcfc501f920404a1c7aa225410f5c802f01d35a959f31f9aec299532c886c025df7ccfddd1084c5ba2e52873caa39147bd8a40100999232eaaedd853f02058d2911752ab7943a9efce9a7337271afe51064935e7a749769470efc4fbea176ca4de7533532185bd3b5ac666847956ce0704b5d9c265b389164af27126a6eef9bc5e385967c7084d425c0913b233b99f9c9afe24814ca911ee8fb30e88f1d4a17493cd4c01ad8796f6a981e1215bc3c8f3d2b578040a77a12b854665563a34a6ab1369570ea03f236fb829a7f85eb6d8cad5e7771c2a17d5672b38dea4c14e6409b4593ea33cb1a8f65111947cd83509e3ea6dfacb4f8a1ead02fd293562288b5e88db0aeeb8192e80b229fc87678a50e9e5d0079fd6a7cc3290f3f052f99d0b250a5d81e1a0e45bb28631dd9d442bc5db8d455d7ff14314f820050b7631efd362b092cacab6c5b32223d8524cfd91e1a85b5653fedc33bb55415a869433e9d46c9c82b6a43a78d9caf5060ab99882b1e1da1255cf43e00bc61d9816a585e9f2a913f547eac0ab747739e98f0d0ff5d2ee80cad8e3f596fc64992bab8d02ee95fd78298fe400ffe3d6b18e1e35101524edde2e844a6c4657fc9f3b83f93a792062a40f4ed5826724758e6b7614235516d27d31b17a4ab0bf72d4d44636df7db29b3d753cf4030d581ed899a4065aef862e20b9a797e9719ecb2fe1ff26990be83f46982222b06fa4ce265a1d39efbd4e94f281ecf05aba2059e130fb34f1f96c6b6396b8668b3bc99b2ecde827f551f0db4f92b4ef8ff204ab862f83585d2ea762b1c0f154ed107848dee5a1812611aace62e82ac9913295dda1763e6817c1571b6ad369fb54612ae018dadcd5e8a44f545ae83eb08623bcc64fddec47292ee5ef7b47e9ff9aa602f9905f269a68cdf5c2880e464eedea131b0bd034237794ce2ba438e775122615288fd449cabf7b2c3312a6d70eebaa884b1366efaf9ea1e400c62cf2c482f567e5407fb457f1ff6c97e700234b21e4e48d681d674606a062a96786dc79bfaf9e622e8129bba63ae8c9b8d68814de4a73fe045acf94719a9f83d82247dbcaeef66f503669bbc2538c911da8b7a64b1163269800efa5627c6f46e43bbc8315acdfdf399a947137f8ebbb5705a782c311efd6a695dd7b19e2cb49e41ea4997cd1b00bef1d67afb33e1215413ad1998af18155a2274815ebc8ea07680eeba442c5a60778910e77da26e919a2255fe07aef735a8deb8b451908eb172484c50f54a8290f9bb1cbfb36c3dbee4d0bca81c70cfa13d5b2dcc6135112d7ed7ff97852e54595da0822415057a3347b9b33be2a13a80d8266f93b0fd0741843c5e658adc6dc62d3f015053178879931c827e4a1661ec634fa163fabe62b8d23b2c35d81c9dede760588df0a497f26b3ee0c6fc1ee034b95f382cea71256c19f8912665d71603c7eb92e84ade8f44f42d627fbcc16eb0b9fdbe9912c766fb49a4c7b6484cf2450a2c54a7b687dca784fae7895471ec7e0b2a0ea75e867d8dcad9caf0bda6b09b0101abb8c2f8aaf7c389fb92bfafc8bdb41f3966d86382eabcc142aa8efadcc3928ebb78a4aef3641218fcdbc1e9a4d2dd3aae422f72f0e0691b1c22e4574f680f03debfde6f4ac7b6c50b42e61687148830dca67d92955efd7d56fb71d50006c309b0be77a9382cf23f63d3a2167786208ab5a10383c02b4719686503f1793d633b2d00e47aef031630520ee0a245ff7ce5c3ebbcf61cd580acacb7e3010844471de796e7d372360d35c5c4451ecba66b7b39c9bf580345dd416ef74addeef086775d42e22e01fb5ceea361dca19a45b3422c32ed88eab8ffc4257fc1d1afb910ae5f42e1a82017d4191ada37c605b7afdfd027efc8712902495e2febd3b94ba2d8de56dcd32d2a99fae88ee34e7bec1ae0e4c18198450914642b00c55b25eb81317f29c9aac2f5126e264cbb40cc2251c05effb8ff939a30962fd31cf4f31ff58cf4860e04e92a25bbba7aec668699f8a2d12f224b2853fd34b9e07511616fed2cebdd7d883b647d1567a85c804ce467c947bae2fb88f5fbe17c06d3be043f8b7d16c7bc197a5ab2aa25be2c15806578cf596610a1e0edc7c5e2a7ad869385045db0c678ef64aa1341505fe8bf27d8abafc35af7dd16127e89356b822894de8b7f44cd5831777ce759f228ef203f2dbf2ffd9afe947ad44211f64880802c5882d8e129217581002ce6a7d796f0602e039c61873d2fc5f355c3c945b44687e7a88abe2c53e1d3f08aaa4b7d108c8ecad3cc22f9f1be1af3ac7c9da5a26a6f2fe9b565762c7d642124c6987f258a43504e64e0b9ed1054bac2f6865df845d7992607c7f26a2c7cbe178d7e63a8a3986fbba13112a2439245fde83d3e83c8ef87d93d65d805b3dcb953e77daf01453cab7930cc63c3fdcd9bba3d58704cdf5fef050cbc5ef8e22b0726dae0ab9bbfca600da6f56d8436fa24c13006a138a1a138315c14bc711a1b1d043648f9b2610038d455026d3eb5c00dd4a25cb72eacdabe023badb7f31617d3375cdd810fe1618daeae5a694aa6e5790473747b52473b294b67994014fc21f1370a325e34ef75fb63f707afa7e68b7dcd20493a13e2ad164f6a31e1c3943cb0e727cb527fa21f5b75da14fcd98c4bb91f69df8352ccc7d8eb33530f640761f565ae6ad83ef81d08c3eb7bf04323005eafffefd1c586ef60352c5efa076e8706635bd082e3c9b2f83f50ebec2dbf23e5f30dffe920e894584366bfbd3409f36049a4a206a2c46ffbd04b252815201919f21eb5be6bc9ca18abdeccd21dce9e6a3ef082badf0641fccc098f0f518bb6d2acc0751c34ea52a8a170b77ff562f6cd65e726bbc3933d9bcbf7ee0e7e7239262cd64f34feee96b0016d3abe6fa47f082ce574d0fdb2310a0f59c107a39c8ab2416249a12a4d775bfd9126383593341d2772fec31f4c7498130cecac93fb7ade6957eb788b12172ae3ea7ffc22405d31b9c267ec8178124216fd321c8f27af34ad9ded503c349f0bf8c50b87a4740b3e5b38915b1a5ca2fd33da6d538035fc2e92bff7673c8a8c794d290114237ebf375177b5bcb5e3960d73d10e125998cf3b741821c3fc1adec1f5bce042bc45759f3333da6e192576b485f94890be11b861cee1f3ab28a84a7bf7bc423dffe3e56b7d492ac567d1854a93d1e761b5c85be3c7e89541545298941bfa894d4b5abd2e1b15bc55684cb02b4e48fb876acf7657625bb731de0cde25f5688c1279306cb5748b889a63c6d93e99cffcd5eb76f3abdf49ec4085c6615a7aec8c9466108eadd88f4711ba76c16bbc4a82cdf79a9d3c342b3e72a348f3a2632b709b711ebc8206f92968d184fcdf8790be52bd91cabed236ff66ea6c53ec116fe9ae3f1cda58ab290420a43a2a162cd8a87f8e7924dd47db9342fecf7a62f7d3edc0d49e3db689dde0185f64c771f416fd9c4774972305415bcb4c87515637b2e7b9f4edd3a5c099cbf60eb8f4750c6faa5cb58597ba0bfb3785d9775075a5f55caccbaf0b3f2124295cc2efd4dc9dda8f2a87b87ea69a56d7bb052b85fbdef8f1ade6bf001af80c2209816371413b188816b7bee15c5eb692a6fb12ec8f04f100f887675eaa44b1a653847ce981d123cb1c9ba6535b374db8330e5c9c9ae1c616b94f7dac02eed45044ca4b41cd40257981725a5290f8e7a5b03fa9cb3179f347310e0d523f4ef2fa17fbfbe84c27754b1fb460894370a17ffecb2131d4180d8d4a957c2e35d0d13348bdf70006d10bff653f0a94f3b5653d430430632887440528ccaba79b97e5490e761622d93e61130653bf0ae7ccde2e434fecdfd2a13f025e7df7e82f9f0b5b07a26fbce8f74fd492a0519f2d53b395c41843eae864ba75050a3e51489ae1b8ae621b71cc78774c10481bbd262f68bf06612c10f9640169c1b66efbc85180bda130cda40fd60e42e6880769a08a199695013c6e15ddb9a10148dbcab0fe79522b64803914e7ac09255dbfbb86f3d23e1146a2f5d9481e864822bcb772b75daf36ba5cc9ebb57c3205620f188acaebe11a1138ace413f6ef7ff6c9174a01fca8c59470175b154494ab9186c6980d94e43c5a9a7f84a6202c92c219201c5112e7c17ed4e900ca358699d905199ba412fa9fff25c08a29f8bca205940b0df6395d53e1e81eeea0b522006ef44a9155733ea411a25bf9c2bf525ea1734421a20004facd01021a32a69d73b475edbc9761611ea87913bac20dccc0263f99b287a21e767dd3a86e4b520f0dd7037e473ad00c8caf9732a77726d82780f7f77e378f947bff602cadaf03b708f9426f335174c4cb2df8e616368fe5dae1cfb3b07bfe6a51758ba2ae3cac9521a6fb0edf6711cce7eaa9ac7cdbb95a9578a27c3fb9a8606c78fa51737cb54ae904c9f06651cdf211e9053207295809e8d330dd75bc50f7e03258b21865a5d29478f6720e1e1d63292f5c91d77732a3446dbe6ce42bd131272e2213c4e2b65c1b7e7a87bd1cdb05635231e20d2cc167d38079280923537801dae7e37b25d2e2ae844a6da02170fa2f8e7170e3417f22f5b5e66861abff7e93a8850b8156fe206ca0840c521ce8455fe64fe059c89b349d1fcbc847eabd39407451a29930f347b534f126caf015390ebd4388b73b80a7e12d28b01ca36fb9fa1e7bbd8ec696c61d9cce6cc7ab62c1223e96bad0c1cae1a07634396eab567601a88944b4ff8e47b686cf736d94848fa39da0fa62df21204580b4926953c1396441d5d801ce37d80963f3dc47d7994b10eedf8230c784b533a518117d7fb3d9ab3776b9093e6617ed8008acc152961bfe78fc338bbcc3bb4afab851a19aad26e16f2d2788ab3ed7f88ef639e760c9db021a3d7631cccb9648865f96919bff7b9b5a3c6be97d2f346f13e712b948dba4cf88551a0b4685f3bcfb4d9e6d2de5d3006229f603849b40791a7d9d88b5c439d9c380787d421b8a44ff7e0f30567c187bded5f198651cedcc969ea85ea34bf445db43782d3e729a43795d74546937ba8565b97d05cba93fab516fae1a8036ade0e4eaa1bcfa1e1d0407156b435a28cb4676b49c1e451bc553359170aebaaa628f4295c5a80e708495cb31adc1c466e554ee2838a978c7e4ddf47f91791ec8408a890ef874cfc274740f2376262d9d791cb38d242fe00ee128d1464b420b13062fe1b83f349a852604409735cd0d36764e969733b81988843e54d0db44dea26eb419dc41d7356c795142009c27b55d60584fec08e4388092b33b66ef4edce2608fe15c5468604403eef4e49f1661e2a8598d1616fe5c05977dd99b7c593725233b0040d466f21fa3e1bbc206948caf473e05d8f21bd689c9d077534d815b0d28caa82dfe34b33ad7435d93aacecc015103e30d62cf5361d1afa1d17e25f2aaaef936f1301f7bd2ceae26d50cc245b753034fce5307883fc674097aef5bce1c4c8306c10f6e4859d00ba933c67c40fa139593a5fb1300aab18c0a77e56b5f0d92021d525d4839924933ebfad9d6ae181cbf00ee2927e8d0bb322c3bff850e138f522d5b8d52f97c39943e62b036fac9291fac5aebb45a13d940edb12c6001d1dd85f123b789774d0b2c6ebe8a8082c7f25d2bd2d5b2641b7932ac18cb4f77ecf1fd8d5cbcbe8f5f2b0a6bd3fdc1e867fb0f79a5548ba195488a8005fdecf40d744db2847f570e2a696ee8cde19649fa9a62f35b137d9aa675e74fde71a9937453252785b0249b28eac2b1a2256a534a8af607311ae6ad0c8cdfe0ea7a607185050ec9c61d0bb582138c4c4aec040625c339c5b5f266f203a62c91dc6be47676143da2c73f9601dd0a5eb02e7081c783e346c8dae71b1546851686bfc40ca13727315f4c4c382919aed2bf5473dd66894c177ef26641518b683e5fd78aab30831400d8c8ca2cc6c51cda047796fdfa947105b14c7f4f13a5dabd9d0d028a15569d4e2bf4fbff852d0dc504ffd7b4c3072c5551cd1fb37d99ce6e4692a4c37a4920a5173baac69f3b218c218e7ca49581c2aacb6e70b866ac08f8b9fd8b308ba978bc3f069683d229f584d3fb2af0114c9b0e62ee1791da7a475f913386e089b1c115c4b5ca37a29ab5f598df4cd9bc3c2f4cf34a5b0d77b4a9c811178900bbdea76a6c6e2841420bd7709d25692b3c0a5f291f8740dc4cfa2997df3c4836ff2d5328e4a2b70b21864b6a0f669b82aeb55941be8ba74310442576a28220770d8c5886d1690c5ba33f47c1295ef4d35b4d585fd0229c5b4ab64010b783aa3bd509a08ecc32d15ee267485c83581c7e4bd7aab38b75b26d3fad8c2096998343b6a7319aa23709e33fa56d1c131fc8e72f3f8adad2a6ad09eb4a1f573c52bccbe69cf54aa786fd27d93f020530d151d2cc5110d8364d13192bb07ce4b81bb6249254afa64abeb2cfadfce4e61c2753b7718c26b3ae7e31f49098c434357e28164c515277b7109c2a06c5e7a9cb51a5f8a67cdd5b53f277c8ab49aa6f0c0265c1c541b3da9092e7fba8f124ccf757858db60f54574a8bbba9a90f49e19c598548294b3e5037c80f331693b02555ea3d36853b867b71b1c4b3e75b12d9f94805404acd7a47befe8c1c9636e5d883e1b93adbb57138fff7dedb19d2ff7f1f2929578e2985747754036f6394f99b03bb131e75f2570f9e58345366b042d74ee591463db954adb35f0f7eb80b12ab801e91d5cb15f4898837b3d5ff68558e1a3ebb2e6865006ccf515a333a6c6a77d95f373b5efea19fb61d62f3b878ffdd96038c87bbb8498318ae6149ee2710341dc831c19cc4b29c372088e868eee1fe01e0b065934e757e8ce09979b3f1df7b8a1bba457c0fc559c12d1d0fab09598077a97da70cd6feac12c476c9a1f15a477e7b26f34f24c318e93edf22f786dca71485d88b5945abb0ad0cfebf77fd8bf0981a330248f04407fc54d8d77f1e2f64cad169896631cd9f39e5a4ad7e131a72b5a0e494a952bbea9de69d8f50a0b0aeda28065f57b82b1e45d076c251bcba67874336f710c1da48f4c992ebc47c80bfcef07885723d26be1a181a1ba2bd0de32fde44d116c51a0a427033e9989cc53102d3552b0dcaca5b9dc55231e3e901e74c389a5253471b09e1fcb8fef02e917c62e9168a6eb05859b7ad33ebdb3392e23246f69d405a94915ff88c13a5fe1f3632eb937107f756215904948007d3ac9fcbf2edece73245a3a09d720d0a7ca3ecce33f04e5a45f15c761cbf7867abc97fde8d4f0e2d0f2c7bfa740c97ce5030f4992d84b47f5701feefcc70def7c2e9a1b142e8ba782eec35e8d25f73549d97bbf9ee2873697e95f2502387e6375d39930fe4d65c818d6606c54e618cb39cb4f9cd47e1c8c47212d9b26867783cda58b0c617af070877389bde65cc700adc06b91c39b646e4249c13117","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
