<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"0a3c2299f0658a6a02276172642a00ce402c203027e51b66f1ae6b2e205385866eb8e8aed55c8faa2c2afcc15dfbb4e1f6e6660cf57213cc2fb8be00a56897aca4708960fe6e0ab848c726162da8a62da03f5f44bb1f848e5ce9fc432ada3da19b25074cc424953dd19ea4a612aafab931c8ef832859116b3991119ca43a6d0019910bd4ca742b992e32cf881d714447ee16fa0563cbc2cf63e2fc13a66f151e3920995eab42a99ef411be822912cd91b541970aec52e4ffbc41b0c536245444f4f4e6bf0fc6457d82af85023d34bf2147c5c128bb178e9ae38fea3811351fa1032357859d9262ee0e9577fecd84a2d89ff1bc612c65c42ed5cb6c29c0fde60769269bb27efb62f7935ededd95175622c3c740e5ad467d07183d19b41ebad19075d144a5f3faf08cbad5c642cb1da55e7dbdddfff330a9019c6292184029f1bf25f494f0dd6416e55e79c599e2e6ce90409aee36b74906082053dddc71d325059400c6d8181a09b2bbf26a5997e5e698c7aec01021d3b0155089acdee9acd460d1ed786cca861bc73532f8e2e76eba6de60ea1b94de1d53b5256601306cc126e479e9ef600e66ea4eb52338f4eb215d65ed7f24a6491fd8d1f37319c171882ce34bd08b3c3f5496499426f3ed1a11c67e9f5976382add72431d64cf2a6898136cd07b06c2dc0ce95e8ecf62d64617845fdcf9d0a91c08357ee17cdd21930c96b5b43ebe961bc3a0ed03ef718ad0d850fbd24442e3c60742b5dbdeb4a2c6527dbebf00165d893c3f114afeba34970205a7c12f1ba9fe11adbb8a5278b36f69ae47ee0f2cbc151db58db6cfa82024a2041e5f2920a255ec07d22fea5960f47f77ad92cb064fd9c6d63a3a22d5a32acc8dbfd040eca4e09466216a18b9b3636beeecd04f4561da39920dc35d784ff6fadb204a865172f4c40a43a446b8f0a53ecb3e08a1f22529a051344fb6f15921db7abd4f098b4cbbaba548968abde719cc7fda55393774b7acac360afe4aa161d7784895da5a94807539755fafd8938f6af8d423ddd2fafa7f3f6b3c3a60bc2798907ffee85f14260df503709890237033ad84ff80d7a52fa16f3418a270104082f841ed3a77f03a0c6585d1746f7162236f12116cced37af6e6c117a08139012a9dd0242a6aeba5d1afb957e32aa0c42fd75e8a13d42770d9b473cdd904de4899cfe2a6f0e8eb637f21aa7cb1bda8aa7718441954d980fb6e994516cd9f3d8ce2ba8a07c4d766a1969bf3a9c85b2af0599637b5d6ace83bbffee1c2f49048f9091d59a28f4b230045f27e36bb47a5c8478dc37fb6a30e1e09018c188318e3d7c179cca09a879fb4f0b78264ae27a7390238cea92460200a6af1f9b9643aec4a27d6b32161a6742d878f9f42bab1edce5bd7449d5b11a9be716c4affd5d2f1beea018af2927914a0322b8eae24b8624d1c498c92f1643118c96d1efc1b47173bbe8e4cf93dd0855b12c5218be890f4b4165e8580d6eea8c5b9722f9d1f1dd04998ae4b5f3433714d35aacbee7a764adc69244a208ce88d512cade9c4009034365881f95a249a908bc99f060fad85fb905a06a9f53f16cf970b081033f96adad58e32412000aab92d119d434c6beaefe84de11dfde4403d1777b593c3ee68348f8848048aace4d65df44bf694d03721cc1b60a24b220f34fa625a7fa837befbd30099bddd67fa6d4bab5d588cbb8a820a731fd336bddc48ec39cfa84dcd8edeb977792239079c6b2740ce4c04023a29eb9ff51d679a048e05391ef4fe631de92d3194725b9ffb04b56977280354aef5d4863d478dcf75e14f39fb69aad680330acafd0842a2bb50bc2ecdd5f455eb8cb2ac801c59337b9a33655a874a64ccf60f437a8c14073f2b85e02758584171198c8f6f4642a9cbb214166b631e52e0e5302b3ca007bd4142781a0d7c38faaab16579297bf0c2569ce5e80c2b311d6e913badc112536d6752779cc0f28f960a8d3ead0c4bda319c7036206c1b58386c4195a833bc16f30823b218a46b3f42f4c3db4a28a4667547de99daf5054b2116633abb7573dfea19712223bf8cd5c91f79d3573206a6c3995a3c7f0dce1f0d7670dedacc44b9fe5c491f911f7aa900180e2270bb047250bf45e8afff780066aba0c05781e94c1423a0a78a9a89233c09793fe474497447c48cee8248ecfc7d032bdb161eb20b8522c2c2f74f526f5319a1f916dfa6851c1a445d252652aabb5bd6155d3cc1d98985dbb1f32ca310fca998fc8d24e7b812f886fe042d6cda8c832c74359c6060db4a5427fa030f0f64dc64513dba17df230ff95c8245ad7d41339c6277021040066b98839b19bd805123de4564c7391527eee60fecaacb47e6276654cc4d570a8039217be990b239672ee8685830560dd8c5c3d460d382091dcd15b217d2b23dd90565c095d76ea5ce93758bb88e9ec9f50db577165220c421ed91135e46f6007b6d250deee171cc54aa893e2b0338f2f6824c83213a1b9d151f85c2642f394b51a9c530e9381a8219bc3de682ec246b108819a524d8de0519c82d2e575e87913e2aba1befb0ead4872ffd4e1f0da5524daca25c95c1c7dc6ec6e21af40092b51b63341392ede8edf358cc47d4ee1f7dcbcf36c9bdc1b97fd4a2a54b0be3b0359832e79c9393d0d200b3af50a4b2a97dcc9c66cfc59f7825ba1bd550b7e02e562b49e2f0230203f764e68da5cbad765ffb0a9ce315399fca4c1b162edb4401071f846cd876057fc85a36ca1fc7a4b122dddc1c343bc77fb2406705e8fc00142151a60b99a1548f5154c3c6058a6cd51a0ca81816d2d7db58c4195c053e2f3f5aefbf18d083c06b5ecd95c967b84ba0defa95a6e83f4a3bff3adf4fb9ce922e3b6849a656b22c717f6071026526e603541137308313369f6ffb19102fe8468b1b911e293f637279973744f7e275c07c1f7e515a99b5000bdfa1526d2d7a65f7ea875d2ef9d3e1f244ea6d9fa37e1708feafc054fb2527bd4265a363f21ca847dd2e8d33a5cf59f0ac535f56c1bf14ea4145200f3fdab7fbd1ddc7b9f554f9dbfd8a6dc68b627947d04401daf63bfc939f87be86a625b26f542297062d7672b18b91219cf2abd8aac499b7cc17b5f67f01f6ff289d3abd8879ef414b8b96bb3201863db64a636cb41f5e5b45c5355a8c4f5509c19bd5e4188d76f25798dcb8d0a75bf04f4b83311a5c8a62afee9985d81e06eb086c995d84cb9e2341381a5e362faa6348756797cca419b580cc094597ddf737ded6a47d584d99c1c6c862cf6cc9e869a7ec33f8806a0a0c6c67954c4efe32edece612d78637ec9c2bf05ab75979795d96c04ee5d5ede7d4401416db3b993534b6a50fd7db6b2a9e0d5daa0de4655400813f7473771a28d74c3cbba6d0a6f517274ec5cb378c9ce3ce325a9c79278366943df78baa4a767bf8ce2dc6c31e19161db5dc258865fc465a6cc750c34c79fc3c94c9cae521834716e5a97e50021d9acd4de5fa9cc5b5ad9a2ac41b9030c9070a98bfdedd8fe78284a4b68f97bbb6f03dd6c1ab50c57d56c9823f441bb42231b8124e190d0b23dc8e36e0b0583e267d025f7e314b2c22f1f252bb9f4f584b8c97cfc62a03a371f88e549231111bd1688f1d7f1a9a04d1e29ddaeb749933499426f6a0e4a2b25c9c41b649ba347fd50f5ab4883066f5d4a8d46b9769a987293c55460dd85468da8179ce236f2a2cf2b8785dfe8a23b9c082dc8d42597127dc24c2ee6008ff62b62db97d87e9f285749ced7c71291df912521b969969697439d2bfe24536d2416be672fdc6f1777b26141b8302d0894629e948f272b2261ddd4ce25d612b722149779ef96881977d312d67136a8c7bcd30c995775586c2ac67de2e7182b5a82c27d53b94d86902b58905962acaade883eb7b98a1b2ac9c11038601d3ccc44ee32136f8c6fcb1f355e675d1289e025f15603277db73c29dc00d400438965e5fc03d695e15817ab4e00035223c91c9dd385d6e8a498481d850660b6d97c1dcf930a6f94817a2a5895e873b97f406920039b4309f09f25d6aff85516c998cecc88c95cb80509ffedba4814c02903211c82b1406aa499c8d071176fe5b8542e1f315655bd21d9be3b8e917d8a0b42ffa84ad46b4480a3dc7c56373fc58d438fd9c6e50714fb61bf7069f64db523f3c3c81ccd6a8d160916945fa555e0f2320d562364fb23b5932c11aaf54f41781b7a7c2207a7feecda9879abeb923ebd360f2be99529b663a6753b14e5dab499a854e1bbb80958f01614a941ea9f4f47aaee459567282716aea2f7dccb3592ed07e14af7c8f75a02705e4dc6ee110e188ff4d3a144c3680d983b9c9fea98ce7e57bdd673d085db81c1e18c4f3b0db6d82186d752bd64337654c89232ce80d98b8fef97483128d4c160698442cac417b48251297f851124a4a6eae55120430560d594ce4aa5f047555cad5b4b5c24cb5ddbfa7bf735aaac5ce82134a2e4bffcc16e930fd98c3fcc162de28ab96107d30a2f53da5144424c0526e0dfc3ca37b73fa2e45a8ff18c0d673a0e47b300b9d4f78a00211f337a244f52f17e1f85fdfcc247941530d63be2f0df46580725f1f74af1316a08654a37defb434bf6a529b3563e7680e8185e8702c558e10c2d280613a3250fbefbda29aea8f4cc1f3d3d64c76b60f77ece581d5d82512c2aa943ec9dfcda3e7a3efe992dd451963f0da05e25770cf69d150eed7374e52e99d97e491122ccbf5b49a3b445e1e5da2e80787c189e90ea4043dba32d69b7ab3b0f29d6a1e1fdae277a3a642a30a65dbe6930d0531a9cbd3b8f9b536f101190747e64a76b31f7e405ddea2ffb7042a60e595574249d10f1e59cf1edba1554ddfe2410ad0633020a2cf8a21c2d2a685a128556117bc4c6ce9e87c869db5e007c03b94c44111731bf12d00f255e9ba9363a3513e7d4f0b3c5e53170f0fe7552a4c5e81876057ebd3e8cae6524a6ed1d695a4b039ed5d01ebea1d5bd6065b7031ae021717b7e5b5a1190c1b333b18350f994b032e5bbae7e5440e7c58b56c062942f64274a34d8cf9ca76fefd8dbbd528b4b67b89d138c372ff3ec0e8482353b26a255644afe5e06eed5adc4344f40b4ca9c72ad525d9484177ddbff76181921f50bab7e7b9784cefd70d55975ef869055d482cd6c047e18479e91f79a0f3d4ea8afb44316b30933a464e9cdfed8335b9fe3c5901b383dcdd96da02db312177a4bf32c7698a0e6b39226580f522af70f95c94ed3d574253b43e04fa28216056000c32d98d0acbdc9e51512db7aa21e59314d8ad9e8964187138c5d7b200a98b88da24b63ef584fb0a8efa41c131cfe363d49ea4ec501dd77e672a85bf77f6e0fb81afba59ba3d6e7c3bea95a3012504029683b25e40f72084d17e1bab87c05bbecb336c030324ee9cd1c0c5deb20de640626c07e08fb62ab15c51ee1d52c3548c5a23a34b3b7ad435b782f3454b4efaf5cd05aac9026ebb5de5a9fdc1f58f309921b4d7c665142f8e94882aba14fbc9f8fc0b97b10b4339f0f1c8834a287c40a2471aff0e533bad079433940baa004f2083da78186111965ea26f6010886d009a0e79a8d342baf215751d90d1eb431d9a048e6821b5bc4032addcd2bb2dbf8393ee0082ac8ab6eaf757679c1625f7d21d55fea2890addcebb08143645382d7d71b65736e0b27677e779d04f234c3a5621a3d2c5f882546c89b8f7f1abe241435d59f1173d7d286bc52d27698692de2ed613853999d255d0845f9872ce7d3a5d2302c5ca6299b508e7bac32ea5c168ab357ca32368d14be593b9efb34020fab72839f202a15b2b5878eca217edadcb43c3449e53de54858f346e9e2ba3841ad0cd9a4caabde024874a0d8e3c1122ac7203b998a7419f93bd539802e57e847ab0dbb86bbb333ea2c6ca6290f3d17763625846e4fb3bbc7271f5652682679032d0645903ae20cfad6505e20ab8988625f543bcc98d80ba7e6494738e8cd879ccdcc8184a99dcbcd4d618f618a67dcb7cd20fd561ba41c85dabd4a2a60f5fa8fbc6b431c2087c4f51d77c5f6b8edcfaacdda8a01f8c5d1f7ad09c75ebfd991a1fe5e5866fdbffbdaccb420019c90b991335164b378dc72c35c77698cb7cb9cde12d60d2436b21103de424e53e0cfc7a814012050f9456b15f559a5e38f5a67806ad73038e1ce4ef4d0ace3a987845dd62c32b14d1433492b423f3e846f4a8f8de996b89c64a37a50209fca5248418b4ee93ca0aa283bb567225d61d9014a4e02ebc703926544e2526ebf63778dcc202353d4914e9c845c3ef61108a06a7e786186d20ac524563df7e78084532517dec25814b498831fd3251a981e48f50c65ea6c4f822472225ed0779539f1305709e510d9ab3970cf0ef6835f55122b522d96ab162ebf86d0eeec64578043ad086e8284acc20bd1dc90810811803326ac2c016ba796bc1fa4d3a88445f65f62a6126de6179ef3e93580ba87cd30e26164ee51dad22f315f1824989eccae84561638d9bdc3eb4427e125cdfd7e20f811898747a8f02c0a902cb2f28a7ba49fb4f4b4154bfabf91bbbb63826f264336ac471da4737139c6a72519c61914e318ff1b1754dde21e5d54539b6aa546cb8fe97d5946c57df09cdb639063ffeced14fd43b71d96f447335904ce388e20fb39e21a8bc25c727c5a9680842ed69da4e4bc154b26ab3e30fff772d3e185597c2d727a9003e33b07c1579097c4c76179a3c193697e245a29306091fcd0c85101a25efd0646b4d71cdf33c6a5a1f6f4a4dfd3c901546a8a606f6cc12e51d56db660e1106656602b4a73382508147e18e8ba2edca85bd6350e52ae54aa89f1aca92ef6fd8fc88ee2fb699d7c31a01383662fb75c42a9e30a1788b6b426af0737a76982ef4146e72914abffb1a4353a7990f123cf7e271fdc0dfd6001890339cbc94f75a8c3cc38a3c5484fd62d79075dfc4c51a34912b5254c62e9e4b125c11488b720a970a6d0d0e1f09ed721936ff8ed9a86a636a55d7addda97f2b591ed9bec443f1edb3e2be4020352322febc52b267582a245522da711719a31047a65b875bfa8aa2c7a36b26b5f2311401da469f49c5272adf02b26655be7ea8466cab9209a590f59ede672372222b8b799ce3f825f84b2c19f72e737fd004f6d3b0966e9a9326779dd697eeee1c5b98bbf2a4caa3307ba9b3f7b92812c50dfbaf55796bcacd44402a2c4022485d666bed9c52bfa5af061726d6217e12421f7f8d9e69943ee4615d18ad3992906353cda7579c9535ceac8b25b4c0282f522a85865f295fe0b01daec2c3776511c7b67edbf4a92eaeb426fef745f70c07d00003431c6d27b91007e11e4fabc107318a133fc83300a8b006fbf1774d8708fa37ed2e83c25a1d4b2d30934d231a60822b1419b55a13db9694435fc92c97df5bef40cce82bd52c4dd440d89805752ed56caf915bc213c971d87c2b910f9454cc94e608d568509962e57ddd38a692da4f5746a6cb031932be529ff9e7c28b9ed5a0fc7743a979830eb16544c1dfdb6ad150e14ba6eb16cb44c6681253a2bb23aa059b2e5d4af1cc0339f720306cea5e9bfea1327b12c7150a628b40b9b05dbba61b564e160d5523b94cfbab70fd92fa9f0332092726b5a590ac416643e1d6125b1b97cb65c391839aa1fa3f610744eb24e359bfd092fcbfb0202915f913834cb5b180d74aa57f5febafce54da79b102883ee93fa9c070438fb7fcf385a4f87234f0d3f110e4b0a3b3fe34066e963a2c439c16cddfed36cbbb96b4b7973f13f71e84da2e5e1fc0a35afb04b3c9650d14013fddca0e594cd4ba418d1a7bfe5836fa6f4454b8099f71282e87c7d55d54e65264204693ea2e13b3765a5c6982c1369226b555164c4e6e2a709f9aeded63629b714c68121caefccdeb26d5210fd8f344c932ab5040928c563b06140e996701c53ea1628fc3b82282d25e5cbeba49f005edf93ada4339ee75fc3d74ecad797ae7037a9ef2a5ee7cc8590580251e0f2f5b96b9cca0417151418413b2e63974e9722bd0d70487ad8427f0a31b032eb24bf03b42fb9c3d89f4279b5f0dce2ff64be68b370b2bebabe42382487a4a429d2737bfa3bf4e0529c861f663645144ee5d0c0e3bbb087af7c5ded0139574730beb82a4f9dc145e0f579b78d450db2e0894243fd9c7f8ae7efec220ddc0c93239f77c9c3a1fa8ea39ab8e58e99c66e5aba26f7f4ce9ff8ed0c38e4f6aff055cb8acff1c1ba92745dd695dae580441ee40c631086bf0e5a6d7d4fc35a8a77568cd2495cddefba988fd9e6f0ab586a8a844f0f544730cb19e3587d13ca54c38a2f39776eed5cf133f5fe81e1160fe9f379cf3ef8ee55a81d0fc4ad24a68e225268408c9b13eb8a1a49a6a07b772ba16afe95a4e6fe01c15031970b2b20d1cda581f7d4260d90dc780db8537fbf21c97a748d9c6dad84daa1e45d8823354f2cd91dee2ec791ab9909eba6db205b28a7d8027669c4c3331a888e3bdd4282248450c58b1bbd61b20ca4af641e6ae2302271fb525995a627c37481731317f1f3670df1876389e08f1ac617b42e3791c3da52eab5ec3ba961f24454cbbe0de68d1f65bee91eaab11daeb64f2e4d47a1a68d4838136e0f321b7b6d14692c3c5d783315eb50137fa954e1f8d412c4624e67b70b33a7a9a1077d5e12cc910e28525e1f411363c492fc26682d333aec77fd76ffdb082ebe9f814e6cbf77078afe3141d45b9715d4f1d15a7491828e272e35778576a342451b60c32f92229f35218da0c8cce0a2fff809f23cbf39600211436885a4f67d78f05b2c5d399ebebb62ce84e544e20f46144208a338bf1588e475648189fb542b87c9bce19194232b8d4fe3e133ee226fb990e11a9aaa4822dfb2b7e84603cb885bf134fc4e3fbf9ea7fc8057b1f062c7326606e5de9550138f98f010bf4de1f6bc479ff8b5934f8b693c75788ff2bdf10788085f37f9ad307e275eb4d6f4a35b3c15dd5c85cdccd8ff49734f5f16b0f59aa3af27952b276abe3b5e89e5e50c92ecfc498d2a7370c73a6f1c4c4beeef35d5b528833ed890e9dc86f00ffdd183781ed435aa1042b9a7ca34653ce2470c9027c513652d8929b1463eeb8f59b7041ee13e224019e304c67ac95c96befa4651ae3212a268dfa5522c5eabfab90e0d05c249366ea8463166a2a7fc981836f74150878d7787cb02c96c98d02bc6ec9fc241cf15e993d76d2bd0a54182971cc79578a317c5e917c8e369dddf391c70d841640b1142fef59c52181a16db2ffd6a98c355b44f2cc16250e983f4838da26b692480cc676c77a5fdfebea32649ed7970b9cc1472071b875859911668e9386fb694718655c878f6eb0c166ecf88fa32936ec4a27cc2913dc22c5f049234594ac014bfdb54937d5215c492c1b3e4f3774660fa9bee6c5d03a0c4aa8bf8ae09064541337e2393572aac06840a0bc746e1aa48b8480961a7a60e39a83aebcfc852535157b71ef04b4df2e28c087f659b001a2832d303b31c7a8db60d37f911082e263ade402bcb61ad15f59145f7a63fd626039db209d573d7cfc6075670cdc82aea04a791f11cc20052cfd3ea292ac05ee83e7b2b9f4edf37ab539ba1d66b51daa168fc643e690445b479ade7c13b7837f2e266fcbb47d975c86797035539a2b7f021a14d8c94f0a18479f5eaa3389dda30d7b32befc2ae4e38537facb5847103d83422d70aed3482bb93ba8624158d7b3a373d5a1d70a3cdb520355dbbee7236a595b71ff7be461cfb1732cde3c74d3b14463b02f5ba5c51f8a8377c65be5794e74a48261e6a96d6756a3088eb7a2fb22340ae412ee39edce93ad351e799bf752633e8ee90cfceb755bc3753023c933d8b6df358ae7e4d9fa9fbd5cd6101ff40eaa94da8ae7ddbc23cf4adeaafd37782eab36823ce5dc08d29de966a4bae3ff2e37c2accfaebf0d5a77ff31aa0e7fdcc082b8e11300e950c8503f04d5592b7adaf182835b8ee66d2e06873acba8e1ebafa103617c539d1a157137fbee21c6faff57927333222d2de539af2be3ff6072c969523ea46a4c9255fc7134c719296813358656af9904e8319d86acf309e71cf25a60f2c1265d832843526fce953885f01867aec4272f0b6e5b8bf9b4c9793ae6cb47526e4416cc868b2b286500f38252fc93ddaa76b34b01577009980dce71a59084551359b07c37e2dccf277ff43e4b606f15d6d92544ef86df4c0897ead74ac243a48eb137f989cb50f732473336e4a4501642c6add3a0fcf852bccac63086194e6c149e832ba77c0fc6b0d49d6481dd5fc2f63d398a0f93bcdebe03c42a6df5a8b0baf2a96a2274fa453b55045c7f5eab3039aa17eb77907717ad5f6d01ffd00b614982f9554830e670257fd0fb1a950adc40bb33ccf0418ac58b1f597fb9d5dee8398cbbe9498d58be938361b617c8732c6b95f6d27f77a8f28616bc38a29e4cd6be0591f0d02440397dbc5ad6fabac001be56fa164fb59913a7e6b816e9edbdb6bdc54114744b037213df1c5b4005e67d5522b9822fe86ca977457f15d8177e7d1f2cc5e11300427a5e6dfd375e66b53c62f074cacbc3d45e8edb61fd3fbd1c23d0fc8198206551e0537e8d53cd7f79b1428bc7a903fe576ec006cc1a96fd19487b22d52a3ccd8988e04731b12104e3582f961b09d0ff9bac1b2468c9fa3340c437f0646c4dfaa92cde6f8c11fce8a112f72ffb6dce6ef8a51e3fe16c3f555b05f24f323fd1c3532652ce1d76076f4249e397c8ffd48980b45195edfc8c3dd6e68e92781cf29a0f3c51d672b137fe64fdad8f76de5f991187c782a021b8ec1b54fe55ae96f147e2e6436be5407f1cb4d5fcbde8b2891d88dd644843a937563aa3459b065ec6f520c42f0b6b4bdd8364d01b53feeb79256bd5d126590ef788ce3f1b09db26e0f64d4679d48d472fef989dabcd098e9d0de4316b27cd24ba208adbf60a0d7a9a0359057ff77b431d0c354ebf97220d4c236086867f6a0b98bed2b7da0089e1b6bac51852afc05ce89f6357a002360979a335d289070c5cf15e8af77bede6a904ae9e393974f96a8bc7979f40fbd1338f054eba0dae120eed9a864f821b3cbea90c52ce705f07ecc814dce7300658323cb69200b0cfdf47f6f3e8727231589c915998a5b72145080524ccbc3aa7930fea1b821b66edee78ef07ff4b550efbed4d23279cd7306bacde0e05b982f09ae8a596bb214c4fb5340d68d8c317be3e6902401e61a27ebf39c41d54d9c5e00c31a858fec4c1f3b5859d7e22e2eaa5a07109d562972e63e7b79db94eff07fc0e997db01eebbd37927114d26e8f7b89ed64d950e4ed5571dff6be509c7c80dba332946f50188f1509e9ce3bc399aa0278a9892093eb4eb800b4ab4426e1816984a6e715642c5e53e246597fe3c730596ba8c388209fb3bd96748c8d4287715379626243ebf1a40b33af60257d4d8ad0d1b75e67bfe6c35ac17588c623f4e87fe15e80ba9ce907c756c52c1be749dafd3b350ab02f5446d90d5b9ec7715dd824875c8ff39b693981a01b6c9ee026d059701656912d092d09eaafcab2946ae98578ead88646e14abc3ecf1d0bb18f54ed4b4c1243930e3edd10f0b44ffca05db7b80b822b65744cb9c2b7b4b929a6afb6f793b72a38e0b015dd865b7b3b954a279f954c7f832780a8d6c9e40a8d88cba17fa4afab7d5ad83fbd988b5f8972b36dae405c174ef577b0e7c4c2fcf1de34ecbe8b4ad0cca621de216313413ce4ca43597bb888b7a62acc07ffd1cbad188ffbb5c3aa0957b580d1ca2309a724e0d5a974696f95b757ce63381160fc7aeb6cbadfa1a56e59d1f9dcd9471acbceb59500fddd8d6759e37bc7d58ce22f490a658eb7f4f8f233b578c14470e3c9d6828e8dcda3a2fd4d6485330e313acdbd66422cd96489f592278030d678d4c69e53ff5fa2157fd1cb24e1c5589e346c12042e1c3dba58414db044bb5ac684270a736d20239c6348ae1d3924874aa7f7026c426c9a0212fd80e1125e9912d6424f001f71e9c494e005bab0a14c06a712209adf045582aeff9deb280031348fdbfc5c958a1e321d74398bb90baafd822828564cf920d844ba782b70c9a88d6b9cc27c520a9ca47b69972a79452988de76d5a9958442d43cf42388ea8cf1fff8afe18f686db169b9c7988b1b5816053fbeed6d41ac8bd7d51eea56a3237beb313d971025812c489633596cc7c69e25f33aa709780fc720c12d1ee01f664973d727764b781f76aa7bc47b841692f4a65a75e2259587e3e53faf4b8c4a479cede8477578e437c1846bb966ecc04f07bc830a353fee58dc199a92789d4106955772898b40a011ad6453de47bb5061e0f4778c6e4c904e8296a15335fda0a30154b03914563f91722454afd63c61af39239f48edef05380cf1f563457b417a150a01ba83a25e32125170bdd5e766f0160ba8d9e6a82adf7c5804e675ffdd61030e963fa4cf378bf1738b4ecf49254430886feb3b570dd0509b8e45763ef885e16cc5f99027eba905766a428c5c0fd2ac8824c600551fc3e4e8fd774620627cf884f9ead48e24346c3add09e673079618306e2296f939deaebca2ed54068e9462287dc46544b527cde782768c7e9ec1caa148e466d8f37ca0fffcbae9dff06f0c3b1a53aff3c496411974a9785d15f60ebc42435857f74f8385942b2a87439f0017f58eaafa982fdbfd81eab3dff43d100b9c69b3ca8f9e5faffa6c1dba6328cb8d216c943a42e0621d2ff3cb65d8917dc56ec7e41f0bd0ac7917e3e6e05746aaa16ce2a2b74176f76a670be13d4067039aac517df3027713253e7b096ccc2d524a4048ce3bba0f8ee6df6563cb93653bbe68c0413c4c4ae12d7a9b06efae30015628bc20896213ffe99fe9a54ec2b45bd046cdb049d0ac344b6da11a281aa07f9ffb90db4808d7d400caf85b22c5911bb9d29877539683dd161b53ddbe90aff55d0e09071e287f226e06de7fa15bd3bfa37e1e21f3aabaf8f703780018ef4b4b36620de52e0471a6eeb22c5c4d8869d06a988c104412b9d213555a83f774112c4b50da784021d491f35c04cc9cbeafdcc1654ea46c68bb396b281e044789b1fb7879f933640c7c74a81b8a915cfc01e1cfad1c94314b06330cee81fd81d8251960a1dca97687703ffa02696a23f57200d8ad043916e10cb0408209ef4719bb7d96b5fd2abd154293cf7ceab386cac9af0259361931d6282fb741cbf8619e6791b612d37989d5aa65491ea965c3d1d67f07a5086bf34b289675ddb6631d0b9ed8e301053fae92bd750c1dbf4ffaa89d1b18c6dc3493fb1973b6ff601249a029e29554b0d34f335f42f607a4cfc5793a3f74244d87e2c84986817324f63f0a28214bfad6f77d600d278e190281b35dcda95f0cc8723b595350e25d7a62ed16e211c0906dee04f860047743b59a0393a40e9a829547994439212adf65b7471e7d0f89b2f25b6e5f523515fef2c36afa28156a71ddc1d1021a838a1c45f15e5c341f24946dafafd48d51f3ebb43d1f5054c35251127c0e6546d750c859cc22e2d449572657ae2c9fffeb440ec0334d190c8e2afcc73465be807f2534cdae08b280d3fb530b9bb69161aa7cb3d07b9a83a039d07439a95034cb40e6a13687291005536b5d992c4db89faa6257e374444da8a6df8d8e29a63d15ebf2b2b0f521ac0e90dda00c80b8479582e7f7abee9c69b1c22044a0adb83b467cd9dad2008f1dc3c62035b10f3d88102eece343882d5bdb1d735647a0d4702df5669caa389de3a4632dd2b526544cf1df9c64c722399127bb99e2c5b29f97e546abfe0ea8d80799279ccfc44795826dc6f8513652d70e514fdfeb76eff285d1c9a8cad15a372a8c8800b5733d1e8dab44559912b91eb6163a3b7106cb7135b3bdce6f95cd0997c41a9889da5777fd0461d92855698e8a59530fb04fe667eb3357c89e90c1a3a7518f2b27c31391d6a68a7c68291c29f363d39740fd2bb3382cba0fffcdfd036a0d18af6b8218dac4d8c52f49d1b4bfb213ab9b76c309d46ae3d7b686c4fbe0afb364e3036a01fcc4cc3072f89b9dcf12ee1ab98ca268f79d36b37821ba856c484ab50d87589c9d3e41bb14f8748f86a515db9b67891dd37eb3831a6609c9fdb209f6c525945f0bbb0d27ee5899b574f9da5c9f1ebe631277a86929bbde7dfd88240146bf8c66eb40f6ba7a3af5519fec7e716628916ee1b530f411dbd4f8f9045c5eec09d6f176621ab88ab412614b99d50db5b5ce73f83ef35c7bc6b74e669c391e802b4ac696a44b3f56db3f3e6987d13cd68cbd2353339751fb4c25d1d0e4ac9f6e20707a7306cea63a3629f97783660376be431037af189d378d28477e4bd97e3dacf8a41615dcf88076122be46339001ad5ecb090cf3bd5e8a4d73c621a18b8fa3b9f6aca1d096cd1a1786fe48febdad8d53fee01d4cda2625b135dfb169b099cbbb51f631e7259290f524779fef65c8912aafc6775ae4330ce121d3ca1971c03a4715a5755dcb273f7b292d5756c261d406b0060ece937b9e493c79fb0392304f1ecbe6ebfdbdd649a081804c9bb2f5596f9c829506aaf4baffed652bba776ab923a5a1a392c4b8592efd4462411b49bbb80d0fb3e67984777930536458b3fa0280c4c883dbd3dc4a85565aa52d9c65aaedeeabcff2112b024cdbb0afafe7933bc0fabce603054db888613d772c4f5eedd1da727796a434d57d79df1940ec86ddcb4362e18d886593d068491cb9cebf5dad91e574ad846886a0208c2c3f331dd695e45347f70070bf9ded6392a24f288f97d313dd00eec53c2b9577cfc64ee0c6ac7933c98b7fd621034db95d6dc7b9eb28b3f20ca8839e3cbe506d46d896e4fb6758426279dade66374b6367b324fce8307e6cdfa259482264f4e74c568014717e46b84170d6f1f23957fe09439e497f6a98769e3bc62a3f706cbb891477ae185c260602b77c70e2f7d7f553eea0d496bc7a72f5b37c276d5a94341d58c6013962f94dc88185230460a8749e95daa59bbd41f8315d31165bba3e99e08b0c55cdc75c2c3ad0d2f4dac0d62f03d8dbcb828535c45ebf222ac4789023add67fd4c1bb25a1f1fe231fe0c103b25446a403777d0ae7cbc0189182dcb09c62f9715e7f35d22d922190a8bdb8c3d90d4ce9f839aaa537b82006650a39cacfa2aaacc491b95a34562f1894d4feeaa6e94eab47ec55fe420fa1f1c958f1a8bb86355deb1c75653cf04049072f38b7f6d7e2563b5216fb19a01257995146a497590935adc9c7c9b19c7a8a8c19ca41c1f3b8459d1c150d8724c4b1de92a15c0ce8e79c1a292968b9e92bf7a2804db42a369a99be2021197ab36fe58b6eb12c0192b396de7487ea7d7b8af20d2b21219738c0035a7b75c7b4f7f920bf7c185b1f436238b7d8875793abd2331feb91a853c694a17ef0369a1288648b292bf55faf4eccb7de328fedeb0cfbe19fa8322a4371171f945b20d5a1f4e4b11296ac43192ca0a521b3cd8c6e3f8b22d745e72f748b55af22213d26b912f9baddc83fdbfa5ae686f16c085b7e19be5c44dfb972fa7ddca7fe658a1434384f9284837ebafa66455c7352fbae16c9ffc582fe43722ea07c9f403406bd638ad0cf33253666b2aea68b7f7e3182396c5c86339438fb1a0beba01f9b32121b7fef13986f17343a561384d2b3ed293dddbdf24fa784df646bb42b8a0958ed1c15cc6c3572277ea481d582be78e2215ea2e8401d6346f182cf187f40b0d9b28a00d3d385a24db223cae14da5c1118ef75155214956e10b585d83bbf8dfe47be838184eda2543a55feeef46d12f514f292f8ea91619874f248f4fe6fcfc46ac70fd1b22d2a57a943fa0e2f08ec7570a97b8c15176b172afd6593f1ebfe27f7e71dbc5bef3e4a36e67ff791d9c6d01fc354b91e2618e5abe75b1181faf61c0203d3512e445cf2bf19c4c3b577a6f50c621e0f5f1f34e3f4ba4fd2f8988e9bb69979e1a41b5b2e9af1bacce64280b75cb4de5580fc393d506199de8909845e175b17e8d6dbad6030196c14e3f8a27b4af3dc606feb754b2f72f68e28a4f132c787bab611d9bc6bac306002b6a9b0a51ed4f52b76f66a755866bbb6c2d1b847827c91609ab47d5528f6b349a2567e42b0fa729031c7d8bd4c4fd9b9e544dedab80f18ba8ed0e16de3abb0672ae9aea00e53966cbd5f4758e2b6483b8a5346246e3226949d5d4da46ac00613504965d6686230bc6a6142a7b9161f1c604a3f9246fc4431bcc292efcb384dce4981d3e0680980263c45ab7089d66b6f6e7aff5cd054cc737c7c5e0ac7e7070aac0ad23dd1e364dcd76eb80d68f50e07b79aebbf337d2c6f32d44f6eeba6d1fa55068222292c78676357a9f7496b4d7d3556052e5c9ac1fa725f1213c4cc18f3a0f6e8b26061d04615b03d09098f226e4b696026cf59e5897f01d31d21ee8d78da997e177cb450afa64205638fa45f5d8fbf790800dac42718ee121c792fc36e8495ae1e5450d2f086738c10ce4b46278ecc299cb1a8b73593fa30ae19761a8f1f7155edb01038a548ea5a326034fca5cc4fbe2ab21516f501b0269cac792f211c48ff56f2854f72034f18b30b462f70cf46d192ce70fdde7510973e958677b3e8323f44e87d9de5e8de4c5c10b167e7d69215306fc342e308fbb5adffee9b1bb0e4aadeeaae7309d0b0723b04767c73fdc08c8a0de96c1f9afc851a6aaed5e5be3746f9d902ad5d612ddc19ab52814dac51ae9187523abe889395006bdaf1336ad19561321ceda86f65955f5360692ba8802b3e9002db5fe561996846b4950cf276405f3496720873eac9228721cc2eaf76266a97237d9a913f0ae8004e7fd1a1bab89d924c55d9584f344be06175b49027734c7f11a98c071d222147b9f490626fe42438efe067bd27580aea5cbdb44680d3a007e219b802539a1c3ad305c42af509f2f80510672d1ada8d509c18549aa386ecbf96af937f912e26408c24fbac6c2bec544b399ce022cbff01a9bee39e4252d69f168ac789f810a33b26b1f1693c2b0789baf4480dc6dea7a42008205c3e308cf924a029c5fd2786eebc85bd9835fed7138490f9b51f260e5eb14adc3bce83fc27ad673bf08ba2f70445bf375ce09110030b5675b5def656c67da8f05f6a699b7370ef88a2d0d9576368929f4372cd9b54de9a23e8608db376b6267d8d59323cc7477e2d6f3f54abf63012ea0b25bc8f02273142257362eab8dbb256c4d74a715912a5adf8377e6ccb9a5eb57bb3c16be4848554e04dab8a179a2dbc6bb505354645deef777870acb9159f8fface5a9d87e0bf53ea6ad627f057f384532356ac820b2b479483bd806820bef6ae3639d4b08f61ce5efb253cf700813d4d0bb6ea35e2b7d951c8b1565148884ce3e1500117bfe88cbc384926634e595b3592fc7084b4c1065f7c6542d1b2753c9263d71a016c5e7a6747df8c8c805c234fb5b124bfa4f1b8e94a2202477fb163be865c2afe0cd608657024513e6fa7079d77670ffab7b738f4aff23fd0992544ab1859cb41055d59d2aa802dca3b35a0f1b8b000671464d981a5aa7c5f601d3dcc1fb167f96373e4e6ff89fae91665ed770d55ec6741e8b41044625021a21e143e133de501eac4d58ae86356f8583e8f31b4099b6c02b5610ae1d6545af29bfe25d49d54a5a3a40e3ac9b1bee9a6d205b090b3e95c6d5be93df781cec617730fcf2e2d87baf4440e74a5f3af249c69f192c77f14990cb41b31a6a243891981d8992e8fbc6f3a3312a4710cd0f7799ebe8b99b40401a2b52e2905b06c785defcbfcfb9426a0fc541f3e7a97d65baea7cbe1e694ba0a6bdd34611ea9f076adf191fc48f41aa0ad8f0cb4ef02185a13d7619bd6b148d4c7820a91f15e160b3bc6beeb33dfead36f0c4ef055aa21774eb345097f98ac562b83e9ba27154aab80945cc61ad3b4a813b318fd7e0d5d0e82678f2dc3115df6d2c6dcea23906266b28c723643246319a80b0d267e9dabb387761c56efd6fc3d3f627ffd3322c29e9ec146c823da8ea2c258b4a25789331e7a3a56d8356bc1032ce3b51f5f328b20e2bec7768582284866868dd56fd675476071fb7404f150f19587bfbcf8d5f7e240623670c95408e816ac08971a8d0be94718818b1c72fb59b846d212ce2f2fb52d17a5a1f9bb07caf4e716e150f1e13d96f469ee3052b3606a448d92e48fa8bb27054fed3862c20373f04efcd439acd2367cc48df8f174147b82bf1473b15eae2b22073753a27aa06b704762d7bdb81055c57f37ae93d9c879902224a3b47ab9991e2a41ccc7c8c8cdeeaa8bb4ce87d1234f6d3b4211e75f52497c9aa667e8877e556eb2d694f30c30aabb2c05f04c8a340e43bee84cd3fabb9311d31b120ad4ad508606f21050baaa1512fad4f28a5514345b5201b7ffc8d2719a0f6d94ccf0df9544a845755f970e71d2f1bc89bac1d5b32bdea7ec99ac982baec44ed7993d7e40af215fab57c49d05607d52d891279182294ccea85198b0356dc47a784234e3ce71bd445e1999d378858b2dfb530ef6db2a2daa632f93f84b579370a23271b8c1d927aa9aa6e1bf88aef6cf59b1fd43556a92958c2144a060c47fb570000378cc65d955902fe6a66a4fa6a39b6de3ebf5e984fdd876750ee648cd36d9e68a99af745a4b38e09176daf1bdb77760b12f9f6eb00360ea99696b345d9afa874218887b9e1b8bdffd9f65882ab366e719ec80771a6a816051e44256cb6637fb45404cd517f2110fdf3ae73b81259ab98a788455a1ac3e049c9db94651a665e9f9bc742f255f79f0c4f4c37fa38cc46c050657d6be9812a1288996ca2597ef033098c8e825241186527ef19eac01261119e858f64c577f3df5e66b9ad707b494449e8fff826b0865c6b2bc78829eaa310b688c50ea7f81da4e92f145e7b420026f1a874cc636aafdfb37317eb73972b7120b9a25ebd80d6a152bb497c77ef8bd4bde6de65522c6a9f2f5e25e5f6de796672f8d46661f562fcace138cd095d2d0ac219f67193189dcff304b38a8ff57b6497cca8ae17991baeda4b30ebe6cd0d9f1e012ea618ee3321e80484a0619fff8e579cee50d4c2079c72967ac191187c379ae44ed0ee21a45b548a31d7c412ceeef79c4d03fb1f86899fa3f27f752fcf73c64d5b12444b8f3bd2be0d31af8d232999d2663d5db7c5956332c813dcce15adb5709eb84b9b04346483e390aa944d2a617f2c131b79d2db66d8ddde1c35e9f7d9e0b49246ee2844ce45aabe1503760393b4e201195e5a642380e51ea2fc08d7c88e6c31376749180088e41c56509f6acc97b1e28d5c81146280b549f199e26118547d0d4490648e6ac62a66ddea2334ec775331432c7d8c567ea3bda0349743488e4a0b90ee759033ff0ef837edb9410dd023c8bb5bae5e60693260be9728bb9083396c8c7f530ec7ccc64e0acc4c4cf92328cc84e6086a8d8e7f177aae92f6915db164945055e6fb514a47f91801f4082a7fe1d4d0088c825848247846652a67472302abc65480e8856618596b9d021e2d1bedd62cdfeda6216ba305b5e068a9a37e03c644daae84a4ff65f97d3183fb2f37c4b5a4f6a4bf33b02a177b4836118010979f110b03225d8d3393b01b161af03d61170271ddc7854553ceb2682d420490ffaa2551cdb768658f75d19446c974777c691d1f7e2df989e323ccd0bfc1b3e682a5ad937cfbeb714ff26d6183a4404f13211201d80a57a4ecce36c02e31f143280d755783d25ef50c8845cdb151d48ad90140c64f19c30d9051d1ae83b9d16a605caf559af0053ce5ad36f5c8318d92a011a3efcfc6ebb4b316d5e53b4856255d3919031aaa962d44efa75251578b184b7b1582b71795bd88607e2ca4599940c98824fb14ceb0fd23dc562e63e352df439f8e77ea9b5b57aef3a66037f34ead395d2fc3920c35ece40a64e759d7cb09854456e468f1f571ebefc9d84a601f14f44c04ca88789692be6f7eba366606a755a5f9b225cdcff4be4eb146e12252937770bb3861644448907571c677a3c9892c292d3c721756b40130b3226ecde99b9c179f1195d91ff818f1971741c1c10578e162b6fd71b7d76b9faf04bf6e071386a8014efe0d4ec0141b87ecbed62009ba027555f42387aa95273fe753a25caa47a50baf3edca67c5692c26d44553e6c6bc43ceeb20ed571c8744527af6822245e62a571384671ffc723d0730d4cb84a932de8dababbf52ef116fb49999753533afa387d7934cbc4f98e16a6541b01344897285524a99f101f78967a1dcddff7c6de29e6cae9e5983ca4e59188bbacfee551a38d96d0eabc8ae7d51880372246b7019069e118befaabca1b693a6dba606eb4e49e0dd8d7d28ddbd236594a39a808fe1539339134994fed819e23756a5df0dc187aa805e3ed453cc84e79060bc4ecabd268ce4e77181b496a18b966ef84a18e501f9fc39cea83456e3318e37ca9873251ea53d9731e58c4fa3ab9220a8d187cf0b650ac0dd2c6190d3cbbd1e41b95aff20f91487311aa9d32b04a3dac5fa9f2d4b10cf40c851edeb72019b58071b5cfd3a6d0d8499d16e6a58822b31bccdc4e3c09323819a2006b064f2b81ef0296ea54729f765ad7475cc7c485d2c53c917bd9bd3ee8f8708e7a0877ba0fd9cee3813550a8c0b48c200a2660cd85f546c2f460cfbace6fe305e4c695d0b4996a49ad6713e9b8fdb1a5c0a3fc4159c0f66c160bb6213e67d3d16ae72e403b1d154d2f3858cb479c2e9388c04977ecce2f6302b33f9ff4e023b3e25f1508b6f5506a190def48138cd4627bd513757285cfdd4b1f17d78ba1fcf76d1732e2db560bb92569d9843368c6a9f9f0aacc7c58a4ac26fa4b8965070b6f4ae683a4dc6b39784a850f6e0b71c124343ef5066bb5bc7f9d3506336df576ade056225773f3c80775d3a55630e9ea0fdc0051eb58a36fedea66715764781d3df32ed775ca313d67d1515128f23c353eb4802bdd80ad8d57e42374cd6f936e24f0ed50e54f15c2f9fdb11652be2fb2bf47c3b0069e10d2adffe2c1f0a6a8f0c1cf9b316d43400c1f7b75384b722b72c4abc286109ff8c1800cb9d73864921ac82cecc490581a5557c9ea4640c8d0c374f5e01b6b5d8eec5abd496a5cd39ff8c2b76b887d006d025964784dd3deec21c41093c5b8c9ed3118d75da11d11c987dbd28b18a727a300962fbb68ef08ade948d6ef2975520de19f194bd2db17d232e76b3ca514833100418c7397f8bdd167df469e092c8c223db0fe81fa72370a8f6b5417cb5f551f7e8cbb796fe45b6a89709c3c117d72d126f6b039969f34663c1a2eec573d0fd095c52cc703ec4318dd35438cd02b58f1c78db6ec562995c373158e253ed1534035e503b677aa75a3bcf93b2e39dbe213e867a78d384ebab0e987365d18c40321a74680313ed1a6395b01512c8e012e67fbe10f84fa5fc8efee9efca822d535cf74d14080cf7d70616f17bb3664349437992467934b3335bd4dca62b41a1ac0498252420255ca8b48a67a0a1c52c4ced95e0a9751547cd08224c2742d240affa8f1b6b6c7cd8dd206e1573a17c57caca31c60ad755af4ce6425360518e81f91d33f81bf26bbf04eb9f9cce8435094caa564b9bad5d8812fd69dc61f0d6d4e4b814442678d84d4fc75cf8649118bd6489db2ea79b7e590902e22d06d0308b05b93a9c1f3e4c1ee2731fef25974fee628164ce1b2fd91132d765f3a0758f4247aa559297bca7da561a5498b2ef6602b7cc2f9d7c77202f0ce62361a05b20a4edabfc3ab94d9297870e8d5595ea77e8c0d9752f2f35ad2984425e734d5b5e781a92c65a25ae6cc1c9b9937719e52c16e4ce0a43fa5886a6d23a53c0919e3ada2232087fea2de4b3df6e48fa3152f7c49f0a19ab6ca231ef555dc3f569982c299d0569d6d0a959e674184bb2a02e0d58af95a970484dec8c42e314a6976163a7610956256f409e74028d4410bbe2db7a4bf4dc25f14000987da933d9c084917dfb0863df8d94408e5cd0805cf8086fdfe424e13ed7586c5e220db74ac61ad9cd070d606f64506ac66b4913531c669c0b437f63bc1207392202e8ce0cedfb00015f2b1d3b1b21ee71091c9103fa4910934f6f832d255f52acf19fd9a0c8b3bf2de1021390f6c113a25b94ee188660c7add8ed8b00dce7bbf39c4be005b333de2d9a133d931234d4b7f0778d8d24d002bb5215c488464d965ce1fa36c48f393b86ac881218a0b6b5b482cf62c748d5ad70e671118d15937996d8c72908e6c9c21e129e75095a600da95cb4dfaa529929d2305ff8089b488951a23abbb8570d7cb256ca62f8132be4f93c43b5091914a68fd57c57bb958f75d1fc6a8a3b3633faeceb4fa618ed8f92dfaed35c37922bd2d016b11c8e3b645e1223af617c1e717cfa527daa31031c1f61cf616e16e179740dbe67dc0fa78f3557b0c0a8f96e540d1ad02a3642921e6f5d18af9393761bfadbf58e3c6ad360e4323c820412aef79158346de69c901e24f6afa362131785e7af7a6c8cb620ac3fe9526f246052fc9be5150d2a2469f3b2c1c2737e0cc2076d4de4771f2264d9eb206af11ff846b626528c7256ca19b85f75a2b5264d3145588a008ac1468bc9b3af25f7c828068f229cf9536645eefdfbdea6d96acefa42eade14b9281aa9103b570eaf813d61c34174c1b856e607a3442dc640a2ca762888783e1f312fed611ba5800448f0e2eac991b09281bdde1ecd7070ad3f4f7e90da215f3d5f4f97ef6196e583a43a6acbcff99d1ae175e9d78c8f30abea075f489b51c2fb7e0555e0975793e29e834b46a94e18bb9b71c322a309f03478386cd57cbbbd4d9849005de3c","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
