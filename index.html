<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"d1ea870fcc999d81f4f8eaef283a2461315341d82be474b4a0b2f96ba03afe323d6d6561498f803cb40412f2b7da12e0c37e4683828186a616479b7f08d628bcd80b4da98116b3aca6dc8705fc54021eb6d4a57323942c5595ebe3e0fe96ed933b928e2d2613e3cec70147b5ef56ce03d3f07f77487877458dca30c355bc00bb5fac863efb51be6626737fbcf0a0ad75f87577a4cb55ab0c3d3735b9ed522e537b771ffd686dad1c7df196ef8fa82f118517109ccf6323a1412c81619cf71946aec88142f08976072f0693731ad5cbde6aeaedcc7c68eac442a23ec2d84cd2a7ce874562ed471a7a6d8ad4b616752e25c092cc87dab561d250b8acb5d288a14772046c4c6f0cfdc06473aa328563f793577474217ef8cbb4043c8656cfa628327a591e795394fde291a37050c7e810777d634402d44a87780e0a1f735c107f0ec10b499569fa75f32e0f04b90b1963131c3a26e003ada8854d0f707408e8e052e9cd50b691159d2589da112c163e275ee3848e9c6996625d55107884a19a33416bb7d70e7bbbafe0d842a2ca1577876a5df7c95b0dfb67a7d641e46458bb03c1f5710bad6153199fbdd4c37fbd4fc4e4143e3387ceb435734c3c8862244b6cf94d711e605fe95c77a5fa899a9e2d665d685c2182003c1fe0010f6a5771a9561a4379ef16f67b0874de269692ee9e53153805d8bc798790a830348b707ac3b08806e973c8fa6cfa32c00aecb460dde063bd94c83589a6806fa6f8ba9762d3606375cd995d1703500af65f764ed991367d4f4635f6bfe37b22fa64da7ff53c2dc6cf6885aad1e681fa452afa646b3398223584a8694d44f6b56dc63a245b8e8d6942d3fbb7091e8ee55d0c927302e444da1936fbb879a8853de27afa36fe32514d19a9b9e173d76f63770effd69398c8654125788a13925aae6250b92f594f1a0e5549e38f6e60455bac7808d2d3be99c9fabb0ba0fd23fe03fbf62ef9793521ba4d1cafa3bdd8c8bbdea59e3e6ea6021403b8fd3e9fe0e2294b7be229f7a5027fd89085b9bf9fec73b6038df2c379043eeb305875442effa6e49cf110080dbc7527245ab45bc657742868585f022fd350f74330d23e66b5e6ec17313a10110e3ed3e3316740dfc968a1f40ad3b48d1f97a77dfae6ff415afedaba725d00b49548e9a79f703536bc72d8d5f02e3cd114c933ae183ffca43ab31cb1e2832c78c1b019b1abed1534e950e05d8217df86008e1d82d8a11ea9b6679b4f6fa37cae24a8b0609acc3ceec797d3d402a1114197fccb71bae6f4263bea302480340d7f31d9b67dc5b63e5ed3df7c6451507ea9214ffd0d523957a789bee9ad402f8d24390ae0ae8fd262f217830d3b90a75ebf7d251e3ca9bf668f7e9838ac2837dbefd43d9fc468c13814dc6c2e3c9a5cb55b79f60fd7460d3f532eecbcd160d6f9dfd881bcb8053c585cdee3f44c2ba02a1e7e4655d50269116f2aa9e3fc14dcad56b0c74b270985f76191b1358851277c5472b4ee0ad5adbc1e6f40a83f6fef5097bb3bef974b63552072d0e312e7934434e282e4b21f3351e52e71992fddf4da5117df65c6d019783cc36a122aead538485d07bb7f3e9e513d00680411024b9954015c758e06170858add83782cc481c05b32d6b00d27a4c0f422e8b5a264a5437a5392caa390c24832564369f4286c0c0847ae0ce732e70de8d692f07676a8128f8ee5b08a7b14c4516e538858227740670ecb74f9cd052320e5bfc3028d178370ac78a74362c020639cba016ac38866f352dea430c6dba0af5823eeedfc988fb41d0dab7e196cdf07aa0e8795e52f446c4819834806ed8d42387a6d3ed1f9226abd8310c9040b042f0f8ea181cc2108cdbd0fe7eea10ecf8c144ac649d303310e1546b1315b684bf1d13f7efcf24d34a2e269db468ce4afdbfc38bc9247134e696245ad35c79ace4b4b0d5b9b3b2d576dff21a28e2bb92c2cb06a9f752f248a0434dd2e621d560efc82173c13233b0d535b426dbcbbdba7d4078fbb824b830512b2460fb97507ff44103d3d12be1b80ecd282381d75abfe0cd1af32f4f17af108007d4b3225b74d70dc157766ad6f770327192f5d9057843dfdbfe68247da7b3648e1cadea61bd2348c7baea25ebed3510a826f54a56318fb2088809efe42eba58eed73b6bfc88fb7ef1873aa4c8873e3d796c4e00a202ace970dc1ea55d930789ea7d989a196ecb7ea35220fb8ce0d5fb661f375be44154b35cca09283d6eda60d65d1c0d6ea1b592cee785621899d286040b18d9d61cab080b38a46d0a13cf0ff6c15600ab7af5dacabe56448e332752bb3d00611ce4443a35e9674c19af59530840bdf10dfe47f39c7cb576ff74d40c067022b19849a553f482901aabefc8e77d79287d4c3f45fafa35fcf5c086b015cbea6dde5a2872db406a71c21c04bb312b0b9ff6baa863b0522d613031484fbcbdaeb7a809fdfb5d8184e88e8735633e9d7ecc1b2c7b4e98592cc2515b3fb1d6a70d9cbfe11b56381de5c6ae381caa49db4d1e388da9dccffe3941bcbfe0e26f8c1a46ac6e0a994b9643f4065c605ec79632059593e4b967fb241e4637d557c16af2e654322bd4e41d60696d1b51dc298e9923032bd4753df76a7bf015ebb41f17c66deb980a99d403a321e6f906aa1b3aead8171a20cf7bee461d8c2852fc0caef01b52614b3b0bf72bed3ed0f88fd45f7bc891b2bcafa6878d18e85fbe86462f1d97848a79831acb857556de557621d86961f6613510863b0efc8b675858cf30d9a5bcad15ef425e5fdb97b95a5e0e849fdc48d5093b3eb0d49748f255419bc43a3d5056578a5f193204bfeba4f3688264a2b33f7f468ed37d67284fd5de1c8b9089238e30145a93c7223b7a0fc9fa193e1718746a0239596868317a143fa4eb34904620ad80f8fa4244df30be4179c248cd853cbb4f7828740997f81aeea8eeb27f1b454a4332c47a64cee904d7b546645ba967ae3d7a699062c2e52642ee9c5c7293c15acd789703a72000c4fd80098a2b6306be96effc6fc8329a690be817302779556ed157552c7fc8cb5b61243bac49f0311205ecb5beb8df3298ead3d1b2e1c1c0f5405b26a98c9ec7a9497872e0af6b621da17827eee541da70574a72a566bd817ee95c80d2a78ed6d89edf4ffab907da58651cff3a70ad0efa815a25916a6536bca71cc8a5474493d4e55c2c0dde2250904506e4a97eb6272067a76c645f554e6da77f7b720063b5945b072d010fbc87489734e01685508ad179f9615e5be453c652a19b1e8c7cfe66db34e8bc5cd9a2e2b62d6639f5a1d2bd96a1c7e596774e400ff3b32b0bbd6b91ca92be24bb6b68633250e43a4ad43f288e7c9dc9c912dc661dfa5f62d2310bf9e74d971f6a65efd2edb9f7307710b6031c8188a0875ea6db3b93c57ef3fb40b73fbbe6a0e69f2a413ba302957c622501b9d03b335242531f77a301256a1b8d35531796483269492623e79ba0beee0dc3955887dfae1aaa92ed2faf5eecc70a684e19d62ac094291075a5eec0db69627541374831e4728fe9d39e51dee9e57ead7ba1af553a7540d3cd2d97c9f7f60d93f350d34536c3478e6943d46d90ad5973d762c9423bcda0cf627a09583e649f7db6c0c75364a09c105603c3e11c4f50dd09e0b0e746e3993f2189a9a4bd1412bab5e0c863bb21b7207152f5a061088911f0b88c72d84e1768152b909cc6f20a7a061392e5541f89923ce37b7d07d8e6f14e790d77f81acb704b4379bbf0dbe75eec6bf5107ef9d6803b66ac91e16bf2d216c6d94692cf1b9ae2f8bf729c77e0c3c2201acdb0e83c6fea9b4bc6d1b774861c69a4b2b6752109c0f4240c2d3d4f4a1f182d8c857f76dc61973b5b0c53de646ac7918896beb04ff7e6eb0de6330afa7674c0fd88175015bcef88a88082a203d4943fe500638430d947b95dd1d4fdea4a9509b604d98c4e3414f86a111cac1fe36d2cc2cfc4cb9be6445523e7250c2b6d39566d5461b03c98b22321efc115ad2e77c99c6d62b473051d7a5a456bb91a3391a3223b1b5810e1066cff450a62c8cf91cdbd6c3c45784e41bfb0f1517bf1321fb9211d0bf4d26f3bb3b198c24388788e0074e36fa6a50d95ee3a79c3a8819bdc1860aa47b817ea5a89820a9b08488dfa079699ad1f509660c46764c3c8ed774189dd7c84f176ff716caa24fa8ac33bba1cef1147c3cbef11632ea0198b839e472379f3934a5a8225463bdb5f8c0ddeafc034aa24779b4d5faca28a5ae4858221f197f57a4c1b1cf4d67857f91d8becda5a9bc1fe6ec191936791b6749c546078bd960d59b713fcbccfb6906de2adb623472b7d46223f335167b19640896f49f90b6115697d854ca517df086ddf8d169c9a22cbbff90b3854ad7d95e2c5666355131cb00a9ef98382ee1d20276db287434d9f4df7de843e125021523201554ed43c2c349b68ff1afb9732eb48024253b8d29fd2adf19818a457bbf98d77b6d67b5757b361b032676840362bb9d1ec706315b52dfc46eaab07be9bcbb33236a8be0b7b32e936ae104f00fbccea03fb577593d7b514ceb1e323f30af73664c71aef9231fe1c524c5ea3a69ffea7905c3011a9324b7fccef049a2da1ee31d4895539749544e3efc67f091f89327e1691fb26b95338fc2c2c205ca2744ade8c9fa7fca9cfb7f54cb7d194b62e036a76aa0c23efeda167085c8b3c67c55da7caca0ff42b581102a251e49590d76f8980bf8b2beb615f5c9ac5d4b7de75e6264b1f8c867f92502f909c773b0e0fb358ef3bdcd06c1f09f1a9e494211b068931c1189980e37523b56b45179921959b018dfcb7b39425e3f84a10feeef654fe5e34e1b18e5ec51569062db8a71e23fa3981a2c19d9daf5663d9aa9e3c65e352eadf17d99cad7f846f5e33ea47b43b5c2df2e99ad456bd7a4637021bb6dc5894c3d97da26240f189a23370328ab577d03612f58a0d222a8598eac2b193c3cb3ae2fc630c090cf0c2684b52c4fe1566f032534d83ac65fb6141cb5669d59bfdd05e8274c96c3d3560d3b051b910369a4644bee44f95afd52b8733243dc4c7981945207ffc788b6816571547ea8dae10ddd1e601b64967a5b839fe1382161e2b81b117a339c4649f5f9c5a1931672a8341481388d0131adc473fa91183257907d52d8cc94990b8f0a3c3a3819f04c98def11339cf9db0e38f7d29bb9ddeb0ba66b4e3bb217cb4f8f44287accad3ba98c50df66f7717780c67b1cbd10b8a766e1a6ef4372d1979bc7378b0554131d2ef177f85cfafb931f1dabddad8cd7a20a373f5d933d5fda17188d0ae6933334eece48eefd522fd3837f10664bd16da3b2ec67ee7dce06af74ec19c5d66234aefc0da2fa289d621c2dc593af795a7844ff916865316e705630b3dfea2f76b308c07ae3bddfb694a26af63325846f08e871e50dcb3c246502c0addff3bcb39170824dbcc0eef16ea5ff503cd15ca6857f06eabab8c22514d34a2e2802fcaca62b61ef286c0f2dd729d5a0ce0dc0605b4a47608fbb24454fab7d5cc7ad0790f82ec551ce51440fd18a5b06a16c484340531a40d1a89c6472b8366b61ad799f3f5171e891c6e5afc09918a1bfa8c562c1bde4b728baa6d5df70b533b2e9e59ab4f815b1667c6076d25245c1c3350aeaecb029af97ada3514af685ca62201f64853d6ffe3f7238258ec21a64727b4b47290a24befded5aea7c9b20b4da158e3603c2c25a33a114b3d58e54fffff6d13f23b3cb0e013fa180b9bbebd2320278adee2d4aec993b8d3c57071454ac8660dcec3cd5b03079b4cee2551f233644dd904763c9e0d3cb5fec4c30fd784e7d80e8e0927ad5ab1b76a12851f3f2a3464eb5a245c7ed6aa2cf55d5f541157bd7be0d6f9482a9cd943bff487f087c383e731a505b7d6226c5fbacbe218bd582fcb0befed5ce2f60a895c16fe5c6008f6a75a21e61de907c1de267aa96d1812e24ba7bf23bd1d77a1c1d4c8382f9421737933b18f695d14e687c818f65e44694000ad3c75a237d2ba8b717a42fe8394c01e51946dd0f5674c2cf5f1d907f446438ad81908ddf39594b9f8fcbc2023d4466118890623bdf239b874b7ced28692b4a8bc4991dad9bbb1ea8eb5080d6dff5b2f8f9da7dc375ace6fc9930538d5effb655c693834610d1c3ad254d7cc16ffabfa3ec4cb1c1957b6a8f9f2cdc5dfddb37e9ffe78a1a8c0c6f29a36c4fa8aeb97a1cc958a8387e405b1aa45a2fc9a57f327f1fe8b1c7b95257a0e574eb7e802419ffc6b181b4b386a1b64062918d0774c4118053e80c86c4e552733fc5f5833154906e9a6a98f0fb0ed2be02546f5a1a5515cdc5f98dd91c006c7afc75c31b41fbdd832512e39f6cf6896eaaf9a2ef5e1b3af6c54137b5ea56030eaaf1fa839dea8388e12325151b10f8901d836a8e891810d556a8dee94d15ae1a8fdf0bc8bb1ecca8a13d962f3d75a33a0a2713557a6bcbcaa0e4a141ff40dd749a48dd4b5eb0f1b743638043a508abc44ab62ab1aa13d5a64920dfa3c497c8f6b25c3d3acf3dc38dbc6451c5cf83e5bad0c67c73d6e66ced2e60f261c92388a7ae8ea24ec61cd164bfc9b9698673068cc31e956f8007400bb8ba480f49471675c5d1222a5524f2efebc9548513df311e837068bf36feb2acd2e87a76275aeb65f808499ecf12498d541822bc2d9b44cd1c1b3de9c3e3b92b5aff2cab4f6f413d7b11b3edb0ba2a32c71dd62cbfee8a37cc9666b28eab01e5adcdfacede15d569edd68fd45caf987c9a9eaaabfa48200770184f617dae8122f436e4376349bec4c7d7592a081f00215a510e4df7fb6febf32d3f173fb8a5b2b880bb96c799b941db366e2fc296caacb3c57c8c80ccc81eceace393530e53381e8333def86cc0a3ddbe886eb96dcc8308e1eda9b0a8b2ce799caf16378e160cebbc1e8b4e150cf82c702340aaf50ae6578009a496cc4b8e0a7f07c09a1427b3bc5c6865fd284d8086ea64367c99b0b452ea3f96f473c005c650900888605eb536a6b9dbf7b341882477280176969f9598787cc061b75dd01ee2c5f2139133bbcfac3669064c52a5c56cf56599fdb9e737c64885ec6cf4296579b9a0ce69af4d62d2892c9159fda60a3fee234b49da677d7d62c0e14e72eaec2a58402e6910bf7631a7f4c6c15765addacba713261863a18b249d4d66f9ab6bd0b2a8ad78a54feb9e505b91cba801f477c3e76edfaa09f2f2b5adf1af292f3a748e71d81e13d37ae295203d53a85d2cf588890d704fc5af6b92e50646a82606e651e0ab9fcb729ac9678aeff79f2b8d6ab84ba109c7db9063fe60d86e6016a2d06062cb2b322fc582be36f7e0335726cbc2b2260cb8628ecaf7deb5ea6c0397386bd8a0e267f81c1e0214eace758a922568e16297730b0367baca9a67d5460f9373773f51be6d4b10fcdb566a7a38bb03b4a8f2132bf5fcd3a54c70dc4c096dd31a3b4f4744edeadc8faa6ec85c5adb64ac84d1baf278f3b3e623670cf21e2f52ebf96143c3a787c7d5ade2979d7e4c36b5e944354046b8acc857c2f6bbb1455a8548fc1f7650f57b36a96050d441b93014217af15666bbbdee51087d71b8dd914731c0a40d4f0c0e0d92b0004a3366da3defd9cf22893cb69afff5b063955ae5a5475e2a98a65726409c00698a7f23d9909576d9a2b3cd586b55c55cf622a951c49c0bcc4ea49ca5f0a1b2b7efb30d9bb2b2233f9498b2bd0f9d534aea80d4870c7506f57b2e32eb4e7056f72007fa05d4a34acdf17ea95070bde883d2b3b3ba8c61b48aa5039382519ef0e6d13db3193cae8eb92c78c720cca6a713229e99bb224f5b10712566b2b0990207708660e50e7467e76d9fed2d6b070e0d679f88cc7ccec65bed86415ff7c33688d46d0fd44273a9c18eeb2801070e6e7a557da5518708096d1dd34bac4080c92b8db5e54a497dba51f161ff4174a74ed78fb8c6592f9c2251febacd95029f9216590155a5770dcc2377d744875f5ea064b1f10b726bc060063ec4e0bb5536300699857895d9fa8d31947ce84ef91b53b7e0f644fcdd53e610dcf85b97106189e175ad072d01fba070ad5ace384acc5f006a52d0061149fbe339a18b8cd0c5916c06cd5c2bb4b3e74b33b4c8caf56bd37e0712badf7b078e0be1514af3d4b0c02c108fcbc9af05a97acb6f81a1005db7259267539c9b62feab349a00684c4c5ae1d2489ad89c9e127e44e04735daab718ce3c88f5a49da3241df569d8ed98c9f34bced5453609be0f847dbe8cdfa2aafff854b5e24a0f447f8266c66a2ad96885a14f2abb784cf7995f0892c70779ce9cc3162e0da75c11ecaf00b0aab01930eeef99c3bbe6930bfc916750865a22bce7d7160b75dcb279ecc39c0c042baf107b3e4bdcbbb9b2c1c4aeacc94914ff86810f3de02c02b1a73e5a9d29495a9b4d53f391b6cd4fc97b4e3d9e238989ed354c4fd14f510ee495c92835f5642c67560a7c859e1761adf5efe415d0e1c509d443e7914d90a293cf748e6c95f9abe30768465aa60799f94b31911de3b2ecaf571cd49b3f7c6fea4bb3e8201025456bfb3616503577c2cc54cc0d4813544e31a4cb4b02b2af7c97087cbd09877f75e0dab267166fddd945e99f9ec6117718743478b0c7a830772091ef15a300a4f31d525e77581c4c7da2bf01907997699d4563b1999153b42ccdcc0f88a1aad3ebd1956389f97ec514ec0cf881162abe62cbf2d7f877f74842e0a0a8e992a35b8820f82d89a7f2b2418c15d73e8e3215bdfeccd81ac2f14fbcd81aa787bb1dc4747fc00ad5275c09abcd6fa5826af1876b699d62ff41da22d5eb77e2bea72aa2a02943833216f7a3155341caa9d6ee5e5949d4286061277da1c6a36852a4ca43fcf150c5efba9f7e9d8a18fc0bacd23d7a804f5782fdb7d3c4fcb888ad88b74cafe7333e0d0e678dc436fa53e4cc49966373185c680acf82ef458b3e7db0b3fab752e40a6a70427a84feef682d0365b525d16985d240031acd9524e54028db644eb949dfba93b7529daccb3f2c266842afe8b9cafa850f414465f886239ef6d0e96ddaef4119f12da484c1f28f8271e7e044e81bd9cbd23fddea76d7fa254ee2ccc596430855cd689368bb0a1f5d0d30c66e9d27831b7f8b360887dfa5bf6553da6e144353e84ab373b89b45bfb6f55345c22cba097985187ec09db695cbee7e5e01c878331e40f02907c18551433d117f47a287dd6fa507ad0ead7b2f8b91e0465b52fb4234a6e2d22ab3500adfc175db9b08da4cd49b5368fb19c62a306680465806bb9ec841e381df5c8f782068426573009eeb8b889d62c02400ade4186b8f6d7401d5dd06e329fe308224b8336a12ba3b1e5f80d83482ae273d569677d756e7c55f24317790d3f4777b8aba7a9c3f464581649be7080125ef2d59a3c451bf117feacc729f0faaf8960a068a3b1db026a12c52877f8799557873a48f77b6bf87be1031c457ec214cdebf70c3a7ec59a5dcb07fd8cd46f5b92e5c52c22ab9cab5faf54457d737ea4e0ed2482354aa525430fc3f23450decf65b136e102ac75822bfa4eb7b87fb194458e268dd38b2f5be20fb3428540c09f3e8790ac76433e48aa6bcb2ed1a6b433fc5840bffbd46615d60122432f00a73c18b83173bc4bb2a8907812f977a30351891971941b8605151c15da3609bce8d8fef0c4239e2d5a3e20d5769400698c8c4d7dbf6c08eaddd6776f0a1b993c93b67a2c945f239cbce847e4745f6c2b2f606c5cc338a388631763bbdcb48aa66af6758dbcd38776c3ff625034af34ae0c18f130a9ff0c5456519b9c64d616f050f9f35de7f878cb852763bfe665690b815dc965bdf11aed5ecdc6115e2049af50f77dd4215883ddd79434fb834c45316aa924752518ce9ae85f252c3d13284fb2cc995b4a6c06418476d98546c5e126b4fbddee591621d6d7007bbf2d879b002eac7693c021a8269b5b943e467b4229c4f6be07ed437d6a15af0180f2e549fb8aed75b3f190e3d72f463d1b160cdc404223e9f53b287b7a6b553b43b86c3a9cc98562b31c775fc44b3a34f2edca30ffd530fae42ec4b9b43cc324180512f96e7fd5d36168a00a55a65e7cfbf0150f83165c07af945e055eef2462a1a5bf9dd7e3117f16c3ccf77ee87167cb9cfd22aaed9796bf9d0749e2bf6548b5b4ed9de99475f9d969b6ee2ff070fe5ac5ca41e563a0ad6e16e4d81ea121f4cbb2eac9f3c80883d111c37102a972292e60a32fde13521201560f2c61ba4b463df76f1cebb3d2172ff5a8fe95303bbdc3fe3014ad29e461b135383b4a41c3884b410dcb52213a1a74c1cfc056c9bf06854d0fd1ee5494a261767b80b38bd87ff1787b71c44c87e700ebf6686ec714057b81c1f1a00d63aeb226f23b9be9d059c88b8d4b413055da039b7558769f43fe5a972df44cfab9d13ef0e5d8b8027f72ed015602c0d563d2fd2fa78715f84c06c733aaa34939ae913bb585b5a9300240631e4fabcf0a9d97c34e053e0dfb88917158b551e31f1c8ecbadf44a894877dd7f1631e16a214bfb34816a86b32de6e2bbe97474f581a429afcfd0b111ed9095fc1aa73ade4a77bc6e731153152a5a4c781cda9151368e00fd9c1a71c6b9f55f3c5b05162197c5de60064ab2b8189c2b280c333ed19bc8c53599c984a710e1d6569aadc885a7687b97c8c96974f476a2a0229625b3c1fcf35a189a4e21035b2af50cedc8576e637e96c4125a42a22c12294958043aea6d99391fd7d28e7284b4a7b68a524ac79236ea08bddcaf52ff259dd5d61ab603034529096ce673b92777551c926f77ae3839767cafacf959caf32d7472eef67bae741b758f4a803894a85a8804796eaaaf64ab1908d906987119a193f7818676d436a02bc6ed3078b3b9691206018b6b5bca36b7129046e997efee7853437618ba928cc7ef47096614bb336c125dfe2bc6fc90d0485ce37a8b07583161e6dbc09a5a19f85e8afa0b70b2ff19ff055f1ed264042fa23135cee390ea007b6656b8ba0dac2c26a734993654e034a6a9aa1ebb454f7deec0f4fe04d368287a5ade4ca74ad62e3f64d3bd8e5259b4a2ebb00147a79106cb722df6f31936a9eab19d55faa53d8aa268a7be0816f506cbdfe5bad59786b43c4a4239aebd9a937290af6b1634669dccbcd06fb02581da5ba5d436c57c3523d179b2d6a6cce0d29ed05ec3a99f569b12407bbe8129ed89432e89217e54450be7aad54f492a30edc4ae88936e6cd29f878603d8373ff55ad91fa267eee49e93d21f6deb338e591aa11464ce29caeedc754ef075fecb910dd36b2d38d315bb583beb8067bfe04e59cd7abf5bcb696fbec517d06516dc62d6014036f147cc8f05fc60eafcb9cdb75ff177dcace53f97e6363e7b0d5cea8b95994c0448d0124e01e32191a6f5e5e7003579f64d2d092fa06ead5380877cc2c2fc29a3c25d90571426cabc9cfdee1852a9f70494c7d793b65c31d5b331783ea2e8d6bd81d123baccae81c8748e166f7e0914c6c29f451e12bedda4f6a687763b2643982365ae2a006266b27361da7eb263529ecc7f0b3960e0419f9924a18b1383e88162b5a11461361a28e757b65112f2ed64ed287bd32f57f871dd639422aa566a5d4e9558674d5ce0e4332fc9399300e127110f0e2f41b722813e0abe36c459c040b21ec0789b56a4c2c79cb3c668d091f0548bfbe3f6974b4e2972bb12e94ac56e8a05785b6e5f842f39b1f4b9c131e213da92323aa670daa363dcc6fb7e5be0effef3edcda627eb04d3f5f5d8768fec5ee65ec80c32fbf94186e33a6b744de137fef34a70a6e12a5979c514634b9dc0b683451e1c3bc38f584c6660535f45bf0ba980e93a582be2c39c88cd42b94da6f76bdd1b08b23379edc2bd7d239792870f9fc41019e86bbb1cb04338e0703b8c13850f41f8bbc105dddd9b96b2ca86f5838e66eef720a7770e88f6dee5cc6598e2b15c6ed146ed9832ef7476d3709e255ce7e687014da2253c76e7d8622237b668bfa2ad57f291ad07fd09eb16358df1f45d1c454a6ce500f46abfb68cc0985f7b1f92404c3a70ba5f6ac50a836c42f768598a0b78289e770fb3cbfaa09ac6e3777801f07b92b2abd82a82533994c5435681c1aeb6c5c1742d3272f5524414c657a8963ccb1b517464a141fbf1b0556eca205f695b55de5dddc82d5dd73361bfd984ba31f0c0f18849b0f0339fbb8a38b467f7ba7ba2f6850638032764ddfbfdd51f91acb7e8302c528af518f02132a8563a5830d9dad53183c8337d1c11a41ec73544599bcab060c9c50107550d8d6e5dd9a36a6d557c388dc918c1692315972656adad787080d636513d363fc4f28115f2ea36472e3a0301635a1535b114db5b81746e544fc71cecadcd3ca577fe130f8004f146662bd70789ba4422b7b85f76827e10d7a5c39cc260cd2458e3bc5e6487ebcacb41fabf8644098c9bd5c53baff0b23748d2581d28611f6716d71e5966e5ff97458b6d857814be851e461e5cadb74ec04bd3816df4af90011b62dcd5acf5213042e5ac531df8dc17d3a6131c895cfaa7d9b16e94530c259ca108d19cc5dea243e7cdd53e73f1284bb110fa7b1aceb5251de74934f5d8311ec7f60bf677d2ab55d5b6e2c5b8cdc767c41ba7faec2e871567b2028a316268b2029d7b3cb09ab34b29159857f4bd15b262ca90517319ce16aa83c319b7b21f9af967cda2321ba5a81ed4bb5889fbaf3b5eefacdf6f8243e2785ac5fb296f2586d8767f87d4735568af4c01f30c1217e64c2639512eda8302646d96511ae05a6977f7fe7c810610ab9fdbbe87a440979861d1efdabc27cacec5ecde4097c863a1c262c2fa32c0af3c64cc9ea2971b73a120d417900c79a739daf50035762540d4b178d93d567ad0ed68d9a6c6a4e4c5f354b5ae8ece522f2117344a6be410bcd6c90890a920b76c370178fb04a69bdd0e8b3f8426adfe158d1b440249220b0068c451110048a0cb9a04f3d2d63996548ace962d83e935f376c1aa7bdd1c2aff355c96cc8b310b31b7a292d1e74a5a396c68d38f2e06f20ae2a6886e2c515e340a0adc2ce642332bbed6f8eb23ed98b6e8d1fe3389934a12c8215b4063da2bd9b6b231e8383766a8678e35a98fb29926c4c6acd3270feb1b413620a145c47e32478b525b61a10247ec939cc801d5caaaada31003dd05117da646c58ba99991a385f3b288ed81244363de12e553fa23631f5899ae521996ccfcfe5cb2e7db31f136d2e344ac6c717cb69ac5bd737ba44704b3b0da23236998c65035f8a0e1ae37142c4500a25b34660d8b5c47ee088ba031350a7fcc41e95a1924e57310d1991b265dcb0a51bb23b2a03fcb83e2ac294a91f398410c39bfc591c5de0346d1d50c610575ed2facee8ed6b52e7f6ce320533bfd603918aaf526ee6078b05e04c595ac532aa8cfc51cb325ffe1044540b97a4c4b71955e9773f83cdc709dc2f74d213672c31fbe96756efcff4acba82b4f01414c378ae19b19068536c09e6ee2bed7cb2355acbd62a165fdb4ef45dca4188dd1b000aca22a872b5a4d88acef25ce554368eee11838e426daa5145e1f2d1c997b9011112bad4365d9a7450e3119c85e4c22b84ef9c363f0336c00f4c04c948badbd54b8025ce83d17032fcb61284b7b92939e6b8ecf5eef01ea9b670f1e552c77f981140fdf08ca720477598a891a8920fe8560df423308b47f5b646d6ed8f7b9b065cb46a185aaa0b96bee5e9c59d0519c158d5a6899827a0d82cd810fb7bbea206ab38ad2d9931fd120bb7ee6d8972f672ac378597c5b64a4cfca3f2590f130f3ef2029c8ffaa75bb805cdb77651363189858976a2f1429f3d98388b996f25ec523f49394a5a07c76ccf626ff56dda61f1f0f1638a37c980d40360fbcb7ddf368917653df00d0eb334af35ac5fae5406110ca45cbf994eb37d997ce7ae3c6072808e16903495bb12b73c8b1e1b7de0514bb2180e0da1377d3249d362b5e654f54591ad865258861defb132907a0935e3ed97cb50f2f89537e8d44e88c4c8b9bc591123c2a5c5dee3345fcbf949e27e5dda8a58f1770cd629484f5b7725c0aebcc769c0618bcf054ff9e1230a4d2fb47dfdc31ca79fd3270399882765b76c6548671bd2290b66bb75346999235fa583045f49d472f2d195117af1ac2c765d4f65621e0a735c18c93dd38ccf5292ae41e5759614d1b71bca2887a74577a4c33d72498c5e095831f03a47cb9453ebb4546c6c7776b56f632c08a10031f2aa130eb91aac3eb3810f4a40bf03766ed620883f0e47bb721bb5306509c6fa30fe5e9e430725c42fa562d9a63ebf317c7e7f88f01655c4c19c8834cbdcaf4cb2930468812fe30bbfd834d4e4ce71458941d75bc2b6bacd4a51c7947c0ff72e69a65f735db1af2957f765cad525658af8d22fc1c6d2dc0a4bf8b775f7c24606c514a8f824715fc428fbd21b40792f91f50f761f903f3c8626f16ea1df5473489747d903559b71bceb1ed39339c71f3ad0c3fe1c770732d6a5e9e24ba489a0033d2ac2e9e651701557c50d15fdef41a387e72b20f8f3bfe616ff0622677375422cba93708c834dbcb720633c2cfc20dec8523811e16563666c353f64208263745e9c17b9357becb8390fcdcca6baebb38d2595ebd0eea68ce759b0ad63b50e640f538f211e25f6375a40848d2ebe8c283120f195114c7e323e3c0103bfeb7ac12b87ee982437531c8da7cb545df96f5d408ef03843acfed755f867560d53951966e6825af145384452e504d509e0854d1dd3da6e10715bc4e8ad116b222741ab44577f1628f9e2b2794153061eadc365d5a7d8e5911c4536ad7cff5b7b3eabd00f2ddbe37851fcf213547b3ab2aadb7228a2371f13803ae44941cd9e195113a0c0921154b82c50138cb5420741e842611fb9528f8ec333b7f6ec58dc48979304d01ee40bfdd2fa38f4491ac7826afd1a838c5da2f6bd68008b65d5e3431aee26ed2275632d4f22a828e6837c52b802510c318116ed0a22ab3919ed590c786de0298ec598b61d7701ba87ecc161d2c8a75c7ee8b88d729c6e52faf43f681e9c18c8141374ebace751a9430d9765250fdeff569758f6ffe3c127660f2589bed684ca3da73fcafd4527d5fa7af7e3593658a289ad1a6c82a0c5dffc8c9dfb45c02825113b9a0e50147b0e624ee66c9482e4d4565948ed163cceeae3f5ee0c01e8891d59616ecf9c6a56e3afd1eb7f0c0395d44251868e2a0bddae264cdc3e73b10ba062e8e38ae4fb444e34c710f1228d09326d67f3d09d0271473fc90f90a23a13726cc30a9637327d2d01711c71b0be3bbb1d744cc18bf46b2351927c10cb541971ec12114426d9cebb91d2dfb0b5bdb97ce5a26c258258e273d100e08644dd35fe0d8362dfc60d1944a0a25fe7d008cef87777f0068c4e5e239a8059b95b508cc231292a61eaf4174343fbb374d86cb775f991e14341f6057ebc9325e48ad4c5428d413ac156c7d34519b8f0eae71f14a5c23436afc60ba4af4056755b5ee1a483ba0a21a370c40fabbea304b4abd92acbe4313555b5da806038d2f32cd6da2a85125087daa4665113fd617f3bf73d7e64f34104a95580cbad0e2f6afe302d807d0cd093ea38e564888f9c2cac6f693404050ff578483ad6919dc10f92c7365aed77f5d69eb6795a031c6e75957b6608896f1098cb9918345700f9f38206096e88085b55520f6319c44ea9f55293c2aa06d8a9e22b4dbddb0c2382cb6cf7214eb58179e02205646619d8d8fe4f77e3dcbd39811d5b6aaa12fa95e4b1415c2e79eae8d13e6eee0004683f5905eb4a9f19bde9b88aaad466617ba940e7f9273ab57fc030caef29eea58725b3c1215645ebf48340f3d6665d238304c38a994977ddc9250694e6d7788cc3c75b08de2b3677e8ce66aa30e6fb4948444a9328f963b75e69ab3b71fffadc842dc8cd88b53d74d75e0bfd9fc7c57fbfed4e102c7e6ac8513b7c23cc1a9b3bdb0b60d1c262787a002ab83da70730b022f799ef47ff594e5693b8d8c0ea35d258bd457846dce83e3aaa2ff5b6ddc331d05e0541c252e83377f55b5421795bcab539bda5155af452e08bd0f8eba0c916397d71e338a8983b9f844110016d45d26e8475418767429ea4fd4ee6e065022f2a261f37cf6023c66e4dd2224cfae4128988c33d652263f7035b1e8e0db70d55aee59fe43b9fdcd8f9e66464d18c208335c547028f3bc9d8fbfad429bb802239dee61581f93212cbb7b5158fb1c2ca707b79556dd62e9e96ea4633bb2460f039449cf5ec2613d984f0e68b99135850880a7f67b27c3cb8377f08a1beadb30e1d60cf30daee2a6d2e3ae18d7d8d27bda6eddec6ead4acd38d57f254ed29b2d3fd27c8b52002e7f0104edd54d1419e43702211497e20ea60b1b7cea995515cf4a37d8b4fcd08ab247aaf51720124bc57813ed09e2b9a5958aba7159a1abc69d04ef14639aaae90add2dc7d3fd5d79e3521ef560d07021fca13bf27e5133e8e368057b4f7634f6df07049794294f420def5755ae127aa7f3f1249116269cfa25c301a577d2d9709d679b59ad608bcacd5d225eebe28ed17a0db4085644f82dac6510db788542655f4c39447b757a84c8011050eb353024ac0885e42c36fc0042a629d6e20aca047b6cb8bfa3e7dde3e501945cda08041897fca24608fb3bf0774b81cd0147b291d5a8f3e3180e67f2680ff364ec5a649cab3b14ec90991e86ca9ab0d1775c47ecad139a024539ea26ba8ddec4569278ed69f8e90033e85674723fc8279ba366169bedb955823d28089ec34018892db7084f9d53cb3a2ac1a3bf0f619cc2a52a5bb14c3e0605e3ead76fd779614b28d92531e0d308094b25cf60af709071518a883435954f32bcbed2e803203c7919517124525fa52371965a70a7622095a09efc7e5c7ad76dddf4796d5222623074ad50d7b3960fe5639ae1c1ed9907c9a715a43e92a5509bd69d9c9cc390e2f5ac6598a17a8512e9e0130a31e3a89e295112892d515eeead000a3414a294ab4ad4ba59c2bbb34061716e5c98267a63e746bb6bb107b6cc6d2a2a592bacd8c06e372911bc7f4630a29e0605e12cddb9f82f44384904fe26cbca42d4eaf99f6302e5c1ef9273e7771ad220c77e1896e2b55cd1243725352c1104b652f20c837978abcb1b1247402a8d6964270f78a10411848284fe2df73be31896c9409147207983c3fd014028851ff3f0c82724f13b7dddf0469fec4e58910f44f162f885156849deccb3ec481740abc4c81fffae358a794dffd63bee0791b8177168970174cafbc92210589bece855d6857e336a9aa6b8f9f97d2d241dad0717fa079925ade203e85c4a21a3774019f0b283788799074fd3b8a697db7462d108d6970ac9eb7c4a9f5633f3991dfff4e7bf84f8528d1df6e98fa1bd01b72224f7b2687b19e139e13812aa5a671c0260f9e70570c04b641c4b3d29c1601fc614f0cfcf5175d4298147fd1682524806217035c3a6f07085c46cca5c7bf256c04726ffbb61786814ba71ec07c9a1760ad6fa4e9cf149bb3df42d56a12263a2043dd308bda9e80986885820084db185ce5c78f22cf9f0c0d7245475e7a2956efa5ff408e19956d11825d429b08b8122bddaa6e30dec3afb572174ccd96781520677c391e0c13165282b591b87bc5716ae2bfb5cf3e00cd87279257462d179a82b74e67e5877fd9e2f43420e728d88f738601b4f39707909ec0539a83b4fb95e72cba64d9fb57e1fcc9edbeeff5a80660759abf5d166a08e250d9395e71862b28ab122f6166437aea87b11e1ec17275fe3f5ca2d8524986282c40085ded5b6dd68ce1554ed489bcf3b634b228bfda09eb7c3d1fff2669f51ddf3ae8d67a8757fbc65d70336c3fba1361d4be654082a9d290ad711f3f974b730ca144b190bd667008f521e068c82268ba811f6208fa8fb26ec57b9ffcfe5e7756d93ab70281019e8998115934e3eb469399b2a235d018e09950d3924971b96861788b46d14a3e408a9d595c166d3656d023418c937d7006602a4d22007a1a07252ba3a0150628cb339d4bebdba7798f6c47b5dbb241b8921e3f810d2541427c638ea58014816e6c3613661da18e926f2f72bf90766f87118b350b0e9f2d75cc362b5610377c4122207788a61a8f6a2ddc7ba0cc774eaf73652b83eee2a5f7882ad36c5bfd5be02df97f95f9b031fa09373c2547e1b4c741c856c1b9a9f14f4d8b19a8b379a786dd6fa601022207b8171b42cc5e3d436aafa0136b0764ef13afa0147091d99787d96f715b90cb338c274d4a232f4dc71a89439d2d47bd9ad7bdbd258f5d3776d89ec5c7756338054b18375bb0f6da4cc51b07d16956fb4ec66cf75c71b4bfd56e65d758805caf118d94d0131d06aebf5a088fb7f5f19b777017e0fe3ac5b77b805e2de9d4e0855fd8021bf4e8f7231b4ddb9d4b9415e10ac53fa1fe3014564712defc220aa08e5c3a90fc8a17419a799ccb04cca49ae9399df74a3d07b846ea1e8bec8a79641576bf4309a60863aa8ea158637de65b8c9d123a4ac57065179e0d80b1ae76d990d3d95152aa4fd0e27e2cb41cc9d11e54b4b984b4dde5b61e5e822aad2b4f671d83cbd576604dc40295e7e9dcb704890b4d390f21267b9e342b111f3adf5738c0dfbc8cf173b56fc4aa13960b967d99e761813d76880368eb066a9cfb57cc05b3de713f111c67faa0c8ce49369b4681a471f41a7a882cfbc6d0fbd655edf03b8cc554459cec3f0a4e58b6fdf89560dbf30112f154d73bb5f226ce3c54bac1d1cd1ead031b8996bdd9e15bce2933f541e50d1a795c1b663a010041fdfef32f3699e8fc673b5bdece3df4b96e8b7c7719f2532ee7e843e3f2188b507e448166067b7d2506495c7f40a55ab58163bd83c5d40f058ad95900b87dcbffa338617d815e3ea3cc223493e2cde6148f032acae0d4bb96fde4eec7d1c3318c234661545410e7db0d99ce4ffea026cf1e34f2c462ac5905a8b073e49db93e0def7a3185a9edcecb752120707d22f332097ac5cd11ac705dda7316caa124dde40dfb4df2ab15ffc1f783c4b76d326a7e50b9bcf0acdc10513ca7f0e2a257026ddb56933ecdebcfead1257c79f38ca5979a820f7478875772cc991402dbac703a16d286f25e96063db99234d04e4779b3fab96e77b58990c93400444bd5337818f010cd2dd39f718844c1405f460bfe5aedc3aeff4a4ede7ca617ff21f7e7552e75b0981726a99de7f8a4e210e58f4f234fa51e619c9ab48a76c6b6234ba448eddc130a3525944fb846a2a4cf92170a63a78486520a3dfbc1cfe545c7814b220d8553231a6ca0198d98aae6cdd7447ae113c59824e2229b440120c4d74f713acf0b8852146caea6bfc19c12db16b832017cc9e430674aa95df3f616df9059d70ad578d59646da0da2496737c58b74fad5f99157dbb424b78fba96f365b07264b5190a06d546ff2dd9d2a8c1945128b28658ecae3bbd73b7a2adc1a66de8dd60afbab4745d4523a2a1c9d994a4d13ef94656db10c818d18e160d805bcf4c61c08bea444ba7cc82ef58cb00e1f4d6554d976feaf6c756f93219a876ebca256ce5cb9b620c5a9e0e4c73016e4cc96a984064206762bea8c845ba96a096c397c116b8bb0d365ea317a537fcbd4868767d7dee8418bc0dbbd8d46b437db9d9962b475988da96b4ad78885f3f23ed2e93720a6ca0bf29db2e72c865e39119753ba99e75557e2d71e6575db50d7ab9d44ef911deb9d4aaa1675c2cf2d04476d3dd64ec3633248fecfa6f07a879f7173d4ab7be104ba7be9f836d5eb1cb9cb482c87f68a7d6f5c87d5eb1d9c5099e5ef16c1df916337c4c3bf0cc21881da396b2e9c53cfbfeb627669d7c1e243e4d5da595ae21d18f8f2a7b4a5f9c13f5ea02ff247a4553942d3cc7741692c20bffa06ac71ce147cdcb78359bbc1804e8d36a6966f25835f63a167eca442d7aef7a80d134729568181e650ef1021f1642e15eec3bee49d93f3bbc42a20dca5c0481f331a458b3baa644b8be560142002a985d3d256acf7b71d40a482bef1a53a086909778bfa6d29bc1301e58a877570af22b30a98b7e175eeb7014f427912164d0283561b2500b6d5b49220810d77a3d297b2bd1135ca6d82f0798b9005dcf2ab1c2ac07409a2801b7432cda971fc07cf48d4ce4bf9e8b455a989771903ef13dae9179e6d6d52a3fc6fc92863b29018dccbdfa0dc7bce6ef292fba79632a5dec97b8bb182bf4ffef3230bb8ea6c57671f2d74815fd089bf1dabd1afb74772763f4d71a1075db06a329431068f672428c0785b07caa8805cae890cdd40445f0beb7567ff258e60d23aa242b5561106cb687caea7fc949f2a7caa1701774baee0174f19089397f1b7bc815f23e7dbb829f1f3045c0497f70a91f4efd1ebeb406647db2d8abb98984029a254e5a8fcee10089587f2c8c27d88024ee2a37c512f9c0bee2838dc4f73d85d5ba90b04a4c5663c478a1a8ca54ef25f9d7587772c78b477f3827ddd462933a1dcddd74889593c879845856fbe9a3af2041beb66128f25bad256fd646740ec59001475e15e341e580841fecc3795f683d684b74df3ab1db374e9807e85f9c5fa9b522469dbf1afeebfa03513a3b30511e3d8c642fd0de42f0c31ba26589103b44523052d3eaa6c852f3247739392d6049115a79a9c08e06d3843b0783e6105716c86832773a38cd121e21b824bcbb3315994aa89de0a3a99c78149118a47b15381406decb3147f78ff1a82370c2dd82447b7f06e67e2134b7f9b840cc2e63d3afe3c8a4f7ed6a724e889af1bcea29ece718cedc74ec909c2cf874afeed36fcb53d72f041ab6d520fb24f5d9293e4428c2a7519fdbc69629c6683d8a306e2ae0146dbbec7bebcc0a90a91bc8b95df6e16e2c9af6d7b140eca0496507913263980dce980230f3d77569362c5365345830e70a832cc5f67409d95bc68c53ef940039a0d7fafecaa1b04d0db78347ce8a16cefe8c5587ccf7d179581253e12638fda45b6d8bee310a1fc389415b994b666a37fded17216bce05d46306a63e3be78bd2d2350e479b911c267b060bc3268f34e720abd281baa602033291e7538671d935099e794f3ca42d24c9d2ae28ca596f9609ec4fab7af84d9247c909769bd5651a535b63346b19fd4adc9dedbff76f9a4a44df1ce899a95a7dae68f3397bacab050598d8168f9901e506cdca61f4be55d93a0bde4eed33caf53ac11bae480d4b20db4cde6abdeecbf434bbb26b8c873ce75d73b36c8b4449c9857a8d90ad6509ef1a170daeb9339525d6823018b91e01bdb38ff5e02ece708d1d5854cd4bdf1e6cedfdf43c678e717b534cde1f47f6f0fd05d54c67908fb5dbd4620a6cbff85123a38eaecbf87bc8a88c6673bed23064c453161da8854a1b5d1398b86e434427858187bd47c415bc0436be8513f96b69a754a726fc05c0e9e4e8f3a49132620a6f30684c331dead45f4a99311689e3127116c40e7d33944a17c02e9ff647a8bd4143de3775ca76edf7fcc329ddfcbaf8e65aae1b1ff4619d82f540b9f4d19ae0b09f53a60b0fad2a3fc89c420a537d477ce1c0845920afdc66701c65a2a05ba835a173eaf8d4cc119009fa7059855ede9430ce1f2a3a2d08dfa971058d46cbe54c6cb661fe4af052423691e75fd33bda53334bbee1bb24d8de5612c469d912c9f61c76186a99554983f09512273cbf2816cc508a01362807fe88f71ed3fc9fbb963cdf8565611c34775c22683c1c1a258765b4f25cff01b38b26ff6e69bc8661b982ffe76c9932fdb0aa336f3249cf24bdf4122dfc7b5f0755267282e6f23e3aed8f9cd77d0be45f7becd47cec92eb270349a27d95b67e2b126a9bbaaf29a2f2c39655e8ca0cc90049be95986527d1c09ebb1a4fc9e6fc9f9f13519a3581cfc47397c30876fa9e6041e39e752b3a5d1c92d1f4911c1fdc0fb206a8c9f1b51a84f1b33f28b2fa8b9e806dc53d7a68b949b9a24c85ceafe83d3ae5da4793c923a4bba4acfba54a69a54c0999827d85971ba79db98b12a138312815c7fdb0a9d01b88c495732dd8fd404b9fb6ff9a1f315cf7c3952fda66fe901146ffe635e0449a598a262c161fb65c5b0f9c2172660472f95518bdb8a677c9526d6d16c43dabef43331016369a9f89ee371e8d1a03fe50ed238e7807a5a9407fc1e6396098dca0785f918bd9fdfc6430df2adb3fce55a402a0fd6e190e80340a15f58050711f3c6eddb81a7e64b6884759eb83ad0745023719da0b23332486dc2b33e9e5fc599d0ef5fe5237454dd8815c065eb8f490bbc1e60794d5dcd08f069d8d25ca028697be1af8ee5400e9bab8e257fcbcd381f7264c2c64c7cf41c24aa38dd4c60d0e26e8c07a41859d68cab64b699a477b4ce771dbb619712ca512349e58a52959e3f54a4bc8e940e12a3094d4586067c3b717e2599c891fb1c6a4e7fcb222512b02f41a7e36f94fa81607011e85e862735a7b5d8a077b1a031bc126915cc0650ae4391063d22602a0930c4fc71140a95b47512800f23803630dc1fae688fd3083e7f5998b580f915a1a29b89db1cd53a2914665cb3d8eb8fad65daef4ecd7e274a81982d87d9adf333236334d7a613f86099dacac4d72691ba4bee83c459bbfacd69ea601c8a04135677c325a437e01e7cd600cac5a7328d2e314fae4a74cd35a894b3e1f02cf63642259f7f845a7d830624bfdd3cd226f5a8183adf987ec26194777fc4b93596219d04f41e89c6b96856e56cd5382444465ebb59d99a428be25dd8ab540706709d0e36842652514a136651f15b8d398d60010bb256","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
